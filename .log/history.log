--[ 2019.10.29.10.12.42.899.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.10.29.10.12.42.957.0 ]--
InitTree:
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/.cos265
/readme.html
/P04_Pathfinding.iml

--[ 2019.10.29.10.12.42.961.0 ]--
InitFile: /.cos265


--[ 2019.10.29.10.12.42.965.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.10.29.10.12.42.970.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.10.29.10.12.42.973.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */
    private class PFNode implements Comparable<PFNode> {
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)
        public PFNode(Coord loc, PFNode fromNode) { }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain
        public float getCost(float heuristic) {
            return 0;
        }

        // returns if this PFNode is not marked invalid
        public boolean isValid() {
            return false;
        }

        // marks the PFNode as invalid
        public void invalidate() {
        }

        // returns if the PFNode is marked as used
        public boolean isUsed() {
            return true;
        }

        // marks the PFNode as used
        public void use() { }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Stack<PFNode> s = new Stack<>();
            s.push(new PFNode(null, null));
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
    }

    public void setPathStart(Coord loc) {
    }

    public Coord getPathStart() {
        return null;
    }

    public void setPathEnd(Coord loc) {
    }

    public Coord getPathEnd() {
        return null;
    }

    public void setHeuristic(float v) {
    }

    public float getHeuristic() {
        return 0;
    }

    public void resetPath() {
    }

    public void computePath() {
    }

    public boolean foundPath() {
        return false;
    }

    public float getPathCost() {
        return 0;
    }

    public int getSearchSize() {
        return 0;
    }

    public Iterable<Coord> getPathSolution() {
        return null;
    }

    public boolean wasSearched(Coord loc) {
        return false;
    }
}

--[ 2019.10.29.10.12.42.977.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.10.29.10.12.42.981.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.10.29.10.12.42.984.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return null;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return true;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
    }

}

--[ 2019.10.29.10.12.42.988.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
    };

    private final static String emapFilename = emaps[2];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.10.29.10.12.42.991.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.10.29.10.22.43.167.0 ]--
UpdateTree (AD): 24 0
+ /out/production/P04_Pathfinding/.donotlog
+ /out/production/P04_Pathfinding/algs4.jar
+ /out/production/P04_Pathfinding/stdlib.jar
+ /out/production/P04_Pathfinding/Coord.class
+ /out/production/P04_Pathfinding/png2emap.py
+ /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/ramp.png.emap
+ /out/production/P04_Pathfinding/Terrain.class
+ /out/production/P04_Pathfinding/ramp2.png.emap
+ /out/production/P04_Pathfinding/ramp3.png.emap
+ /out/production/P04_Pathfinding/mazeAB.png.emap
+ /out/production/P04_Pathfinding/usa128.png.emap
+ /out/production/P04_Pathfinding/usa256.png.emap
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/usa1024.png.emap
+ /out/production/P04_Pathfinding/maze32_0.png.emap
+ /out/production/P04_Pathfinding/maze32_1.png.emap
+ /out/production/P04_Pathfinding/maze232_0.png.emap
+ /out/production/P04_Pathfinding/maze320_0.png.emap
+ /out/production/P04_Pathfinding/mazeBrain.png.emap
+ /out/production/P04_Pathfinding/TerrainEditor.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/PathfinderVisualizer.class
+ /out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class

--[ 2019.10.29.10.22.43.200.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.10.29.11.02.21.976.0 ]--
:/src/Pathfinder.java
+ 17         
--[ 2019.10.29.11.02.23.046.0 ]--
r 17         C
--[ 2019.10.29.11.02.23.417.0 ]--
r 17         Co
--[ 2019.10.29.11.02.23.600.0 ]--
r 17         Coo
--[ 2019.10.29.11.02.23.649.0 ]--
r 17         Coor
--[ 2019.10.29.11.02.23.822.0 ]--
r 17         Coord
--[ 2019.10.29.11.02.23.940.0 ]--
r 17         Coord 
--[ 2019.10.29.11.02.24.140.0 ]--
r 17         Coord
--[ 2019.10.29.11.02.24.287.0 ]--
r 17         Coor
--[ 2019.10.29.11.02.24.456.0 ]--
r 17         Coo
--[ 2019.10.29.11.02.24.597.0 ]--
r 17         Co
--[ 2019.10.29.11.02.24.769.0 ]--
r 17         C
--[ 2019.10.29.11.02.24.926.0 ]--
r 17         
--[ 2019.10.29.11.02.25.336.0 ]--
r 17         p
--[ 2019.10.29.11.02.25.400.0 ]--
r 17         pr
--[ 2019.10.29.11.02.25.524.0 ]--
r 17         pri
--[ 2019.10.29.11.02.25.653.0 ]--
r 17         priv
--[ 2019.10.29.11.02.25.756.0 ]--
r 17         priva
--[ 2019.10.29.11.02.25.876.0 ]--
r 17         privat
--[ 2019.10.29.11.02.25.964.0 ]--
r 17         private
--[ 2019.10.29.11.02.26.072.0 ]--
r 17         private 
--[ 2019.10.29.11.02.26.970.0 ]--
r 17         private C
--[ 2019.10.29.11.02.27.183.0 ]--
r 17         private Co
--[ 2019.10.29.11.02.27.309.0 ]--
r 17         private Coo
--[ 2019.10.29.11.02.27.478.0 ]--
r 17         private Coor
--[ 2019.10.29.11.02.27.574.0 ]--
r 17         private Coord
--[ 2019.10.29.11.02.27.627.0 ]--
r 17         private Coord 
--[ 2019.10.29.11.02.27.720.0 ]--
r 17         private Coord l
--[ 2019.10.29.11.02.27.872.0 ]--
r 17         private Coord lo
--[ 2019.10.29.11.02.27.980.0 ]--
r 17         private Coord loc
--[ 2019.10.29.11.02.28.047.0 ]--
r 17         private Coord loc;
--[ 2019.10.29.11.02.28.374.0 ]--
+ 18         
--[ 2019.10.29.11.02.29.849.0 ]--
r 18         p
--[ 2019.10.29.11.02.30.004.0 ]--
r 18         pr
--[ 2019.10.29.11.02.30.108.0 ]--
r 18         pri
--[ 2019.10.29.11.02.30.219.0 ]--
r 18         priv
--[ 2019.10.29.11.02.30.359.0 ]--
r 18         priva
--[ 2019.10.29.11.02.30.551.0 ]--
r 18         privat
--[ 2019.10.29.11.02.30.644.0 ]--
r 18         private
--[ 2019.10.29.11.02.30.743.0 ]--
r 18         private 
--[ 2019.10.29.11.02.31.843.0 ]--
r 18         private P
--[ 2019.10.29.11.02.31.896.0 ]--
r 18         private PF
--[ 2019.10.29.11.02.32.213.0 ]--
r 18         private PFN
--[ 2019.10.29.11.02.32.477.0 ]--
r 18         private PFNo
--[ 2019.10.29.11.02.32.625.0 ]--
r 18         private PFNod
--[ 2019.10.29.11.02.32.836.0 ]--
r 18         private PFNode
--[ 2019.10.29.11.02.32.878.0 ]--
r 18         private PFNode 
--[ 2019.10.29.11.02.34.045.0 ]--
r 18         private PFNode f
--[ 2019.10.29.11.02.34.235.0 ]--
r 18         private PFNode fr
--[ 2019.10.29.11.02.34.295.0 ]--
r 18         private PFNode fro
--[ 2019.10.29.11.02.34.379.0 ]--
r 18         private PFNode from
--[ 2019.10.29.11.02.34.563.0 ]--
r 18         private PFNode fromN
--[ 2019.10.29.11.02.34.671.0 ]--
r 18         private PFNode fromNo
--[ 2019.10.29.11.02.34.795.0 ]--
r 18         private PFNode fromNod
--[ 2019.10.29.11.02.34.967.0 ]--
r 18         private PFNode fromNode
--[ 2019.10.29.11.02.35.009.0 ]--
r 18         private PFNode fromNode;
--[ 2019.10.29.11.02.35.213.0 ]--
+ 19         
--[ 2019.10.29.11.02.38.045.0 ]--
+ 20         public PFNode(Coord loc, PFNode fromNode) { 
r 21         }
--[ 2019.10.29.11.02.38.072.0 ]--
+ 21             
--[ 2019.10.29.11.02.39.156.0 ]--
r 21             t
--[ 2019.10.29.11.02.39.208.0 ]--
r 21             th
--[ 2019.10.29.11.02.39.279.0 ]--
r 21             thi
--[ 2019.10.29.11.02.39.411.0 ]--
r 21             this
--[ 2019.10.29.11.02.39.491.0 ]--
r 21             this.
--[ 2019.10.29.11.02.39.708.0 ]--
r 21             this.l
--[ 2019.10.29.11.02.39.886.0 ]--
r 21             this.lo
--[ 2019.10.29.11.02.39.973.0 ]--
r 21             this.loc
--[ 2019.10.29.11.02.40.039.0 ]--
r 21             this.loc 
--[ 2019.10.29.11.02.40.162.0 ]--
r 21             this.loc =
--[ 2019.10.29.11.02.40.282.0 ]--
r 21             this.loc = 
--[ 2019.10.29.11.02.40.425.0 ]--
r 21             this.loc = l
--[ 2019.10.29.11.02.40.647.0 ]--
r 21             this.loc = lo
--[ 2019.10.29.11.02.40.741.0 ]--
r 21             this.loc = loc
--[ 2019.10.29.11.02.40.867.0 ]--
r 21             this.loc = loc;
--[ 2019.10.29.11.02.41.058.0 ]--
+ 22             
--[ 2019.10.29.11.02.41.607.0 ]--
r 22             t
--[ 2019.10.29.11.02.41.665.0 ]--
r 22             th
--[ 2019.10.29.11.02.41.741.0 ]--
r 22             thi
--[ 2019.10.29.11.02.41.851.0 ]--
r 22             this
--[ 2019.10.29.11.02.41.952.0 ]--
r 22             this.
--[ 2019.10.29.11.02.42.242.0 ]--
r 22             this.f
--[ 2019.10.29.11.02.42.452.0 ]--
r 22             this.fr
--[ 2019.10.29.11.02.42.486.0 ]--
r 22             this.fro
--[ 2019.10.29.11.02.42.572.0 ]--
r 22             this.from
--[ 2019.10.29.11.02.42.836.0 ]--
r 22             this.fromN
--[ 2019.10.29.11.02.42.900.0 ]--
r 22             this.fromNo
--[ 2019.10.29.11.02.43.056.0 ]--
r 22             this.fromNod
--[ 2019.10.29.11.02.43.252.0 ]--
r 22             this.fromNode
--[ 2019.10.29.11.02.43.311.0 ]--
r 22             this.fromNode 
--[ 2019.10.29.11.02.43.399.0 ]--
r 22             this.fromNode =
--[ 2019.10.29.11.02.43.503.0 ]--
r 22             this.fromNode = 
--[ 2019.10.29.11.02.44.148.0 ]--
r 22             this.fromNode = f
--[ 2019.10.29.11.02.44.356.0 ]--
r 22             this.fromNode = fr
--[ 2019.10.29.11.02.44.420.0 ]--
r 22             this.fromNode = fro
--[ 2019.10.29.11.02.44.507.0 ]--
r 22             this.fromNode = from
--[ 2019.10.29.11.02.44.712.0 ]--
r 22             this.fromNode = fromN
--[ 2019.10.29.11.02.44.819.0 ]--
r 22             this.fromNode = fromNo
--[ 2019.10.29.11.02.44.961.0 ]--
r 22             this.fromNode = fromNod
--[ 2019.10.29.11.02.45.132.0 ]--
r 22             this.fromNode = fromNode
--[ 2019.10.29.11.02.45.162.0 ]--
r 22             this.fromNode = fromNode;
--[ 2019.10.29.11.03.36.581.0 ]--
+ 61     public Pathfinder(Terrain terrain) 
r 62     {
--[ 2019.10.29.11.04.09.410.0 ]--
- 61
r 61     public Pathfinder(Terrain terrain) {
--[ 2019.10.29.11.04.10.661.0 ]--
+ 62         
--[ 2019.10.29.11.04.17.350.0 ]--
+ 73         
--[ 2019.10.29.11.04.25.632.0 ]--
+ 91         
--[ 2019.10.29.11.04.39.679.0 ]--
r 19 
r 20         public PFNode(Coord loc, PFNode fromNode) {
r 62 
r 73 
r 91 
--[ 2019.10.29.11.04.55.084.0 ]--
+ 14      
--[ 2019.10.29.11.04.55.108.0 ]--
r 14     
--[ 2019.10.29.11.04.55.253.0 ]--
+ 14     
--[ 2019.10.29.11.04.56.594.0 ]--
+ 14     
--[ 2019.10.29.11.04.57.275.0 ]--
r 15     p
--[ 2019.10.29.11.04.57.405.0 ]--
r 15     pr
--[ 2019.10.29.11.04.57.599.0 ]--
r 15     pri
--[ 2019.10.29.11.04.57.667.0 ]--
r 15     priv
--[ 2019.10.29.11.04.57.811.0 ]--
r 15     priva
--[ 2019.10.29.11.04.57.955.0 ]--
r 15     privat
--[ 2019.10.29.11.04.58.065.0 ]--
r 15     private
--[ 2019.10.29.11.04.58.118.0 ]--
r 15     private 
--[ 2019.10.29.11.04.58.284.0 ]--
r 15     private c
--[ 2019.10.29.11.04.58.375.0 ]--
r 15     private co
--[ 2019.10.29.11.04.58.566.0 ]--
r 15     private coo
--[ 2019.10.29.11.04.58.623.0 ]--
r 15     private coor
--[ 2019.10.29.11.04.58.798.0 ]--
r 15     private coord
--[ 2019.10.29.11.04.58.885.0 ]--
r 15     private coord 
--[ 2019.10.29.11.04.59.149.0 ]--
r 15     private coord
--[ 2019.10.29.11.04.59.302.0 ]--
r 15     private coor
--[ 2019.10.29.11.04.59.461.0 ]--
r 15     private coo
--[ 2019.10.29.11.04.59.605.0 ]--
r 15     private co
--[ 2019.10.29.11.04.59.758.0 ]--
r 15     private c
--[ 2019.10.29.11.04.59.926.0 ]--
r 15     private 
--[ 2019.10.29.11.05.00.159.0 ]--
r 15     private C
--[ 2019.10.29.11.05.00.465.0 ]--
r 15     private Co
--[ 2019.10.29.11.05.00.631.0 ]--
r 15     private Coo
--[ 2019.10.29.11.05.00.683.0 ]--
r 15     private Coor
--[ 2019.10.29.11.05.00.894.0 ]--
r 15     private Coord
--[ 2019.10.29.11.05.00.980.0 ]--
r 15     private Coord 
--[ 2019.10.29.11.05.01.139.0 ]--
r 15     private Coord s
--[ 2019.10.29.11.05.01.263.0 ]--
r 15     private Coord st
--[ 2019.10.29.11.05.01.363.0 ]--
r 15     private Coord sta
--[ 2019.10.29.11.05.01.506.0 ]--
r 15     private Coord star
--[ 2019.10.29.11.05.01.718.0 ]--
r 15     private Coord start
--[ 2019.10.29.11.05.01.982.0 ]--
r 15     private Coord startL
--[ 2019.10.29.11.05.02.139.0 ]--
r 15     private Coord startLo
--[ 2019.10.29.11.05.02.223.0 ]--
r 15     private Coord startLoc
--[ 2019.10.29.11.05.02.422.0 ]--
r 15     private Coord startLoca
--[ 2019.10.29.11.05.02.588.0 ]--
r 15     private Coord startLocat
--[ 2019.10.29.11.05.02.644.0 ]--
r 15     private Coord startLocati
--[ 2019.10.29.11.05.02.702.0 ]--
r 15     private Coord startLocatio
--[ 2019.10.29.11.05.02.790.0 ]--
r 15     private Coord startLocation
--[ 2019.10.29.11.05.02.984.0 ]--
r 15     private Coord startLocatio
--[ 2019.10.29.11.05.03.485.0 ]--
r 15     private Coord startLocati
--[ 2019.10.29.11.05.03.516.0 ]--
r 15     private Coord startLocat
--[ 2019.10.29.11.05.03.549.0 ]--
r 15     private Coord startLoca
--[ 2019.10.29.11.05.03.581.0 ]--
r 15     private Coord startLoc
--[ 2019.10.29.11.05.03.615.0 ]--
r 15     private Coord startLo
--[ 2019.10.29.11.05.03.781.0 ]--
r 15     private Coord startL
--[ 2019.10.29.11.05.03.950.0 ]--
r 15     private Coord start
--[ 2019.10.29.11.05.04.326.0 ]--
r 15     private Coord start;
--[ 2019.10.29.11.05.04.627.0 ]--
+ 16     
--[ 2019.10.29.11.05.05.028.0 ]--
r 16     p
--[ 2019.10.29.11.05.05.095.0 ]--
r 16     pr
--[ 2019.10.29.11.05.05.203.0 ]--
r 16     pri
--[ 2019.10.29.11.05.05.341.0 ]--
r 16     priv
--[ 2019.10.29.11.05.05.491.0 ]--
r 16     priva
--[ 2019.10.29.11.05.05.561.0 ]--
r 16     privat
--[ 2019.10.29.11.05.05.666.0 ]--
r 16     private
--[ 2019.10.29.11.05.05.726.0 ]--
r 16     private 
--[ 2019.10.29.11.05.05.911.0 ]--
r 16     private C
--[ 2019.10.29.11.05.06.047.0 ]--
r 16     private Co
--[ 2019.10.29.11.05.06.174.0 ]--
r 16     private Coo
--[ 2019.10.29.11.05.06.263.0 ]--
r 16     private Coor
--[ 2019.10.29.11.05.06.484.0 ]--
r 16     private Coord
--[ 2019.10.29.11.05.06.544.0 ]--
r 16     private Coord 
--[ 2019.10.29.11.05.06.657.0 ]--
r 16     private Coord e
--[ 2019.10.29.11.05.07.034.0 ]--
r 16     private Coord end;
--[ 2019.10.29.11.05.42.696.0 ]--
r 14 
r 17 
--[ 2019.10.29.11.08.24.853.0 ]--
+ 47             
--[ 2019.10.29.11.09.16.995.0 ]--
+ 71         
--[ 2019.10.29.11.09.18.575.0 ]--
r 71         s
--[ 2019.10.29.11.09.18.674.0 ]--
r 71         st
--[ 2019.10.29.11.09.18.828.0 ]--
r 71         sta
--[ 2019.10.29.11.09.18.890.0 ]--
r 71         star
--[ 2019.10.29.11.09.19.091.0 ]--
r 71         start
--[ 2019.10.29.11.09.19.153.0 ]--
r 71         start 
--[ 2019.10.29.11.09.19.236.0 ]--
r 71         start =
--[ 2019.10.29.11.09.19.349.0 ]--
r 71         start = 
--[ 2019.10.29.11.09.19.500.0 ]--
r 71         start = n
--[ 2019.10.29.11.09.19.587.0 ]--
r 71         start = ne
--[ 2019.10.29.11.09.19.674.0 ]--
r 71         start = new
--[ 2019.10.29.11.09.19.715.0 ]--
r 71         start = new 
--[ 2019.10.29.11.09.19.989.0 ]--
r 71         start = new C
--[ 2019.10.29.11.09.20.114.0 ]--
r 71         start = new Co
--[ 2019.10.29.11.09.20.269.0 ]--
r 71         start = new Coo
--[ 2019.10.29.11.09.20.331.0 ]--
r 71         start = new Coor
--[ 2019.10.29.11.09.20.520.0 ]--
r 71         start = new Coord
--[ 2019.10.29.11.09.20.714.0 ]--
r 71         start = new Coord()
--[ 2019.10.29.11.09.21.442.0 ]--
r 71         start = new Coord(l)
--[ 2019.10.29.11.09.21.590.0 ]--
r 71         start = new Coord(lo)
--[ 2019.10.29.11.09.21.638.0 ]--
r 71         start = new Coord(loc)
--[ 2019.10.29.11.09.21.906.0 ]--
r 71         start = new Coord(loc.)
--[ 2019.10.29.11.09.22.925.0 ]--
r 71         start = new Coord(loc.g)
--[ 2019.10.29.11.09.22.996.0 ]--
r 71         start = new Coord(loc.ge)
--[ 2019.10.29.11.09.23.182.0 ]--
r 71         start = new Coord(loc.get)
--[ 2019.10.29.11.09.23.387.0 ]--
r 71         start = new Coord(loc.getI)
--[ 2019.10.29.11.09.23.744.0 ]--
r 71         start = new Coord(loc.getI())
--[ 2019.10.29.11.09.24.549.0 ]--
r 71         start = new Coord(loc.getI(),)
--[ 2019.10.29.11.09.24.659.0 ]--
r 71         start = new Coord(loc.getI(), )
--[ 2019.10.29.11.09.24.974.0 ]--
r 71         start = new Coord(loc.getI(), l)
--[ 2019.10.29.11.09.25.155.0 ]--
r 71         start = new Coord(loc.getI(), lo)
--[ 2019.10.29.11.09.25.195.0 ]--
r 71         start = new Coord(loc.getI(), loc)
--[ 2019.10.29.11.09.25.341.0 ]--
r 71         start = new Coord(loc.getI(), loc.)
--[ 2019.10.29.11.09.25.504.0 ]--
r 71         start = new Coord(loc.getI(), loc.g)
--[ 2019.10.29.11.09.25.564.0 ]--
r 71         start = new Coord(loc.getI(), loc.ge)
--[ 2019.10.29.11.09.25.714.0 ]--
r 71         start = new Coord(loc.getI(), loc.get)
--[ 2019.10.29.11.09.25.944.0 ]--
r 71         start = new Coord(loc.getI(), loc.getJ)
--[ 2019.10.29.11.09.26.251.0 ]--
r 71         start = new Coord(loc.getI(), loc.getJ())
--[ 2019.10.29.11.09.26.770.0 ]--
r 71         start = new Coord(loc.getI(), loc.getJ());
--[ 2019.10.29.11.09.30.607.0 ]--
r 79     
--[ 2019.10.29.11.09.30.813.0 ]--
r 79         
--[ 2019.10.29.11.09.31.259.0 ]--
r 79         e
--[ 2019.10.29.11.09.31.372.0 ]--
r 79         en
--[ 2019.10.29.11.09.31.449.0 ]--
r 79         end
--[ 2019.10.29.11.09.31.528.0 ]--
r 79         end 
--[ 2019.10.29.11.09.31.613.0 ]--
r 79         end =
--[ 2019.10.29.11.09.31.748.0 ]--
r 79         end = 
--[ 2019.10.29.11.09.31.861.0 ]--
r 79         end = n
--[ 2019.10.29.11.09.31.946.0 ]--
r 79         end = ne
--[ 2019.10.29.11.09.32.020.0 ]--
r 79         end = new
--[ 2019.10.29.11.09.32.076.0 ]--
r 79         end = new 
--[ 2019.10.29.11.09.32.314.0 ]--
r 79         end = new C
--[ 2019.10.29.11.09.32.437.0 ]--
r 79         end = new Co
--[ 2019.10.29.11.09.32.587.0 ]--
r 79         end = new Coo
--[ 2019.10.29.11.09.32.647.0 ]--
r 79         end = new Coor
--[ 2019.10.29.11.09.32.835.0 ]--
r 79         end = new Coord
--[ 2019.10.29.11.09.32.974.0 ]--
r 79         end = new Coord()
--[ 2019.10.29.11.09.33.721.0 ]--
r 79         end = new Coord(l)
--[ 2019.10.29.11.09.33.889.0 ]--
r 79         end = new Coord(lo)
--[ 2019.10.29.11.09.33.945.0 ]--
r 79         end = new Coord(loc)
--[ 2019.10.29.11.09.34.093.0 ]--
r 79         end = new Coord(loc.)
--[ 2019.10.29.11.09.34.258.0 ]--
r 79         end = new Coord(loc.g)
--[ 2019.10.29.11.09.34.323.0 ]--
r 79         end = new Coord(loc.ge)
--[ 2019.10.29.11.09.34.485.0 ]--
r 79         end = new Coord(loc.get)
--[ 2019.10.29.11.09.34.664.0 ]--
r 79         end = new Coord(loc.getI)
--[ 2019.10.29.11.09.34.967.0 ]--
r 79         end = new Coord(loc.getI())
--[ 2019.10.29.11.09.35.541.0 ]--
r 79         end = new Coord(loc.getI(),)
--[ 2019.10.29.11.09.35.620.0 ]--
r 79         end = new Coord(loc.getI(), )
--[ 2019.10.29.11.09.35.882.0 ]--
r 79         end = new Coord(loc.getI(), l)
--[ 2019.10.29.11.09.36.083.0 ]--
r 79         end = new Coord(loc.getI(), lo)
--[ 2019.10.29.11.09.36.123.0 ]--
r 79         end = new Coord(loc.getI(), loc)
--[ 2019.10.29.11.09.36.262.0 ]--
r 79         end = new Coord(loc.getI(), loc.)
--[ 2019.10.29.11.09.36.410.0 ]--
r 79         end = new Coord(loc.getI(), loc.g)
--[ 2019.10.29.11.09.36.484.0 ]--
r 79         end = new Coord(loc.getI(), loc.ge)
--[ 2019.10.29.11.09.36.659.0 ]--
r 79         end = new Coord(loc.getI(), loc.get)
--[ 2019.10.29.11.09.36.845.0 ]--
r 79         end = new Coord(loc.getI(), loc.getJ)
--[ 2019.10.29.11.09.37.166.0 ]--
r 79         end = new Coord(loc.getI(), loc.getJ())
--[ 2019.10.29.11.09.37.825.0 ]--
r 79         end = new Coord(loc.getI(), loc.getJ());
--[ 2019.10.29.11.09.42.475.0 ]--
r 75         return s
--[ 2019.10.29.11.09.42.732.0 ]--
r 75         return sta
--[ 2019.10.29.11.09.42.783.0 ]--
r 75         return star
--[ 2019.10.29.11.09.42.958.0 ]--
r 75         return star;
--[ 2019.10.29.11.09.42.972.0 ]--
r 75         return star;t
--[ 2019.10.29.11.09.43.891.0 ]--
r 75         return star;
--[ 2019.10.29.11.09.44.083.0 ]--
r 75         return star
--[ 2019.10.29.11.09.44.236.0 ]--
r 75         return sta
--[ 2019.10.29.11.09.44.902.0 ]--
r 75         return star
--[ 2019.10.29.11.09.45.117.0 ]--
r 75         return start
--[ 2019.10.29.11.09.45.174.0 ]--
r 75         return start;
--[ 2019.10.29.11.09.48.173.0 ]--
r 83         return e;
--[ 2019.10.29.11.09.48.274.0 ]--
r 83         return en;
--[ 2019.10.29.11.09.48.336.0 ]--
r 83         return end;
--[ 2019.10.29.11.09.54.321.0 ]--
r 67     
--[ 2019.10.29.11.09.54.746.0 ]--
r 67         
--[ 2019.10.29.11.09.55.270.0 ]--
r 67         s
--[ 2019.10.29.11.09.55.397.0 ]--
r 67         st
--[ 2019.10.29.11.09.55.498.0 ]--
r 67         sta
--[ 2019.10.29.11.09.55.592.0 ]--
r 67         star
--[ 2019.10.29.11.09.55.800.0 ]--
r 67         start
--[ 2019.10.29.11.09.55.867.0 ]--
r 67         start 
--[ 2019.10.29.11.09.55.949.0 ]--
r 67         start =
--[ 2019.10.29.11.09.56.036.0 ]--
r 67         start = 
--[ 2019.10.29.11.09.56.193.0 ]--
r 67         start = n
--[ 2019.10.29.11.09.56.434.0 ]--
r 67         start = nu
--[ 2019.10.29.11.09.56.625.0 ]--
r 67         start = nul
--[ 2019.10.29.11.09.56.760.0 ]--
r 67         start = null
--[ 2019.10.29.11.09.56.860.0 ]--
r 67         start = null;
--[ 2019.10.29.11.09.57.048.0 ]--
+ 68         
--[ 2019.10.29.11.09.57.569.0 ]--
r 68         e
--[ 2019.10.29.11.09.57.660.0 ]--
r 68         en
--[ 2019.10.29.11.09.57.769.0 ]--
r 68         end
--[ 2019.10.29.11.09.57.848.0 ]--
r 68         end 
--[ 2019.10.29.11.09.57.949.0 ]--
r 68         end =
--[ 2019.10.29.11.09.58.090.0 ]--
r 68         end = 
--[ 2019.10.29.11.09.58.205.0 ]--
r 68         end = n
--[ 2019.10.29.11.09.58.469.0 ]--
r 68         end = nu
--[ 2019.10.29.11.09.58.645.0 ]--
r 68         end = nul
--[ 2019.10.29.11.09.58.790.0 ]--
r 68         end = null
--[ 2019.10.29.11.09.58.823.0 ]--
r 68         end = null;
--[ 2019.10.29.11.10.17.276.0 ]--
+ 95         
--[ 2019.10.29.11.13.30.721.0 ]--
+ 17     
--[ 2019.10.29.11.13.32.088.0 ]--
r 17     p
--[ 2019.10.29.11.13.32.182.0 ]--
r 17     pr
--[ 2019.10.29.11.13.32.288.0 ]--
r 17     pri
--[ 2019.10.29.11.13.32.462.0 ]--
r 17     priv
--[ 2019.10.29.11.13.32.589.0 ]--
r 17     priva
--[ 2019.10.29.11.13.32.689.0 ]--
r 17     privat
--[ 2019.10.29.11.13.32.784.0 ]--
r 17     private
--[ 2019.10.29.11.13.32.859.0 ]--
r 17     private 
--[ 2019.10.29.11.13.33.300.0 ]--
r 17     private M
--[ 2019.10.29.11.13.33.627.0 ]--
r 17     private Mi
--[ 2019.10.29.11.13.33.668.0 ]--
r 17     private Min
--[ 2019.10.29.11.13.34.161.0 ]--
r 17     private MinP
--[ 2019.10.29.11.13.35.028.0 ]--
r 17     private MinPq
--[ 2019.10.29.11.13.35.442.0 ]--
r 17     private MinPq<>
--[ 2019.10.29.11.13.37.359.0 ]--
r 17     private MinPq<P>
--[ 2019.10.29.11.13.37.484.0 ]--
r 17     private MinPq<PF>
--[ 2019.10.29.11.13.37.640.0 ]--
r 17     private MinPq<PFN>
--[ 2019.10.29.11.13.37.969.0 ]--
r 17     private MinPq<PFNo>
--[ 2019.10.29.11.13.38.048.0 ]--
r 17     private MinPq<PFNod>
--[ 2019.10.29.11.13.38.252.0 ]--
r 17     private MinPq<PFNode>
--[ 2019.10.29.11.13.38.459.0 ]--
r 17     private MinPq<PFNode> 
--[ 2019.10.29.11.13.40.076.0 ]--
r 17     private MinPq<PFNode> m
--[ 2019.10.29.11.13.40.168.0 ]--
r 17     private MinPq<PFNode> mi
--[ 2019.10.29.11.13.40.326.0 ]--
r 17     private MinPq<PFNode> min
--[ 2019.10.29.11.13.41.271.0 ]--
r 17     private MinPq<PFNode> mi
--[ 2019.10.29.11.13.41.464.0 ]--
r 17     private MinPq<PFNode> m
--[ 2019.10.29.11.13.41.598.0 ]--
r 17     private MinPq<PFNode> 
--[ 2019.10.29.11.13.41.881.0 ]--
r 17     private MinPq<PFNode> p
--[ 2019.10.29.11.13.42.056.0 ]--
r 17     private MinPq<PFNode> pq
--[ 2019.10.29.11.13.42.109.0 ]--
r 17     private MinPq<PFNode> pq;
--[ 2019.10.29.11.14.04.454.0 ]--
r 17     private M<PFNode> pq;
--[ 2019.10.29.11.14.04.671.0 ]--
r 17     private Mi<PFNode> pq;
--[ 2019.10.29.11.14.04.772.0 ]--
r 17     private Min<PFNode> pq;
--[ 2019.10.29.11.14.05.012.0 ]--
r 17     private MinP<PFNode> pq;
--[ 2019.10.29.11.14.05.178.0 ]--
r 17     private MinPQ<PFNode> pq;
--[ 2019.10.29.11.14.12.372.0 ]--
+ 70         
--[ 2019.10.29.11.14.12.755.0 ]--
r 70         p
--[ 2019.10.29.11.14.12.917.0 ]--
r 70         pq
--[ 2019.10.29.11.14.12.987.0 ]--
r 70         pq 
--[ 2019.10.29.11.14.13.127.0 ]--
r 70         pq =
--[ 2019.10.29.11.14.13.235.0 ]--
r 70         pq = 
--[ 2019.10.29.11.14.13.415.0 ]--
r 70         pq = n
--[ 2019.10.29.11.14.13.502.0 ]--
r 70         pq = ne
--[ 2019.10.29.11.14.13.599.0 ]--
r 70         pq = new
--[ 2019.10.29.11.14.13.668.0 ]--
r 70         pq = new 
--[ 2019.10.29.11.14.15.044.0 ]--
r 70         pq = new
--[ 2019.10.29.11.14.15.707.0 ]--
r 70         pq = new 
--[ 2019.10.29.11.14.15.993.0 ]--
r 70         pq = new M
--[ 2019.10.29.11.14.16.242.0 ]--
r 70         pq = new Mi
--[ 2019.10.29.11.14.16.326.0 ]--
r 70         pq = new Min
--[ 2019.10.29.11.14.16.726.0 ]--
r 70         pq = new MinP
--[ 2019.10.29.11.14.16.882.0 ]--
r 70         pq = new MinPQ
--[ 2019.10.29.11.14.17.310.0 ]--
r 70         pq = new MinPQ<>
--[ 2019.10.29.11.14.17.330.0 ]--
r 70         pq = new MinPQ<>()
--[ 2019.10.29.11.14.19.167.0 ]--
r 70         pq = new MinPQ<>();
--[ 2019.10.29.11.14.46.109.0 ]--
r 48 
r 97 
--[ 2019.10.29.11.17.50.886.0 ]--
+ 90         
--[ 2019.10.29.11.18.59.005.0 ]--
+ 18     
--[ 2019.10.29.11.18.59.532.0 ]--
r 18     p
--[ 2019.10.29.11.18.59.599.0 ]--
r 18     pr
--[ 2019.10.29.11.18.59.750.0 ]--
r 18     pri
--[ 2019.10.29.11.18.59.867.0 ]--
r 18     priv
--[ 2019.10.29.11.18.59.970.0 ]--
r 18     priva
--[ 2019.10.29.11.19.00.131.0 ]--
r 18     priva t
--[ 2019.10.29.11.19.00.225.0 ]--
r 18     priva te
--[ 2019.10.29.11.19.00.327.0 ]--
r 18     priva te 
--[ 2019.10.29.11.19.00.797.0 ]--
r 18     priva te
--[ 2019.10.29.11.19.00.971.0 ]--
r 18     priva t
--[ 2019.10.29.11.19.01.127.0 ]--
r 18     priva 
--[ 2019.10.29.11.19.01.304.0 ]--
r 18     priva
--[ 2019.10.29.11.19.01.578.0 ]--
r 18     privat
--[ 2019.10.29.11.19.01.658.0 ]--
r 18     private
--[ 2019.10.29.11.19.01.774.0 ]--
r 18     private 
--[ 2019.10.29.11.19.02.143.0 ]--
r 18     private T
--[ 2019.10.29.11.19.02.310.0 ]--
r 18     private Te
--[ 2019.10.29.11.19.02.466.0 ]--
r 18     private Ter
--[ 2019.10.29.11.19.02.795.0 ]--
r 18     private Terr
--[ 2019.10.29.11.19.02.972.0 ]--
r 18     private Terra
--[ 2019.10.29.11.19.03.067.0 ]--
r 18     private Terrai
--[ 2019.10.29.11.19.03.114.0 ]--
r 18     private Terrain
--[ 2019.10.29.11.19.03.222.0 ]--
r 18     private Terrain 
--[ 2019.10.29.11.19.03.342.0 ]--
r 18     private Terrain t
--[ 2019.10.29.11.19.03.425.0 ]--
r 18     private Terrain te
--[ 2019.10.29.11.19.03.573.0 ]--
r 18     private Terrain ter
--[ 2019.10.29.11.19.03.756.0 ]--
r 18     private Terrain terr
--[ 2019.10.29.11.19.03.827.0 ]--
r 18     private Terrain terra
--[ 2019.10.29.11.19.03.850.0 ]--
r 18     private Terrain terrai
--[ 2019.10.29.11.19.03.914.0 ]--
r 18     private Terrain terrain
--[ 2019.10.29.11.19.04.012.0 ]--
r 18     private Terrain terrain;
--[ 2019.10.29.11.19.07.161.0 ]--
+ 72         
--[ 2019.10.29.11.19.07.464.0 ]--
r 72         t
--[ 2019.10.29.11.19.07.577.0 ]--
r 72         th
--[ 2019.10.29.11.19.07.646.0 ]--
r 72         thi
--[ 2019.10.29.11.19.07.699.0 ]--
r 72         this
--[ 2019.10.29.11.19.07.856.0 ]--
r 72         this.
--[ 2019.10.29.11.19.07.992.0 ]--
r 72         this.t
--[ 2019.10.29.11.19.08.086.0 ]--
r 72         this.te
--[ 2019.10.29.11.19.08.236.0 ]--
r 72         this.ter
--[ 2019.10.29.11.19.08.407.0 ]--
r 72         this.terr
--[ 2019.10.29.11.19.08.459.0 ]--
r 72         this.terra
--[ 2019.10.29.11.19.08.507.0 ]--
r 72         this.terrai
--[ 2019.10.29.11.19.08.563.0 ]--
r 72         this.terrain
--[ 2019.10.29.11.19.08.670.0 ]--
r 72         this.terrain 
--[ 2019.10.29.11.19.08.816.0 ]--
r 72         this.terrain =
--[ 2019.10.29.11.19.08.913.0 ]--
r 72         this.terrain = 
--[ 2019.10.29.11.19.09.057.0 ]--
r 72         this.terrain = t
--[ 2019.10.29.11.19.09.318.0 ]--
r 72         this.terrain = ter
--[ 2019.10.29.11.19.09.467.0 ]--
r 72         this.terrain = terr
--[ 2019.10.29.11.19.09.554.0 ]--
r 72         this.terrain = terra
--[ 2019.10.29.11.19.09.577.0 ]--
r 72         this.terrain = terrai
--[ 2019.10.29.11.19.09.651.0 ]--
r 72         this.terrain = terrain
--[ 2019.10.29.11.19.09.788.0 ]--
r 72         this.terrain = terrain;
--[ 2019.10.29.11.23.20.931.0 ]--
+ 19     
--[ 2019.10.29.11.23.21.635.0 ]--
r 19     p
--[ 2019.10.29.11.23.21.724.0 ]--
r 19     pr
--[ 2019.10.29.11.23.21.850.0 ]--
r 19     pri
--[ 2019.10.29.11.23.22.000.0 ]--
r 19     priv
--[ 2019.10.29.11.23.22.097.0 ]--
r 19     priva
--[ 2019.10.29.11.23.22.270.0 ]--
r 19     privat
--[ 2019.10.29.11.23.22.347.0 ]--
r 19     private
--[ 2019.10.29.11.23.22.440.0 ]--
r 19     private 
--[ 2019.10.29.11.23.22.510.0 ]--
r 19     private i
--[ 2019.10.29.11.23.22.601.0 ]--
r 19     private in
--[ 2019.10.29.11.23.22.698.0 ]--
r 19     private int
--[ 2019.10.29.11.23.23.211.0 ]--
r 19     private int[]
--[ 2019.10.29.11.23.23.464.0 ]--
r 19     private int[][]
--[ 2019.10.29.11.23.23.770.0 ]--
r 19     private int[][] 
--[ 2019.10.29.11.23.26.115.0 ]--
r 19     private int[][] b
--[ 2019.10.29.11.23.26.286.0 ]--
r 19     private int[][] bo
--[ 2019.10.29.11.23.26.585.0 ]--
r 19     private int[][] b
--[ 2019.10.29.11.23.26.730.0 ]--
r 19     private int[][] 
--[ 2019.10.29.11.23.28.618.0 ]--
r 19     private int[][] b
--[ 2019.10.29.11.23.28.799.0 ]--
r 19     private int[][] bo
--[ 2019.10.29.11.23.28.931.0 ]--
r 19     private int[][] boa
--[ 2019.10.29.11.23.28.982.0 ]--
r 19     private int[][] boar
--[ 2019.10.29.11.23.29.188.0 ]--
r 19     private int[][] board
--[ 2019.10.29.11.23.29.221.0 ]--
r 19     private int[][] board;
--[ 2019.10.29.11.23.50.892.0 ]--
+ 74         
--[ 2019.10.29.11.23.51.738.0 ]--
r 74         b
--[ 2019.10.29.11.23.51.828.0 ]--
r 74         bo
--[ 2019.10.29.11.23.51.991.0 ]--
r 74         boa
--[ 2019.10.29.11.23.52.057.0 ]--
r 74         boar
--[ 2019.10.29.11.23.52.253.0 ]--
r 74         board
--[ 2019.10.29.11.23.52.350.0 ]--
r 74         board 
--[ 2019.10.29.11.23.52.398.0 ]--
r 74         board =
--[ 2019.10.29.11.23.52.566.0 ]--
r 74         board = 
--[ 2019.10.29.11.23.52.690.0 ]--
r 74         board = n
--[ 2019.10.29.11.23.52.809.0 ]--
r 74         board = ne
--[ 2019.10.29.11.23.52.882.0 ]--
r 74         board = new
--[ 2019.10.29.11.23.52.918.0 ]--
r 74         board = new 
--[ 2019.10.29.11.23.53.681.0 ]--
r 74         board = new i
--[ 2019.10.29.11.23.53.763.0 ]--
r 74         board = new in
--[ 2019.10.29.11.23.53.835.0 ]--
r 74         board = new int
--[ 2019.10.29.11.23.54.244.0 ]--
r 74         board = new int[]
--[ 2019.10.29.11.23.54.510.0 ]--
r 74         board = new int[][]
--[ 2019.10.29.11.23.56.566.0 ]--
r 74         board = new int[][]()
--[ 2019.10.29.11.23.56.941.0 ]--
r 74         board = new int[][]
--[ 2019.10.29.11.23.57.132.0 ]--
r 74         board = new int[][
--[ 2019.10.29.11.23.57.325.0 ]--
r 74         board = new int[]
--[ 2019.10.29.11.23.57.576.0 ]--
r 74         board = new int[
--[ 2019.10.29.11.23.59.109.0 ]--
r 74         board = new int[t
--[ 2019.10.29.11.23.59.193.0 ]--
r 74         board = new int[th
--[ 2019.10.29.11.23.59.266.0 ]--
r 74         board = new int[thi
--[ 2019.10.29.11.23.59.313.0 ]--
r 74         board = new int[this
--[ 2019.10.29.11.23.59.471.0 ]--
r 74         board = new int[this.
--[ 2019.10.29.11.23.59.560.0 ]--
r 74         board = new int[this.t
--[ 2019.10.29.11.23.59.660.0 ]--
r 74         board = new int[this.te
--[ 2019.10.29.11.23.59.807.0 ]--
r 74         board = new int[this.ter
--[ 2019.10.29.11.23.59.995.0 ]--
r 74         board = new int[this.terr
--[ 2019.10.29.11.24.00.050.0 ]--
r 74         board = new int[this.terra
--[ 2019.10.29.11.24.00.113.0 ]--
r 74         board = new int[this.terrai
--[ 2019.10.29.11.24.00.186.0 ]--
r 74         board = new int[this.terrain
--[ 2019.10.29.11.24.00.318.0 ]--
r 74         board = new int[this.terrain.
--[ 2019.10.29.11.24.00.438.0 ]--
r 74         board = new int[this.terrain.g
--[ 2019.10.29.11.24.00.522.0 ]--
r 74         board = new int[this.terrain.ge
--[ 2019.10.29.11.24.00.694.0 ]--
r 74         board = new int[this.terrain.get
--[ 2019.10.29.11.24.00.893.0 ]--
r 74         board = new int[this.terrain.getN
--[ 2019.10.29.11.24.01.680.0 ]--
r 74         board = new int[this.terrain.getN()
--[ 2019.10.29.11.24.02.821.0 ]--
r 74         board = new int[this.terrain.getN()[]
--[ 2019.10.29.11.24.03.269.0 ]--
r 74         board = new int[this.terrain.getN()]
--[ 2019.10.29.11.24.05.129.0 ]--
r 74         board = new int[this.terrain.getN()][]
--[ 2019.10.29.11.24.06.350.0 ]--
r 74         board = new int[this.terrain.getN()][t]
--[ 2019.10.29.11.24.06.431.0 ]--
r 74         board = new int[this.terrain.getN()][th]
--[ 2019.10.29.11.24.06.490.0 ]--
r 74         board = new int[this.terrain.getN()][thi]
--[ 2019.10.29.11.24.06.589.0 ]--
r 74         board = new int[this.terrain.getN()][this]
--[ 2019.10.29.11.24.06.706.0 ]--
r 74         board = new int[this.terrain.getN()][this.]
--[ 2019.10.29.11.24.06.808.0 ]--
r 74         board = new int[this.terrain.getN()][this.t]
--[ 2019.10.29.11.24.06.891.0 ]--
r 74         board = new int[this.terrain.getN()][this.te]
--[ 2019.10.29.11.24.07.034.0 ]--
r 74         board = new int[this.terrain.getN()][this.ter]
--[ 2019.10.29.11.24.07.195.0 ]--
r 74         board = new int[this.terrain.getN()][this.terr]
--[ 2019.10.29.11.24.07.264.0 ]--
r 74         board = new int[this.terrain.getN()][this.terra]
--[ 2019.10.29.11.24.07.329.0 ]--
r 74         board = new int[this.terrain.getN()][this.terrai]
--[ 2019.10.29.11.24.07.369.0 ]--
r 74         board = new int[this.terrain.getN()][this.terrain]
--[ 2019.10.29.11.24.07.581.0 ]--
r 74         board = new int[this.terrain.getN()][this.terrain.]
--[ 2019.10.29.11.24.07.663.0 ]--
r 74         board = new int[this.terrain.getN()][this.terrain.g]
--[ 2019.10.29.11.24.07.760.0 ]--
r 74         board = new int[this.terrain.getN()][this.terrain.ge]
--[ 2019.10.29.11.24.07.912.0 ]--
r 74         board = new int[this.terrain.getN()][this.terrain.get]
--[ 2019.10.29.11.24.08.128.0 ]--
r 74         board = new int[this.terrain.getN()][this.terrain.getN]
--[ 2019.10.29.11.24.08.552.0 ]--
r 74         board = new int[this.terrain.getN()][this.terrain.getN()]
--[ 2019.10.29.11.24.09.453.0 ]--
r 74         board = new int[this.terrain.getN()][this.terrain.getN()];
--[ 2019.10.29.11.24.44.879.0 ]--
+ 75         
--[ 2019.10.29.11.24.46.422.0 ]--
r 75         b
--[ 2019.10.29.11.24.46.688.0 ]--
r 75         bo
--[ 2019.10.29.11.24.46.957.0 ]--
r 75         b
--[ 2019.10.29.11.24.47.126.0 ]--
r 75         
--[ 2019.10.29.11.24.57.987.0 ]--
+ 74         
--[ 2019.10.29.11.24.58.317.0 ]--
r 74         i
--[ 2019.10.29.11.24.58.405.0 ]--
r 74         in
--[ 2019.10.29.11.24.58.441.0 ]--
r 74         int
--[ 2019.10.29.11.24.58.540.0 ]--
r 74         int 
--[ 2019.10.29.11.24.58.665.0 ]--
r 74         int N
--[ 2019.10.29.11.24.58.813.0 ]--
r 74         int N 
--[ 2019.10.29.11.24.58.907.0 ]--
r 74         int N =
--[ 2019.10.29.11.24.59.064.0 ]--
r 74         int N = 
--[ 2019.10.29.11.24.59.245.0 ]--
r 74         int N = t
--[ 2019.10.29.11.24.59.434.0 ]--
r 74         int N = th
--[ 2019.10.29.11.24.59.605.0 ]--
r 74         int N = thi
--[ 2019.10.29.11.24.59.741.0 ]--
r 74         int N = this
--[ 2019.10.29.11.24.59.848.0 ]--
r 74         int N = this.
--[ 2019.10.29.11.24.59.935.0 ]--
r 74         int N = this.t
--[ 2019.10.29.11.25.00.051.0 ]--
r 74         int N = this.te
--[ 2019.10.29.11.25.00.233.0 ]--
r 74         int N = this.ter
--[ 2019.10.29.11.25.00.405.0 ]--
r 74         int N = this.terr
--[ 2019.10.29.11.25.00.487.0 ]--
r 74         int N = this.terra
--[ 2019.10.29.11.25.00.776.0 ]--
r 74         int N = this.terrai
--[ 2019.10.29.11.25.00.833.0 ]--
r 74         int N = this.terrain
--[ 2019.10.29.11.25.01.029.0 ]--
r 74         int N = this.terrain.
--[ 2019.10.29.11.25.01.127.0 ]--
r 74         int N = this.terrain.g
--[ 2019.10.29.11.25.01.220.0 ]--
r 74         int N = this.terrain.ge
--[ 2019.10.29.11.25.01.348.0 ]--
r 74         int N = this.terrain.get
--[ 2019.10.29.11.25.01.545.0 ]--
r 74         int N = this.terrain.getN
--[ 2019.10.29.11.25.01.912.0 ]--
r 74         int N = this.terrain.getN()
--[ 2019.10.29.11.25.02.237.0 ]--
r 74         int N = this.terrain.getN();
--[ 2019.10.29.11.25.06.211.0 ]--
r 75         board = new int[N][this.terrain.getN()];
--[ 2019.10.29.11.25.11.111.0 ]--
r 75         board = new int[N][N];
--[ 2019.10.29.11.27.03.043.0 ]--
r 96 
--[ 2019.10.29.11.27.06.558.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.10.29.11.27.28.627.0 ]--
r 108     
--[ 2019.10.29.11.27.28.813.0 ]--
r 108         
--[ 2019.10.29.11.27.29.295.0 ]--
r 108         S
--[ 2019.10.29.11.27.29.509.0 ]--
r 108         St
--[ 2019.10.29.11.27.29.725.0 ]--
r 108         Std
--[ 2019.10.29.11.27.29.907.0 ]--
r 108         StdO
--[ 2019.10.29.11.27.30.113.0 ]--
r 108         StdOu
--[ 2019.10.29.11.27.30.225.0 ]--
r 108         StdOut
--[ 2019.10.29.11.27.30.400.0 ]--
r 108         StdOut.
--[ 2019.10.29.11.27.30.924.0 ]--
r 108         StdOut.p
--[ 2019.10.29.11.27.31.074.0 ]--
r 108         StdOut.pr
--[ 2019.10.29.11.27.31.117.0 ]--
r 108         StdOut.pri
--[ 2019.10.29.11.27.31.213.0 ]--
r 108         StdOut.prin
--[ 2019.10.29.11.27.31.378.0 ]--
r 108         StdOut.print
--[ 2019.10.29.11.27.31.416.0 ]--
r 108         StdOut.printl
--[ 2019.10.29.11.27.31.523.0 ]--
r 108         StdOut.println
--[ 2019.10.29.11.27.31.704.0 ]--
r 108         StdOut.println()
--[ 2019.10.29.11.27.31.920.0 ]--
r 108         StdOut.println("")
--[ 2019.10.29.11.27.32.196.0 ]--
r 108         StdOut.println("y")
--[ 2019.10.29.11.27.32.316.0 ]--
r 108         StdOut.println("ye")
--[ 2019.10.29.11.27.32.469.0 ]--
r 108         StdOut.println("yee")
--[ 2019.10.29.11.27.32.565.0 ]--
r 108         StdOut.println("yeet")
--[ 2019.10.29.11.27.32.964.0 ]--
r 108         StdOut.println("yeet"0)
--[ 2019.10.29.11.27.33.498.0 ]--
r 108         StdOut.println("yeet")
--[ 2019.10.29.11.27.33.973.0 ]--
r 108         StdOut.println("yeet");
--[ 2019.10.29.11.27.35.880.0 ]--
r 76 
--[ 2019.10.29.11.27.37.088.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.10.29.11.27.53.012.0 ]--
r 108 
--[ 2019.10.29.11.27.53.177.0 ]--
- 108
--[ 2019.10.29.11.27.53.458.0 ]--
+ 108         
--[ 2019.10.29.11.29.53.142.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.10.29.11.29.54.409.0 ]--
r 46     private final static String emapFilename = emaps[7];        // change index to load a different elevation map
--[ 2019.10.29.11.29.56.241.0 ]--
:/src/Pathfinder.java
r 108 
--[ 2019.10.29.11.29.57.869.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.10.29.11.32.04.658.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.10.29.11.32.44.883.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.10.29.11.32.45.644.0 ]--
r 46     private final static String emapFilename = emaps[0];        // change index to load a different elevation map
--[ 2019.10.29.11.32.48.727.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.10.29.11.33.00.308.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.10.29.11.34.07.550.0 ]--
:/src/Pathfinder.java
r 34             return ;
--[ 2019.10.29.11.34.12.147.0 ]--
r 34             return t;
--[ 2019.10.29.11.34.12.236.0 ]--
r 34             return th;
--[ 2019.10.29.11.34.12.268.0 ]--
r 34             return thi;
--[ 2019.10.29.11.34.12.379.0 ]--
r 34             return this;
--[ 2019.10.29.11.34.12.623.0 ]--
r 34             return thi;
--[ 2019.10.29.11.34.12.801.0 ]--
r 34             return th;
--[ 2019.10.29.11.34.12.945.0 ]--
r 34             return t;
--[ 2019.10.29.11.34.13.108.0 ]--
r 34             return ;
--[ 2019.10.29.11.34.32.959.0 ]--
r 34             return g;
--[ 2019.10.29.11.34.33.197.0 ]--
r 34             return ge;
--[ 2019.10.29.11.34.33.226.0 ]--
r 34             return get;
--[ 2019.10.29.11.34.33.494.0 ]--
r 34             return getC;
--[ 2019.10.29.11.34.33.709.0 ]--
r 34             return getCo;
--[ 2019.10.29.11.34.33.783.0 ]--
r 34             return getCos;
--[ 2019.10.29.11.34.33.935.0 ]--
r 34             return getCost;
--[ 2019.10.29.11.34.34.257.0 ]--
r 34             return getCost();
--[ 2019.10.29.11.34.45.284.0 ]--
r 34             return getCost() ;
--[ 2019.10.29.11.34.45.649.0 ]--
r 34             return getCost() - ;
--[ 2019.10.29.11.34.46.036.0 ]--
r 34             return getCost() - t;
--[ 2019.10.29.11.34.46.138.0 ]--
r 34             return getCost() - th;
--[ 2019.10.29.11.34.46.201.0 ]--
r 34             return getCost() - thi;
--[ 2019.10.29.11.34.46.288.0 ]--
r 34             return getCost() - this;
--[ 2019.10.29.11.34.46.444.0 ]--
r 34             return getCost() - this.;
--[ 2019.10.29.11.34.46.537.0 ]--
r 34             return getCost() - this.g;
--[ 2019.10.29.11.34.46.625.0 ]--
r 34             return getCost() - this.ge;
--[ 2019.10.29.11.34.46.796.0 ]--
r 34             return getCost() - this.get;
--[ 2019.10.29.11.34.47.045.0 ]--
r 34             return getCost() - this.getC;
--[ 2019.10.29.11.34.47.240.0 ]--
r 34             return getCost() - this.getCo;
--[ 2019.10.29.11.34.47.479.0 ]--
r 34             return getCost() - this.getC;
--[ 2019.10.29.11.34.47.694.0 ]--
r 34             return getCost() - this.get;
--[ 2019.10.29.11.34.47.875.0 ]--
r 34             return getCost() - this.ge;
--[ 2019.10.29.11.34.48.053.0 ]--
r 34             return getCost() - this.g;
--[ 2019.10.29.11.34.48.191.0 ]--
r 34             return getCost() - this.;
--[ 2019.10.29.11.34.48.379.0 ]--
r 34             return getCost() - this;
--[ 2019.10.29.11.34.48.568.0 ]--
r 34             return getCost() - thi;
--[ 2019.10.29.11.34.48.737.0 ]--
r 34             return getCost() - th;
--[ 2019.10.29.11.34.48.924.0 ]--
r 34             return getCost() - t;
--[ 2019.10.29.11.34.49.133.0 ]--
r 34             return getCost() - ;
--[ 2019.10.29.11.34.49.430.0 ]--
r 34             return getCost() - t;
--[ 2019.10.29.11.34.49.611.0 ]--
r 34             return getCost() - th;
--[ 2019.10.29.11.34.49.730.0 ]--
r 34             return getCost() - tha;
--[ 2019.10.29.11.34.49.784.0 ]--
r 34             return getCost() - that;
--[ 2019.10.29.11.34.53.402.0 ]--
r 34             return getCost() - that.;
--[ 2019.10.29.11.34.54.070.0 ]--
r 34             return getCost() - that.g;
--[ 2019.10.29.11.34.54.152.0 ]--
r 34             return getCost() - that.ge;
--[ 2019.10.29.11.34.54.321.0 ]--
r 34             return getCost() - that.get;
--[ 2019.10.29.11.34.54.524.0 ]--
r 34             return getCost() - that.getC;
--[ 2019.10.29.11.34.54.663.0 ]--
r 34             return getCost() - that.getCo;
--[ 2019.10.29.11.34.54.875.0 ]--
r 34             return getCost() - that.getCos;
--[ 2019.10.29.11.34.54.954.0 ]--
r 34             return getCost() - that.getCost;
--[ 2019.10.29.11.34.55.414.0 ]--
r 34             return getCost() - that.getCost();
--[ 2019.10.29.11.35.02.266.0 ]--
+ 39         
--[ 2019.10.29.11.35.02.417.0 ]--
+ 39         
--[ 2019.10.29.11.35.03.401.0 ]--
+ 39         
--[ 2019.10.29.11.35.04.065.0 ]--
r 40         p
--[ 2019.10.29.11.35.04.188.0 ]--
r 40         pu
--[ 2019.10.29.11.35.04.274.0 ]--
r 40         pub
--[ 2019.10.29.11.35.04.404.0 ]--
r 40         publ
--[ 2019.10.29.11.35.04.498.0 ]--
r 40         publi
--[ 2019.10.29.11.35.04.554.0 ]--
r 40         public
--[ 2019.10.29.11.35.04.671.0 ]--
r 40         public 
--[ 2019.10.29.11.35.04.773.0 ]--
r 40         public f
--[ 2019.10.29.11.35.04.854.0 ]--
r 40         public fl
--[ 2019.10.29.11.35.05.029.0 ]--
r 40         public flo
--[ 2019.10.29.11.35.05.127.0 ]--
r 40         public floa
--[ 2019.10.29.11.35.05.207.0 ]--
r 40         public float
--[ 2019.10.29.11.35.05.276.0 ]--
r 40         public float 
--[ 2019.10.29.11.35.05.437.0 ]--
r 40         public float g
--[ 2019.10.29.11.35.05.713.0 ]--
r 40         public float get
--[ 2019.10.29.11.35.05.905.0 ]--
r 40         public float getC
--[ 2019.10.29.11.35.06.004.0 ]--
r 40         public float getCo
--[ 2019.10.29.11.35.06.157.0 ]--
r 40         public float getCos
--[ 2019.10.29.11.35.06.235.0 ]--
r 40         public float getCost
--[ 2019.10.29.11.35.06.481.0 ]--
r 40         public float getCost()
--[ 2019.10.29.11.35.06.756.0 ]--
r 40         public float getCost() 
--[ 2019.10.29.11.35.06.954.0 ]--
r 40         public float getCost() {}
--[ 2019.10.29.11.35.07.136.0 ]--
+ 40         public float getCost() {
r 41         }
--[ 2019.10.29.11.35.07.159.0 ]--
+ 41             
--[ 2019.10.29.11.35.07.429.0 ]--
r 41             r
--[ 2019.10.29.11.35.07.514.0 ]--
r 41             re
--[ 2019.10.29.11.35.07.682.0 ]--
r 41             ret
--[ 2019.10.29.11.35.07.751.0 ]--
r 41             retu
--[ 2019.10.29.11.35.07.899.0 ]--
r 41             retur
--[ 2019.10.29.11.35.07.959.0 ]--
r 41             return
--[ 2019.10.29.11.35.08.047.0 ]--
r 41             return 
--[ 2019.10.29.11.35.08.149.0 ]--
r 41             return 0
--[ 2019.10.29.11.35.08.364.0 ]--
r 41             return 0;
--[ 2019.10.29.11.35.16.399.0 ]--
r 34             return igetCost() - that.getCost();
--[ 2019.10.29.11.35.16.596.0 ]--
r 34             return intgetCost() - that.getCost();
--[ 2019.10.29.11.35.16.734.0 ]--
r 34             return int(getCost() - that.getCost();
--[ 2019.10.29.11.35.19.993.0 ]--
r 34             return int(getCost() - that.getCost());
--[ 2019.10.29.11.35.23.847.0 ]--
r 34             return int(getCost() - that.getCost();
--[ 2019.10.29.11.35.25.042.0 ]--
r 34             return intgetCost() - that.getCost();
--[ 2019.10.29.11.35.25.241.0 ]--
r 34             return ingetCost() - that.getCost();
--[ 2019.10.29.11.35.25.427.0 ]--
r 34             return igetCost() - that.getCost();
--[ 2019.10.29.11.35.25.612.0 ]--
r 34             return getCost() - that.getCost();
--[ 2019.10.29.11.35.41.278.0 ]--
r 40         public i getCost() {
--[ 2019.10.29.11.35.41.499.0 ]--
r 40         public int getCost() {
--[ 2019.10.29.11.38.29.929.0 ]--
r 113     
--[ 2019.10.29.11.38.30.158.0 ]--
r 113         
--[ 2019.10.29.11.38.30.427.0 ]--
r 113         /
--[ 2019.10.29.11.38.30.572.0 ]--
r 113         //
--[ 2019.10.29.11.38.30.707.0 ]--
r 113         // 
--[ 2019.10.29.11.38.30.908.0 ]--
r 113         // S
--[ 2019.10.29.11.38.31.117.0 ]--
r 113         // St
--[ 2019.10.29.11.38.31.324.0 ]--
r 113         // Step
--[ 2019.10.29.11.38.31.356.0 ]--
r 113         // Step 
--[ 2019.10.29.11.38.31.467.0 ]--
r 113         // Step 1
--[ 2019.10.29.11.38.31.830.0 ]--
r 113         // Step 1:
--[ 2019.10.29.11.38.31.900.0 ]--
r 113         // Step 1: 
--[ 2019.10.29.11.38.33.647.0 ]--
r 113         // Step 1: L
--[ 2019.10.29.11.38.33.848.0 ]--
r 113         // Step 1: Lo
--[ 2019.10.29.11.38.34.003.0 ]--
r 113         // Step 1: Loo
--[ 2019.10.29.11.38.34.128.0 ]--
r 113         // Step 1: Look
--[ 2019.10.29.11.38.34.179.0 ]--
r 113         // Step 1: Look 
--[ 2019.10.29.11.38.34.319.0 ]--
r 113         // Step 1: Look a
--[ 2019.10.29.11.38.34.395.0 ]--
r 113         // Step 1: Look at
--[ 2019.10.29.11.38.34.505.0 ]--
r 113         // Step 1: Look at 
--[ 2019.10.29.11.38.34.603.0 ]--
r 113         // Step 1: Look at a
--[ 2019.10.29.11.38.34.679.0 ]--
r 113         // Step 1: Look at al
--[ 2019.10.29.11.38.34.858.0 ]--
r 113         // Step 1: Look at all
--[ 2019.10.29.11.38.34.923.0 ]--
r 113         // Step 1: Look at all 
--[ 2019.10.29.11.38.35.071.0 ]--
r 113         // Step 1: Look at all p
--[ 2019.10.29.11.38.35.195.0 ]--
r 113         // Step 1: Look at all po
--[ 2019.10.29.11.38.35.364.0 ]--
r 113         // Step 1: Look at all pos
--[ 2019.10.29.11.38.35.507.0 ]--
r 113         // Step 1: Look at all poss
--[ 2019.10.29.11.38.35.627.0 ]--
r 113         // Step 1: Look at all possi
--[ 2019.10.29.11.38.35.722.0 ]--
r 113         // Step 1: Look at all possib
--[ 2019.10.29.11.38.35.835.0 ]--
r 113         // Step 1: Look at all possibl
--[ 2019.10.29.11.38.35.969.0 ]--
r 113         // Step 1: Look at all possible
--[ 2019.10.29.11.38.36.027.0 ]--
r 113         // Step 1: Look at all possible 
--[ 2019.10.29.11.38.36.151.0 ]--
r 113         // Step 1: Look at all possible l
--[ 2019.10.29.11.38.36.300.0 ]--
r 113         // Step 1: Look at all possible lo
--[ 2019.10.29.11.38.36.400.0 ]--
r 113         // Step 1: Look at all possible loc
--[ 2019.10.29.11.38.36.603.0 ]--
r 113         // Step 1: Look at all possible loca
--[ 2019.10.29.11.38.36.674.0 ]--
r 113         // Step 1: Look at all possible locat
--[ 2019.10.29.11.38.36.734.0 ]--
r 113         // Step 1: Look at all possible locati
--[ 2019.10.29.11.38.36.845.0 ]--
r 113         // Step 1: Look at all possible locatio
--[ 2019.10.29.11.38.36.903.0 ]--
r 113         // Step 1: Look at all possible location
--[ 2019.10.29.11.38.37.002.0 ]--
r 113         // Step 1: Look at all possible locations
--[ 2019.10.29.11.38.37.044.0 ]--
r 113         // Step 1: Look at all possible locations 
--[ 2019.10.29.11.38.37.172.0 ]--
r 113         // Step 1: Look at all possible locations f
--[ 2019.10.29.11.38.37.406.0 ]--
r 113         // Step 1: Look at all possible locations fr
--[ 2019.10.29.11.38.37.509.0 ]--
r 113         // Step 1: Look at all possible locations fro
--[ 2019.10.29.11.38.37.588.0 ]--
r 113         // Step 1: Look at all possible locations from
--[ 2019.10.29.11.38.37.651.0 ]--
r 113         // Step 1: Look at all possible locations from 
--[ 2019.10.29.11.38.37.763.0 ]--
r 113         // Step 1: Look at all possible locations from s
--[ 2019.10.29.11.38.37.851.0 ]--
r 113         // Step 1: Look at all possible locations from st
--[ 2019.10.29.11.38.38.005.0 ]--
r 113         // Step 1: Look at all possible locations from sta
--[ 2019.10.29.11.38.38.086.0 ]--
r 113         // Step 1: Look at all possible locations from star
--[ 2019.10.29.11.38.38.354.0 ]--
r 113         // Step 1: Look at all possible locations from start
--[ 2019.10.29.11.38.38.486.0 ]--
r 113         // Step 1: Look at all possible locations from starti
--[ 2019.10.29.11.38.38.555.0 ]--
r 113         // Step 1: Look at all possible locations from startin
--[ 2019.10.29.11.38.38.627.0 ]--
r 113         // Step 1: Look at all possible locations from starting
--[ 2019.10.29.11.38.38.699.0 ]--
r 113         // Step 1: Look at all possible locations from starting 
--[ 2019.10.29.11.38.38.814.0 ]--
r 113         // Step 1: Look at all possible locations from starting p
--[ 2019.10.29.11.38.38.884.0 ]--
r 113         // Step 1: Look at all possible locations from starting po
--[ 2019.10.29.11.38.39.019.0 ]--
r 113         // Step 1: Look at all possible locations from starting poi
--[ 2019.10.29.11.38.39.127.0 ]--
r 113         // Step 1: Look at all possible locations from starting poin
--[ 2019.10.29.11.38.39.238.0 ]--
r 113         // Step 1: Look at all possible locations from starting point
--[ 2019.10.29.11.38.39.384.0 ]--
+ 114         
--[ 2019.10.29.11.38.46.536.0 ]--
r 114         s
--[ 2019.10.29.11.38.46.773.0 ]--
r 114         sta
--[ 2019.10.29.11.38.46.855.0 ]--
r 114         star
--[ 2019.10.29.11.38.47.066.0 ]--
r 114         start
--[ 2019.10.29.11.38.47.307.0 ]--
r 114         star
--[ 2019.10.29.11.38.47.496.0 ]--
r 114         sta
--[ 2019.10.29.11.38.47.669.0 ]--
r 114         st
--[ 2019.10.29.11.38.47.839.0 ]--
r 114         s
--[ 2019.10.29.11.38.47.982.0 ]--
r 114         
--[ 2019.10.29.11.38.48.332.0 ]--
r 114         P
--[ 2019.10.29.11.38.48.423.0 ]--
r 114         PF
--[ 2019.10.29.11.38.48.900.0 ]--
r 114         PFN
--[ 2019.10.29.11.38.49.211.0 ]--
r 114         PFNo
--[ 2019.10.29.11.38.49.289.0 ]--
r 114         PFNod
--[ 2019.10.29.11.38.49.481.0 ]--
r 114         PFNode
--[ 2019.10.29.11.38.49.575.0 ]--
r 114         PFNode 
--[ 2019.10.29.11.38.49.703.0 ]--
r 114         PFNode s
--[ 2019.10.29.11.38.49.820.0 ]--
r 114         PFNode st
--[ 2019.10.29.11.38.49.936.0 ]--
r 114         PFNode sta
--[ 2019.10.29.11.38.50.029.0 ]--
r 114         PFNode star
--[ 2019.10.29.11.38.50.239.0 ]--
r 114         PFNode start
--[ 2019.10.29.11.38.50.414.0 ]--
r 114         PFNode startN
--[ 2019.10.29.11.38.50.587.0 ]--
r 114         PFNode startNo
--[ 2019.10.29.11.38.50.651.0 ]--
r 114         PFNode startNod
--[ 2019.10.29.11.38.50.871.0 ]--
r 114         PFNode startNode
--[ 2019.10.29.11.38.50.905.0 ]--
r 114         PFNode startNode 
--[ 2019.10.29.11.38.51.291.0 ]--
r 114         PFNode startNode =
--[ 2019.10.29.11.38.51.456.0 ]--
r 114         PFNode startNode = 
--[ 2019.10.29.11.38.51.668.0 ]--
r 114         PFNode startNode = n
--[ 2019.10.29.11.38.51.743.0 ]--
r 114         PFNode startNode = ne
--[ 2019.10.29.11.38.51.799.0 ]--
r 114         PFNode startNode = new
--[ 2019.10.29.11.38.51.952.0 ]--
r 114         PFNode startNode = new 
--[ 2019.10.29.11.38.52.209.0 ]--
r 114         PFNode startNode = new P
--[ 2019.10.29.11.38.52.323.0 ]--
r 114         PFNode startNode = new PF
--[ 2019.10.29.11.38.52.536.0 ]--
r 114         PFNode startNode = new PFN
--[ 2019.10.29.11.38.53.035.0 ]--
r 114         PFNode startNode = new PFNo
--[ 2019.10.29.11.38.53.134.0 ]--
r 114         PFNode startNode = new PFNod
--[ 2019.10.29.11.38.53.337.0 ]--
r 114         PFNode startNode = new PFNode
--[ 2019.10.29.11.38.53.533.0 ]--
r 114         PFNode startNode = new PFNode()
--[ 2019.10.29.11.39.11.408.0 ]--
r 114         PFNode startNode = new PFNode
--[ 2019.10.29.11.39.11.882.0 ]--
r 114         PFNode startNode = new PFNod
--[ 2019.10.29.11.39.11.911.0 ]--
r 114         PFNode startNode = new PFNo
--[ 2019.10.29.11.39.11.944.0 ]--
r 114         PFNode startNode = new PFN
--[ 2019.10.29.11.39.11.968.0 ]--
r 114         PFNode startNode = new PF
--[ 2019.10.29.11.39.12.003.0 ]--
r 114         PFNode startNode = new P
--[ 2019.10.29.11.39.12.035.0 ]--
r 114         PFNode startNode = new 
--[ 2019.10.29.11.39.12.069.0 ]--
r 114         PFNode startNode = new
--[ 2019.10.29.11.39.12.112.0 ]--
r 114         PFNode startNode = ne
--[ 2019.10.29.11.39.12.142.0 ]--
r 114         PFNode startNode = n
--[ 2019.10.29.11.39.12.167.0 ]--
r 114         PFNode startNode = 
--[ 2019.10.29.11.39.12.204.0 ]--
r 114         PFNode startNode =
--[ 2019.10.29.11.39.12.233.0 ]--
r 114         PFNode startNode 
--[ 2019.10.29.11.39.12.262.0 ]--
r 114         PFNode startNode
--[ 2019.10.29.11.39.12.296.0 ]--
r 114         PFNode startNod
--[ 2019.10.29.11.39.12.334.0 ]--
r 114         PFNode startNo
--[ 2019.10.29.11.39.12.373.0 ]--
r 114         PFNode startN
--[ 2019.10.29.11.39.12.399.0 ]--
r 114         PFNode start
--[ 2019.10.29.11.39.12.431.0 ]--
r 114         PFNode star
--[ 2019.10.29.11.39.12.476.0 ]--
r 114         PFNode sta
--[ 2019.10.29.11.39.12.498.0 ]--
r 114         PFNode st
--[ 2019.10.29.11.39.12.533.0 ]--
r 114         PFNode s
--[ 2019.10.29.11.39.12.564.0 ]--
r 114         PFNode 
--[ 2019.10.29.11.39.12.738.0 ]--
r 114         PFNode
--[ 2019.10.29.11.39.12.983.0 ]--
r 114         PFNod
--[ 2019.10.29.11.39.13.126.0 ]--
r 114         PFNo
--[ 2019.10.29.11.39.13.294.0 ]--
r 114         PFN
--[ 2019.10.29.11.39.13.471.0 ]--
r 114         PF
--[ 2019.10.29.11.39.13.662.0 ]--
r 114         P
--[ 2019.10.29.11.39.13.942.0 ]--
r 114         
--[ 2019.10.29.11.39.17.607.0 ]--
r 114         P
--[ 2019.10.29.11.39.17.707.0 ]--
r 114         PF
--[ 2019.10.29.11.39.17.914.0 ]--
r 114         PFN
--[ 2019.10.29.11.39.18.306.0 ]--
r 114         PFNo
--[ 2019.10.29.11.39.18.763.0 ]--
r 114         PFNod
--[ 2019.10.29.11.39.19.008.0 ]--
r 114         PFNode
--[ 2019.10.29.11.39.19.028.0 ]--
r 114         PFNode 
--[ 2019.10.29.11.39.19.287.0 ]--
r 114         PFNode =
--[ 2019.10.29.11.39.19.363.0 ]--
r 114         PFNode = 
--[ 2019.10.29.11.39.19.604.0 ]--
r 114         PFNode = s
--[ 2019.10.29.11.39.19.716.0 ]--
r 114         PFNode = st
--[ 2019.10.29.11.39.19.864.0 ]--
r 114         PFNode = sta
--[ 2019.10.29.11.39.19.976.0 ]--
r 114         PFNode = star
--[ 2019.10.29.11.39.20.197.0 ]--
r 114         PFNode = start
--[ 2019.10.29.11.39.20.233.0 ]--
r 114         PFNode = star
--[ 2019.10.29.11.39.20.762.0 ]--
r 114         PFNode = sta
--[ 2019.10.29.11.39.20.788.0 ]--
r 114         PFNode = st
--[ 2019.10.29.11.39.20.824.0 ]--
r 114         PFNode = s
--[ 2019.10.29.11.39.20.856.0 ]--
r 114         PFNode = 
--[ 2019.10.29.11.39.20.891.0 ]--
r 114         PFNode =
--[ 2019.10.29.11.39.20.924.0 ]--
r 114         PFNode 
--[ 2019.10.29.11.39.20.960.0 ]--
r 114         PFNode
--[ 2019.10.29.11.39.20.992.0 ]--
r 114         PFNod
--[ 2019.10.29.11.39.21.024.0 ]--
r 114         PFNo
--[ 2019.10.29.11.39.21.057.0 ]--
r 114         PFN
--[ 2019.10.29.11.39.21.093.0 ]--
r 114         PF
--[ 2019.10.29.11.39.21.271.0 ]--
r 114         P
--[ 2019.10.29.11.39.21.460.0 ]--
r 114         
--[ 2019.10.29.11.39.55.081.0 ]--
+ 111     
--[ 2019.10.29.11.39.55.300.0 ]--
+ 111     
--[ 2019.10.29.11.39.55.656.0 ]--
r 112     p
--[ 2019.10.29.11.39.55.699.0 ]--
r 112     pr
--[ 2019.10.29.11.39.55.862.0 ]--
r 112     pri
--[ 2019.10.29.11.39.55.941.0 ]--
r 112     priv
--[ 2019.10.29.11.39.56.079.0 ]--
r 112     priva
--[ 2019.10.29.11.39.56.207.0 ]--
r 112     privat
--[ 2019.10.29.11.39.56.286.0 ]--
r 112     private
--[ 2019.10.29.11.39.56.362.0 ]--
r 112     private 
--[ 2019.10.29.11.39.56.893.0 ]--
r 112     private f
--[ 2019.10.29.11.39.57.022.0 ]--
r 112     private fi
--[ 2019.10.29.11.39.57.096.0 ]--
r 112     private fin
--[ 2019.10.29.11.39.57.189.0 ]--
r 112     private find
--[ 2019.10.29.11.39.57.688.0 ]--
r 112     private findN
--[ 2019.10.29.11.39.57.827.0 ]--
r 112     private findNe
--[ 2019.10.29.11.39.57.914.0 ]--
r 112     private findNei
--[ 2019.10.29.11.39.57.994.0 ]--
r 112     private findNeig
--[ 2019.10.29.11.39.58.103.0 ]--
r 112     private findNeigh
--[ 2019.10.29.11.39.58.258.0 ]--
r 112     private findNeighb
--[ 2019.10.29.11.39.58.370.0 ]--
r 112     private findNeighbo
--[ 2019.10.29.11.39.58.507.0 ]--
r 112     private findNeighbor
--[ 2019.10.29.11.39.58.691.0 ]--
r 112     private findNeighbors
--[ 2019.10.29.11.39.59.035.0 ]--
r 112     private findNeighbors()
--[ 2019.10.29.11.39.59.428.0 ]--
r 112     private findNeighbors() 
--[ 2019.10.29.11.39.59.590.0 ]--
r 112     private findNeighbors() {}
--[ 2019.10.29.11.39.59.719.0 ]--
+ 112     private findNeighbors() {
r 113     }
--[ 2019.10.29.11.39.59.750.0 ]--
+ 113         
--[ 2019.10.29.11.40.08.430.0 ]--
r 112     private vfindNeighbors() {
--[ 2019.10.29.11.40.08.625.0 ]--
r 112     private voifindNeighbors() {
--[ 2019.10.29.11.40.08.666.0 ]--
r 112     private voidfindNeighbors() {
--[ 2019.10.29.11.40.08.755.0 ]--
r 112     private void findNeighbors() {
--[ 2019.10.29.11.41.14.681.0 ]--
+ 113         
--[ 2019.10.29.11.41.15.106.0 ]--
r 113         C
--[ 2019.10.29.11.41.15.324.0 ]--
r 113         Co
--[ 2019.10.29.11.41.15.474.0 ]--
r 113         Coo
--[ 2019.10.29.11.41.15.535.0 ]--
r 113         Coor
--[ 2019.10.29.11.41.15.680.0 ]--
r 113         Coord
--[ 2019.10.29.11.41.15.818.0 ]--
r 113         Coor
--[ 2019.10.29.11.41.16.007.0 ]--
r 113         Coo
--[ 2019.10.29.11.41.16.151.0 ]--
r 113         Co
--[ 2019.10.29.11.41.16.311.0 ]--
r 113         C
--[ 2019.10.29.11.41.16.790.0 ]--
r 113         
--[ 2019.10.29.11.41.19.146.0 ]--
r 112     private void findNeighbors(C) {
--[ 2019.10.29.11.41.19.351.0 ]--
r 112     private void findNeighbors(Co) {
--[ 2019.10.29.11.41.19.488.0 ]--
r 112     private void findNeighbors(Coo) {
--[ 2019.10.29.11.41.19.604.0 ]--
r 112     private void findNeighbors(Coor) {
--[ 2019.10.29.11.41.19.771.0 ]--
r 112     private void findNeighbors(Coord) {
--[ 2019.10.29.11.41.19.848.0 ]--
r 112     private void findNeighbors(Coord ) {
--[ 2019.10.29.11.41.20.210.0 ]--
r 112     private void findNeighbors(Coord s) {
--[ 2019.10.29.11.41.26.561.0 ]--
r 113         C
--[ 2019.10.29.11.41.27.054.0 ]--
r 113         Co
--[ 2019.10.29.11.41.27.144.0 ]--
r 113         Coo
--[ 2019.10.29.11.41.27.233.0 ]--
r 113         Coor
--[ 2019.10.29.11.41.27.446.0 ]--
r 113         Coord
--[ 2019.10.29.11.41.27.478.0 ]--
r 113         Coord 
--[ 2019.10.29.11.41.27.672.0 ]--
r 113         Coord =
--[ 2019.10.29.11.41.28.007.0 ]--
r 113         Coord 
--[ 2019.10.29.11.41.28.290.0 ]--
r 113         Coord a
--[ 2019.10.29.11.41.28.372.0 ]--
r 113         Coord a 
--[ 2019.10.29.11.41.28.480.0 ]--
r 113         Coord a =
--[ 2019.10.29.11.41.28.594.0 ]--
r 113         Coord a = 
--[ 2019.10.29.11.41.28.690.0 ]--
r 113         Coord a = n
--[ 2019.10.29.11.41.28.800.0 ]--
r 113         Coord a = ne
--[ 2019.10.29.11.41.28.870.0 ]--
r 113         Coord a = new
--[ 2019.10.29.11.41.28.938.0 ]--
r 113         Coord a = new 
--[ 2019.10.29.11.41.29.179.0 ]--
r 113         Coord a = new C
--[ 2019.10.29.11.41.29.363.0 ]--
r 113         Coord a = new Co
--[ 2019.10.29.11.41.29.496.0 ]--
r 113         Coord a = new Coo
--[ 2019.10.29.11.41.29.576.0 ]--
r 113         Coord a = new Coor
--[ 2019.10.29.11.41.29.790.0 ]--
r 113         Coord a = new Coord
--[ 2019.10.29.11.41.29.914.0 ]--
r 113         Coord a = new Coord()
--[ 2019.10.29.11.41.31.425.0 ]--
r 113         Coord a = new Coord(s)
--[ 2019.10.29.11.41.31.534.0 ]--
r 113         Coord a = new Coord(s.)
--[ 2019.10.29.11.41.31.841.0 ]--
r 113         Coord a = new Coord(s.g)
--[ 2019.10.29.11.41.31.905.0 ]--
r 113         Coord a = new Coord(s.ge)
--[ 2019.10.29.11.41.32.098.0 ]--
r 113         Coord a = new Coord(s.get)
--[ 2019.10.29.11.41.32.308.0 ]--
r 113         Coord a = new Coord(s.getI)
--[ 2019.10.29.11.41.32.643.0 ]--
r 113         Coord a = new Coord(s.getI())
--[ 2019.10.29.11.41.33.321.0 ]--
r 113         Coord a = new Coord(s.getI(),)
--[ 2019.10.29.11.41.33.402.0 ]--
r 113         Coord a = new Coord(s.getI(), )
--[ 2019.10.29.11.41.33.626.0 ]--
r 113         Coord a = new Coord(s.getI(), s)
--[ 2019.10.29.11.41.33.744.0 ]--
r 113         Coord a = new Coord(s.getI(), s.)
--[ 2019.10.29.11.41.33.915.0 ]--
r 113         Coord a = new Coord(s.getI(), s.g)
--[ 2019.10.29.11.41.33.985.0 ]--
r 113         Coord a = new Coord(s.getI(), s.ge)
--[ 2019.10.29.11.41.34.143.0 ]--
r 113         Coord a = new Coord(s.getI(), s.get)
--[ 2019.10.29.11.41.34.474.0 ]--
r 113         Coord a = new Coord(s.getI(), s.getJ)
--[ 2019.10.29.11.41.34.816.0 ]--
r 113         Coord a = new Coord(s.getI(), s.getJ())
--[ 2019.10.29.11.41.35.698.0 ]--
r 113         Coord a = new Coord(s.getI(), s.getJ());
--[ 2019.10.29.11.41.37.946.0 ]--
r 113         Coord a = new Coord(s.getI()+, s.getJ());
--[ 2019.10.29.11.41.38.234.0 ]--
r 113         Coord a = new Coord(s.getI()+1, s.getJ());
--[ 2019.10.29.11.41.41.951.0 ]--
+ 114         
--[ 2019.10.29.11.41.42.298.0 ]--
r 114         C
--[ 2019.10.29.11.41.42.426.0 ]--
r 114         Co
--[ 2019.10.29.11.41.42.579.0 ]--
r 114         Coo
--[ 2019.10.29.11.41.42.655.0 ]--
r 114         Coor
--[ 2019.10.29.11.41.42.863.0 ]--
r 114         Coord
--[ 2019.10.29.11.41.42.973.0 ]--
r 114         Coord 
--[ 2019.10.29.11.41.43.243.0 ]--
r 114         Coord b
--[ 2019.10.29.11.41.43.339.0 ]--
r 114         Coord b 
--[ 2019.10.29.11.41.43.519.0 ]--
r 114         Coord b =
--[ 2019.10.29.11.41.43.609.0 ]--
r 114         Coord b = 
--[ 2019.10.29.11.41.43.811.0 ]--
r 114         Coord b = n
--[ 2019.10.29.11.41.43.880.0 ]--
r 114         Coord b = ne
--[ 2019.10.29.11.41.43.947.0 ]--
r 114         Coord b = new
--[ 2019.10.29.11.41.43.994.0 ]--
r 114         Coord b = new 
--[ 2019.10.29.11.41.44.365.0 ]--
r 114         Coord b = new C
--[ 2019.10.29.11.41.44.482.0 ]--
r 114         Coord b = new Co
--[ 2019.10.29.11.41.44.635.0 ]--
r 114         Coord b = new Coo
--[ 2019.10.29.11.41.44.690.0 ]--
r 114         Coord b = new Coor
--[ 2019.10.29.11.41.44.903.0 ]--
r 114         Coord b = new Coord
--[ 2019.10.29.11.41.45.009.0 ]--
r 114         Coord b = new Coord()
--[ 2019.10.29.11.41.45.394.0 ]--
r 114         Coord b = new Coord(s)
--[ 2019.10.29.11.41.45.564.0 ]--
r 114         Coord b = new Coord(s.)
--[ 2019.10.29.11.41.45.775.0 ]--
r 114         Coord b = new Coord(s.g)
--[ 2019.10.29.11.41.45.836.0 ]--
r 114         Coord b = new Coord(s.ge)
--[ 2019.10.29.11.41.45.990.0 ]--
r 114         Coord b = new Coord(s.get)
--[ 2019.10.29.11.41.46.660.0 ]--
r 114         Coord b = new Coord(s.getI)
--[ 2019.10.29.11.41.47.971.0 ]--
r 114         Coord b = new Coord(s.getI())
--[ 2019.10.29.11.43.13.044.0 ]--
r 113         Coord a = new Coord(s.getI()+, s.getJ());
--[ 2019.10.29.11.43.13.273.0 ]--
r 113         Coord a = new Coord(s.getI(), s.getJ());
--[ 2019.10.29.11.43.16.055.0 ]--
r 113         Coord a = new Coord(s.getI(), s.getJ()-);
--[ 2019.10.29.11.43.16.146.0 ]--
r 113         Coord a = new Coord(s.getI(), s.getJ()-1);
--[ 2019.10.29.11.43.19.503.0 ]--
r 114         Coord b = new Coord(s.getI(),)
--[ 2019.10.29.11.43.19.578.0 ]--
r 114         Coord b = new Coord(s.getI(), )
--[ 2019.10.29.11.43.20.967.0 ]--
r 114         Coord b = new Coord(s.getI(), s)
--[ 2019.10.29.11.43.22.345.0 ]--
r 114         Coord b = new Coord(s.getI(), s.)
--[ 2019.10.29.11.43.22.479.0 ]--
r 114         Coord b = new Coord(s.getI(), s.g)
--[ 2019.10.29.11.43.22.575.0 ]--
r 114         Coord b = new Coord(s.getI(), s.ge)
--[ 2019.10.29.11.43.22.711.0 ]--
r 114         Coord b = new Coord(s.getI(), s.get)
--[ 2019.10.29.11.43.22.935.0 ]--
r 114         Coord b = new Coord(s.getI(), s.getJ)
--[ 2019.10.29.11.43.23.572.0 ]--
r 114         Coord b = new Coord(s.getI(), s.getJ())
--[ 2019.10.29.11.43.26.606.0 ]--
r 114         Coord b = new Coord(s.getI(), s.getJ())''
--[ 2019.10.29.11.43.27.028.0 ]--
r 114         Coord b = new Coord(s.getI(), s.getJ())
--[ 2019.10.29.11.43.27.386.0 ]--
r 114         Coord b = new Coord(s.getI(), s.getJ());
--[ 2019.10.29.11.43.29.729.0 ]--
r 114         Coord b = new Coord(s.getI()+, s.getJ());
--[ 2019.10.29.11.43.30.034.0 ]--
r 114         Coord b = new Coord(s.getI()+1, s.getJ());
--[ 2019.10.29.11.43.31.680.0 ]--
+ 115         
--[ 2019.10.29.11.43.32.935.0 ]--
r 115         C
--[ 2019.10.29.11.43.33.172.0 ]--
r 115         Co
--[ 2019.10.29.11.43.33.360.0 ]--
r 115         Coo
--[ 2019.10.29.11.43.33.406.0 ]--
r 115         Coor
--[ 2019.10.29.11.43.33.620.0 ]--
r 115         Coord
--[ 2019.10.29.11.43.33.749.0 ]--
r 115         Coord 
--[ 2019.10.29.11.43.33.811.0 ]--
r 115         Coord c
--[ 2019.10.29.11.43.33.958.0 ]--
r 115         Coord c 
--[ 2019.10.29.11.43.34.081.0 ]--
r 115         Coord c =
--[ 2019.10.29.11.43.34.180.0 ]--
r 115         Coord c = 
--[ 2019.10.29.11.43.34.307.0 ]--
r 115         Coord c = n
--[ 2019.10.29.11.43.34.403.0 ]--
r 115         Coord c = ne
--[ 2019.10.29.11.43.34.486.0 ]--
r 115         Coord c = new
--[ 2019.10.29.11.43.34.518.0 ]--
r 115         Coord c = new 
--[ 2019.10.29.11.43.34.771.0 ]--
r 115         Coord c = new C
--[ 2019.10.29.11.43.34.882.0 ]--
r 115         Coord c = new Co
--[ 2019.10.29.11.43.35.061.0 ]--
r 115         Coord c = new Coo
--[ 2019.10.29.11.43.35.119.0 ]--
r 115         Coord c = new Coor
--[ 2019.10.29.11.43.35.315.0 ]--
r 115         Coord c = new Coord
--[ 2019.10.29.11.43.36.445.0 ]--
r 115         Coord c = new Coord()
--[ 2019.10.29.11.43.38.151.0 ]--
r 115         Coord c = new Coord(s)
--[ 2019.10.29.11.43.38.377.0 ]--
r 115         Coord c = new Coord(s.)
--[ 2019.10.29.11.43.38.495.0 ]--
r 115         Coord c = new Coord(s.g)
--[ 2019.10.29.11.43.38.584.0 ]--
r 115         Coord c = new Coord(s.ge)
--[ 2019.10.29.11.43.38.741.0 ]--
r 115         Coord c = new Coord(s.get)
--[ 2019.10.29.11.43.38.963.0 ]--
r 115         Coord c = new Coord(s.getI)
--[ 2019.10.29.11.43.39.350.0 ]--
r 115         Coord c = new Coord(s.getI())
--[ 2019.10.29.11.43.39.683.0 ]--
r 115         Coord c = new Coord(s.getI(),)
--[ 2019.10.29.11.43.39.802.0 ]--
r 115         Coord c = new Coord(s.getI(), )
--[ 2019.10.29.11.43.39.969.0 ]--
r 115         Coord c = new Coord(s.getI(), s)
--[ 2019.10.29.11.43.40.102.0 ]--
r 115         Coord c = new Coord(s.getI(), s.)
--[ 2019.10.29.11.43.40.284.0 ]--
r 115         Coord c = new Coord(s.getI(), s.g)
--[ 2019.10.29.11.43.40.353.0 ]--
r 115         Coord c = new Coord(s.getI(), s.ge)
--[ 2019.10.29.11.43.40.500.0 ]--
r 115         Coord c = new Coord(s.getI(), s.get)
--[ 2019.10.29.11.43.40.709.0 ]--
r 115         Coord c = new Coord(s.getI(), s.getJ)
--[ 2019.10.29.11.43.41.127.0 ]--
r 115         Coord c = new Coord(s.getI(), s.getJ())
--[ 2019.10.29.11.43.41.526.0 ]--
r 115         Coord c = new Coord(s.getI(), s.getJ()+)
--[ 2019.10.29.11.43.41.738.0 ]--
r 115         Coord c = new Coord(s.getI(), s.getJ()+1)
--[ 2019.10.29.11.43.42.095.0 ]--
r 115         Coord c = new Coord(s.getI(), s.getJ()+1_)
--[ 2019.10.29.11.43.42.498.0 ]--
r 115         Coord c = new Coord(s.getI(), s.getJ()+1_);
--[ 2019.10.29.11.43.42.905.0 ]--
r 115         Coord c = new Coord(s.getI(), s.getJ()+1_)
--[ 2019.10.29.11.43.43.077.0 ]--
r 115         Coord c = new Coord(s.getI(), s.getJ()+1_
--[ 2019.10.29.11.43.43.325.0 ]--
r 115         Coord c = new Coord(s.getI(), s.getJ()+1
--[ 2019.10.29.11.43.43.916.0 ]--
r 115         Coord c = new Coord(s.getI(), s.getJ()+1)
--[ 2019.10.29.11.43.44.143.0 ]--
r 115         Coord c = new Coord(s.getI(), s.getJ()+1);
--[ 2019.10.29.11.43.44.367.0 ]--
+ 116         
--[ 2019.10.29.11.43.45.463.0 ]--
r 116         C
--[ 2019.10.29.11.43.45.685.0 ]--
r 116         Co
--[ 2019.10.29.11.43.45.845.0 ]--
r 116         Coo
--[ 2019.10.29.11.43.45.897.0 ]--
r 116         Coor
--[ 2019.10.29.11.43.46.086.0 ]--
r 116         Coord
--[ 2019.10.29.11.43.46.136.0 ]--
r 116         Coord 
--[ 2019.10.29.11.43.46.265.0 ]--
r 116         Coord d
--[ 2019.10.29.11.43.46.332.0 ]--
r 116         Coord d 
--[ 2019.10.29.11.43.46.361.0 ]--
r 116         Coord d =
--[ 2019.10.29.11.43.46.558.0 ]--
r 116         Coord d = 
--[ 2019.10.29.11.43.46.658.0 ]--
r 116         Coord d = n
--[ 2019.10.29.11.43.46.978.0 ]--
r 116         Coord d = ne
--[ 2019.10.29.11.43.47.126.0 ]--
r 116         Coord d = new
--[ 2019.10.29.11.43.47.202.0 ]--
r 116         Coord d = new 
--[ 2019.10.29.11.43.47.435.0 ]--
r 116         Coord d = new C
--[ 2019.10.29.11.43.47.604.0 ]--
r 116         Coord d = new Co
--[ 2019.10.29.11.43.47.784.0 ]--
r 116         Coord d = new Coo
--[ 2019.10.29.11.43.47.837.0 ]--
r 116         Coord d = new Coor
--[ 2019.10.29.11.43.48.001.0 ]--
r 116         Coord d = new Coord
--[ 2019.10.29.11.43.48.128.0 ]--
r 116         Coord d = new Coord()
--[ 2019.10.29.11.43.48.410.0 ]--
r 116         Coord d = new Coord(s)
--[ 2019.10.29.11.43.48.574.0 ]--
r 116         Coord d = new Coord(s.)
--[ 2019.10.29.11.43.48.880.0 ]--
r 116         Coord d = new Coord(s.g)
--[ 2019.10.29.11.43.48.974.0 ]--
r 116         Coord d = new Coord(s.ge)
--[ 2019.10.29.11.43.49.099.0 ]--
r 116         Coord d = new Coord(s.get)
--[ 2019.10.29.11.43.51.874.0 ]--
r 116         Coord d = new Coord(s.getI)
--[ 2019.10.29.11.43.54.701.0 ]--
r 116         Coord d = new Coord(s.getI())
--[ 2019.10.29.11.43.55.179.0 ]--
r 116         Coord d = new Coord(s.getI()-)
--[ 2019.10.29.11.43.55.326.0 ]--
r 116         Coord d = new Coord(s.getI()-1)
--[ 2019.10.29.11.43.55.905.0 ]--
r 116         Coord d = new Coord(s.getI()-1,)
--[ 2019.10.29.11.43.56.003.0 ]--
r 116         Coord d = new Coord(s.getI()-1, )
--[ 2019.10.29.11.43.56.534.0 ]--
r 116         Coord d = new Coord(s.getI()-1, s)
--[ 2019.10.29.11.43.56.612.0 ]--
r 116         Coord d = new Coord(s.getI()-1, s.)
--[ 2019.10.29.11.43.56.752.0 ]--
r 116         Coord d = new Coord(s.getI()-1, s.g)
--[ 2019.10.29.11.43.56.858.0 ]--
r 116         Coord d = new Coord(s.getI()-1, s.ge)
--[ 2019.10.29.11.43.56.990.0 ]--
r 116         Coord d = new Coord(s.getI()-1, s.get)
--[ 2019.10.29.11.43.57.260.0 ]--
r 116         Coord d = new Coord(s.getI()-1, s.getJ)
--[ 2019.10.29.11.43.57.612.0 ]--
r 116         Coord d = new Coord(s.getI()-1, s.getJ())
--[ 2019.10.29.11.43.58.268.0 ]--
r 116         Coord d = new Coord(s.getI()-1, s.getJ());
--[ 2019.10.29.11.44.00.247.0 ]--
+ 117         
--[ 2019.10.29.11.44.00.383.0 ]--
+ 117         
--[ 2019.10.29.11.44.01.385.0 ]--
- 117
--[ 2019.10.29.11.44.02.278.0 ]--
r 117         /
--[ 2019.10.29.11.44.02.429.0 ]--
r 117         //
--[ 2019.10.29.11.44.02.513.0 ]--
r 117         // 
--[ 2019.10.29.11.44.02.650.0 ]--
r 117         // a
--[ 2019.10.29.11.44.02.782.0 ]--
r 117         // a 
--[ 2019.10.29.11.44.02.942.0 ]--
r 117         // a i
--[ 2019.10.29.11.44.03.058.0 ]--
r 117         // a is
--[ 2019.10.29.11.44.03.129.0 ]--
r 117         // a is 
--[ 2019.10.29.11.44.03.334.0 ]--
r 117         // a is r
--[ 2019.10.29.11.44.03.395.0 ]--
r 117         // a is ri
--[ 2019.10.29.11.44.03.598.0 ]--
r 117         // a is rig
--[ 2019.10.29.11.44.03.658.0 ]--
r 117         // a is righ
--[ 2019.10.29.11.44.03.794.0 ]--
r 117         // a is right
--[ 2019.10.29.11.44.03.933.0 ]--
r 117         // a is right,
--[ 2019.10.29.11.44.04.086.0 ]--
r 117         // a is right, 
--[ 2019.10.29.11.44.04.391.0 ]--
r 117         // a is right, b
--[ 2019.10.29.11.44.05.437.0 ]--
r 117         // a is right, 
--[ 2019.10.29.11.44.05.655.0 ]--
r 117         // a is right,
--[ 2019.10.29.11.44.05.761.0 ]--
r 117         // a is right
--[ 2019.10.29.11.44.05.958.0 ]--
r 117         // a is righ
--[ 2019.10.29.11.44.06.113.0 ]--
r 117         // a is rig
--[ 2019.10.29.11.44.06.300.0 ]--
r 117         // a is ri
--[ 2019.10.29.11.44.06.481.0 ]--
r 117         // a is r
--[ 2019.10.29.11.44.06.665.0 ]--
r 117         // a is 
--[ 2019.10.29.11.44.07.134.0 ]--
r 117         // a is u
--[ 2019.10.29.11.44.07.202.0 ]--
r 117         // a is up
--[ 2019.10.29.11.44.07.731.0 ]--
r 117         // a is u
--[ 2019.10.29.11.44.07.926.0 ]--
r 117         // a is 
--[ 2019.10.29.11.44.08.073.0 ]--
r 117         // a is 1
--[ 2019.10.29.11.44.08.206.0 ]--
r 117         // a is 1 
--[ 2019.10.29.11.44.08.386.0 ]--
r 117         // a is 1 pu
--[ 2019.10.29.11.44.08.965.0 ]--
r 117         // a is 1 p
--[ 2019.10.29.11.44.09.139.0 ]--
r 117         // a is 1 
--[ 2019.10.29.11.44.09.375.0 ]--
r 117         // a is 1 u
--[ 2019.10.29.11.44.09.505.0 ]--
r 117         // a is 1 up
--[ 2019.10.29.11.44.09.761.0 ]--
r 117         // a is 1 up,
--[ 2019.10.29.11.44.09.841.0 ]--
r 117         // a is 1 up, 
--[ 2019.10.29.11.44.10.014.0 ]--
r 117         // a is 1 up, b
--[ 2019.10.29.11.44.10.129.0 ]--
r 117         // a is 1 up, b 
--[ 2019.10.29.11.44.10.346.0 ]--
r 117         // a is 1 up, b i
--[ 2019.10.29.11.44.10.474.0 ]--
r 117         // a is 1 up, b is
--[ 2019.10.29.11.44.10.522.0 ]--
r 117         // a is 1 up, b is 
--[ 2019.10.29.11.44.11.198.0 ]--
r 117         // a is 1 up, b is 1
--[ 2019.10.29.11.44.11.378.0 ]--
r 117         // a is 1 up, b is 1 
--[ 2019.10.29.11.44.11.546.0 ]--
r 117         // a is 1 up, b is 1 r
--[ 2019.10.29.11.44.11.657.0 ]--
r 117         // a is 1 up, b is 1 ri
--[ 2019.10.29.11.44.11.829.0 ]--
r 117         // a is 1 up, b is 1 rig
--[ 2019.10.29.11.44.11.889.0 ]--
r 117         // a is 1 up, b is 1 righ
--[ 2019.10.29.11.44.12.044.0 ]--
r 117         // a is 1 up, b is 1 right
--[ 2019.10.29.11.44.12.089.0 ]--
r 117         // a is 1 up, b is 1 right,
--[ 2019.10.29.11.44.12.203.0 ]--
r 117         // a is 1 up, b is 1 right, 
--[ 2019.10.29.11.44.12.767.0 ]--
r 117         // a is 1 up, b is 1 right, c
--[ 2019.10.29.11.44.12.857.0 ]--
r 117         // a is 1 up, b is 1 right, c 
--[ 2019.10.29.11.44.13.014.0 ]--
r 117         // a is 1 up, b is 1 right, c i
--[ 2019.10.29.11.44.13.122.0 ]--
r 117         // a is 1 up, b is 1 right, c is
--[ 2019.10.29.11.44.13.186.0 ]--
r 117         // a is 1 up, b is 1 right, c is 
--[ 2019.10.29.11.44.13.438.0 ]--
r 117         // a is 1 up, b is 1 right, c is 2
--[ 2019.10.29.11.44.13.874.0 ]--
r 117         // a is 1 up, b is 1 right, c is 21
--[ 2019.10.29.11.44.14.082.0 ]--
r 117         // a is 1 up, b is 1 right, c is 21 
--[ 2019.10.29.11.44.14.309.0 ]--
r 117         // a is 1 up, b is 1 right, c is 21
--[ 2019.10.29.11.44.14.473.0 ]--
r 117         // a is 1 up, b is 1 right, c is 2
--[ 2019.10.29.11.44.14.649.0 ]--
r 117         // a is 1 up, b is 1 right, c is 
--[ 2019.10.29.11.44.14.843.0 ]--
r 117         // a is 1 up, b is 1 right, c is 1
--[ 2019.10.29.11.44.14.931.0 ]--
r 117         // a is 1 up, b is 1 right, c is 1 
--[ 2019.10.29.11.44.15.138.0 ]--
r 117         // a is 1 up, b is 1 right, c is 1 d
--[ 2019.10.29.11.44.15.233.0 ]--
r 117         // a is 1 up, b is 1 right, c is 1 do
--[ 2019.10.29.11.44.15.349.0 ]--
r 117         // a is 1 up, b is 1 right, c is 1 dow
--[ 2019.10.29.11.44.15.427.0 ]--
r 117         // a is 1 up, b is 1 right, c is 1 down
--[ 2019.10.29.11.44.15.610.0 ]--
r 117         // a is 1 up, b is 1 right, c is 1 down,
--[ 2019.10.29.11.44.15.838.0 ]--
r 117         // a is 1 up, b is 1 right, c is 1 down, 
--[ 2019.10.29.11.44.15.890.0 ]--
r 117         // a is 1 up, b is 1 right, c is 1 down, d
--[ 2019.10.29.11.44.15.986.0 ]--
r 117         // a is 1 up, b is 1 right, c is 1 down, d 
--[ 2019.10.29.11.44.16.048.0 ]--
r 117         // a is 1 up, b is 1 right, c is 1 down, d i
--[ 2019.10.29.11.44.16.215.0 ]--
r 117         // a is 1 up, b is 1 right, c is 1 down, d is
--[ 2019.10.29.11.44.16.249.0 ]--
r 117         // a is 1 up, b is 1 right, c is 1 down, d is 
--[ 2019.10.29.11.44.16.444.0 ]--
r 117         // a is 1 up, b is 1 right, c is 1 down, d is 1
--[ 2019.10.29.11.44.16.583.0 ]--
r 117         // a is 1 up, b is 1 right, c is 1 down, d is 1 
--[ 2019.10.29.11.44.16.742.0 ]--
r 117         // a is 1 up, b is 1 right, c is 1 down, d is 1 l
--[ 2019.10.29.11.44.16.801.0 ]--
r 117         // a is 1 up, b is 1 right, c is 1 down, d is 1 le
--[ 2019.10.29.11.44.16.953.0 ]--
r 117         // a is 1 up, b is 1 right, c is 1 down, d is 1 lef
--[ 2019.10.29.11.44.17.162.0 ]--
r 117         // a is 1 up, b is 1 right, c is 1 down, d is 1 left
--[ 2019.10.29.11.44.17.262.0 ]--
+ 118         
--[ 2019.10.29.11.46.31.618.0 ]--
r 118         C
--[ 2019.10.29.11.46.31.855.0 ]--
r 118         Co
--[ 2019.10.29.11.46.31.969.0 ]--
r 118         Coo
--[ 2019.10.29.11.46.32.054.0 ]--
r 118         Coor
--[ 2019.10.29.11.46.32.257.0 ]--
r 118         Coord
--[ 2019.10.29.11.46.32.618.0 ]--
r 118         Coord[]
--[ 2019.10.29.11.46.32.977.0 ]--
r 118         Coord[] 
--[ 2019.10.29.11.46.33.150.0 ]--
r 118         Coord[] e
--[ 2019.10.29.11.46.33.259.0 ]--
r 118         Coord[] e 
--[ 2019.10.29.11.46.33.500.0 ]--
r 118         Coord[] e
--[ 2019.10.29.11.46.33.619.0 ]--
r 118         Coord[] e 
--[ 2019.10.29.11.46.34.709.0 ]--
r 118         Coord[] e =
--[ 2019.10.29.11.46.34.837.0 ]--
r 118         Coord[] e = 
--[ 2019.10.29.11.46.35.445.0 ]--
r 118         Coord[] e = n
--[ 2019.10.29.11.46.35.536.0 ]--
r 118         Coord[] e = ne
--[ 2019.10.29.11.46.35.631.0 ]--
r 118         Coord[] e = new
--[ 2019.10.29.11.46.35.723.0 ]--
r 118         Coord[] e = new 
--[ 2019.10.29.11.46.36.012.0 ]--
r 118         Coord[] e = new C
--[ 2019.10.29.11.46.36.184.0 ]--
r 118         Coord[] e = new Co
--[ 2019.10.29.11.46.36.366.0 ]--
r 118         Coord[] e = new Coo
--[ 2019.10.29.11.46.36.429.0 ]--
r 118         Coord[] e = new Coor
--[ 2019.10.29.11.46.36.652.0 ]--
r 118         Coord[] e = new Coord
--[ 2019.10.29.11.46.38.538.0 ]--
r 118         Coord[] e = new Coord[]
--[ 2019.10.29.11.46.38.635.0 ]--
r 118         Coord[] e = new Coord[4]
--[ 2019.10.29.11.46.39.465.0 ]--
r 118         Coord[] e = new Coord[4];
--[ 2019.10.29.11.46.40.471.0 ]--
+ 119         
--[ 2019.10.29.11.46.45.121.0 ]--
r 119         f
--[ 2019.10.29.11.46.45.381.0 ]--
r 119         for
--[ 2019.10.29.11.46.45.433.0 ]--
r 119         for 
--[ 2019.10.29.11.46.45.790.0 ]--
r 119         for ()
--[ 2019.10.29.11.46.46.176.0 ]--
r 119         for (
--[ 2019.10.29.11.46.46.467.0 ]--
r 119         for 
--[ 2019.10.29.11.46.47.061.0 ]--
r 119         for ()
--[ 2019.10.29.11.46.47.617.0 ]--
r 119         for (i)
--[ 2019.10.29.11.46.47.710.0 ]--
r 119         for (in)
--[ 2019.10.29.11.46.47.734.0 ]--
r 119         for (int)
--[ 2019.10.29.11.46.47.819.0 ]--
r 119         for (int )
--[ 2019.10.29.11.46.47.897.0 ]--
r 119         for (int i)
--[ 2019.10.29.11.46.48.069.0 ]--
r 119         for (int i )
--[ 2019.10.29.11.46.48.137.0 ]--
r 119         for (int i =)
--[ 2019.10.29.11.46.48.257.0 ]--
r 119         for (int i = )
--[ 2019.10.29.11.46.48.364.0 ]--
r 119         for (int i = 0)
--[ 2019.10.29.11.46.48.649.0 ]--
r 119         for (int i = 0;)
--[ 2019.10.29.11.46.48.784.0 ]--
r 119         for (int i = 0; )
--[ 2019.10.29.11.46.48.867.0 ]--
r 119         for (int i = 0; i)
--[ 2019.10.29.11.46.48.997.0 ]--
r 119         for (int i = 0; i )
--[ 2019.10.29.11.46.49.196.0 ]--
r 119         for (int i = 0; i <)
--[ 2019.10.29.11.46.49.256.0 ]--
r 119         for (int i = 0; i < )
--[ 2019.10.29.11.46.49.629.0 ]--
r 119         for (int i = 0; i < 4)
--[ 2019.10.29.11.46.49.847.0 ]--
r 119         for (int i = 0; i < 4;)
--[ 2019.10.29.11.46.49.942.0 ]--
r 119         for (int i = 0; i < 4; )
--[ 2019.10.29.11.46.50.533.0 ]--
r 119         for (int i = 0; i < 4;)
--[ 2019.10.29.11.46.50.703.0 ]--
r 119         for (int i = 0; i < 4)
--[ 2019.10.29.11.46.50.865.0 ]--
r 119         for (int i = 0; i < )
--[ 2019.10.29.11.46.51.241.0 ]--
r 119         for (int i = 0; i < e)
--[ 2019.10.29.11.46.51.435.0 ]--
r 119         for (int i = 0; i < e.)
--[ 2019.10.29.11.46.51.948.0 ]--
r 119         for (int i = 0; i < e.l)
--[ 2019.10.29.11.46.52.012.0 ]--
r 119         for (int i = 0; i < e.le)
--[ 2019.10.29.11.46.52.149.0 ]--
r 119         for (int i = 0; i < e.len)
--[ 2019.10.29.11.46.52.219.0 ]--
r 119         for (int i = 0; i < e.leng)
--[ 2019.10.29.11.46.52.455.0 ]--
r 119         for (int i = 0; i < e.lengt)
--[ 2019.10.29.11.46.52.490.0 ]--
r 119         for (int i = 0; i < e.length)
--[ 2019.10.29.11.46.52.628.0 ]--
r 119         for (int i = 0; i < e.length;)
--[ 2019.10.29.11.46.52.724.0 ]--
r 119         for (int i = 0; i < e.length; )
--[ 2019.10.29.11.46.52.824.0 ]--
r 119         for (int i = 0; i < e.length; i)
--[ 2019.10.29.11.46.53.134.0 ]--
r 119         for (int i = 0; i < e.length; i+)
--[ 2019.10.29.11.46.53.330.0 ]--
r 119         for (int i = 0; i < e.length; i+=)
--[ 2019.10.29.11.46.53.774.0 ]--
r 119         for (int i = 0; i < e.length; i+=) 
--[ 2019.10.29.11.46.54.056.0 ]--
r 119         for (int i = 0; i < e.length; i+=)
--[ 2019.10.29.11.46.54.248.0 ]--
r 119         for (int i = 0; i < e.length; i+=
--[ 2019.10.29.11.46.54.401.0 ]--
r 119         for (int i = 0; i < e.length; i+
--[ 2019.10.29.11.46.55.021.0 ]--
r 119         for (int i = 0; i < e.length; i++
--[ 2019.10.29.11.46.55.272.0 ]--
r 119         for (int i = 0; i < e.length; i++)
--[ 2019.10.29.11.46.55.617.0 ]--
r 119         for (int i = 0; i < e.length; i++) 
--[ 2019.10.29.11.46.55.798.0 ]--
r 119         for (int i = 0; i < e.length; i++) {
--[ 2019.10.29.11.46.56.014.0 ]--
+ 120 
+ 121 }
--[ 2019.10.29.11.46.56.070.0 ]--
r 121         }
--[ 2019.10.29.11.46.56.089.0 ]--
r 120             
--[ 2019.10.29.11.46.57.565.0 ]--
r 120             e
--[ 2019.10.29.11.46.57.970.0 ]--
r 120             e[]
--[ 2019.10.29.11.46.58.589.0 ]--
r 120             e[i]
--[ 2019.10.29.11.46.59.284.0 ]--
r 120             e[i] 
--[ 2019.10.29.11.46.59.395.0 ]--
r 120             e[i] =
--[ 2019.10.29.11.46.59.489.0 ]--
r 120             e[i] = 
--[ 2019.10.29.11.47.04.959.0 ]--
+ 119         
--[ 2019.10.29.11.47.05.422.0 ]--
r 119         e
--[ 2019.10.29.11.47.05.654.0 ]--
r 119         e[]
--[ 2019.10.29.11.47.05.921.0 ]--
r 119         e[0]
--[ 2019.10.29.11.47.06.542.0 ]--
r 119         e[0] 
--[ 2019.10.29.11.47.06.636.0 ]--
r 119         e[0] =
--[ 2019.10.29.11.47.06.745.0 ]--
r 119         e[0] = 
--[ 2019.10.29.11.47.07.385.0 ]--
r 119         e[0] = a
--[ 2019.10.29.11.47.07.458.0 ]--
r 119         e[0] = a;
--[ 2019.10.29.11.47.07.676.0 ]--
+ 120         
--[ 2019.10.29.11.47.08.386.0 ]--
r 120         e
--[ 2019.10.29.11.47.08.482.0 ]--
r 120         e[]
--[ 2019.10.29.11.47.08.890.0 ]--
r 120         e[0]
--[ 2019.10.29.11.47.10.205.0 ]--
r 120         e[0] 
--[ 2019.10.29.11.47.10.301.0 ]--
r 120         e[0] =
--[ 2019.10.29.11.47.10.437.0 ]--
r 120         e[0] = 
--[ 2019.10.29.11.47.10.644.0 ]--
r 120         e[0] = b
--[ 2019.10.29.11.47.11.576.0 ]--
r 120         e[0] = b;
--[ 2019.10.29.11.47.11.775.0 ]--
+ 121         
--[ 2019.10.29.11.47.12.138.0 ]--
r 121         e
--[ 2019.10.29.11.47.13.179.0 ]--
r 121         e[]
--[ 2019.10.29.11.47.13.521.0 ]--
r 121         e[0]
--[ 2019.10.29.11.47.14.318.0 ]--
r 121         e[0] 
--[ 2019.10.29.11.47.14.402.0 ]--
r 121         e[0] =
--[ 2019.10.29.11.47.14.567.0 ]--
r 121         e[0] = 
--[ 2019.10.29.11.47.14.845.0 ]--
r 121         e[0] =
--[ 2019.10.29.11.47.15.025.0 ]--
r 121         e[0] 
--[ 2019.10.29.11.47.15.196.0 ]--
r 121         e[0]
--[ 2019.10.29.11.47.15.374.0 ]--
r 121         e[0
--[ 2019.10.29.11.47.15.537.0 ]--
r 121         e[
--[ 2019.10.29.11.47.15.811.0 ]--
r 121         e[2
--[ 2019.10.29.11.47.16.108.0 ]--
r 121         e[2]
--[ 2019.10.29.11.47.16.909.0 ]--
r 121         e[2] 
--[ 2019.10.29.11.47.17.077.0 ]--
r 121         e[2] =
--[ 2019.10.29.11.47.17.193.0 ]--
r 121         e[2] = 
--[ 2019.10.29.11.47.17.549.0 ]--
r 121         e[2] = c
--[ 2019.10.29.11.47.17.626.0 ]--
r 121         e[2] = c;
--[ 2019.10.29.11.47.17.846.0 ]--
+ 122         
--[ 2019.10.29.11.47.18.395.0 ]--
r 122         e
--[ 2019.10.29.11.47.18.498.0 ]--
r 122         e[]
--[ 2019.10.29.11.47.18.644.0 ]--
r 122         e[3]
--[ 2019.10.29.11.47.19.397.0 ]--
r 122         e[3] 
--[ 2019.10.29.11.47.19.564.0 ]--
r 122         e[3] =
--[ 2019.10.29.11.47.19.617.0 ]--
r 122         e[3] = 
--[ 2019.10.29.11.47.19.875.0 ]--
r 122         e[3] = d
--[ 2019.10.29.11.47.19.970.0 ]--
r 122         e[3] = d;
--[ 2019.10.29.11.47.22.785.0 ]--
r 120         e[] = b;
--[ 2019.10.29.11.47.22.865.0 ]--
r 120         e[1] = b;
--[ 2019.10.29.11.47.25.490.0 ]--
- 123
- 123
r 123 
--[ 2019.10.29.11.47.25.685.0 ]--
- 123
--[ 2019.10.29.11.47.27.063.0 ]--
+ 123         
--[ 2019.10.29.11.47.28.526.0 ]--
r 123         r
--[ 2019.10.29.11.47.28.629.0 ]--
r 123         re
--[ 2019.10.29.11.47.28.851.0 ]--
r 123         ret
--[ 2019.10.29.11.47.28.915.0 ]--
r 123         retu
--[ 2019.10.29.11.47.29.050.0 ]--
r 123         retur
--[ 2019.10.29.11.47.29.100.0 ]--
r 123         return
--[ 2019.10.29.11.47.29.201.0 ]--
r 123         return 
--[ 2019.10.29.11.47.29.316.0 ]--
r 123         return e
--[ 2019.10.29.11.47.29.407.0 ]--
r 123         return e;
--[ 2019.10.29.11.47.31.960.0 ]--
r 112     private C findNeighbors(Coord s) {
--[ 2019.10.29.11.47.32.164.0 ]--
r 112     private Co findNeighbors(Coord s) {
--[ 2019.10.29.11.47.32.304.0 ]--
r 112     private Coo findNeighbors(Coord s) {
--[ 2019.10.29.11.47.32.369.0 ]--
r 112     private Coor findNeighbors(Coord s) {
--[ 2019.10.29.11.47.32.549.0 ]--
r 112     private Coord findNeighbors(Coord s) {
--[ 2019.10.29.11.47.33.033.0 ]--
r 112     private Coord[] findNeighbors(Coord s) {
--[ 2019.10.29.11.47.35.896.0 ]--
- 124
--[ 2019.10.29.11.47.38.255.0 ]--
+ 111     
--[ 2019.10.29.11.47.38.926.0 ]--
r 112     /
--[ 2019.10.29.11.47.39.065.0 ]--
r 112     //
--[ 2019.10.29.11.47.39.201.0 ]--
r 112     // 
--[ 2019.10.29.11.47.39.328.0 ]--
r 112     // H
--[ 2019.10.29.11.47.39.476.0 ]--
r 112     // He
--[ 2019.10.29.11.47.39.579.0 ]--
r 112     // Hel
--[ 2019.10.29.11.47.39.696.0 ]--
r 112     // Help
--[ 2019.10.29.11.47.39.806.0 ]--
r 112     // Helpe
--[ 2019.10.29.11.47.39.905.0 ]--
r 112     // Helper
--[ 2019.10.29.11.47.40.026.0 ]--
r 112     // Helper 
--[ 2019.10.29.11.47.40.130.0 ]--
r 112     // Helper f
--[ 2019.10.29.11.47.40.202.0 ]--
r 112     // Helper fu
--[ 2019.10.29.11.47.40.377.0 ]--
r 112     // Helper fun
--[ 2019.10.29.11.47.40.448.0 ]--
r 112     // Helper func
--[ 2019.10.29.11.47.40.709.0 ]--
r 112     // Helper funct
--[ 2019.10.29.11.47.40.758.0 ]--
r 112     // Helper functi
--[ 2019.10.29.11.47.40.879.0 ]--
r 112     // Helper functio
--[ 2019.10.29.11.47.40.920.0 ]--
r 112     // Helper function
--[ 2019.10.29.11.47.40.994.0 ]--
r 112     // Helper function 
--[ 2019.10.29.11.47.41.113.0 ]--
r 112     // Helper function t
--[ 2019.10.29.11.47.41.161.0 ]--
r 112     // Helper function to
--[ 2019.10.29.11.47.41.232.0 ]--
r 112     // Helper function to 
--[ 2019.10.29.11.47.41.381.0 ]--
r 112     // Helper function to f
--[ 2019.10.29.11.47.41.447.0 ]--
r 112     // Helper function to fi
--[ 2019.10.29.11.47.41.554.0 ]--
r 112     // Helper function to fin
--[ 2019.10.29.11.47.41.656.0 ]--
r 112     // Helper function to find
--[ 2019.10.29.11.47.41.738.0 ]--
r 112     // Helper function to find 
--[ 2019.10.29.11.47.42.684.0 ]--
r 112     // Helper function to find c
--[ 2019.10.29.11.47.42.801.0 ]--
r 112     // Helper function to find co
--[ 2019.10.29.11.47.42.950.0 ]--
r 112     // Helper function to find coo
--[ 2019.10.29.11.47.43.049.0 ]--
r 112     // Helper function to find coor
--[ 2019.10.29.11.47.43.351.0 ]--
r 112     // Helper function to find coo
--[ 2019.10.29.11.47.43.495.0 ]--
r 112     // Helper function to find co
--[ 2019.10.29.11.47.43.665.0 ]--
r 112     // Helper function to find c
--[ 2019.10.29.11.47.43.804.0 ]--
r 112     // Helper function to find 
--[ 2019.10.29.11.47.44.083.0 ]--
r 112     // Helper function to find n
--[ 2019.10.29.11.47.44.229.0 ]--
r 112     // Helper function to find ne
--[ 2019.10.29.11.47.44.330.0 ]--
r 112     // Helper function to find nei
--[ 2019.10.29.11.47.44.418.0 ]--
r 112     // Helper function to find neig
--[ 2019.10.29.11.47.44.520.0 ]--
r 112     // Helper function to find neigh
--[ 2019.10.29.11.47.44.816.0 ]--
r 112     // Helper function to find neighb
--[ 2019.10.29.11.47.44.998.0 ]--
r 112     // Helper function to find neighbo
--[ 2019.10.29.11.47.45.127.0 ]--
r 112     // Helper function to find neighbor
--[ 2019.10.29.11.47.45.329.0 ]--
r 112     // Helper function to find neighbors
--[ 2019.10.29.11.47.45.456.0 ]--
r 112     // Helper function to find neighbors 
--[ 2019.10.29.11.47.45.830.0 ]--
r 112     // Helper function to find neighbors g
--[ 2019.10.29.11.47.45.937.0 ]--
r 112     // Helper function to find neighbors gi
--[ 2019.10.29.11.47.46.161.0 ]--
r 112     // Helper function to find neighbors give
--[ 2019.10.29.11.47.46.216.0 ]--
r 112     // Helper function to find neighbors given
--[ 2019.10.29.11.47.46.464.0 ]--
r 112     // Helper function to find neighbors given 
--[ 2019.10.29.11.47.46.545.0 ]--
r 112     // Helper function to find neighbors given a
--[ 2019.10.29.11.47.46.645.0 ]--
r 112     // Helper function to find neighbors given a 
--[ 2019.10.29.11.47.46.769.0 ]--
r 112     // Helper function to find neighbors given a s
--[ 2019.10.29.11.47.46.849.0 ]--
r 112     // Helper function to find neighbors given a se
--[ 2019.10.29.11.47.46.888.0 ]--
r 112     // Helper function to find neighbors given a se4
--[ 2019.10.29.11.47.46.951.0 ]--
r 112     // Helper function to find neighbors given a se4t
--[ 2019.10.29.11.47.47.116.0 ]--
r 112     // Helper function to find neighbors given a se4t 
--[ 2019.10.29.11.47.47.492.0 ]--
r 112     // Helper function to find neighbors given a se4t
--[ 2019.10.29.11.47.47.640.0 ]--
r 112     // Helper function to find neighbors given a se4
--[ 2019.10.29.11.47.47.817.0 ]--
r 112     // Helper function to find neighbors given a se
--[ 2019.10.29.11.47.48.587.0 ]--
r 112     // Helper function to find neighbors given a s
--[ 2019.10.29.11.47.48.763.0 ]--
r 112     // Helper function to find neighbors given a 
--[ 2019.10.29.11.47.49.190.0 ]--
r 112     // Helper function to find neighbors given a c
--[ 2019.10.29.11.47.49.450.0 ]--
r 112     // Helper function to find neighbors given a co
--[ 2019.10.29.11.47.49.619.0 ]--
r 112     // Helper function to find neighbors given a coo
--[ 2019.10.29.11.47.49.772.0 ]--
r 112     // Helper function to find neighbors given a coor
--[ 2019.10.29.11.47.49.970.0 ]--
r 112     // Helper function to find neighbors given a coord
--[ 2019.10.29.11.47.56.996.0 ]--
r 128         // Step 1: Look at all possible locations from starting point,
--[ 2019.10.29.11.47.57.212.0 ]--
r 128         // Step 1: Look at all possible locations from starting point, 
--[ 2019.10.29.11.47.57.315.0 ]--
r 128         // Step 1: Look at all possible locations from starting point, c
--[ 2019.10.29.11.47.57.621.0 ]--
r 128         // Step 1: Look at all possible locations from starting point, cr
--[ 2019.10.29.11.47.57.717.0 ]--
r 128         // Step 1: Look at all possible locations from starting point, cre
--[ 2019.10.29.11.47.57.794.0 ]--
r 128         // Step 1: Look at all possible locations from starting point, crea
--[ 2019.10.29.11.47.57.890.0 ]--
r 128         // Step 1: Look at all possible locations from starting point, creat
--[ 2019.10.29.11.47.57.962.0 ]--
r 128         // Step 1: Look at all possible locations from starting point, create
--[ 2019.10.29.11.47.58.101.0 ]--
r 128         // Step 1: Look at all possible locations from starting point, create 
--[ 2019.10.29.11.47.58.217.0 ]--
r 128         // Step 1: Look at all possible locations from starting point, create n
--[ 2019.10.29.11.47.58.296.0 ]--
r 128         // Step 1: Look at all possible locations from starting point, create no
--[ 2019.10.29.11.47.58.357.0 ]--
r 128         // Step 1: Look at all possible locations from starting point, create nod
--[ 2019.10.29.11.47.58.564.0 ]--
r 128         // Step 1: Look at all possible locations from starting point, create node
--[ 2019.10.29.11.47.58.632.0 ]--
r 128         // Step 1: Look at all possible locations from starting point, create nodes
--[ 2019.10.29.11.47.58.660.0 ]--
r 128         // Step 1: Look at all possible locations from starting point, create nodes 
--[ 2019.10.29.11.47.58.801.0 ]--
r 128         // Step 1: Look at all possible locations from starting point, create nodes f
--[ 2019.10.29.11.47.58.890.0 ]--
r 128         // Step 1: Look at all possible locations from starting point, create nodes fo
--[ 2019.10.29.11.47.59.032.0 ]--
r 128         // Step 1: Look at all possible locations from starting point, create nodes for
--[ 2019.10.29.11.47.59.143.0 ]--
r 128         // Step 1: Look at all possible locations from starting point, create nodes for 
--[ 2019.10.29.11.47.59.288.0 ]--
r 128         // Step 1: Look at all possible locations from starting point, create nodes for e
--[ 2019.10.29.11.47.59.388.0 ]--
r 128         // Step 1: Look at all possible locations from starting point, create nodes for ea
--[ 2019.10.29.11.47.59.508.0 ]--
r 128         // Step 1: Look at all possible locations from starting point, create nodes for eac
--[ 2019.10.29.11.47.59.587.0 ]--
r 128         // Step 1: Look at all possible locations from starting point, create nodes for each
--[ 2019.10.29.11.47.59.748.0 ]--
+ 129         
--[ 2019.10.29.11.48.02.293.0 ]--
r 129         C
--[ 2019.10.29.11.48.02.497.0 ]--
r 129         Co
--[ 2019.10.29.11.48.02.672.0 ]--
r 129         Coo
--[ 2019.10.29.11.48.02.726.0 ]--
r 129         Coor
--[ 2019.10.29.11.48.02.939.0 ]--
r 129         Coord
--[ 2019.10.29.11.48.03.322.0 ]--
r 129         Coord[]
--[ 2019.10.29.11.48.06.147.0 ]--
r 129         Coord[
--[ 2019.10.29.11.48.06.324.0 ]--
r 129         Coord
--[ 2019.10.29.11.48.06.473.0 ]--
r 129         Coor
--[ 2019.10.29.11.48.06.639.0 ]--
r 129         Coo
--[ 2019.10.29.11.48.06.803.0 ]--
r 129         Co
--[ 2019.10.29.11.48.06.985.0 ]--
r 129         C
--[ 2019.10.29.11.48.07.163.0 ]--
r 129         
--[ 2019.10.29.11.48.07.989.0 ]--
r 129         C
--[ 2019.10.29.11.48.08.184.0 ]--
r 129         Co
--[ 2019.10.29.11.48.08.340.0 ]--
r 129         Coo
--[ 2019.10.29.11.48.08.455.0 ]--
r 129         Coor
--[ 2019.10.29.11.48.08.627.0 ]--
r 129         Coord
--[ 2019.10.29.11.48.09.338.0 ]--
r 129         Coord[]
--[ 2019.10.29.11.48.09.764.0 ]--
r 129         Coord[] 
--[ 2019.10.29.11.48.11.836.0 ]--
r 129         Coord[] n
--[ 2019.10.29.11.48.11.912.0 ]--
r 129         Coord[] ne
--[ 2019.10.29.11.48.12.052.0 ]--
r 129         Coord[] nei
--[ 2019.10.29.11.48.12.130.0 ]--
r 129         Coord[] neig
--[ 2019.10.29.11.48.12.208.0 ]--
r 129         Coord[] neigh
--[ 2019.10.29.11.48.12.354.0 ]--
r 129         Coord[] neighb
--[ 2019.10.29.11.48.12.451.0 ]--
r 129         Coord[] neighbo
--[ 2019.10.29.11.48.12.584.0 ]--
r 129         Coord[] neighbor
--[ 2019.10.29.11.48.12.716.0 ]--
r 129         Coord[] neighbors
--[ 2019.10.29.11.48.12.832.0 ]--
r 129         Coord[] neighbors 
--[ 2019.10.29.11.48.12.913.0 ]--
r 129         Coord[] neighbors =
--[ 2019.10.29.11.48.13.053.0 ]--
r 129         Coord[] neighbors = 
--[ 2019.10.29.11.48.16.658.0 ]--
r 129         Coord[] neighbors = f
--[ 2019.10.29.11.48.16.770.0 ]--
r 129         Coord[] neighbors = fi
--[ 2019.10.29.11.48.16.854.0 ]--
r 129         Coord[] neighbors = fin
--[ 2019.10.29.11.48.16.924.0 ]--
r 129         Coord[] neighbors = find
--[ 2019.10.29.11.48.17.204.0 ]--
r 129         Coord[] neighbors = findN
--[ 2019.10.29.11.48.17.325.0 ]--
r 129         Coord[] neighbors = findNe
--[ 2019.10.29.11.48.17.410.0 ]--
r 129         Coord[] neighbors = findNei
--[ 2019.10.29.11.48.17.585.0 ]--
r 129         Coord[] neighbors = findNeig
--[ 2019.10.29.11.48.17.609.0 ]--
r 129         Coord[] neighbors = findNeigh
--[ 2019.10.29.11.48.17.772.0 ]--
r 129         Coord[] neighbors = findNeighb
--[ 2019.10.29.11.48.17.875.0 ]--
r 129         Coord[] neighbors = findNeighbo
--[ 2019.10.29.11.48.18.007.0 ]--
r 129         Coord[] neighbors = findNeighbor
--[ 2019.10.29.11.48.18.084.0 ]--
r 129         Coord[] neighbors = findNeighbors
--[ 2019.10.29.11.48.18.373.0 ]--
r 129         Coord[] neighbors = findNeighbors()
--[ 2019.10.29.11.48.18.521.0 ]--
r 129         Coord[] neighbors = findNeighbors(s)
--[ 2019.10.29.11.48.18.971.0 ]--
r 129         Coord[] neighbors = findNeighbors(s);
--[ 2019.10.29.11.48.19.660.0 ]--
r 129         Coord[] neighbors = findNeighbors(s)
--[ 2019.10.29.11.48.19.838.0 ]--
r 129         Coord[] neighbors = findNeighbors(s
--[ 2019.10.29.11.48.19.979.0 ]--
r 129         Coord[] neighbors = findNeighbors(
--[ 2019.10.29.11.48.20.843.0 ]--
r 129         Coord[] neighbors = findNeighbors(s
--[ 2019.10.29.11.48.20.984.0 ]--
r 129         Coord[] neighbors = findNeighbors(st
--[ 2019.10.29.11.48.21.061.0 ]--
r 129         Coord[] neighbors = findNeighbors(sta
--[ 2019.10.29.11.48.21.181.0 ]--
r 129         Coord[] neighbors = findNeighbors(star
--[ 2019.10.29.11.48.21.361.0 ]--
r 129         Coord[] neighbors = findNeighbors(start
--[ 2019.10.29.11.48.21.475.0 ]--
r 129         Coord[] neighbors = findNeighbors(start)
--[ 2019.10.29.11.48.21.671.0 ]--
r 129         Coord[] neighbors = findNeighbors(start);
--[ 2019.10.29.11.48.21.837.0 ]--
+ 130         
--[ 2019.10.29.11.48.25.175.0 ]--
r 130         f
--[ 2019.10.29.11.48.25.378.0 ]--
r 130         fo
--[ 2019.10.29.11.48.25.428.0 ]--
r 130         for
--[ 2019.10.29.11.48.25.724.0 ]--
r 130         for 
--[ 2019.10.29.11.48.27.501.0 ]--
r 130         for c
--[ 2019.10.29.11.48.27.736.0 ]--
r 130         for c 
--[ 2019.10.29.11.48.28.284.0 ]--
r 130         for c
--[ 2019.10.29.11.48.28.474.0 ]--
r 130         for 
--[ 2019.10.29.11.48.28.834.0 ]--
r 130         for ()
--[ 2019.10.29.11.48.29.079.0 ]--
r 130         for (c)
--[ 2019.10.29.11.48.29.229.0 ]--
r 130         for (c )
--[ 2019.10.29.11.48.29.412.0 ]--
r 130         for (c :)
--[ 2019.10.29.11.48.29.528.0 ]--
r 130         for (c : )
--[ 2019.10.29.11.48.30.148.0 ]--
r 130         for (c :)
--[ 2019.10.29.11.48.30.312.0 ]--
r 130         for (c )
--[ 2019.10.29.11.48.30.452.0 ]--
r 130         for (c)
--[ 2019.10.29.11.48.30.644.0 ]--
r 130         for ()
--[ 2019.10.29.11.48.30.999.0 ]--
r 130         for (C)
--[ 2019.10.29.11.48.31.504.0 ]--
r 130         for (Co)
--[ 2019.10.29.11.48.31.651.0 ]--
r 130         for (Coo)
--[ 2019.10.29.11.48.31.704.0 ]--
r 130         for (Coor)
--[ 2019.10.29.11.48.31.908.0 ]--
r 130         for (Coord)
--[ 2019.10.29.11.48.32.236.0 ]--
r 130         for (Coord )
--[ 2019.10.29.11.48.32.396.0 ]--
r 130         for (Coord c)
--[ 2019.10.29.11.48.32.572.0 ]--
r 130         for (Coord c )
--[ 2019.10.29.11.48.32.847.0 ]--
r 130         for (Coord c :)
--[ 2019.10.29.11.48.32.919.0 ]--
r 130         for (Coord c : )
--[ 2019.10.29.11.48.33.093.0 ]--
r 130         for (Coord c : n)
--[ 2019.10.29.11.48.33.124.0 ]--
r 130         for (Coord c : ne)
--[ 2019.10.29.11.48.33.266.0 ]--
r 130         for (Coord c : nei)
--[ 2019.10.29.11.48.33.321.0 ]--
r 130         for (Coord c : neig)
--[ 2019.10.29.11.48.33.469.0 ]--
r 130         for (Coord c : neigh)
--[ 2019.10.29.11.48.33.531.0 ]--
r 130         for (Coord c : neighb)
--[ 2019.10.29.11.48.33.649.0 ]--
r 130         for (Coord c : neighbo)
--[ 2019.10.29.11.48.33.759.0 ]--
r 130         for (Coord c : neighbor)
--[ 2019.10.29.11.48.33.863.0 ]--
r 130         for (Coord c : neighbors)
--[ 2019.10.29.11.48.34.353.0 ]--
r 130         for (Coord c : neighbors) 
--[ 2019.10.29.11.48.34.576.0 ]--
r 130         for (Coord c : neighbors) {
--[ 2019.10.29.11.48.34.735.0 ]--
+ 131 
+ 132 }
--[ 2019.10.29.11.48.34.784.0 ]--
r 132         }
--[ 2019.10.29.11.48.34.808.0 ]--
r 131             
--[ 2019.10.29.11.48.58.756.0 ]--
r 131             I
--[ 2019.10.29.11.48.59.302.0 ]--
r 131             
--[ 2019.10.29.11.48.59.392.0 ]--
r 131             i
--[ 2019.10.29.11.48.59.558.0 ]--
r 131             in
--[ 2019.10.29.11.48.59.752.0 ]--
r 131             int 
--[ 2019.10.29.11.49.00.271.0 ]--
r 131             int c
--[ 2019.10.29.11.49.00.400.0 ]--
r 131             int co
--[ 2019.10.29.11.49.00.511.0 ]--
r 131             int cos
--[ 2019.10.29.11.49.00.608.0 ]--
r 131             int cost
--[ 2019.10.29.11.49.00.705.0 ]--
r 131             int cost 
--[ 2019.10.29.11.49.00.804.0 ]--
r 131             int cost =
--[ 2019.10.29.11.49.00.933.0 ]--
r 131             int cost = 
--[ 2019.10.29.11.49.50.677.0 ]--
r 131             int cost = t
--[ 2019.10.29.11.49.50.891.0 ]--
r 131             int cost = te
--[ 2019.10.29.11.49.50.904.0 ]--
r 131             int cost = ter
--[ 2019.10.29.11.49.51.094.0 ]--
r 131             int cost = terr
--[ 2019.10.29.11.49.51.154.0 ]--
r 131             int cost = terra
--[ 2019.10.29.11.49.51.187.0 ]--
r 131             int cost = terrai
--[ 2019.10.29.11.49.51.259.0 ]--
r 131             int cost = terrain
--[ 2019.10.29.11.49.51.428.0 ]--
r 131             int cost = terrain.
--[ 2019.10.29.11.49.51.639.0 ]--
r 131             int cost = terrain.c
--[ 2019.10.29.11.49.51.743.0 ]--
r 131             int cost = terrain.co
--[ 2019.10.29.11.49.51.866.0 ]--
r 131             int cost = terrain.co,
--[ 2019.10.29.11.49.52.312.0 ]--
r 131             int cost = terrain.co
--[ 2019.10.29.11.49.52.829.0 ]--
r 131             int cost = terrain.com
--[ 2019.10.29.11.49.53.014.0 ]--
r 131             int cost = terrain.comp
--[ 2019.10.29.11.49.53.137.0 ]--
r 131             int cost = terrain.compu
--[ 2019.10.29.11.49.53.214.0 ]--
r 131             int cost = terrain.comput
--[ 2019.10.29.11.49.53.303.0 ]--
r 131             int cost = terrain.compute
--[ 2019.10.29.11.49.53.698.0 ]--
r 131             int cost = terrain.computeT
--[ 2019.10.29.11.49.53.914.0 ]--
r 131             int cost = terrain.computeTr
--[ 2019.10.29.11.49.53.996.0 ]--
r 131             int cost = terrain.computeTra
--[ 2019.10.29.11.49.54.168.0 ]--
r 131             int cost = terrain.computeTrav
--[ 2019.10.29.11.49.54.254.0 ]--
r 131             int cost = terrain.computeTrave
--[ 2019.10.29.11.49.54.355.0 ]--
r 131             int cost = terrain.computeTravel
--[ 2019.10.29.11.49.54.558.0 ]--
r 131             int cost = terrain.computeTravelC
--[ 2019.10.29.11.49.54.896.0 ]--
r 131             int cost = terrain.computeTravelCo
--[ 2019.10.29.11.49.55.473.0 ]--
r 131             int cost = terrain.computeTravelCos
--[ 2019.10.29.11.49.55.532.0 ]--
r 131             int cost = terrain.computeTravelCost
--[ 2019.10.29.11.49.56.517.0 ]--
r 131             int cost = terrain.computeTravelCost()
--[ 2019.10.29.11.50.00.957.0 ]--
r 131             int cost = terrain.computeTravelCost(s)
--[ 2019.10.29.11.50.01.165.0 ]--
r 131             int cost = terrain.computeTravelCost(st)
--[ 2019.10.29.11.50.01.263.0 ]--
r 131             int cost = terrain.computeTravelCost(sta)
--[ 2019.10.29.11.50.01.370.0 ]--
r 131             int cost = terrain.computeTravelCost(star)
--[ 2019.10.29.11.50.01.562.0 ]--
r 131             int cost = terrain.computeTravelCost(start)
--[ 2019.10.29.11.50.01.610.0 ]--
r 131             int cost = terrain.computeTravelCost(start,)
--[ 2019.10.29.11.50.01.680.0 ]--
r 131             int cost = terrain.computeTravelCost(start, )
--[ 2019.10.29.11.50.02.179.0 ]--
r 131             int cost = terrain.computeTravelCost(start, 0)
--[ 2019.10.29.11.50.02.680.0 ]--
r 131             int cost = terrain.computeTravelCost(start, 0
--[ 2019.10.29.11.50.02.847.0 ]--
r 131             int cost = terrain.computeTravelCost(start, 
--[ 2019.10.29.11.50.03.509.0 ]--
r 131             int cost = terrain.computeTravelCost(start, c
--[ 2019.10.29.11.50.03.865.0 ]--
r 131             int cost = terrain.computeTravelCost(start, c)
--[ 2019.10.29.11.50.04.538.0 ]--
r 131             int cost = terrain.computeTravelCost(start, c);
--[ 2019.10.29.11.50.04.718.0 ]--
+ 132             
--[ 2019.10.29.11.50.10.943.0 ]--
r 131             f cost = terrain.computeTravelCost(start, c);
--[ 2019.10.29.11.50.11.056.0 ]--
r 131             fl cost = terrain.computeTravelCost(start, c);
--[ 2019.10.29.11.50.11.262.0 ]--
r 131             flo cost = terrain.computeTravelCost(start, c);
--[ 2019.10.29.11.50.11.297.0 ]--
r 131             floa cost = terrain.computeTravelCost(start, c);
--[ 2019.10.29.11.50.11.356.0 ]--
r 131             float cost = terrain.computeTravelCost(start, c);
--[ 2019.10.29.11.50.53.563.0 ]--
r 131             ;
--[ 2019.10.29.11.50.55.660.0 ]--
r 131             P;
--[ 2019.10.29.11.50.55.802.0 ]--
r 131             PF;
--[ 2019.10.29.11.50.55.981.0 ]--
r 131             PFN;
--[ 2019.10.29.11.50.56.237.0 ]--
r 131             PFNO;
--[ 2019.10.29.11.50.57.284.0 ]--
r 131             PFN;
--[ 2019.10.29.11.50.57.687.0 ]--
r 131             PFNo;
--[ 2019.10.29.11.50.57.763.0 ]--
r 131             PFNod;
--[ 2019.10.29.11.50.57.985.0 ]--
r 131             PFNode;
--[ 2019.10.29.11.50.58.245.0 ]--
r 131             PFNode ;
--[ 2019.10.29.11.50.59.913.0 ]--
r 131             PFNode c;
--[ 2019.10.29.11.51.00.191.0 ]--
r 131             PFNode cN;
--[ 2019.10.29.11.51.00.359.0 ]--
r 131             PFNode cNo;
--[ 2019.10.29.11.51.00.419.0 ]--
r 131             PFNode cNod;
--[ 2019.10.29.11.51.00.615.0 ]--
r 131             PFNode cNode;
--[ 2019.10.29.11.51.00.679.0 ]--
r 131             PFNode cNode ;
--[ 2019.10.29.11.51.00.791.0 ]--
r 131             PFNode cNode =;
--[ 2019.10.29.11.51.00.871.0 ]--
r 131             PFNode cNode = ;
--[ 2019.10.29.11.51.01.154.0 ]--
r 131             PFNode cNode = n;
--[ 2019.10.29.11.51.01.229.0 ]--
r 131             PFNode cNode = ne;
--[ 2019.10.29.11.51.01.306.0 ]--
r 131             PFNode cNode = new;
--[ 2019.10.29.11.51.01.386.0 ]--
r 131             PFNode cNode = new ;
--[ 2019.10.29.11.51.01.591.0 ]--
r 131             PFNode cNode = new P;
--[ 2019.10.29.11.51.01.695.0 ]--
r 131             PFNode cNode = new PF;
--[ 2019.10.29.11.51.01.877.0 ]--
r 131             PFNode cNode = new PFN;
--[ 2019.10.29.11.51.02.268.0 ]--
r 131             PFNode cNode = new PFNo;
--[ 2019.10.29.11.51.02.373.0 ]--
r 131             PFNode cNode = new PFNod;
--[ 2019.10.29.11.51.02.547.0 ]--
r 131             PFNode cNode = new PFNode;
--[ 2019.10.29.11.51.02.752.0 ]--
r 131             PFNode cNode = new PFNode();
--[ 2019.10.29.11.51.05.868.0 ]--
r 131             PFNode cNode = new PFNode(l);
--[ 2019.10.29.11.51.06.098.0 ]--
r 131             PFNode cNode = new PFNode(lo);
--[ 2019.10.29.11.51.06.130.0 ]--
r 131             PFNode cNode = new PFNode(loc);
--[ 2019.10.29.11.51.06.248.0 ]--
r 131             PFNode cNode = new PFNode(loc,);
--[ 2019.10.29.11.51.06.319.0 ]--
r 131             PFNode cNode = new PFNode(loc, );
--[ 2019.10.29.11.51.39.846.0 ]--
r 131             PFNode cNode = new PFNode(loc, s);
--[ 2019.10.29.11.51.40.087.0 ]--
r 131             PFNode cNode = new PFNode(loc, st);
--[ 2019.10.29.11.51.40.100.0 ]--
r 131             PFNode cNode = new PFNode(loc, sta);
--[ 2019.10.29.11.51.40.216.0 ]--
r 131             PFNode cNode = new PFNode(loc, star);
--[ 2019.10.29.11.51.40.395.0 ]--
r 131             PFNode cNode = new PFNode(loc, start);
--[ 2019.10.29.11.51.43.893.0 ]--
+ 130         
--[ 2019.10.29.11.51.45.029.0 ]--
r 130         P
--[ 2019.10.29.11.51.45.120.0 ]--
r 130         PF
--[ 2019.10.29.11.51.45.860.0 ]--
r 130         PFN
--[ 2019.10.29.11.51.46.073.0 ]--
r 130         PFNo
--[ 2019.10.29.11.51.46.178.0 ]--
r 130         PFNod
--[ 2019.10.29.11.51.46.366.0 ]--
r 130         PFNode
--[ 2019.10.29.11.51.46.436.0 ]--
r 130         PFNode 
--[ 2019.10.29.11.51.46.547.0 ]--
r 130         PFNode s
--[ 2019.10.29.11.51.46.714.0 ]--
r 130         PFNode st
--[ 2019.10.29.11.51.46.813.0 ]--
r 130         PFNode sta
--[ 2019.10.29.11.51.46.904.0 ]--
r 130         PFNode star
--[ 2019.10.29.11.51.47.099.0 ]--
r 130         PFNode start
--[ 2019.10.29.11.51.47.273.0 ]--
r 130         PFNode startN
--[ 2019.10.29.11.51.47.463.0 ]--
r 130         PFNode startNo
--[ 2019.10.29.11.51.47.535.0 ]--
r 130         PFNode startNod
--[ 2019.10.29.11.51.47.710.0 ]--
r 130         PFNode startNode
--[ 2019.10.29.11.51.47.783.0 ]--
r 130         PFNode startNode 
--[ 2019.10.29.11.51.47.914.0 ]--
r 130         PFNode startNode =
--[ 2019.10.29.11.51.47.967.0 ]--
r 130         PFNode startNode = 
--[ 2019.10.29.11.51.48.555.0 ]--
r 130         PFNode startNode = n
--[ 2019.10.29.11.51.48.636.0 ]--
r 130         PFNode startNode = ne
--[ 2019.10.29.11.51.48.715.0 ]--
r 130         PFNode startNode = new
--[ 2019.10.29.11.51.48.791.0 ]--
r 130         PFNode startNode = new 
--[ 2019.10.29.11.51.48.978.0 ]--
r 130         PFNode startNode = new P
--[ 2019.10.29.11.51.49.095.0 ]--
r 130         PFNode startNode = new PF
--[ 2019.10.29.11.51.49.239.0 ]--
r 130         PFNode startNode = new PFN
--[ 2019.10.29.11.51.49.694.0 ]--
r 130         PFNode startNode = new PFNo
--[ 2019.10.29.11.51.49.847.0 ]--
r 130         PFNode startNode = new PFNod
--[ 2019.10.29.11.51.50.014.0 ]--
r 130         PFNode startNode = new PFNode
--[ 2019.10.29.11.51.50.145.0 ]--
r 130         PFNode startNode = new PFNode()
--[ 2019.10.29.11.51.50.346.0 ]--
r 130         PFNode startNode = new PFNode(s)
--[ 2019.10.29.11.51.50.553.0 ]--
r 130         PFNode startNode = new PFNode(st)
--[ 2019.10.29.11.51.50.653.0 ]--
r 130         PFNode startNode = new PFNode(sta)
--[ 2019.10.29.11.51.50.722.0 ]--
r 130         PFNode startNode = new PFNode(star)
--[ 2019.10.29.11.51.50.908.0 ]--
r 130         PFNode startNode = new PFNode(start)
--[ 2019.10.29.11.51.50.977.0 ]--
r 130         PFNode startNode = new PFNode(start,)
--[ 2019.10.29.11.51.51.038.0 ]--
r 130         PFNode startNode = new PFNode(start, )
--[ 2019.10.29.11.51.51.715.0 ]--
r 130         PFNode startNode = new PFNode(start, p)
--[ 2019.10.29.11.51.51.796.0 ]--
r 130         PFNode startNode = new PFNode(start, pf)
--[ 2019.10.29.11.51.52.087.0 ]--
r 130         PFNode startNode = new PFNode(start, p)
--[ 2019.10.29.11.51.52.283.0 ]--
r 130         PFNode startNode = new PFNode(start, )
--[ 2019.10.29.11.51.52.488.0 ]--
r 130         PFNode startNode = new PFNode(start, s)
--[ 2019.10.29.11.51.52.583.0 ]--
r 130         PFNode startNode = new PFNode(start, st)
--[ 2019.10.29.11.51.52.716.0 ]--
r 130         PFNode startNode = new PFNode(start, sta)
--[ 2019.10.29.11.51.52.819.0 ]--
r 130         PFNode startNode = new PFNode(start, star)
--[ 2019.10.29.11.51.53.568.0 ]--
r 130         PFNode startNode = new PFNode(start, start)
--[ 2019.10.29.11.51.54.399.0 ]--
r 130         PFNode startNode = new PFNode(start, star)
--[ 2019.10.29.11.51.54.597.0 ]--
r 130         PFNode startNode = new PFNode(start, sta)
--[ 2019.10.29.11.51.54.767.0 ]--
r 130         PFNode startNode = new PFNode(start, st)
--[ 2019.10.29.11.51.54.959.0 ]--
r 130         PFNode startNode = new PFNode(start, s)
--[ 2019.10.29.11.51.55.156.0 ]--
r 130         PFNode startNode = new PFNode(start, )
--[ 2019.10.29.11.51.57.876.0 ]--
r 130         PFNode startNode = new PFNode(start, n)
--[ 2019.10.29.11.51.58.124.0 ]--
r 130         PFNode startNode = new PFNode(start, nu)
--[ 2019.10.29.11.51.58.331.0 ]--
r 130         PFNode startNode = new PFNode(start, nul)
--[ 2019.10.29.11.51.58.510.0 ]--
r 130         PFNode startNode = new PFNode(start, null)
--[ 2019.10.29.11.51.58.971.0 ]--
r 130         PFNode startNode = new PFNode(start, null);
--[ 2019.10.29.11.52.09.127.0 ]--
r 132             PFNode cNode = new PFNode(c, start);
--[ 2019.10.29.11.52.12.261.0 ]--
r 132             PFNode cNode = new PFNode(c, startN);
--[ 2019.10.29.11.52.12.402.0 ]--
r 132             PFNode cNode = new PFNode(c, startNo);
--[ 2019.10.29.11.52.12.491.0 ]--
r 132             PFNode cNode = new PFNode(c, startNod);
--[ 2019.10.29.11.52.12.696.0 ]--
r 132             PFNode cNode = new PFNode(c, startNode);
--[ 2019.10.29.11.52.30.628.0 ]--
r 133             p
--[ 2019.10.29.11.52.30.846.0 ]--
r 133             pw
--[ 2019.10.29.11.52.31.002.0 ]--
r 133             p
--[ 2019.10.29.11.52.31.240.0 ]--
r 133             pq
--[ 2019.10.29.11.52.31.416.0 ]--
r 133             pq.
--[ 2019.10.29.11.52.33.340.0 ]--
r 133             pq.i
--[ 2019.10.29.11.52.33.438.0 ]--
r 133             pq.in
--[ 2019.10.29.11.52.33.499.0 ]--
r 133             pq.ins
--[ 2019.10.29.11.52.33.592.0 ]--
r 133             pq.inse
--[ 2019.10.29.11.52.33.712.0 ]--
r 133             pq.inser
--[ 2019.10.29.11.52.33.923.0 ]--
r 133             pq.insert
--[ 2019.10.29.11.52.34.241.0 ]--
r 133             pq.insert()
--[ 2019.10.29.11.52.34.719.0 ]--
r 133             pq.insert(c)
--[ 2019.10.29.11.52.35.029.0 ]--
r 133             pq.insert(cN)
--[ 2019.10.29.11.52.35.208.0 ]--
r 133             pq.insert(cNo)
--[ 2019.10.29.11.52.35.256.0 ]--
r 133             pq.insert(cNod)
--[ 2019.10.29.11.52.35.472.0 ]--
r 133             pq.insert(cNode)
--[ 2019.10.29.11.52.35.760.0 ]--
r 133             pq.insert(cNode);
--[ 2019.10.29.11.52.50.168.0 ]--
r 39 
r 43 
r 111 
r 135 
--[ 2019.10.29.11.52.51.443.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.10.29.11.54.58.939.0 ]--
DisposeComponent
--[ 2019.10.29.13.12.46.799.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.10.29.13.12.46.971.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/.cos265
/readme.html
/P04_Pathfinding.iml

--[ 2019.10.29.13.12.46.971.1 ]--
InitFile: /.cos265


--[ 2019.10.29.13.12.46.987.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.10.29.13.12.46.987.1 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.10.29.13.12.46.987.2 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private Terrain terrain;
    private int[][] board;

    private class PFNode implements Comparable<PFNode> {
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)
        private Coord loc;
        private PFNode fromNode;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            return getCost() - that.getCost();
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        public int getCost() {
            return 0;
        }

        public float getCost(float heuristic) {
            return 0;
        }

        // returns if this PFNode is not marked invalid
        public boolean isValid() {
            return false;
        }

        // marks the PFNode as invalid
        public void invalidate() {

        }

        // returns if the PFNode is marked as used
        public boolean isUsed() {
            return true;
        }

        // marks the PFNode as used
        public void use() { }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Stack<PFNode> s = new Stack<>();
            s.push(new PFNode(null, null));
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        int N = this.terrain.getN();
        board = new int[N][N];

    }

    public void setPathStart(Coord loc) {
        start = new Coord(loc.getI(), loc.getJ());
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        end = new Coord(loc.getI(), loc.getJ());
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {

    }

    public float getHeuristic() {
        return 0;
    }

    public void resetPath() {

    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        // Step 1: Look at all possible locations from starting point, create nodes for each
        Coord[] neighbors = findNeighbors(start);
        PFNode startNode = new PFNode(start, null);
        for (Coord c : neighbors) {
            PFNode cNode = new PFNode(c, startNode);
            pq.insert(cNode);
        }

    }

    public boolean foundPath() {
        return false;
    }

    public float getPathCost() {
        return 0;
    }

    public int getSearchSize() {
        return 0;
    }

    public Iterable<Coord> getPathSolution() {
        return null;
    }

    public boolean wasSearched(Coord loc) {
        return false;
    }
}

--[ 2019.10.29.13.12.46.987.3 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return null;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return true;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
    }

}

--[ 2019.10.29.13.12.47.003.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.10.29.13.12.47.003.1 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.10.29.13.12.47.003.2 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
    };

    private final static String emapFilename = emaps[0];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.10.29.13.12.47.018.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.10.29.13.18.17.494.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.10.29.13.19.12.695.0 ]--
DisposeComponent
--[ 2019.11.02.14.01.23.074.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.11.02.14.01.23.209.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/.cos265
/readme.html
/P04_Pathfinding.iml

--[ 2019.11.02.14.01.23.218.0 ]--
InitFile: /.cos265


--[ 2019.11.02.14.01.23.221.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.11.02.14.01.23.225.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.11.02.14.01.23.229.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private Terrain terrain;
    private int[][] board;

    private class PFNode implements Comparable<PFNode> {
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)
        private Coord loc;
        private PFNode fromNode;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            return getCost() - that.getCost();
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        public int getCost() {
            return 0;
        }

        public float getCost(float heuristic) {
            return 0;
        }

        // returns if this PFNode is not marked invalid
        public boolean isValid() {
            return false;
        }

        // marks the PFNode as invalid
        public void invalidate() {

        }

        // returns if the PFNode is marked as used
        public boolean isUsed() {
            return true;
        }

        // marks the PFNode as used
        public void use() { }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Stack<PFNode> s = new Stack<>();
            s.push(new PFNode(null, null));
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        int N = this.terrain.getN();
        board = new int[N][N];

    }

    public void setPathStart(Coord loc) {
        start = new Coord(loc.getI(), loc.getJ());
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        end = new Coord(loc.getI(), loc.getJ());
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {

    }

    public float getHeuristic() {
        return 0;
    }

    public void resetPath() {

    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        // Step 1: Look at all possible locations from starting point, create nodes for each
        Coord[] neighbors = findNeighbors(start);
        PFNode startNode = new PFNode(start, null);
        for (Coord c : neighbors) {
            PFNode cNode = new PFNode(c, startNode);
            pq.insert(cNode);
        }

    }

    public boolean foundPath() {
        return false;
    }

    public float getPathCost() {
        return 0;
    }

    public int getSearchSize() {
        return 0;
    }

    public Iterable<Coord> getPathSolution() {
        return null;
    }

    public boolean wasSearched(Coord loc) {
        return false;
    }
}

--[ 2019.11.02.14.01.23.233.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return null;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return true;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
    }

}

--[ 2019.11.02.14.01.23.237.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.11.02.14.01.23.241.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.11.02.14.01.23.244.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
    };

    private final static String emapFilename = emaps[0];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.11.02.14.01.23.248.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.02.14.02.49.737.0 ]--
:/src/Pathfinder.java
+ 20     
--[ 2019.11.02.14.02.49.997.0 ]--
+ 20     
--[ 2019.11.02.14.02.50.528.0 ]--
r 21     /
--[ 2019.11.02.14.02.50.887.0 ]--
r 21     /*
--[ 2019.11.02.14.02.51.496.0 ]--
r 21     /**
--[ 2019.11.02.14.02.51.951.0 ]--
+ 22     
--[ 2019.11.02.14.02.51.966.0 ]--
+ 22     *
r 23 */
--[ 2019.11.02.14.02.52.029.0 ]--
r 23      */
--[ 2019.11.02.14.02.52.107.0 ]--
r 20 
--[ 2019.11.02.14.02.52.123.0 ]--
r 22      *
--[ 2019.11.02.14.02.52.138.0 ]--
r 22      * 
--[ 2019.11.02.14.02.54.075.0 ]--
r 22      *  
--[ 2019.11.02.14.02.54.462.0 ]--
r 22      * 
--[ 2019.11.02.14.02.54.977.0 ]--
r 22      * P
--[ 2019.11.02.14.02.55.071.0 ]--
r 22      * PF
--[ 2019.11.02.14.02.55.339.0 ]--
r 22      * PFN
--[ 2019.11.02.14.02.55.613.0 ]--
r 22      * PFNo
--[ 2019.11.02.14.02.55.751.0 ]--
r 22      * PFNod
--[ 2019.11.02.14.02.55.963.0 ]--
r 22      * PFNode
--[ 2019.11.02.14.02.56.026.0 ]--
r 22      * PFNode 
--[ 2019.11.02.14.02.56.135.0 ]--
r 22      * PFNode w
--[ 2019.11.02.14.02.56.198.0 ]--
r 22      * PFNode wi
--[ 2019.11.02.14.02.56.433.0 ]--
r 22      * PFNode wil
--[ 2019.11.02.14.02.56.556.0 ]--
r 22      * PFNode will
--[ 2019.11.02.14.02.56.660.0 ]--
r 22      * PFNode will 
--[ 2019.11.02.14.02.56.848.0 ]--
r 22      * PFNode will b
--[ 2019.11.02.14.02.56.957.0 ]--
r 22      * PFNode will be
--[ 2019.11.02.14.02.57.062.0 ]--
r 22      * PFNode will be 
--[ 2019.11.02.14.02.57.158.0 ]--
r 22      * PFNode will be k
--[ 2019.11.02.14.02.57.322.0 ]--
r 22      * PFNode will be ke
--[ 2019.11.02.14.02.57.462.0 ]--
r 22      * PFNode will be key
--[ 2019.11.02.14.02.57.838.0 ]--
r 22      * PFNode will be ke
--[ 2019.11.02.14.02.58.015.0 ]--
r 22      * PFNode will be k
--[ 2019.11.02.14.02.58.202.0 ]--
r 22      * PFNode will be 
--[ 2019.11.02.14.02.58.390.0 ]--
r 22      * PFNode will be t
--[ 2019.11.02.14.02.58.484.0 ]--
r 22      * PFNode will be th
--[ 2019.11.02.14.02.58.609.0 ]--
r 22      * PFNode will be the
--[ 2019.11.02.14.02.58.656.0 ]--
r 22      * PFNode will be the 
--[ 2019.11.02.14.02.58.796.0 ]--
r 22      * PFNode will be the k
--[ 2019.11.02.14.02.58.890.0 ]--
r 22      * PFNode will be the ke
--[ 2019.11.02.14.02.58.994.0 ]--
r 22      * PFNode will be the key
--[ 2019.11.02.14.02.59.041.0 ]--
r 22      * PFNode will be the key 
--[ 2019.11.02.14.02.59.214.0 ]--
r 22      * PFNode will be the key f
--[ 2019.11.02.14.02.59.275.0 ]--
r 22      * PFNode will be the key fo
--[ 2019.11.02.14.02.59.421.0 ]--
r 22      * PFNode will be the key for
--[ 2019.11.02.14.02.59.507.0 ]--
r 22      * PFNode will be the key for 
--[ 2019.11.02.14.02.59.767.0 ]--
r 22      * PFNode will be the key for M
--[ 2019.11.02.14.03.00.059.0 ]--
r 22      * PFNode will be the key for Min
--[ 2019.11.02.14.03.00.200.0 ]--
r 22      * PFNode will be the key for MinP
--[ 2019.11.02.14.03.00.278.0 ]--
r 22      * PFNode will be the key for MinPQ
--[ 2019.11.02.14.03.00.767.0 ]--
r 22      * PFNode will be the key for MinPQ 
--[ 2019.11.02.14.03.01.127.0 ]--
r 22      * PFNode will be the key for MinPQ *
--[ 2019.11.02.14.03.01.694.0 ]--
r 22      * PFNode will be the key for MinPQ 
--[ 2019.11.02.14.03.01.961.0 ]--
r 22      * PFNode will be the key for MinPQ (
--[ 2019.11.02.14.03.02.255.0 ]--
r 22      * PFNode will be the key for MinPQ (u
--[ 2019.11.02.14.03.02.315.0 ]--
r 22      * PFNode will be the key for MinPQ (us
--[ 2019.11.02.14.03.02.403.0 ]--
r 22      * PFNode will be the key for MinPQ (use
--[ 2019.11.02.14.03.02.577.0 ]--
r 22      * PFNode will be the key for MinPQ (used
--[ 2019.11.02.14.03.02.684.0 ]--
r 22      * PFNode will be the key for MinPQ (used 
--[ 2019.11.02.14.03.02.713.0 ]--
r 22      * PFNode will be the key for MinPQ (used i
--[ 2019.11.02.14.03.02.779.0 ]--
r 22      * PFNode will be the key for MinPQ (used in
--[ 2019.11.02.14.03.02.931.0 ]--
r 22      * PFNode will be the key for MinPQ (used in 
--[ 2019.11.02.14.03.03.127.0 ]--
r 22      * PFNode will be the key for MinPQ (used in c
--[ 2019.11.02.14.03.03.175.0 ]--
r 22      * PFNode will be the key for MinPQ (used in co
--[ 2019.11.02.14.03.03.270.0 ]--
r 22      * PFNode will be the key for MinPQ (used in com
--[ 2019.11.02.14.03.03.364.0 ]--
r 22      * PFNode will be the key for MinPQ (used in comp
--[ 2019.11.02.14.03.03.504.0 ]--
r 22      * PFNode will be the key for MinPQ (used in compu
--[ 2019.11.02.14.03.03.630.0 ]--
r 22      * PFNode will be the key for MinPQ (used in comput
--[ 2019.11.02.14.03.03.711.0 ]--
r 22      * PFNode will be the key for MinPQ (used in compute
--[ 2019.11.02.14.03.03.978.0 ]--
r 22      * PFNode will be the key for MinPQ (used in computeP
--[ 2019.11.02.14.03.04.173.0 ]--
r 22      * PFNode will be the key for MinPQ (used in computePa
--[ 2019.11.02.14.03.04.236.0 ]--
r 22      * PFNode will be the key for MinPQ (used in computePat
--[ 2019.11.02.14.03.04.345.0 ]--
r 22      * PFNode will be the key for MinPQ (used in computePath
--[ 2019.11.02.14.03.04.407.0 ]--
r 22      * PFNode will be the key for MinPQ (used in computePathh
--[ 2019.11.02.14.03.05.091.0 ]--
r 22      * PFNode will be the key for MinPQ (used in computePath
--[ 2019.11.02.14.03.06.094.0 ]--
r 22      * PFNode will be the key for MinPQ (used in computePath(
--[ 2019.11.02.14.03.06.172.0 ]--
r 22      * PFNode will be the key for MinPQ (used in computePath()
--[ 2019.11.02.14.03.06.392.0 ]--
r 22      * PFNode will be the key for MinPQ (used in computePath())
--[ 2019.11.02.14.03.10.458.0 ]--
- 11
- 11
- 11
--[ 2019.11.02.14.03.10.676.0 ]--
- 10
r 10     
--[ 2019.11.02.14.03.53.854.0 ]--
+ 68             
--[ 2019.11.02.14.03.54.761.0 ]--
r 68             C
--[ 2019.11.02.14.03.54.950.0 ]--
r 68             Co
--[ 2019.11.02.14.03.55.075.0 ]--
r 68             Coo
--[ 2019.11.02.14.03.55.216.0 ]--
r 68             Coor
--[ 2019.11.02.14.03.55.450.0 ]--
r 68             Coord
--[ 2019.11.02.14.03.55.932.0 ]--
r 68             Coord[]
--[ 2019.11.02.14.03.56.371.0 ]--
r 68             Coord[] 
--[ 2019.11.02.14.03.56.574.0 ]--
r 68             Coord[] c
--[ 2019.11.02.14.03.56.748.0 ]--
r 68             Coord[] co
--[ 2019.11.02.14.03.56.905.0 ]--
r 68             Coord[] coo
--[ 2019.11.02.14.03.57.001.0 ]--
r 68             Coord[] coor
--[ 2019.11.02.14.03.57.160.0 ]--
r 68             Coord[] coord
--[ 2019.11.02.14.03.57.225.0 ]--
r 68             Coord[] coords
--[ 2019.11.02.14.03.57.338.0 ]--
r 68             Coord[] coords 
--[ 2019.11.02.14.03.57.513.0 ]--
r 68             Coord[] coords =
--[ 2019.11.02.14.03.57.586.0 ]--
r 68             Coord[] coords = 
--[ 2019.11.02.14.03.57.791.0 ]--
r 68             Coord[] coords = f
--[ 2019.11.02.14.03.57.948.0 ]--
r 68             Coord[] coords = fi
--[ 2019.11.02.14.03.58.026.0 ]--
r 68             Coord[] coords = fin
--[ 2019.11.02.14.03.58.072.0 ]--
r 68             Coord[] coords = find
--[ 2019.11.02.14.03.58.260.0 ]--
r 68             Coord[] coords = findN
--[ 2019.11.02.14.03.58.434.0 ]--
r 68             Coord[] coords = findNe
--[ 2019.11.02.14.03.58.494.0 ]--
r 68             Coord[] coords = findNei
--[ 2019.11.02.14.03.58.603.0 ]--
r 68             Coord[] coords = findNeig
--[ 2019.11.02.14.03.58.681.0 ]--
r 68             Coord[] coords = findNeigh
--[ 2019.11.02.14.03.58.822.0 ]--
r 68             Coord[] coords = findNeighb
--[ 2019.11.02.14.03.58.900.0 ]--
r 68             Coord[] coords = findNeighbo
--[ 2019.11.02.14.03.59.048.0 ]--
r 68             Coord[] coords = findNeighbor
--[ 2019.11.02.14.03.59.123.0 ]--
r 68             Coord[] coords = findNeighbors
--[ 2019.11.02.14.03.59.513.0 ]--
r 68             Coord[] coords = findNeighbors()
--[ 2019.11.02.14.03.59.971.0 ]--
r 68             Coord[] coords = findNeighbors();
--[ 2019.11.02.14.04.01.422.0 ]--
r 68             Coord[] coords = findNeighbors()
--[ 2019.11.02.14.04.11.652.0 ]--
r 68             Coord[] coords = findNeighbors();
--[ 2019.11.02.14.04.17.927.0 ]--
r 68             Coord[] coords = findNeighbors(l);
--[ 2019.11.02.14.04.18.078.0 ]--
r 68             Coord[] coords = findNeighbors(lo);
--[ 2019.11.02.14.04.18.173.0 ]--
r 68             Coord[] coords = findNeighbors(loc);
--[ 2019.11.02.14.04.29.429.0 ]--
+ 70             
--[ 2019.11.02.14.04.30.066.0 ]--
r 70             f
--[ 2019.11.02.14.04.30.186.0 ]--
r 70             fo
--[ 2019.11.02.14.04.30.280.0 ]--
r 70             for
--[ 2019.11.02.14.04.30.358.0 ]--
r 70             for 
--[ 2019.11.02.14.04.30.436.0 ]--
r 70             for a
--[ 2019.11.02.14.04.30.812.0 ]--
r 70             for aC
--[ 2019.11.02.14.04.30.942.0 ]--
r 70             for aCo
--[ 2019.11.02.14.04.31.114.0 ]--
r 70             for aCoo
--[ 2019.11.02.14.04.31.193.0 ]--
r 70             for aCoor
--[ 2019.11.02.14.04.31.355.0 ]--
r 70             for aCoord
--[ 2019.11.02.14.04.31.433.0 ]--
r 70             for aCoord 
--[ 2019.11.02.14.04.31.543.0 ]--
r 70             for aCoord i
--[ 2019.11.02.14.04.31.621.0 ]--
r 70             for aCoord in
--[ 2019.11.02.14.04.31.699.0 ]--
r 70             for aCoord in 
--[ 2019.11.02.14.04.31.808.0 ]--
r 70             for aCoord in c
--[ 2019.11.02.14.04.31.949.0 ]--
r 70             for aCoord in co
--[ 2019.11.02.14.04.32.058.0 ]--
r 70             for aCoord in coo
--[ 2019.11.02.14.04.32.160.0 ]--
r 70             for aCoord in coor
--[ 2019.11.02.14.04.32.424.0 ]--
r 70             for aCoord in coo
--[ 2019.11.02.14.04.32.897.0 ]--
r 70             for aCoord in co
--[ 2019.11.02.14.04.32.926.0 ]--
r 70             for aCoord in c
--[ 2019.11.02.14.04.32.960.0 ]--
r 70             for aCoord in 
--[ 2019.11.02.14.04.32.988.0 ]--
r 70             for aCoord in
--[ 2019.11.02.14.04.33.020.0 ]--
r 70             for aCoord i
--[ 2019.11.02.14.04.33.066.0 ]--
r 70             for aCoord 
--[ 2019.11.02.14.04.33.113.0 ]--
r 70             for aCoord
--[ 2019.11.02.14.04.33.145.0 ]--
r 70             for aCoor
--[ 2019.11.02.14.04.33.160.0 ]--
r 70             for aCoo
--[ 2019.11.02.14.04.33.301.0 ]--
r 70             for aCo
--[ 2019.11.02.14.04.33.474.0 ]--
r 70             for aC
--[ 2019.11.02.14.04.33.637.0 ]--
r 70             for a
--[ 2019.11.02.14.04.33.793.0 ]--
r 70             for 
--[ 2019.11.02.14.04.34.137.0 ]--
r 70             for ()
--[ 2019.11.02.14.04.34.544.0 ]--
r 70             for (c)
--[ 2019.11.02.14.04.34.695.0 ]--
r 70             for (co)
--[ 2019.11.02.14.04.34.836.0 ]--
r 70             for (coo)
--[ 2019.11.02.14.04.34.914.0 ]--
r 70             for (coor)
--[ 2019.11.02.14.04.35.134.0 ]--
r 70             for (coord)
--[ 2019.11.02.14.04.35.201.0 ]--
r 70             for (coord )
--[ 2019.11.02.14.04.35.405.0 ]--
r 70             for (coord :)
--[ 2019.11.02.14.04.35.510.0 ]--
r 70             for (coord : )
--[ 2019.11.02.14.04.35.713.0 ]--
r 70             for (coord : c)
--[ 2019.11.02.14.04.35.838.0 ]--
r 70             for (coord : co)
--[ 2019.11.02.14.04.35.932.0 ]--
r 70             for (coord : coo)
--[ 2019.11.02.14.04.36.041.0 ]--
r 70             for (coord : coor)
--[ 2019.11.02.14.04.36.261.0 ]--
r 70             for (coord : coord)
--[ 2019.11.02.14.04.36.325.0 ]--
r 70             for (coord : coords)
--[ 2019.11.02.14.04.37.387.0 ]--
r 70             for (coord : coords) 
--[ 2019.11.02.14.04.37.490.0 ]--
r 70             for (coord : coords) {
--[ 2019.11.02.14.04.39.784.0 ]--
r 70             for (Ccoord : coords) {
--[ 2019.11.02.14.04.40.063.0 ]--
r 70             for (Cocoord : coords) {
--[ 2019.11.02.14.04.40.250.0 ]--
r 70             for (Coocoord : coords) {
--[ 2019.11.02.14.04.40.315.0 ]--
r 70             for (Coorcoord : coords) {
--[ 2019.11.02.14.04.40.488.0 ]--
r 70             for (Coordcoord : coords) {
--[ 2019.11.02.14.04.40.566.0 ]--
r 70             for (Coord coord : coords) {
--[ 2019.11.02.14.04.42.289.0 ]--
+ 71 
+ 72 }
--[ 2019.11.02.14.04.42.302.0 ]--
r 72             }
--[ 2019.11.02.14.04.42.349.0 ]--
r 71                 
--[ 2019.11.02.14.04.43.236.0 ]--
r 71                 s
--[ 2019.11.02.14.04.43.298.0 ]--
r 71                 s.
--[ 2019.11.02.14.04.43.611.0 ]--
r 71                 s.pu
--[ 2019.11.02.14.04.43.750.0 ]--
r 71                 s.pus
--[ 2019.11.02.14.04.43.828.0 ]--
r 71                 s.push
--[ 2019.11.02.14.04.43.993.0 ]--
r 71                 s.push()
--[ 2019.11.02.14.04.44.265.0 ]--
r 71                 s.push(n)
--[ 2019.11.02.14.04.44.328.0 ]--
r 71                 s.push(ne)
--[ 2019.11.02.14.04.44.425.0 ]--
r 71                 s.push(new)
--[ 2019.11.02.14.04.44.561.0 ]--
r 71                 s.push(new )
--[ 2019.11.02.14.04.44.721.0 ]--
r 71                 s.push(new P)
--[ 2019.11.02.14.04.44.848.0 ]--
r 71                 s.push(new PF)
--[ 2019.11.02.14.04.44.944.0 ]--
r 71                 s.push(new PFN)
--[ 2019.11.02.14.04.45.229.0 ]--
r 71                 s.push(new PFNo)
--[ 2019.11.02.14.04.45.323.0 ]--
r 71                 s.push(new PFNod)
--[ 2019.11.02.14.04.45.558.0 ]--
r 71                 s.push(new PFNode)
--[ 2019.11.02.14.04.45.803.0 ]--
r 71                 s.push(new PFNode())
--[ 2019.11.02.14.04.46.427.0 ]--
r 71                 s.push(new PFNode(l))
--[ 2019.11.02.14.04.46.608.0 ]--
r 71                 s.push(new PFNode(lo))
--[ 2019.11.02.14.04.46.673.0 ]--
r 71                 s.push(new PFNode(loc))
--[ 2019.11.02.14.04.46.878.0 ]--
r 71                 s.push(new PFNode(loc:))
--[ 2019.11.02.14.04.46.950.0 ]--
r 71                 s.push(new PFNode(loc: ))
--[ 2019.11.02.14.04.49.897.0 ]--
r 71                 s.push(new PFNode(loc: c))
--[ 2019.11.02.14.04.50.152.0 ]--
r 71                 s.push(new PFNode(loc: coo))
--[ 2019.11.02.14.04.50.294.0 ]--
r 71                 s.push(new PFNode(loc: coor))
--[ 2019.11.02.14.04.50.592.0 ]--
r 71                 s.push(new PFNode(loc: coord))
--[ 2019.11.02.14.04.50.638.0 ]--
r 71                 s.push(new PFNode(loc: coord,))
--[ 2019.11.02.14.04.50.794.0 ]--
r 71                 s.push(new PFNode(loc: coord, ))
--[ 2019.11.02.14.04.51.500.0 ]--
r 71                 s.push(new PFNode(loc: coord, f))
--[ 2019.11.02.14.04.51.706.0 ]--
r 71                 s.push(new PFNode(loc: coord, fr))
--[ 2019.11.02.14.04.51.769.0 ]--
r 71                 s.push(new PFNode(loc: coord, fro))
--[ 2019.11.02.14.04.51.815.0 ]--
r 71                 s.push(new PFNode(loc: coord, from))
--[ 2019.11.02.14.04.52.122.0 ]--
r 71                 s.push(new PFNode(loc: coord, fromN))
--[ 2019.11.02.14.04.52.340.0 ]--
r 71                 s.push(new PFNode(loc: coord, fromNo))
--[ 2019.11.02.14.04.52.560.0 ]--
r 71                 s.push(new PFNode(loc: coord, fromNod))
--[ 2019.11.02.14.04.52.747.0 ]--
r 71                 s.push(new PFNode(loc: coord, fromNode))
--[ 2019.11.02.14.04.52.934.0 ]--
r 71                 s.push(new PFNode(loc: coord, fromNode:))
--[ 2019.11.02.14.04.53.088.0 ]--
r 71                 s.push(new PFNode(loc: coord, fromNode: ))
--[ 2019.11.02.14.05.10.837.0 ]--
r 71                 s.push(new PFNode(loc: coord, fromNode: t))
--[ 2019.11.02.14.05.11.009.0 ]--
r 71                 s.push(new PFNode(loc: coord, fromNode: th))
--[ 2019.11.02.14.05.11.046.0 ]--
r 71                 s.push(new PFNode(loc: coord, fromNode: thi))
--[ 2019.11.02.14.05.11.062.0 ]--
r 71                 s.push(new PFNode(loc: coord, fromNode: this))
--[ 2019.11.02.14.05.13.280.0 ]--
r 71                 s.push(new PFNode(loc: \coord, fromNode: this))
--[ 2019.11.02.14.05.13.445.0 ]--
r 71                 s.push(new PFNode(loc: \\coord, fromNode: this))
--[ 2019.11.02.14.05.13.712.0 ]--
r 71                 s.push(new PFNode(loc: \\\coord, fromNode: this))
--[ 2019.11.02.14.05.14.185.0 ]--
r 71                 s.push(new PFNode(loc: \\coord, fromNode: this))
--[ 2019.11.02.14.05.14.669.0 ]--
r 71                 s.push(new PFNode(loc: \coord, fromNode: this))
--[ 2019.11.02.14.05.14.702.0 ]--
r 71                 s.push(new PFNode(loc: coord, fromNode: this))
--[ 2019.11.02.14.05.14.736.0 ]--
r 71                 s.push(new PFNode(loc:coord, fromNode: this))
--[ 2019.11.02.14.05.15.035.0 ]--
r 71                 s.push(new PFNode(loccoord, fromNode: this))
--[ 2019.11.02.14.05.15.246.0 ]--
r 71                 s.push(new PFNode(locoord, fromNode: this))
--[ 2019.11.02.14.05.15.436.0 ]--
r 71                 s.push(new PFNode(lcoord, fromNode: this))
--[ 2019.11.02.14.05.15.644.0 ]--
r 71                 s.push(new PFNode(coord, fromNode: this))
--[ 2019.11.02.14.05.18.471.0 ]--
r 71                 s.push(new PFNode(coord, this))
--[ 2019.11.02.14.05.20.976.0 ]--
r 71                 s.push(new PFNode(coord, this));
--[ 2019.11.02.14.05.26.575.0 ]--
r 73 =
--[ 2019.11.02.14.05.26.747.0 ]--
r 73 
--[ 2019.11.02.14.05.27.200.0 ]--
- 73
--[ 2019.11.02.14.10.11.495.0 ]--
r 142         f
--[ 2019.11.02.14.10.11.695.0 ]--
r 142         for
--[ 2019.11.02.14.10.11.773.0 ]--
r 142         for 
--[ 2019.11.02.14.10.11.914.0 ]--
r 142         for ()
--[ 2019.11.02.14.10.12.228.0 ]--
r 142         for (n)
--[ 2019.11.02.14.10.12.251.0 ]--
r 142         for (no)
--[ 2019.11.02.14.10.12.361.0 ]--
r 142         for (nod)
--[ 2019.11.02.14.10.12.550.0 ]--
r 142         for (node)
--[ 2019.11.02.14.10.12.654.0 ]--
r 142         for (node )
--[ 2019.11.02.14.10.12.826.0 ]--
r 142         for (node :)
--[ 2019.11.02.14.10.12.951.0 ]--
r 142         for (node : )
--[ 2019.11.02.14.10.13.156.0 ]--
r 142         for (node : m)
--[ 2019.11.02.14.10.13.539.0 ]--
r 142         for (node : mi)
--[ 2019.11.02.14.10.13.884.0 ]--
r 142         for (node : m)
--[ 2019.11.02.14.10.14.046.0 ]--
r 142         for (node : )
--[ 2019.11.02.14.10.14.191.0 ]--
r 142         for (node :)
--[ 2019.11.02.14.10.14.367.0 ]--
r 142         for (node )
--[ 2019.11.02.14.10.14.517.0 ]--
r 142         for (node)
--[ 2019.11.02.14.10.14.684.0 ]--
r 142         for (nod)
--[ 2019.11.02.14.10.14.836.0 ]--
r 142         for (no)
--[ 2019.11.02.14.10.15.192.0 ]--
r 142         for (n)
--[ 2019.11.02.14.10.15.629.0 ]--
r 142         for ()
--[ 2019.11.02.14.10.16.008.0 ]--
r 142         for (P)
--[ 2019.11.02.14.10.16.102.0 ]--
r 142         for (PF)
--[ 2019.11.02.14.10.16.243.0 ]--
r 142         for (PF )
--[ 2019.11.02.14.10.16.588.0 ]--
r 142         for (PF)
--[ 2019.11.02.14.10.16.900.0 ]--
r 142         for (PFN)
--[ 2019.11.02.14.10.17.188.0 ]--
r 142         for (PFNo)
--[ 2019.11.02.14.10.17.263.0 ]--
r 142         for (PFNod)
--[ 2019.11.02.14.10.17.479.0 ]--
r 142         for (PFNode)
--[ 2019.11.02.14.10.17.543.0 ]--
r 142         for (PFNode )
--[ 2019.11.02.14.10.17.758.0 ]--
r 142         for (PFNode n)
--[ 2019.11.02.14.10.17.855.0 ]--
r 142         for (PFNode no)
--[ 2019.11.02.14.10.17.919.0 ]--
r 142         for (PFNode nod)
--[ 2019.11.02.14.10.18.196.0 ]--
r 142         for (PFNode node)
--[ 2019.11.02.14.10.18.227.0 ]--
r 142         for (PFNode node )
--[ 2019.11.02.14.10.18.430.0 ]--
r 142         for (PFNode node :)
--[ 2019.11.02.14.10.18.526.0 ]--
r 142         for (PFNode node : )
--[ 2019.11.02.14.10.18.710.0 ]--
r 142         for (PFNode node : m)
--[ 2019.11.02.14.10.18.760.0 ]--
r 142         for (PFNode node : mi)
--[ 2019.11.02.14.10.18.885.0 ]--
r 142         for (PFNode node : min)
--[ 2019.11.02.14.10.19.151.0 ]--
r 142         for (PFNode node : minP)
--[ 2019.11.02.14.10.19.464.0 ]--
r 142         for (PFNode node : min)
--[ 2019.11.02.14.10.19.632.0 ]--
r 142         for (PFNode node : mi)
--[ 2019.11.02.14.10.19.757.0 ]--
r 142         for (PFNode node : m)
--[ 2019.11.02.14.10.19.930.0 ]--
r 142         for (PFNode node : )
--[ 2019.11.02.14.10.22.352.0 ]--
r 142         for (PFNode node : p)
--[ 2019.11.02.14.10.22.762.0 ]--
r 142         for (PFNode node : pq)
--[ 2019.11.02.14.10.23.611.0 ]--
r 142         for (PFNode node : pq) 
--[ 2019.11.02.14.10.23.778.0 ]--
r 142         for (PFNode node : pq) {
--[ 2019.11.02.14.10.23.981.0 ]--
+ 143 
+ 144 }
--[ 2019.11.02.14.10.24.028.0 ]--
r 144         }
--[ 2019.11.02.14.10.24.059.0 ]--
r 143             
--[ 2019.11.02.14.10.26.444.0 ]--
r 143             i
--[ 2019.11.02.14.10.26.500.0 ]--
r 143             if
--[ 2019.11.02.14.10.26.625.0 ]--
r 143             if 
--[ 2019.11.02.14.10.26.750.0 ]--
r 143             if ()
--[ 2019.11.02.14.10.27.534.0 ]--
r 143             if (n)
--[ 2019.11.02.14.10.27.623.0 ]--
r 143             if (no)
--[ 2019.11.02.14.10.27.665.0 ]--
r 143             if (nod)
--[ 2019.11.02.14.10.27.883.0 ]--
r 143             if (node)
--[ 2019.11.02.14.10.27.930.0 ]--
r 143             if (node.)
--[ 2019.11.02.14.10.50.962.0 ]--
+ 43         
--[ 2019.11.02.14.10.51.198.0 ]--
+ 43         
--[ 2019.11.02.14.10.51.933.0 ]--
r 44         /
--[ 2019.11.02.14.10.52.080.0 ]--
r 44         //
--[ 2019.11.02.14.10.52.253.0 ]--
r 44         // 
--[ 2019.11.02.14.10.52.593.0 ]--
r 44         // R
--[ 2019.11.02.14.10.52.796.0 ]--
r 44         // Re
--[ 2019.11.02.14.10.53.046.0 ]--
r 44         // Ret
--[ 2019.11.02.14.10.53.187.0 ]--
r 44         // Retu
--[ 2019.11.02.14.10.53.343.0 ]--
r 44         // Retur
--[ 2019.11.02.14.10.53.421.0 ]--
r 44         // Return
--[ 2019.11.02.14.10.53.530.0 ]--
r 44         // Returns
--[ 2019.11.02.14.10.53.671.0 ]--
r 44         // Returns 
--[ 2019.11.02.14.10.53.782.0 ]--
r 44         // Returns t
--[ 2019.11.02.14.10.53.832.0 ]--
r 44         // Returns th
--[ 2019.11.02.14.10.53.894.0 ]--
r 44         // Returns the
--[ 2019.11.02.14.10.53.988.0 ]--
r 44         // Returns the 
--[ 2019.11.02.14.10.54.904.0 ]--
r 44         // Returns the l
--[ 2019.11.02.14.10.55.053.0 ]--
r 44         // Returns the lo
--[ 2019.11.02.14.10.55.147.0 ]--
r 44         // Returns the loc
--[ 2019.11.02.14.10.55.415.0 ]--
r 44         // Returns the loca
--[ 2019.11.02.14.10.55.525.0 ]--
r 44         // Returns the locat
--[ 2019.11.02.14.10.55.572.0 ]--
r 44         // Returns the locati
--[ 2019.11.02.14.10.55.635.0 ]--
r 44         // Returns the locatio
--[ 2019.11.02.14.10.55.728.0 ]--
r 44         // Returns the location
--[ 2019.11.02.14.10.55.838.0 ]--
r 44         // Returns the location 
--[ 2019.11.02.14.10.55.931.0 ]--
r 44         // Returns the location o
--[ 2019.11.02.14.10.56.028.0 ]--
r 44         // Returns the location of
--[ 2019.11.02.14.10.56.153.0 ]--
r 44         // Returns the location of 
--[ 2019.11.02.14.10.56.327.0 ]--
r 44         // Returns the location of t
--[ 2019.11.02.14.10.56.454.0 ]--
r 44         // Returns the location of th
--[ 2019.11.02.14.10.56.517.0 ]--
r 44         // Returns the location of the
--[ 2019.11.02.14.10.56.579.0 ]--
r 44         // Returns the location of the 
--[ 2019.11.02.14.10.56.688.0 ]--
r 44         // Returns the location of the
--[ 2019.11.02.14.10.57.248.0 ]--
r 44         // Returns the location of th
--[ 2019.11.02.14.10.57.288.0 ]--
r 44         // Returns the location of t
--[ 2019.11.02.14.10.58.011.0 ]--
r 44         // Returns the location of th
--[ 2019.11.02.14.10.58.175.0 ]--
r 44         // Returns the location of the
--[ 2019.11.02.14.10.58.221.0 ]--
r 44         // Returns the location of the 
--[ 2019.11.02.14.10.58.464.0 ]--
r 44         // Returns the location of the P
--[ 2019.11.02.14.10.58.605.0 ]--
r 44         // Returns the location of the PF
--[ 2019.11.02.14.10.58.809.0 ]--
r 44         // Returns the location of the PFN
--[ 2019.11.02.14.10.59.108.0 ]--
r 44         // Returns the location of the PFNo
--[ 2019.11.02.14.10.59.209.0 ]--
r 44         // Returns the location of the PFNod
--[ 2019.11.02.14.10.59.466.0 ]--
r 44         // Returns the location of the PFNode
--[ 2019.11.02.14.10.59.511.0 ]--
+ 45         
--[ 2019.11.02.14.11.00.812.0 ]--
r 45         p
--[ 2019.11.02.14.11.00.871.0 ]--
r 45         pu
--[ 2019.11.02.14.11.01.027.0 ]--
r 45         pub
--[ 2019.11.02.14.11.01.261.0 ]--
r 45         publi
--[ 2019.11.02.14.11.01.293.0 ]--
r 45         public
--[ 2019.11.02.14.11.01.433.0 ]--
r 45         public 
--[ 2019.11.02.14.11.04.244.0 ]--
r 45         public C
--[ 2019.11.02.14.11.04.480.0 ]--
r 45         public Co
--[ 2019.11.02.14.11.04.605.0 ]--
r 45         public Coo
--[ 2019.11.02.14.11.04.700.0 ]--
r 45         public Coor
--[ 2019.11.02.14.11.04.884.0 ]--
r 45         public Coord
--[ 2019.11.02.14.11.04.995.0 ]--
r 45         public Coord 
--[ 2019.11.02.14.11.05.180.0 ]--
r 45         public Coord g
--[ 2019.11.02.14.11.05.273.0 ]--
r 45         public Coord ge
--[ 2019.11.02.14.11.05.461.0 ]--
r 45         public Coord get
--[ 2019.11.02.14.11.05.728.0 ]--
r 45         public Coord getL
--[ 2019.11.02.14.11.05.896.0 ]--
r 45         public Coord getLo
--[ 2019.11.02.14.11.05.974.0 ]--
r 45         public Coord getLoc
--[ 2019.11.02.14.11.06.780.0 ]--
r 45         public Coord getLoc()
--[ 2019.11.02.14.11.07.131.0 ]--
r 45         public Coord getLoc() 
--[ 2019.11.02.14.11.07.304.0 ]--
r 45         public Coord getLoc() {}
--[ 2019.11.02.14.11.07.727.0 ]--
+ 45         public Coord getLoc() {
r 46         }
--[ 2019.11.02.14.11.07.751.0 ]--
+ 46             
--[ 2019.11.02.14.11.07.911.0 ]--
+ 46             
--[ 2019.11.02.14.11.08.494.0 ]--
- 46
--[ 2019.11.02.14.11.09.504.0 ]--
r 46             r
--[ 2019.11.02.14.11.09.566.0 ]--
r 46             re
--[ 2019.11.02.14.11.09.786.0 ]--
r 46             ret
--[ 2019.11.02.14.11.09.833.0 ]--
r 46             retu
--[ 2019.11.02.14.11.09.977.0 ]--
r 46             retur
--[ 2019.11.02.14.11.10.055.0 ]--
r 46             return
--[ 2019.11.02.14.11.10.180.0 ]--
r 46             return 
--[ 2019.11.02.14.11.10.699.0 ]--
r 46             return t
--[ 2019.11.02.14.11.11.262.0 ]--
r 46             return 
--[ 2019.11.02.14.11.11.507.0 ]--
r 46             return l
--[ 2019.11.02.14.11.11.694.0 ]--
r 46             return lo
--[ 2019.11.02.14.11.11.788.0 ]--
r 46             return loc
--[ 2019.11.02.14.11.11.850.0 ]--
r 46             return loc;
--[ 2019.11.02.14.11.24.607.0 ]--
r 148             if (node)
--[ 2019.11.02.14.11.25.031.0 ]--
r 148             if (node.)
--[ 2019.11.02.14.11.25.611.0 ]--
r 148             if (node.g)
--[ 2019.11.02.14.11.25.704.0 ]--
r 148             if (node.ge)
--[ 2019.11.02.14.11.25.924.0 ]--
r 148             if (node.get)
--[ 2019.11.02.14.11.26.230.0 ]--
r 148             if (node.getL)
--[ 2019.11.02.14.11.26.564.0 ]--
r 148             if (node.getLo)
--[ 2019.11.02.14.11.26.658.0 ]--
r 148             if (node.getLoc)
--[ 2019.11.02.14.11.27.020.0 ]--
r 148             if (node.getLoc())
--[ 2019.11.02.14.11.27.711.0 ]--
r 148             if (node.getLoc() )
--[ 2019.11.02.14.11.27.801.0 ]--
r 148             if (node.getLoc() =)
--[ 2019.11.02.14.11.27.966.0 ]--
r 148             if (node.getLoc() ==)
--[ 2019.11.02.14.11.28.055.0 ]--
r 148             if (node.getLoc() == )
--[ 2019.11.02.14.11.29.574.0 ]--
r 148             if (node.getLoc() == e)
--[ 2019.11.02.14.11.30.019.0 ]--
r 148             if (node.getLoc() == )
--[ 2019.11.02.14.11.31.872.0 ]--
r 148             if (node.getLoc() == g)
--[ 2019.11.02.14.11.31.942.0 ]--
r 148             if (node.getLoc() == ge)
--[ 2019.11.02.14.11.32.139.0 ]--
r 148             if (node.getLoc() == get)
--[ 2019.11.02.14.11.32.558.0 ]--
r 148             if (node.getLoc() == getE)
--[ 2019.11.02.14.11.33.113.0 ]--
r 148             if (node.getLoc() == get)
--[ 2019.11.02.14.11.33.419.0 ]--
r 148             if (node.getLoc() == getP)
--[ 2019.11.02.14.11.33.622.0 ]--
r 148             if (node.getLoc() == getPa)
--[ 2019.11.02.14.11.33.673.0 ]--
r 148             if (node.getLoc() == getPat)
--[ 2019.11.02.14.11.33.798.0 ]--
r 148             if (node.getLoc() == getPath)
--[ 2019.11.02.14.11.34.042.0 ]--
r 148             if (node.getLoc() == getPathE)
--[ 2019.11.02.14.11.34.387.0 ]--
r 148             if (node.getLoc() == getPathEn)
--[ 2019.11.02.14.11.34.536.0 ]--
r 148             if (node.getLoc() == getPathEnd)
--[ 2019.11.02.14.11.34.930.0 ]--
r 148             if (node.getLoc() == getPathEnd())
--[ 2019.11.02.14.11.41.474.0 ]--
r 148             if (node.getLoc() == getPathEnd()) 
--[ 2019.11.02.14.11.41.605.0 ]--
r 148             if (node.getLoc() == getPathEnd()) {
--[ 2019.11.02.14.11.41.808.0 ]--
+ 149 
+ 150 }
--[ 2019.11.02.14.11.41.871.0 ]--
r 150             }
--[ 2019.11.02.14.11.41.918.0 ]--
r 149                 
--[ 2019.11.02.14.11.44.089.0 ]--
r 149                 r
--[ 2019.11.02.14.11.44.195.0 ]--
r 149                 re
--[ 2019.11.02.14.11.44.383.0 ]--
r 149                 ret
--[ 2019.11.02.14.11.44.419.0 ]--
r 149                 retu
--[ 2019.11.02.14.11.44.591.0 ]--
r 149                 retur
--[ 2019.11.02.14.11.44.671.0 ]--
r 149                 return
--[ 2019.11.02.14.11.44.734.0 ]--
r 149                 return 
--[ 2019.11.02.14.11.45.501.0 ]--
r 149                 return
--[ 2019.11.02.14.11.45.798.0 ]--
r 149                 retur
--[ 2019.11.02.14.11.45.876.0 ]--
r 149                 retu
--[ 2019.11.02.14.11.46.064.0 ]--
r 149                 ret
--[ 2019.11.02.14.11.46.229.0 ]--
r 149                 re
--[ 2019.11.02.14.11.46.466.0 ]--
r 149                 r
--[ 2019.11.02.14.11.46.595.0 ]--
r 149                 
--[ 2019.11.02.14.11.49.438.0 ]--
r 149                 r
--[ 2019.11.02.14.11.49.533.0 ]--
r 149                 re
--[ 2019.11.02.14.11.49.721.0 ]--
r 149                 ret
--[ 2019.11.02.14.11.49.803.0 ]--
r 149                 retu
--[ 2019.11.02.14.11.49.913.0 ]--
r 149                 retur
--[ 2019.11.02.14.11.49.991.0 ]--
r 149                 return
--[ 2019.11.02.14.11.50.100.0 ]--
r 149                 return 
--[ 2019.11.02.14.11.50.178.0 ]--
r 149                 return t
--[ 2019.11.02.14.11.50.428.0 ]--
r 149                 return tr
--[ 2019.11.02.14.11.50.490.0 ]--
r 149                 return tru
--[ 2019.11.02.14.11.50.568.0 ]--
r 149                 return true
--[ 2019.11.02.14.11.50.631.0 ]--
r 149                 return true;
--[ 2019.11.02.14.11.52.634.0 ]--
+ 152         
--[ 2019.11.02.14.11.53.087.0 ]--
r 152         r
--[ 2019.11.02.14.11.53.165.0 ]--
r 152         re
--[ 2019.11.02.14.11.53.323.0 ]--
r 152         ret
--[ 2019.11.02.14.11.53.403.0 ]--
r 152         retu
--[ 2019.11.02.14.11.53.513.0 ]--
r 152         retur
--[ 2019.11.02.14.11.53.606.0 ]--
r 152         return
--[ 2019.11.02.14.11.53.669.0 ]--
r 152         return 
--[ 2019.11.02.14.11.53.763.0 ]--
r 152         return f
--[ 2019.11.02.14.11.53.872.0 ]--
r 152         return fa
--[ 2019.11.02.14.11.53.934.0 ]--
r 152         return fal
--[ 2019.11.02.14.11.54.091.0 ]--
r 152         return fals
--[ 2019.11.02.14.11.54.153.0 ]--
r 152         return false
--[ 2019.11.02.14.11.54.184.0 ]--
r 152         return false;
--[ 2019.11.02.14.13.00.784.0 ]--
r 10 
r 43 
--[ 2019.11.02.14.42.22.602.0 ]--
+ 153         
--[ 2019.11.02.14.42.25.449.0 ]--
- 153
--[ 2019.11.02.14.50.32.666.0 ]--
r 41             return ;
--[ 2019.11.02.14.50.33.692.0 ]--
r 41             return t;
--[ 2019.11.02.14.50.33.811.0 ]--
r 41             return te;
--[ 2019.11.02.14.50.33.936.0 ]--
r 41             return ter;
--[ 2019.11.02.14.50.34.140.0 ]--
r 41             return terr;
--[ 2019.11.02.14.50.34.204.0 ]--
r 41             return terra;
--[ 2019.11.02.14.50.34.283.0 ]--
r 41             return terrai;
--[ 2019.11.02.14.50.34.329.0 ]--
r 41             return terrain;
--[ 2019.11.02.14.50.34.501.0 ]--
r 41             return terrain.;
--[ 2019.11.02.14.50.35.190.0 ]--
r 41             return terrain.g;
--[ 2019.11.02.14.50.35.281.0 ]--
r 41             return terrain.ge;
--[ 2019.11.02.14.50.35.469.0 ]--
r 41             return terrain.get;
--[ 2019.11.02.14.50.35.749.0 ]--
r 41             return terrain.getH;
--[ 2019.11.02.14.50.35.859.0 ]--
r 41             return terrain.getHe;
--[ 2019.11.02.14.50.35.969.0 ]--
r 41             return terrain.getHei;
--[ 2019.11.02.14.50.36.047.0 ]--
r 41             return terrain.getHeig;
--[ 2019.11.02.14.50.36.125.0 ]--
r 41             return terrain.getHeigh;
--[ 2019.11.02.14.50.36.281.0 ]--
r 41             return terrain.getHeight;
--[ 2019.11.02.14.50.36.548.0 ]--
r 41             return terrain.getHeight();
--[ 2019.11.02.14.50.36.734.0 ]--
r 41             return terrain.getHeight(l);
--[ 2019.11.02.14.50.36.939.0 ]--
r 41             return terrain.getHeight(lo);
--[ 2019.11.02.14.50.37.023.0 ]--
r 41             return terrain.getHeight(loc);
--[ 2019.11.02.14.52.12.469.0 ]--
r 41             return fterrain.getHeight(loc);
--[ 2019.11.02.14.52.12.893.0 ]--
r 41             return terrain.getHeight(loc);
--[ 2019.11.02.14.52.13.277.0 ]--
r 41             return fterrain.getHeight(loc);
--[ 2019.11.02.14.52.13.563.0 ]--
r 41             return frterrain.getHeight(loc);
--[ 2019.11.02.14.52.13.657.0 ]--
r 41             return froterrain.getHeight(loc);
--[ 2019.11.02.14.52.13.720.0 ]--
r 41             return fronterrain.getHeight(loc);
--[ 2019.11.02.14.52.13.814.0 ]--
r 41             return frontterrain.getHeight(loc);
--[ 2019.11.02.14.52.14.049.0 ]--
r 41             return front.terrain.getHeight(loc);
--[ 2019.11.02.14.52.14.397.0 ]--
r 41             return frontterrain.getHeight(loc);
--[ 2019.11.02.14.52.14.574.0 ]--
r 41             return fronterrain.getHeight(loc);
--[ 2019.11.02.14.52.14.755.0 ]--
r 41             return froterrain.getHeight(loc);
--[ 2019.11.02.14.52.14.914.0 ]--
r 41             return frterrain.getHeight(loc);
--[ 2019.11.02.14.52.15.080.0 ]--
r 41             return fterrain.getHeight(loc);
--[ 2019.11.02.14.52.15.205.0 ]--
r 41             return terrain.getHeight(loc);
--[ 2019.11.02.14.52.15.471.0 ]--
r 41             return fterrain.getHeight(loc);
--[ 2019.11.02.14.52.15.694.0 ]--
r 41             return frterrain.getHeight(loc);
--[ 2019.11.02.14.52.15.774.0 ]--
r 41             return froterrain.getHeight(loc);
--[ 2019.11.02.14.52.15.852.0 ]--
r 41             return fromterrain.getHeight(loc);
--[ 2019.11.02.14.52.16.057.0 ]--
r 41             return fromNterrain.getHeight(loc);
--[ 2019.11.02.14.52.16.208.0 ]--
r 41             return fromNoterrain.getHeight(loc);
--[ 2019.11.02.14.52.16.318.0 ]--
r 41             return fromNodterrain.getHeight(loc);
--[ 2019.11.02.14.52.16.475.0 ]--
r 41             return fromNodeterrain.getHeight(loc);
--[ 2019.11.02.14.52.16.574.0 ]--
r 41             return fromNode.terrain.getHeight(loc);
--[ 2019.11.02.14.52.16.966.0 ]--
r 41             return fromNode.gterrain.getHeight(loc);
--[ 2019.11.02.14.52.17.054.0 ]--
r 41             return fromNode.geterrain.getHeight(loc);
--[ 2019.11.02.14.52.17.193.0 ]--
r 41             return fromNode.getterrain.getHeight(loc);
--[ 2019.11.02.14.52.17.442.0 ]--
r 41             return fromNode.getCterrain.getHeight(loc);
--[ 2019.11.02.14.52.17.609.0 ]--
r 41             return fromNode.getCoterrain.getHeight(loc);
--[ 2019.11.02.14.52.17.711.0 ]--
r 41             return fromNode.getCosterrain.getHeight(loc);
--[ 2019.11.02.14.52.17.798.0 ]--
r 41             return fromNode.getCostterrain.getHeight(loc);
--[ 2019.11.02.14.52.18.072.0 ]--
r 41             return fromNode.getCost(terrain.getHeight(loc);
--[ 2019.11.02.14.52.18.113.0 ]--
r 41             return fromNode.getCost()terrain.getHeight(loc);
--[ 2019.11.02.14.52.18.474.0 ]--
r 41             return fromNode.getCost() terrain.getHeight(loc);
--[ 2019.11.02.14.52.18.662.0 ]--
r 41             return fromNode.getCost() +terrain.getHeight(loc);
--[ 2019.11.02.14.52.18.725.0 ]--
r 41             return fromNode.getCost() + terrain.getHeight(loc);
--[ 2019.11.02.14.52.38.576.0 ]--
+ 41             
--[ 2019.11.02.14.52.38.810.0 ]--
r 41             j
--[ 2019.11.02.14.52.38.918.0 ]--
r 41             ji
--[ 2019.11.02.14.52.39.247.0 ]--
r 41             j
--[ 2019.11.02.14.52.39.388.0 ]--
r 41             
--[ 2019.11.02.14.52.39.639.0 ]--
r 41             i
--[ 2019.11.02.14.52.39.752.0 ]--
r 41             if
--[ 2019.11.02.14.52.39.830.0 ]--
r 41             if 
--[ 2019.11.02.14.52.39.970.0 ]--
r 41             if f
--[ 2019.11.02.14.52.40.206.0 ]--
r 41             if fr
--[ 2019.11.02.14.52.40.255.0 ]--
r 41             if fro
--[ 2019.11.02.14.52.40.302.0 ]--
r 41             if from
--[ 2019.11.02.14.52.40.537.0 ]--
r 41             if fromn
--[ 2019.11.02.14.52.40.616.0 ]--
r 41             if fromno
--[ 2019.11.02.14.52.40.772.0 ]--
r 41             if fromnod
--[ 2019.11.02.14.52.40.961.0 ]--
r 41             if fromnode
--[ 2019.11.02.14.52.41.039.0 ]--
r 41             if fromnode 
--[ 2019.11.02.14.52.41.446.0 ]--
r 41             if fromnode
--[ 2019.11.02.14.52.41.613.0 ]--
r 41             if fromnod
--[ 2019.11.02.14.52.41.794.0 ]--
r 41             if fromno
--[ 2019.11.02.14.52.41.950.0 ]--
r 41             if fromn
--[ 2019.11.02.14.52.42.106.0 ]--
r 41             if from
--[ 2019.11.02.14.52.42.373.0 ]--
r 41             if fromN
--[ 2019.11.02.14.52.42.593.0 ]--
r 41             if fromNo
--[ 2019.11.02.14.52.42.666.0 ]--
r 41             if fromNod
--[ 2019.11.02.14.52.42.855.0 ]--
r 41             if fromNode
--[ 2019.11.02.14.52.42.888.0 ]--
r 41             if fromNode 
--[ 2019.11.02.14.52.43.013.0 ]--
r 41             if fromNode =
--[ 2019.11.02.14.52.43.185.0 ]--
r 41             if fromNode ==
--[ 2019.11.02.14.52.43.278.0 ]--
r 41             if fromNode == 
--[ 2019.11.02.14.52.43.372.0 ]--
r 41             if fromNode == n
--[ 2019.11.02.14.52.43.671.0 ]--
r 41             if fromNode == nu
--[ 2019.11.02.14.52.43.797.0 ]--
r 41             if fromNode == nul
--[ 2019.11.02.14.52.43.954.0 ]--
r 41             if fromNode == null
--[ 2019.11.02.14.52.44.039.0 ]--
r 41             if fromNode == null 
--[ 2019.11.02.14.52.44.846.0 ]--
r 41             if fromNode == null
--[ 2019.11.02.14.52.45.316.0 ]--
r 41             if fromNode == nul
--[ 2019.11.02.14.52.45.347.0 ]--
r 41             if fromNode == nu
--[ 2019.11.02.14.52.45.381.0 ]--
r 41             if fromNode == n
--[ 2019.11.02.14.52.45.412.0 ]--
r 41             if fromNode == 
--[ 2019.11.02.14.52.45.444.0 ]--
r 41             if fromNode ==
--[ 2019.11.02.14.52.45.475.0 ]--
r 41             if fromNode =
--[ 2019.11.02.14.52.45.522.0 ]--
r 41             if fromNode 
--[ 2019.11.02.14.52.45.553.0 ]--
r 41             if fromNode
--[ 2019.11.02.14.52.45.584.0 ]--
r 41             if fromNod
--[ 2019.11.02.14.52.45.616.0 ]--
r 41             if fromNo
--[ 2019.11.02.14.52.45.647.0 ]--
r 41             if fromN
--[ 2019.11.02.14.52.45.678.0 ]--
r 41             if from
--[ 2019.11.02.14.52.45.709.0 ]--
r 41             if fro
--[ 2019.11.02.14.52.45.741.0 ]--
r 41             if fr
--[ 2019.11.02.14.52.45.865.0 ]--
r 41             if f
--[ 2019.11.02.14.52.46.086.0 ]--
r 41             if 
--[ 2019.11.02.14.52.46.743.0 ]--
r 41             if ()
--[ 2019.11.02.14.52.46.805.0 ]--
r 41             if (f)
--[ 2019.11.02.14.52.47.033.0 ]--
r 41             if (fr)
--[ 2019.11.02.14.52.47.085.0 ]--
r 41             if (fro)
--[ 2019.11.02.14.52.47.139.0 ]--
r 41             if (from)
--[ 2019.11.02.14.52.47.339.0 ]--
r 41             if (fromN)
--[ 2019.11.02.14.52.47.436.0 ]--
r 41             if (fromNo)
--[ 2019.11.02.14.52.47.563.0 ]--
r 41             if (fromNod)
--[ 2019.11.02.14.52.47.782.0 ]--
r 41             if (fromNode)
--[ 2019.11.02.14.52.47.864.0 ]--
r 41             if (fromNode )
--[ 2019.11.02.14.52.48.002.0 ]--
r 41             if (fromNode =)
--[ 2019.11.02.14.52.48.174.0 ]--
r 41             if (fromNode ==)
--[ 2019.11.02.14.52.48.299.0 ]--
r 41             if (fromNode == )
--[ 2019.11.02.14.52.48.392.0 ]--
r 41             if (fromNode == n)
--[ 2019.11.02.14.52.48.612.0 ]--
r 41             if (fromNode == nu)
--[ 2019.11.02.14.52.48.810.0 ]--
r 41             if (fromNode == nul)
--[ 2019.11.02.14.52.48.969.0 ]--
r 41             if (fromNode == null)
--[ 2019.11.02.14.52.49.285.0 ]--
r 41             if (fromNode == null) 
--[ 2019.11.02.14.52.49.480.0 ]--
r 41             if (fromNode == null) r
--[ 2019.11.02.14.52.49.590.0 ]--
r 41             if (fromNode == null) re
--[ 2019.11.02.14.52.49.746.0 ]--
r 41             if (fromNode == null) ret
--[ 2019.11.02.14.52.49.840.0 ]--
r 41             if (fromNode == null) retu
--[ 2019.11.02.14.52.49.902.0 ]--
r 41             if (fromNode == null) retur
--[ 2019.11.02.14.52.50.027.0 ]--
r 41             if (fromNode == null) return
--[ 2019.11.02.14.52.50.090.0 ]--
r 41             if (fromNode == null) return 
--[ 2019.11.02.14.52.50.183.0 ]--
r 41             if (fromNode == null) return t
--[ 2019.11.02.14.52.50.386.0 ]--
r 41             if (fromNode == null) return te
--[ 2019.11.02.14.52.50.599.0 ]--
r 41             if (fromNode == null) return ter
--[ 2019.11.02.14.52.50.738.0 ]--
r 41             if (fromNode == null) return terr
--[ 2019.11.02.14.52.50.800.0 ]--
r 41             if (fromNode == null) return terra
--[ 2019.11.02.14.52.50.894.0 ]--
r 41             if (fromNode == null) return terrai
--[ 2019.11.02.14.52.50.941.0 ]--
r 41             if (fromNode == null) return terrain
--[ 2019.11.02.14.52.51.081.0 ]--
r 41             if (fromNode == null) return terrain.
--[ 2019.11.02.14.52.51.222.0 ]--
r 41             if (fromNode == null) return terrain.g
--[ 2019.11.02.14.52.51.269.0 ]--
r 41             if (fromNode == null) return terrain.ge
--[ 2019.11.02.14.52.51.441.0 ]--
r 41             if (fromNode == null) return terrain.get
--[ 2019.11.02.14.52.51.660.0 ]--
r 41             if (fromNode == null) return terrain.getH
--[ 2019.11.02.14.52.51.793.0 ]--
r 41             if (fromNode == null) return terrain.getHe
--[ 2019.11.02.14.52.51.856.0 ]--
r 41             if (fromNode == null) return terrain.getHei
--[ 2019.11.02.14.52.51.934.0 ]--
r 41             if (fromNode == null) return terrain.getHeig
--[ 2019.11.02.14.52.52.059.0 ]--
r 41             if (fromNode == null) return terrain.getHeigh
--[ 2019.11.02.14.52.52.137.0 ]--
r 41             if (fromNode == null) return terrain.getHeight
--[ 2019.11.02.14.52.52.748.0 ]--
r 41             if (fromNode == null) return terrain.getHeight()
--[ 2019.11.02.14.52.53.261.0 ]--
r 41             if (fromNode == null) return terrain.getHeight(l)
--[ 2019.11.02.14.52.53.437.0 ]--
r 41             if (fromNode == null) return terrain.getHeight(lo)
--[ 2019.11.02.14.52.53.485.0 ]--
r 41             if (fromNode == null) return terrain.getHeight(loc)
--[ 2019.11.02.14.52.53.869.0 ]--
r 41             if (fromNode == null) return terrain.getHeight(loc);
--[ 2019.11.02.14.52.56.194.0 ]--
+ 42             
--[ 2019.11.02.14.52.56.888.0 ]--
r 42             e
--[ 2019.11.02.14.52.57.021.0 ]--
r 42             el
--[ 2019.11.02.14.52.57.134.0 ]--
r 42             els
--[ 2019.11.02.14.52.57.204.0 ]--
r 42             else
--[ 2019.11.02.14.52.57.286.0 ]--
r 42             else 
--[ 2019.11.02.14.52.59.133.0 ]--
- 42
r 42             else return fromNode.getCost() + terrain.getHeight(loc);
--[ 2019.11.02.14.53.38.180.0 ]--
r 41             if (fromNode == null) return 0;
--[ 2019.11.02.14.53.54.923.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.02.14.54.59.427.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.02.14.59.54.181.0 ]--
+ 41             
--[ 2019.11.02.14.59.54.343.0 ]--
+ 41             
--[ 2019.11.02.14.59.54.501.0 ]--
+ 41             
--[ 2019.11.02.14.59.55.837.0 ]--
r 42             /
--[ 2019.11.02.14.59.56.073.0 ]--
r 42             // 
--[ 2019.11.02.14.59.56.151.0 ]--
r 42             // u
--[ 2019.11.02.14.59.56.213.0 ]--
r 42             // us
--[ 2019.11.02.14.59.56.292.0 ]--
r 42             // use
--[ 2019.11.02.14.59.56.385.0 ]--
r 42             // use 
--[ 2019.11.02.14.59.56.731.0 ]--
r 42             // use T
--[ 2019.11.02.14.59.57.134.0 ]--
r 42             // use 
--[ 2019.11.02.14.59.58.013.0 ]--
r 42             // use t
--[ 2019.11.02.14.59.58.312.0 ]--
r 42             // use te
--[ 2019.11.02.14.59.58.383.0 ]--
r 42             // use ter
--[ 2019.11.02.14.59.58.588.0 ]--
r 42             // use terr
--[ 2019.11.02.14.59.58.841.0 ]--
r 42             // use terra
--[ 2019.11.02.14.59.58.919.0 ]--
r 42             // use terrai
--[ 2019.11.02.14.59.58.990.0 ]--
r 42             // use terrain
--[ 2019.11.02.14.59.59.195.0 ]--
r 42             // use terrain.
--[ 2019.11.02.14.59.59.460.0 ]--
r 42             // use terrain.c
--[ 2019.11.02.14.59.59.521.0 ]--
r 42             // use terrain.co
--[ 2019.11.02.14.59.59.590.0 ]--
r 42             // use terrain.com
--[ 2019.11.02.14.59.59.747.0 ]--
r 42             // use terrain.comp
--[ 2019.11.02.14.59.59.878.0 ]--
r 42             // use terrain.compu
--[ 2019.11.02.14.59.59.985.0 ]--
r 42             // use terrain.comput
--[ 2019.11.02.15.00.00.095.0 ]--
r 42             // use terrain.compute
--[ 2019.11.02.15.00.00.580.0 ]--
r 42             // use terrain.computeT
--[ 2019.11.02.15.00.00.769.0 ]--
r 42             // use terrain.computeTr
--[ 2019.11.02.15.00.00.863.0 ]--
r 42             // use terrain.computeTra
--[ 2019.11.02.15.00.01.003.0 ]--
r 42             // use terrain.computeTrav
--[ 2019.11.02.15.00.01.130.0 ]--
r 42             // use terrain.computeTrave
--[ 2019.11.02.15.00.01.348.0 ]--
r 42             // use terrain.computeTravel
--[ 2019.11.02.15.00.01.724.0 ]--
r 42             // use terrain.computeTravelC
--[ 2019.11.02.15.00.02.339.0 ]--
r 42             // use terrain.computeTravelCo
--[ 2019.11.02.15.00.02.506.0 ]--
r 42             // use terrain.computeTravelCos
--[ 2019.11.02.15.00.02.569.0 ]--
r 42             // use terrain.computeTravelCost
--[ 2019.11.02.15.00.03.128.0 ]--
r 42             // use terrain.computeTravelCost(
--[ 2019.11.02.15.00.03.178.0 ]--
r 42             // use terrain.computeTravelCost()
--[ 2019.11.02.15.01.31.963.0 ]--
r 42             // use terrain.computeTravelCost() 
--[ 2019.11.02.15.01.32.190.0 ]--
r 42             // use terrain.computeTravelCost() t
--[ 2019.11.02.15.01.32.279.0 ]--
r 42             // use terrain.computeTravelCost() to
--[ 2019.11.02.15.01.32.349.0 ]--
r 42             // use terrain.computeTravelCost() to 
--[ 2019.11.02.15.01.32.800.0 ]--
r 42             // use terrain.computeTravelCost() to g
--[ 2019.11.02.15.01.32.894.0 ]--
r 42             // use terrain.computeTravelCost() to ge
--[ 2019.11.02.15.01.33.080.0 ]--
r 42             // use terrain.computeTravelCost() to get
--[ 2019.11.02.15.01.33.142.0 ]--
r 42             // use terrain.computeTravelCost() to get 
--[ 2019.11.02.15.01.33.267.0 ]--
r 42             // use terrain.computeTravelCost() to get t
--[ 2019.11.02.15.01.33.345.0 ]--
r 42             // use terrain.computeTravelCost() to get the
--[ 2019.11.02.15.01.33.486.0 ]--
r 42             // use terrain.computeTravelCost() to get the 
--[ 2019.11.02.15.01.33.706.0 ]--
r 42             // use terrain.computeTravelCost() to get the c
--[ 2019.11.02.15.01.33.820.0 ]--
r 42             // use terrain.computeTravelCost() to get the co
--[ 2019.11.02.15.01.33.976.0 ]--
r 42             // use terrain.computeTravelCost() to get the cos
--[ 2019.11.02.15.01.34.088.0 ]--
r 42             // use terrain.computeTravelCost() to get the cost
--[ 2019.11.02.15.01.34.189.0 ]--
r 42             // use terrain.computeTravelCost() to get the cost 
--[ 2019.11.02.15.01.34.361.0 ]--
r 42             // use terrain.computeTravelCost() to get the cost o
--[ 2019.11.02.15.01.34.455.0 ]--
r 42             // use terrain.computeTravelCost() to get the cost of
--[ 2019.11.02.15.01.34.564.0 ]--
r 42             // use terrain.computeTravelCost() to get the cost of 
--[ 2019.11.02.15.01.34.720.0 ]--
r 42             // use terrain.computeTravelCost() to get the cost of t
--[ 2019.11.02.15.01.34.798.0 ]--
r 42             // use terrain.computeTravelCost() to get the cost of th
--[ 2019.11.02.15.01.34.829.0 ]--
r 42             // use terrain.computeTravelCost() to get the cost of the
--[ 2019.11.02.15.01.34.970.0 ]--
r 42             // use terrain.computeTravelCost() to get the cost of the 
--[ 2019.11.02.15.01.35.347.0 ]--
r 42             // use terrain.computeTravelCost() to get the cost of the c
--[ 2019.11.02.15.01.35.534.0 ]--
r 42             // use terrain.computeTravelCost() to get the cost of the cu
--[ 2019.11.02.15.01.35.693.0 ]--
r 42             // use terrain.computeTravelCost() to get the cost of the cur
--[ 2019.11.02.15.01.35.893.0 ]--
r 42             // use terrain.computeTravelCost() to get the cost of the curr
--[ 2019.11.02.15.01.35.940.0 ]--
r 42             // use terrain.computeTravelCost() to get the cost of the curre
--[ 2019.11.02.15.01.36.049.0 ]--
r 42             // use terrain.computeTravelCost() to get the cost of the curren
--[ 2019.11.02.15.01.36.096.0 ]--
r 42             // use terrain.computeTravelCost() to get the cost of the current
--[ 2019.11.02.15.01.36.205.0 ]--
r 42             // use terrain.computeTravelCost() to get the cost of the current 
--[ 2019.11.02.15.01.36.394.0 ]--
r 42             // use terrain.computeTravelCost() to get the cost of the current n
--[ 2019.11.02.15.01.36.441.0 ]--
r 42             // use terrain.computeTravelCost() to get the cost of the current no
--[ 2019.11.02.15.01.36.597.0 ]--
r 42             // use terrain.computeTravelCost() to get the cost of the current nod
--[ 2019.11.02.15.01.36.817.0 ]--
r 42             // use terrain.computeTravelCost() to get the cost of the current node
--[ 2019.11.02.15.01.42.611.0 ]--
+ 43             
--[ 2019.11.02.15.01.46.189.0 ]--
r 45             /if (fromNode == null) return 0;
--[ 2019.11.02.15.01.46.400.0 ]--
r 45             //if (fromNode == null) return 0;
--[ 2019.11.02.15.01.47.250.0 ]--
r 46             /else return fromNode.getCost() + terrain.getHeight(loc);
--[ 2019.11.02.15.01.47.422.0 ]--
r 46             //else return fromNode.getCost() + terrain.getHeight(loc);
--[ 2019.11.02.15.01.49.274.0 ]--
+ 43             
--[ 2019.11.02.15.01.50.138.0 ]--
r 44             i
--[ 2019.11.02.15.01.50.184.0 ]--
r 44             if
--[ 2019.11.02.15.01.50.247.0 ]--
r 44             if 
--[ 2019.11.02.15.01.50.451.0 ]--
r 44             if ()
--[ 2019.11.02.15.01.50.616.0 ]--
r 44             if (f)
--[ 2019.11.02.15.01.50.835.0 ]--
r 44             if (fr)
--[ 2019.11.02.15.01.50.900.0 ]--
r 44             if (fro)
--[ 2019.11.02.15.01.50.946.0 ]--
r 44             if (from)
--[ 2019.11.02.15.01.51.166.0 ]--
r 44             if (fromN)
--[ 2019.11.02.15.01.51.246.0 ]--
r 44             if (fromNo)
--[ 2019.11.02.15.01.51.513.0 ]--
r 44             if (fromNod)
--[ 2019.11.02.15.01.51.821.0 ]--
r 44             if (fromNode)
--[ 2019.11.02.15.01.51.900.0 ]--
r 44             if (fromNode )
--[ 2019.11.02.15.01.52.009.0 ]--
r 44             if (fromNode =)
--[ 2019.11.02.15.01.52.150.0 ]--
r 44             if (fromNode ==)
--[ 2019.11.02.15.01.52.260.0 ]--
r 44             if (fromNode == )
--[ 2019.11.02.15.01.52.365.0 ]--
r 44             if (fromNode == n)
--[ 2019.11.02.15.01.52.616.0 ]--
r 44             if (fromNode == nu)
--[ 2019.11.02.15.01.52.880.0 ]--
r 44             if (fromNode == nul)
--[ 2019.11.02.15.01.52.958.0 ]--
r 44             if (fromNode == null)
--[ 2019.11.02.15.01.53.270.0 ]--
r 44             if (fromNode == null) 
--[ 2019.11.02.15.01.53.537.0 ]--
r 44             if (fromNode == null) r
--[ 2019.11.02.15.01.53.633.0 ]--
r 44             if (fromNode == null) re
--[ 2019.11.02.15.01.53.805.0 ]--
r 44             if (fromNode == null) ret
--[ 2019.11.02.15.01.53.868.0 ]--
r 44             if (fromNode == null) retu
--[ 2019.11.02.15.01.54.008.0 ]--
r 44             if (fromNode == null) retur
--[ 2019.11.02.15.01.54.055.0 ]--
r 44             if (fromNode == null) return
--[ 2019.11.02.15.01.54.196.0 ]--
r 44             if (fromNode == null) return 
--[ 2019.11.02.15.01.54.274.0 ]--
r 44             if (fromNode == null) return 0
--[ 2019.11.02.15.01.54.603.0 ]--
r 44             if (fromNode == null) return 0;
--[ 2019.11.02.15.01.57.872.0 ]--
+ 45             
--[ 2019.11.02.15.01.58.303.0 ]--
r 45             e
--[ 2019.11.02.15.01.58.444.0 ]--
r 45             el
--[ 2019.11.02.15.01.58.555.0 ]--
r 45             els
--[ 2019.11.02.15.01.58.634.0 ]--
r 45             else
--[ 2019.11.02.15.01.58.712.0 ]--
r 45             else 
--[ 2019.11.02.15.01.58.884.0 ]--
r 45             else r
--[ 2019.11.02.15.01.58.946.0 ]--
r 45             else re
--[ 2019.11.02.15.01.59.186.0 ]--
r 45             else ret
--[ 2019.11.02.15.01.59.268.0 ]--
r 45             else retu
--[ 2019.11.02.15.01.59.387.0 ]--
r 45             else retur
--[ 2019.11.02.15.01.59.458.0 ]--
r 45             else return
--[ 2019.11.02.15.01.59.715.0 ]--
r 45             else return 
--[ 2019.11.02.15.02.00.486.0 ]--
r 45             else return f
--[ 2019.11.02.15.02.01.001.0 ]--
r 45             else return 
--[ 2019.11.02.15.02.04.848.0 ]--
r 45             else return t
--[ 2019.11.02.15.02.05.070.0 ]--
r 45             else return te
--[ 2019.11.02.15.02.05.116.0 ]--
r 45             else return ter
--[ 2019.11.02.15.02.05.336.0 ]--
r 45             else return terr
--[ 2019.11.02.15.02.05.380.0 ]--
r 45             else return terra
--[ 2019.11.02.15.02.05.427.0 ]--
r 45             else return terrai
--[ 2019.11.02.15.02.05.489.0 ]--
r 45             else return terrain
--[ 2019.11.02.15.02.05.694.0 ]--
r 45             else return terrain.
--[ 2019.11.02.15.02.05.884.0 ]--
r 45             else return terrain.c
--[ 2019.11.02.15.02.05.994.0 ]--
r 45             else return terrain.co
--[ 2019.11.02.15.02.06.087.0 ]--
r 45             else return terrain.com
--[ 2019.11.02.15.02.06.197.0 ]--
r 45             else return terrain.comp
--[ 2019.11.02.15.02.06.369.0 ]--
r 45             else return terrain.compu
--[ 2019.11.02.15.02.06.525.0 ]--
r 45             else return terrain.computa
--[ 2019.11.02.15.02.06.587.0 ]--
r 45             else return terrain.computae
--[ 2019.11.02.15.02.06.932.0 ]--
r 45             else return terrain.computa
--[ 2019.11.02.15.02.07.105.0 ]--
r 45             else return terrain.comput
--[ 2019.11.02.15.02.07.922.0 ]--
r 45             else return terrain.compute
--[ 2019.11.02.15.02.08.322.0 ]--
r 45             else return terrain.computeT
--[ 2019.11.02.15.02.08.563.0 ]--
r 45             else return terrain.computeTr
--[ 2019.11.02.15.02.08.626.0 ]--
r 45             else return terrain.computeTra
--[ 2019.11.02.15.02.08.847.0 ]--
r 45             else return terrain.computeTrav
--[ 2019.11.02.15.02.08.940.0 ]--
r 45             else return terrain.computeTrave
--[ 2019.11.02.15.02.09.050.0 ]--
r 45             else return terrain.computeTravel
--[ 2019.11.02.15.02.09.269.0 ]--
r 45             else return terrain.computeTravelC
--[ 2019.11.02.15.02.09.572.0 ]--
r 45             else return terrain.computeTravelCo
--[ 2019.11.02.15.02.09.666.0 ]--
r 45             else return terrain.computeTravelCos
--[ 2019.11.02.15.02.09.994.0 ]--
r 45             else return terrain.computeTravelCost
--[ 2019.11.02.15.02.13.146.0 ]--
r 45             else return terrain.computeTravelCost*()
--[ 2019.11.02.15.02.13.778.0 ]--
r 45             else return terrain.computeTravelCost*
--[ 2019.11.02.15.02.13.934.0 ]--
r 45             else return terrain.computeTravelCost
--[ 2019.11.02.15.02.14.684.0 ]--
r 45             else return terrain.computeTravelCost()
--[ 2019.11.02.15.02.26.127.0 ]--
r 45             else return terrain.computeTravelCost(c)
--[ 2019.11.02.15.02.26.331.0 ]--
r 45             else return terrain.computeTravelCost(co)
--[ 2019.11.02.15.02.26.452.0 ]--
r 45             else return terrain.computeTravelCost(c)
--[ 2019.11.02.15.02.26.922.0 ]--
r 45             else return terrain.computeTravelCost()
--[ 2019.11.02.15.02.27.557.0 ]--
r 45             else return terrain.computeTravelCost(c)
--[ 2019.11.02.15.02.27.598.0 ]--
r 45             else return terrain.computeTravelCost(c0)
--[ 2019.11.02.15.02.27.926.0 ]--
r 45             else return terrain.computeTravelCost(c0,)
--[ 2019.11.02.15.02.28.133.0 ]--
r 45             else return terrain.computeTravelCost(c0)
--[ 2019.11.02.15.02.28.298.0 ]--
r 45             else return terrain.computeTravelCost(c)
--[ 2019.11.02.15.02.28.439.0 ]--
r 45             else return terrain.computeTravelCost()
--[ 2019.11.02.15.02.56.146.0 ]--
r 45             else return terrain.computeTravelCost(c)
--[ 2019.11.02.15.02.56.662.0 ]--
r 45             else return terrain.computeTravelCost()
--[ 2019.11.02.15.02.57.419.0 ]--
r 45             else return terrain.computeTravelCost(c)
--[ 2019.11.02.15.02.57.502.0 ]--
r 45             else return terrain.computeTravelCost(co)
--[ 2019.11.02.15.02.57.629.0 ]--
r 45             else return terrain.computeTravelCost(com)
--[ 2019.11.02.15.02.57.691.0 ]--
r 45             else return terrain.computeTravelCost(comp)
--[ 2019.11.02.15.02.57.897.0 ]--
r 45             else return terrain.computeTravelCost(compu)
--[ 2019.11.02.15.02.57.962.0 ]--
r 45             else return terrain.computeTravelCost(comput)
--[ 2019.11.02.15.02.58.085.0 ]--
r 45             else return terrain.computeTravelCost(compute)
--[ 2019.11.02.15.02.58.258.0 ]--
r 45             else return terrain.computeTravelCost(computer)
--[ 2019.11.02.15.02.58.335.0 ]--
r 45             else return terrain.computeTravelCost(compute)
--[ 2019.11.02.15.02.58.908.0 ]--
r 45             else return terrain.computeTravelCost(comput)
--[ 2019.11.02.15.02.58.973.0 ]--
r 45             else return terrain.computeTravelCost(compu)
--[ 2019.11.02.15.02.59.015.0 ]--
r 45             else return terrain.computeTravelCost(comp)
--[ 2019.11.02.15.02.59.136.0 ]--
r 45             else return terrain.computeTravelCost(com)
--[ 2019.11.02.15.02.59.299.0 ]--
r 45             else return terrain.computeTravelCost(co)
--[ 2019.11.02.15.02.59.481.0 ]--
r 45             else return terrain.computeTravelCost(c)
--[ 2019.11.02.15.02.59.648.0 ]--
r 45             else return terrain.computeTravelCost()
--[ 2019.11.02.15.03.01.044.0 ]--
r 45             else return terrain.computeTravelCost(f)
--[ 2019.11.02.15.03.01.575.0 ]--
r 45             else return terrain.computeTravelCost(fr)
--[ 2019.11.02.15.03.01.719.0 ]--
r 45             else return terrain.computeTravelCost(fro)
--[ 2019.11.02.15.03.01.797.0 ]--
r 45             else return terrain.computeTravelCost(from)
--[ 2019.11.02.15.03.02.042.0 ]--
r 45             else return terrain.computeTravelCost(fromn)
--[ 2019.11.02.15.03.02.345.0 ]--
r 45             else return terrain.computeTravelCost(fromno)
--[ 2019.11.02.15.03.02.689.0 ]--
r 45             else return terrain.computeTravelCost(fromn)
--[ 2019.11.02.15.03.02.873.0 ]--
r 45             else return terrain.computeTravelCost(from)
--[ 2019.11.02.15.03.03.143.0 ]--
r 45             else return terrain.computeTravelCost(fromN)
--[ 2019.11.02.15.03.03.341.0 ]--
r 45             else return terrain.computeTravelCost(fromNo)
--[ 2019.11.02.15.03.03.515.0 ]--
r 45             else return terrain.computeTravelCost(fromNod)
--[ 2019.11.02.15.03.03.755.0 ]--
r 45             else return terrain.computeTravelCost(fromNode)
--[ 2019.11.02.15.03.04.633.0 ]--
r 45             else return terrain.computeTravelCost(fromNode.)
--[ 2019.11.02.15.03.05.619.0 ]--
r 45             else return terrain.computeTravelCost(fromNode.l)
--[ 2019.11.02.15.03.05.795.0 ]--
r 45             else return terrain.computeTravelCost(fromNode.lo)
--[ 2019.11.02.15.03.06.093.0 ]--
r 45             else return terrain.computeTravelCost(fromNode.l)
--[ 2019.11.02.15.03.06.233.0 ]--
r 45             else return terrain.computeTravelCost(fromNode.)
--[ 2019.11.02.15.03.06.458.0 ]--
r 45             else return terrain.computeTravelCost(fromNode)
--[ 2019.11.02.15.03.07.020.0 ]--
r 45             else return terrain.computeTravelCost(fromNode.)
--[ 2019.11.02.15.03.07.215.0 ]--
r 45             else return terrain.computeTravelCost(fromNode.g)
--[ 2019.11.02.15.03.07.283.0 ]--
r 45             else return terrain.computeTravelCost(fromNode.ge)
--[ 2019.11.02.15.03.07.441.0 ]--
r 45             else return terrain.computeTravelCost(fromNode.get)
--[ 2019.11.02.15.03.07.684.0 ]--
r 45             else return terrain.computeTravelCost(fromNode.getL)
--[ 2019.11.02.15.03.07.856.0 ]--
r 45             else return terrain.computeTravelCost(fromNode.getLo)
--[ 2019.11.02.15.03.07.926.0 ]--
r 45             else return terrain.computeTravelCost(fromNode.getLoc)
--[ 2019.11.02.15.03.08.262.0 ]--
r 45             else return terrain.computeTravelCost(fromNode.getLoc())
--[ 2019.11.02.15.03.09.034.0 ]--
r 45             else return terrain.computeTravelCost(fromNode.getLoc(),)
--[ 2019.11.02.15.03.09.097.0 ]--
r 45             else return terrain.computeTravelCost(fromNode.getLoc(), )
--[ 2019.11.02.15.03.11.035.0 ]--
r 45             else return terrain.computeTravelCost(fromNode.getLoc(), l)
--[ 2019.11.02.15.03.11.190.0 ]--
r 45             else return terrain.computeTravelCost(fromNode.getLoc(), lo)
--[ 2019.11.02.15.03.11.237.0 ]--
r 45             else return terrain.computeTravelCost(fromNode.getLoc(), loc)
--[ 2019.11.02.15.03.11.808.0 ]--
r 45             else return terrain.computeTravelCost(fromNode.getLoc(), loc);
--[ 2019.11.02.15.03.13.460.0 ]--
r 45             else return terrain.computeTravelCost(fromNode.getLoc(), lo);
--[ 2019.11.02.15.03.13.691.0 ]--
r 45             else return terrain.computeTravelCost(fromNode.getLoc(), l);
--[ 2019.11.02.15.03.13.895.0 ]--
r 45             else return terrain.computeTravelCost(fromNode.getLoc(), );
--[ 2019.11.02.15.03.14.201.0 ]--
r 45             else return terrain.computeTravelCost(fromNode.getLoc(), g);
--[ 2019.11.02.15.03.14.305.0 ]--
r 45             else return terrain.computeTravelCost(fromNode.getLoc(), ge);
--[ 2019.11.02.15.03.14.442.0 ]--
r 45             else return terrain.computeTravelCost(fromNode.getLoc(), get);
--[ 2019.11.02.15.03.14.704.0 ]--
r 45             else return terrain.computeTravelCost(fromNode.getLoc(), getL);
--[ 2019.11.02.15.03.14.867.0 ]--
r 45             else return terrain.computeTravelCost(fromNode.getLoc(), getLo);
--[ 2019.11.02.15.03.14.923.0 ]--
r 45             else return terrain.computeTravelCost(fromNode.getLoc(), getLoc);
--[ 2019.11.02.15.03.15.221.0 ]--
r 45             else return terrain.computeTravelCost(fromNode.getLoc(), getLoc());
--[ 2019.11.02.15.03.24.042.0 ]--
r 45             else return iterrain.computeTravelCost(fromNode.getLoc(), getLoc());
--[ 2019.11.02.15.03.24.261.0 ]--
r 45             else return intterrain.computeTravelCost(fromNode.getLoc(), getLoc());
--[ 2019.11.02.15.03.24.528.0 ]--
r 45             else return int(terrain.computeTravelCost(fromNode.getLoc(), getLoc());
--[ 2019.11.02.15.03.27.606.0 ]--
r 45             else return int(terrain.computeTravelCost(fromNode.getLoc(), getLoc()));
--[ 2019.11.02.15.03.32.888.0 ]--
r 41 
r 43 
r 46 
--[ 2019.11.02.15.05.13.112.0 ]--
r 45             else return (int(terrain.computeTravelCost(fromNode.getLoc(), getLoc()));
--[ 2019.11.02.15.05.14.534.0 ]--
r 45             else return (int)(terrain.computeTravelCost(fromNode.getLoc(), getLoc()));
--[ 2019.11.02.15.05.14.631.0 ]--
r 45             else return (int) (terrain.computeTravelCost(fromNode.getLoc(), getLoc()));
--[ 2019.11.02.15.05.18.835.0 ]--
r 45             else return (int) (terrain.computeTravelCost(fromNode.getLoc(), getLoc());
--[ 2019.11.02.15.05.21.032.0 ]--
r 45             else return (int) terrain.computeTravelCost(fromNode.getLoc(), getLoc());
--[ 2019.11.02.15.05.40.973.0 ]--
+ 154         
--[ 2019.11.02.15.05.41.307.0 ]--
r 154         p
--[ 2019.11.02.15.05.41.412.0 ]--
r 154         pq
--[ 2019.11.02.15.05.41.567.0 ]--
r 154         pq.
--[ 2019.11.02.15.15.53.586.0 ]--
r 154         pq
--[ 2019.11.02.15.15.53.811.0 ]--
r 154         p
--[ 2019.11.02.15.15.53.992.0 ]--
r 154         
--[ 2019.11.02.15.30.34.876.0 ]--
+ 26         
--[ 2019.11.02.15.30.35.376.0 ]--
r 26         p
--[ 2019.11.02.15.30.35.512.0 ]--
r 26         pr
--[ 2019.11.02.15.30.35.890.0 ]--
r 26         pri
--[ 2019.11.02.15.30.35.973.0 ]--
r 26         priv
--[ 2019.11.02.15.30.36.131.0 ]--
r 26         priva
--[ 2019.11.02.15.30.36.198.0 ]--
r 26         privat
--[ 2019.11.02.15.30.36.323.0 ]--
r 26         private
--[ 2019.11.02.15.30.36.370.0 ]--
r 26         private 
--[ 2019.11.02.15.30.36.417.0 ]--
r 26         private i
--[ 2019.11.02.15.30.36.495.0 ]--
r 26         private in
--[ 2019.11.02.15.30.36.557.0 ]--
r 26         private int
--[ 2019.11.02.15.30.36.667.0 ]--
r 26         private int 
--[ 2019.11.02.15.30.36.809.0 ]--
r 26         private int c
--[ 2019.11.02.15.30.36.872.0 ]--
r 26         private int co
--[ 2019.11.02.15.30.37.003.0 ]--
r 26         private int cos
--[ 2019.11.02.15.30.37.127.0 ]--
r 26         private int cost
--[ 2019.11.02.15.30.37.182.0 ]--
r 26         private int cost;
--[ 2019.11.02.15.40.15.343.0 ]--
+ 51         
--[ 2019.11.02.15.40.15.578.0 ]--
+ 51         
--[ 2019.11.02.15.40.16.563.0 ]--
r 52         p
--[ 2019.11.02.15.40.16.628.0 ]--
r 52         pr
--[ 2019.11.02.15.40.16.721.0 ]--
r 52         pri
--[ 2019.11.02.15.40.16.815.0 ]--
r 52         priv
--[ 2019.11.02.15.40.16.909.0 ]--
r 52         priva
--[ 2019.11.02.15.40.17.084.0 ]--
r 52         privat
--[ 2019.11.02.15.40.17.161.0 ]--
r 52         private
--[ 2019.11.02.15.40.17.264.0 ]--
r 52         private 
--[ 2019.11.02.15.40.17.396.0 ]--
r 52         private i
--[ 2019.11.02.15.40.17.491.0 ]--
r 52         private in
--[ 2019.11.02.15.40.17.528.0 ]--
r 52         private int
--[ 2019.11.02.15.40.17.610.0 ]--
r 52         private int 
--[ 2019.11.02.15.40.22.292.0 ]--
r 52         private int f
--[ 2019.11.02.15.40.22.378.0 ]--
r 52         private int fi
--[ 2019.11.02.15.40.22.456.0 ]--
r 52         private int fin
--[ 2019.11.02.15.40.22.518.0 ]--
r 52         private int find
--[ 2019.11.02.15.40.22.724.0 ]--
r 52         private int findH
--[ 2019.11.02.15.40.22.894.0 ]--
r 52         private int findHe
--[ 2019.11.02.15.40.22.987.0 ]--
r 52         private int findHei
--[ 2019.11.02.15.40.23.097.0 ]--
r 52         private int findHeig
--[ 2019.11.02.15.40.23.200.0 ]--
r 52         private int findHeigh
--[ 2019.11.02.15.40.23.294.0 ]--
r 52         private int findHeight
--[ 2019.11.02.15.40.23.483.0 ]--
r 52         private int findHeightD
--[ 2019.11.02.15.40.23.662.0 ]--
r 52         private int findHeightDi
--[ 2019.11.02.15.40.23.741.0 ]--
r 52         private int findHeightDiv
--[ 2019.11.02.15.40.23.914.0 ]--
r 52         private int findHeightDivv
--[ 2019.11.02.15.40.24.085.0 ]--
r 52         private int findHeightDivv()
--[ 2019.11.02.15.40.24.351.0 ]--
r 52         private int findHeightDivv
--[ 2019.11.02.15.40.24.522.0 ]--
r 52         private int findHeightDiv
--[ 2019.11.02.15.40.24.681.0 ]--
r 52         private int findHeightDi
--[ 2019.11.02.15.40.24.962.0 ]--
r 52         private int findHeightD
--[ 2019.11.02.15.40.26.231.0 ]--
r 52         private int findHeightDi
--[ 2019.11.02.15.40.26.450.0 ]--
r 52         private int findHeightDiff
--[ 2019.11.02.15.40.26.568.0 ]--
r 52         private int findHeightDiff()
--[ 2019.11.02.15.40.27.287.0 ]--
r 52         private int findHeightDiff(P)
--[ 2019.11.02.15.40.27.380.0 ]--
r 52         private int findHeightDiff(PF)
--[ 2019.11.02.15.40.27.595.0 ]--
r 52         private int findHeightDiff(PFN)
--[ 2019.11.02.15.40.27.931.0 ]--
r 52         private int findHeightDiff(PFNo)
--[ 2019.11.02.15.40.27.995.0 ]--
r 52         private int findHeightDiff(PFNod)
--[ 2019.11.02.15.40.28.200.0 ]--
r 52         private int findHeightDiff(PFNode)
--[ 2019.11.02.15.40.28.263.0 ]--
r 52         private int findHeightDiff(PFNode )
--[ 2019.11.02.15.40.28.278.0 ]--
r 52         private int findHeightDiff(PFNode a)
--[ 2019.11.02.15.40.28.481.0 ]--
r 52         private int findHeightDiff(PFNode a,)
--[ 2019.11.02.15.40.28.606.0 ]--
r 52         private int findHeightDiff(PFNode a, )
--[ 2019.11.02.15.40.28.997.0 ]--
r 52         private int findHeightDiff(PFNode a, P)
--[ 2019.11.02.15.40.29.173.0 ]--
r 52         private int findHeightDiff(PFNode a, PF)
--[ 2019.11.02.15.40.29.275.0 ]--
r 52         private int findHeightDiff(PFNode a, PFN)
--[ 2019.11.02.15.40.29.514.0 ]--
r 52         private int findHeightDiff(PFNode a, PFNo)
--[ 2019.11.02.15.40.29.583.0 ]--
r 52         private int findHeightDiff(PFNode a, PFNod)
--[ 2019.11.02.15.40.29.815.0 ]--
r 52         private int findHeightDiff(PFNode a, PFNode)
--[ 2019.11.02.15.40.30.080.0 ]--
r 52         private int findHeightDiff(PFNode a, PFNode )
--[ 2019.11.02.15.40.30.173.0 ]--
r 52         private int findHeightDiff(PFNode a, PFNode b)
--[ 2019.11.02.15.40.31.081.0 ]--
r 52         private int findHeightDiff(PFNode a, PFNode b) 
--[ 2019.11.02.15.40.31.238.0 ]--
r 52         private int findHeightDiff(PFNode a, PFNode b) {}
--[ 2019.11.02.15.40.31.363.0 ]--
+ 52         private int findHeightDiff(PFNode a, PFNode b) {
r 53         }
--[ 2019.11.02.15.40.31.394.0 ]--
+ 53             
--[ 2019.11.02.15.40.40.423.0 ]--
r 53             i
--[ 2019.11.02.15.40.40.671.0 ]--
r 53             in
--[ 2019.11.02.15.40.40.687.0 ]--
r 53             int 
--[ 2019.11.02.15.40.41.110.0 ]--
r 53             int h
--[ 2019.11.02.15.40.41.242.0 ]--
r 53             int ha
--[ 2019.11.02.15.40.41.367.0 ]--
r 53             int ha 
--[ 2019.11.02.15.40.41.492.0 ]--
r 53             int ha =
--[ 2019.11.02.15.40.41.570.0 ]--
r 53             int ha = 
--[ 2019.11.02.15.40.42.102.0 ]--
r 53             int ha = b
--[ 2019.11.02.15.40.42.158.0 ]--
r 53             int ha = bo
--[ 2019.11.02.15.40.42.378.0 ]--
r 53             int ha = boa
--[ 2019.11.02.15.40.42.439.0 ]--
r 53             int ha = boar
--[ 2019.11.02.15.40.42.643.0 ]--
r 53             int ha = board
--[ 2019.11.02.15.40.42.810.0 ]--
r 53             int ha = board[]
--[ 2019.11.02.15.40.45.416.0 ]--
r 53             int ha = board[a]
--[ 2019.11.02.15.40.45.817.0 ]--
r 53             int ha = board[a.]
--[ 2019.11.02.15.40.46.340.0 ]--
r 53             int ha = board[a.g]
--[ 2019.11.02.15.40.46.403.0 ]--
r 53             int ha = board[a.ge]
--[ 2019.11.02.15.40.46.543.0 ]--
r 53             int ha = board[a.get]
--[ 2019.11.02.15.40.46.779.0 ]--
r 53             int ha = board[a.getL]
--[ 2019.11.02.15.40.46.964.0 ]--
r 53             int ha = board[a.getLo]
--[ 2019.11.02.15.40.47.076.0 ]--
r 53             int ha = board[a.getLoc]
--[ 2019.11.02.15.40.47.422.0 ]--
r 53             int ha = board[a.getLoc()]
--[ 2019.11.02.15.40.47.849.0 ]--
r 53             int ha = board[a.getLoc().]
--[ 2019.11.02.15.40.48.037.0 ]--
r 53             int ha = board[a.getLoc().g]
--[ 2019.11.02.15.40.48.133.0 ]--
r 53             int ha = board[a.getLoc().ge]
--[ 2019.11.02.15.40.48.289.0 ]--
r 53             int ha = board[a.getLoc().get]
--[ 2019.11.02.15.40.48.557.0 ]--
r 53             int ha = board[a.getLoc().getI]
--[ 2019.11.02.15.40.48.901.0 ]--
r 53             int ha = board[a.getLoc().getI()]
--[ 2019.11.02.15.40.49.145.0 ]--
r 53             int ha = board[a.getLoc().getI())]
--[ 2019.11.02.15.40.49.833.0 ]--
r 53             int ha = board[a.getLoc().getI()]
--[ 2019.11.02.15.40.51.092.0 ]--
r 53             int ha = board[a.getLoc().getI()][]
--[ 2019.11.02.15.40.52.609.0 ]--
r 53             int ha = board[a.getLoc().getI()][a]
--[ 2019.11.02.15.40.52.735.0 ]--
r 53             int ha = board[a.getLoc().getI()][a.]
--[ 2019.11.02.15.40.53.081.0 ]--
r 53             int ha = board[a.getLoc().getI()][a.g]
--[ 2019.11.02.15.40.53.137.0 ]--
r 53             int ha = board[a.getLoc().getI()][a.ge]
--[ 2019.11.02.15.40.53.262.0 ]--
r 53             int ha = board[a.getLoc().getI()][a.get]
--[ 2019.11.02.15.40.53.497.0 ]--
r 53             int ha = board[a.getLoc().getI()][a.getL]
--[ 2019.11.02.15.40.53.684.0 ]--
r 53             int ha = board[a.getLoc().getI()][a.getLo]
--[ 2019.11.02.15.40.53.763.0 ]--
r 53             int ha = board[a.getLoc().getI()][a.getLoc]
--[ 2019.11.02.15.40.54.119.0 ]--
r 53             int ha = board[a.getLoc().getI()][a.getLoc()]
--[ 2019.11.02.15.40.54.487.0 ]--
r 53             int ha = board[a.getLoc().getI()][a.getLoc().]
--[ 2019.11.02.15.40.54.695.0 ]--
r 53             int ha = board[a.getLoc().getI()][a.getLoc().g]
--[ 2019.11.02.15.40.54.791.0 ]--
r 53             int ha = board[a.getLoc().getI()][a.getLoc().ge]
--[ 2019.11.02.15.40.54.932.0 ]--
r 53             int ha = board[a.getLoc().getI()][a.getLoc().get]
--[ 2019.11.02.15.40.55.198.0 ]--
r 53             int ha = board[a.getLoc().getI()][a.getLoc().getJ]
--[ 2019.11.02.15.40.55.636.0 ]--
r 53             int ha = board[a.getLoc().getI()][a.getLoc().getJ()]
--[ 2019.11.02.15.40.57.072.0 ]--
r 53             int ha = board[a.getLoc().getI()][a.getLoc().getJ()];
--[ 2019.11.02.15.40.57.974.0 ]--
+ 54             
--[ 2019.11.02.15.40.58.474.0 ]--
r 54             i
--[ 2019.11.02.15.40.58.543.0 ]--
r 54             in
--[ 2019.11.02.15.40.58.621.0 ]--
r 54             int
--[ 2019.11.02.15.40.58.684.0 ]--
r 54             int 
--[ 2019.11.02.15.40.58.809.0 ]--
r 54             int h
--[ 2019.11.02.15.40.58.903.0 ]--
r 54             int hb
--[ 2019.11.02.15.40.59.035.0 ]--
r 54             int hb 
--[ 2019.11.02.15.40.59.099.0 ]--
r 54             int hb =
--[ 2019.11.02.15.40.59.228.0 ]--
r 54             int hb = 
--[ 2019.11.02.15.40.59.865.0 ]--
r 54             int hb = b
--[ 2019.11.02.15.40.59.950.0 ]--
r 54             int hb = bo
--[ 2019.11.02.15.41.00.110.0 ]--
r 54             int hb = boa
--[ 2019.11.02.15.41.00.172.0 ]--
r 54             int hb = boar
--[ 2019.11.02.15.41.00.376.0 ]--
r 54             int hb = board
--[ 2019.11.02.15.41.00.469.0 ]--
r 54             int hb = board[]
--[ 2019.11.02.15.41.00.594.0 ]--
r 54             int hb = board[b]
--[ 2019.11.02.15.41.00.688.0 ]--
r 54             int hb = board[b.]
--[ 2019.11.02.15.41.00.939.0 ]--
r 54             int hb = board[b.g]
--[ 2019.11.02.15.41.01.007.0 ]--
r 54             int hb = board[b.ge]
--[ 2019.11.02.15.41.01.163.0 ]--
r 54             int hb = board[b.get]
--[ 2019.11.02.15.41.01.862.0 ]--
r 54             int hb = board[b.getL]
--[ 2019.11.02.15.41.02.153.0 ]--
r 54             int hb = board[b.getLoc]
--[ 2019.11.02.15.41.02.174.0 ]--
r 54             int hb = board[b.getLoc()]
--[ 2019.11.02.15.41.03.032.0 ]--
r 54             int hb = board[b.getLoc().]
--[ 2019.11.02.15.41.03.251.0 ]--
r 54             int hb = board[b.getLoc().g]
--[ 2019.11.02.15.41.03.330.0 ]--
r 54             int hb = board[b.getLoc().ge]
--[ 2019.11.02.15.41.03.486.0 ]--
r 54             int hb = board[b.getLoc().get]
--[ 2019.11.02.15.41.03.692.0 ]--
r 54             int hb = board[b.getLoc().getI]
--[ 2019.11.02.15.41.04.093.0 ]--
r 54             int hb = board[b.getLoc().getI()]
--[ 2019.11.02.15.41.05.241.0 ]--
r 54             int hb = board[b.getLoc().getI()][]
--[ 2019.11.02.15.41.05.818.0 ]--
r 54             int hb = board[b.getLoc().getI()][b]
--[ 2019.11.02.15.41.05.944.0 ]--
r 54             int hb = board[b.getLoc().getI()][b.]
--[ 2019.11.02.15.41.06.305.0 ]--
r 54             int hb = board[b.getLoc().getI()][b.g]
--[ 2019.11.02.15.41.06.393.0 ]--
r 54             int hb = board[b.getLoc().getI()][b.ge]
--[ 2019.11.02.15.41.06.518.0 ]--
r 54             int hb = board[b.getLoc().getI()][b.get]
--[ 2019.11.02.15.41.06.753.0 ]--
r 54             int hb = board[b.getLoc().getI()][b.getL]
--[ 2019.11.02.15.41.06.917.0 ]--
r 54             int hb = board[b.getLoc().getI()][b.getLo]
--[ 2019.11.02.15.41.06.964.0 ]--
r 54             int hb = board[b.getLoc().getI()][b.getLoc]
--[ 2019.11.02.15.41.07.248.0 ]--
r 54             int hb = board[b.getLoc().getI()][b.getLoc()]
--[ 2019.11.02.15.41.07.596.0 ]--
r 54             int hb = board[b.getLoc().getI()][b.getLoc().]
--[ 2019.11.02.15.41.08.226.0 ]--
r 54             int hb = board[b.getLoc().getI()][b.getLoc().g]
--[ 2019.11.02.15.41.08.319.0 ]--
r 54             int hb = board[b.getLoc().getI()][b.getLoc().ge]
--[ 2019.11.02.15.41.08.471.0 ]--
r 54             int hb = board[b.getLoc().getI()][b.getLoc().get]
--[ 2019.11.02.15.41.08.707.0 ]--
r 54             int hb = board[b.getLoc().getI()][b.getLoc().getJ]
--[ 2019.11.02.15.41.09.118.0 ]--
r 54             int hb = board[b.getLoc().getI()][b.getLoc().getJ()]
--[ 2019.11.02.15.41.10.159.0 ]--
r 54             int hb = board[b.getLoc().getI()][b.getLoc().getJ()];
--[ 2019.11.02.15.41.10.362.0 ]--
+ 55             
--[ 2019.11.02.15.41.10.989.0 ]--
r 55             r
--[ 2019.11.02.15.41.11.064.0 ]--
r 55             re
--[ 2019.11.02.15.41.11.252.0 ]--
r 55             ret
--[ 2019.11.02.15.41.11.513.0 ]--
r 55             retur
--[ 2019.11.02.15.41.11.575.0 ]--
r 55             return 
--[ 2019.11.02.15.41.11.747.0 ]--
r 55             return M
--[ 2019.11.02.15.41.12.231.0 ]--
r 55             return Ma
--[ 2019.11.02.15.41.12.262.0 ]--
r 55             return Math
--[ 2019.11.02.15.41.12.309.0 ]--
r 55             return Math.
--[ 2019.11.02.15.41.12.355.0 ]--
r 55             return Math.a
--[ 2019.11.02.15.41.12.512.0 ]--
r 55             return Math.ab
--[ 2019.11.02.15.41.12.621.0 ]--
r 55             return Math.abs
--[ 2019.11.02.15.41.12.935.0 ]--
r 55             return Math.abs()
--[ 2019.11.02.15.41.14.299.0 ]--
r 55             return Math.abs(h)
--[ 2019.11.02.15.41.14.405.0 ]--
r 55             return Math.abs(ha)
--[ 2019.11.02.15.41.14.674.0 ]--
r 55             return Math.abs(ha )
--[ 2019.11.02.15.41.14.800.0 ]--
r 55             return Math.abs(ha -)
--[ 2019.11.02.15.41.14.868.0 ]--
r 55             return Math.abs(ha - )
--[ 2019.11.02.15.41.15.018.0 ]--
r 55             return Math.abs(ha - h)
--[ 2019.11.02.15.41.15.096.0 ]--
r 55             return Math.abs(ha - hb)
--[ 2019.11.02.15.41.15.600.0 ]--
r 55             return Math.abs(ha - hb);
--[ 2019.11.02.15.41.23.106.0 ]--
r 45            / if (fromNode == null) return 0;
--[ 2019.11.02.15.41.23.294.0 ]--
r 45            // if (fromNode == null) return 0;
--[ 2019.11.02.15.41.24.248.0 ]--
r 45            / if (fromNode == null) return 0;
--[ 2019.11.02.15.41.24.373.0 ]--
r 45             if (fromNode == null) return 0;
--[ 2019.11.02.15.41.24.937.0 ]--
r 45             /if (fromNode == null) return 0;
--[ 2019.11.02.15.41.25.100.0 ]--
r 45             //if (fromNode == null) return 0;
--[ 2019.11.02.15.41.26.164.0 ]--
r 46             /else return (int) terrain.computeTravelCost(fromNode.getLoc(), getLoc());
--[ 2019.11.02.15.41.26.298.0 ]--
r 46             //else return (int) terrain.computeTravelCost(fromNode.getLoc(), getLoc());
--[ 2019.11.02.15.41.28.994.0 ]--
+ 50             
--[ 2019.11.02.15.41.29.145.0 ]--
+ 50             
--[ 2019.11.02.15.41.31.988.0 ]--
r 51             P
--[ 2019.11.02.15.41.32.091.0 ]--
r 51             PF
--[ 2019.11.02.15.41.32.279.0 ]--
r 51             PFN
--[ 2019.11.02.15.41.32.607.0 ]--
r 51             PFNo
--[ 2019.11.02.15.41.32.750.0 ]--
r 51             PFNod
--[ 2019.11.02.15.41.32.928.0 ]--
r 51             PFNode
--[ 2019.11.02.15.41.32.990.0 ]--
r 51             PFNode 
--[ 2019.11.02.15.41.33.147.0 ]--
r 51             PFNode b
--[ 2019.11.02.15.41.33.381.0 ]--
r 51             PFNode b 
--[ 2019.11.02.15.41.33.412.0 ]--
r 51             PFNode b =
--[ 2019.11.02.15.41.33.490.0 ]--
r 51             PFNode b = 
--[ 2019.11.02.15.41.37.362.0 ]--
r 51             PFNode b = f
--[ 2019.11.02.15.41.37.603.0 ]--
r 51             PFNode b = fr
--[ 2019.11.02.15.41.37.663.0 ]--
r 51             PFNode b = fro
--[ 2019.11.02.15.41.37.710.0 ]--
r 51             PFNode b = from
--[ 2019.11.02.15.41.37.896.0 ]--
r 51             PFNode b = fromN
--[ 2019.11.02.15.41.38.036.0 ]--
r 51             PFNode b = fromNo
--[ 2019.11.02.15.41.38.102.0 ]--
r 51             PFNode b = fromNod
--[ 2019.11.02.15.41.38.307.0 ]--
r 51             PFNode b = fromNode
--[ 2019.11.02.15.41.38.354.0 ]--
r 51             PFNode b = fromNode;
--[ 2019.11.02.15.41.38.528.0 ]--
+ 52             
--[ 2019.11.02.15.41.39.357.0 ]--
r 52             i
--[ 2019.11.02.15.41.39.460.0 ]--
r 52             if
--[ 2019.11.02.15.41.39.523.0 ]--
r 52             if 
--[ 2019.11.02.15.41.41.103.0 ]--
r 52             if ()
--[ 2019.11.02.15.41.41.291.0 ]--
r 52             if (b)
--[ 2019.11.02.15.41.41.419.0 ]--
r 52             if (b )
--[ 2019.11.02.15.41.41.575.0 ]--
r 52             if (b =)
--[ 2019.11.02.15.41.41.747.0 ]--
r 52             if (b ==)
--[ 2019.11.02.15.41.41.856.0 ]--
r 52             if (b == )
--[ 2019.11.02.15.41.41.982.0 ]--
r 52             if (b == n)
--[ 2019.11.02.15.41.42.220.0 ]--
r 52             if (b == nu)
--[ 2019.11.02.15.41.42.423.0 ]--
r 52             if (b == nul)
--[ 2019.11.02.15.41.42.547.0 ]--
r 52             if (b == null)
--[ 2019.11.02.15.41.42.814.0 ]--
r 52             if (b == null) 
--[ 2019.11.02.15.41.44.275.0 ]--
r 52             if (b == null) r
--[ 2019.11.02.15.41.44.510.0 ]--
r 52             if (b == null) re
--[ 2019.11.02.15.41.44.527.0 ]--
r 52             if (b == null) ret
--[ 2019.11.02.15.41.44.604.0 ]--
r 52             if (b == null) retu
--[ 2019.11.02.15.41.44.764.0 ]--
r 52             if (b == null) retur
--[ 2019.11.02.15.41.44.796.0 ]--
r 52             if (b == null) return
--[ 2019.11.02.15.41.44.937.0 ]--
r 52             if (b == null) return 
--[ 2019.11.02.15.41.45.036.0 ]--
r 52             if (b == null) return 0
--[ 2019.11.02.15.41.45.303.0 ]--
r 52             if (b == null) return 0;
--[ 2019.11.02.15.41.45.797.0 ]--
+ 53             
--[ 2019.11.02.15.41.47.521.0 ]--
r 53             e
--[ 2019.11.02.15.41.47.809.0 ]--
r 53             el
--[ 2019.11.02.15.41.47.863.0 ]--
r 53             els
--[ 2019.11.02.15.41.47.944.0 ]--
r 53             else
--[ 2019.11.02.15.41.48.007.0 ]--
r 53             else 
--[ 2019.11.02.15.41.48.242.0 ]--
r 53             else {
--[ 2019.11.02.15.41.49.008.0 ]--
+ 54 
+ 55 }
--[ 2019.11.02.15.41.49.034.0 ]--
r 55             }
--[ 2019.11.02.15.41.49.065.0 ]--
r 54                 
--[ 2019.11.02.15.41.52.781.0 ]--
r 54                 i
--[ 2019.11.02.15.41.52.877.0 ]--
r 54                 in
--[ 2019.11.02.15.41.52.956.0 ]--
r 54                 int
--[ 2019.11.02.15.41.53.002.0 ]--
r 54                 int 
--[ 2019.11.02.15.41.53.221.0 ]--
r 54                 int f
--[ 2019.11.02.15.41.53.441.0 ]--
r 54                 int for
--[ 2019.11.02.15.41.53.505.0 ]--
r 54                 int form
--[ 2019.11.02.15.41.53.757.0 ]--
r 54                 int formC
--[ 2019.11.02.15.41.53.907.0 ]--
r 54                 int formCo
--[ 2019.11.02.15.41.54.017.0 ]--
r 54                 int formCos
--[ 2019.11.02.15.41.54.126.0 ]--
r 54                 int formCost
--[ 2019.11.02.15.41.54.205.0 ]--
r 54                 int formCost 
--[ 2019.11.02.15.41.54.456.0 ]--
r 54                 int formCost
--[ 2019.11.02.15.41.54.950.0 ]--
r 54                 int formCos
--[ 2019.11.02.15.41.54.985.0 ]--
r 54                 int formCo
--[ 2019.11.02.15.41.55.017.0 ]--
r 54                 int formC
--[ 2019.11.02.15.41.55.048.0 ]--
r 54                 int form
--[ 2019.11.02.15.41.55.079.0 ]--
r 54                 int for
--[ 2019.11.02.15.41.55.220.0 ]--
r 54                 int fo
--[ 2019.11.02.15.41.55.391.0 ]--
r 54                 int f
--[ 2019.11.02.15.41.55.565.0 ]--
r 54                 int 
--[ 2019.11.02.15.41.55.773.0 ]--
r 54                 int f
--[ 2019.11.02.15.41.56.003.0 ]--
r 54                 int fr
--[ 2019.11.02.15.41.56.078.0 ]--
r 54                 int fro
--[ 2019.11.02.15.41.56.140.0 ]--
r 54                 int from
--[ 2019.11.02.15.41.56.312.0 ]--
r 54                 int fromC
--[ 2019.11.02.15.41.56.745.0 ]--
r 54                 int fromCo
--[ 2019.11.02.15.41.56.896.0 ]--
r 54                 int fromCos
--[ 2019.11.02.15.41.56.977.0 ]--
r 54                 int fromCost
--[ 2019.11.02.15.41.57.044.0 ]--
r 54                 int fromCost 
--[ 2019.11.02.15.41.57.213.0 ]--
r 54                 int fromCost =
--[ 2019.11.02.15.41.57.251.0 ]--
r 54                 int fromCost = 
--[ 2019.11.02.15.41.57.946.0 ]--
r 54                 int fromCost = b
--[ 2019.11.02.15.41.58.057.0 ]--
r 54                 int fromCost = bo
--[ 2019.11.02.15.41.58.151.0 ]--
r 54                 int fromCost = boa
--[ 2019.11.02.15.41.58.213.0 ]--
r 54                 int fromCost = boar
--[ 2019.11.02.15.41.58.449.0 ]--
r 54                 int fromCost = board
--[ 2019.11.02.15.41.58.480.0 ]--
r 54                 int fromCost = board[]
--[ 2019.11.02.15.41.59.175.0 ]--
r 54                 int fromCost = board[b]
--[ 2019.11.02.15.41.59.294.0 ]--
r 54                 int fromCost = board[b.]
--[ 2019.11.02.15.42.00.806.0 ]--
r 54                 int fromCost = board[b.g]
--[ 2019.11.02.15.42.00.884.0 ]--
r 54                 int fromCost = board[b.ge]
--[ 2019.11.02.15.42.01.040.0 ]--
r 54                 int fromCost = board[b.get]
--[ 2019.11.02.15.42.01.260.0 ]--
r 54                 int fromCost = board[b.getL]
--[ 2019.11.02.15.42.01.419.0 ]--
r 54                 int fromCost = board[b.getLo]
--[ 2019.11.02.15.42.01.513.0 ]--
r 54                 int fromCost = board[b.getLoc]
--[ 2019.11.02.15.42.01.920.0 ]--
r 54                 int fromCost = board[b.getLoc()]
--[ 2019.11.02.15.42.02.273.0 ]--
r 54                 int fromCost = board[b.getLoc().]
--[ 2019.11.02.15.42.02.435.0 ]--
r 54                 int fromCost = board[b.getLoc().g]
--[ 2019.11.02.15.42.02.533.0 ]--
r 54                 int fromCost = board[b.getLoc().ge]
--[ 2019.11.02.15.42.02.684.0 ]--
r 54                 int fromCost = board[b.getLoc().get]
--[ 2019.11.02.15.42.02.914.0 ]--
r 54                 int fromCost = board[b.getLoc().getI]
--[ 2019.11.02.15.42.03.235.0 ]--
r 54                 int fromCost = board[b.getLoc().getI()]
--[ 2019.11.02.15.42.04.126.0 ]--
r 54                 int fromCost = board[b.getLoc().getI()];
--[ 2019.11.02.15.42.10.639.0 ]--
r 54                 int fromCost = board[b.getLoc().getI()][];
--[ 2019.11.02.15.42.11.596.0 ]--
r 54                 int fromCost = board[b.getLoc().getI()][b];
--[ 2019.11.02.15.42.11.705.0 ]--
r 54                 int fromCost = board[b.getLoc().getI()][b.];
--[ 2019.11.02.15.42.12.019.0 ]--
r 54                 int fromCost = board[b.getLoc().getI()][b.g];
--[ 2019.11.02.15.42.12.105.0 ]--
r 54                 int fromCost = board[b.getLoc().getI()][b.ge];
--[ 2019.11.02.15.42.12.262.0 ]--
r 54                 int fromCost = board[b.getLoc().getI()][b.get];
--[ 2019.11.02.15.42.12.480.0 ]--
r 54                 int fromCost = board[b.getLoc().getI()][b.getL];
--[ 2019.11.02.15.42.12.636.0 ]--
r 54                 int fromCost = board[b.getLoc().getI()][b.getLo];
--[ 2019.11.02.15.42.12.716.0 ]--
r 54                 int fromCost = board[b.getLoc().getI()][b.getLoc];
--[ 2019.11.02.15.42.12.956.0 ]--
r 54                 int fromCost = board[b.getLoc().getI()][b.getLoc()];
--[ 2019.11.02.15.42.13.326.0 ]--
r 54                 int fromCost = board[b.getLoc().getI()][b.getLoc().];
--[ 2019.11.02.15.42.13.468.0 ]--
r 54                 int fromCost = board[b.getLoc().getI()][b.getLoc().g];
--[ 2019.11.02.15.42.13.594.0 ]--
r 54                 int fromCost = board[b.getLoc().getI()][b.getLoc().ge];
--[ 2019.11.02.15.42.13.735.0 ]--
r 54                 int fromCost = board[b.getLoc().getI()][b.getLoc().get];
--[ 2019.11.02.15.42.13.981.0 ]--
r 54                 int fromCost = board[b.getLoc().getI()][b.getLoc().getJ];
--[ 2019.11.02.15.42.14.368.0 ]--
r 54                 int fromCost = board[b.getLoc().getI()][b.getLoc().getJ()];
--[ 2019.11.02.15.42.16.135.0 ]--
+ 55                 
--[ 2019.11.02.15.42.17.616.0 ]--
r 55                 r
--[ 2019.11.02.15.42.17.715.0 ]--
r 55                 re
--[ 2019.11.02.15.42.17.889.0 ]--
r 55                 ret
--[ 2019.11.02.15.42.18.006.0 ]--
r 55                 retu
--[ 2019.11.02.15.42.18.067.0 ]--
r 55                 retur
--[ 2019.11.02.15.42.18.254.0 ]--
r 55                 return
--[ 2019.11.02.15.42.18.302.0 ]--
r 55                 return 
--[ 2019.11.02.15.42.18.457.0 ]--
r 55                 return f
--[ 2019.11.02.15.42.18.692.0 ]--
r 55                 return fr
--[ 2019.11.02.15.42.18.765.0 ]--
r 55                 return fro
--[ 2019.11.02.15.42.18.781.0 ]--
r 55                 return from
--[ 2019.11.02.15.42.19.017.0 ]--
r 55                 return fromC
--[ 2019.11.02.15.42.19.203.0 ]--
r 55                 return fromCo
--[ 2019.11.02.15.42.19.250.0 ]--
r 55                 return fromCos
--[ 2019.11.02.15.42.19.406.0 ]--
r 55                 return fromCost
--[ 2019.11.02.15.42.19.455.0 ]--
r 55                 return fromCost 
--[ 2019.11.02.15.42.19.675.0 ]--
r 55                 return fromCost +
--[ 2019.11.02.15.42.19.730.0 ]--
r 55                 return fromCost + 
--[ 2019.11.02.15.42.20.870.0 ]--
r 55                 return fromCost + f
--[ 2019.11.02.15.42.21.070.0 ]--
r 55                 return fromCost + fin
--[ 2019.11.02.15.42.21.117.0 ]--
r 55                 return fromCost + find
--[ 2019.11.02.15.42.21.462.0 ]--
r 55                 return fromCost + findH
--[ 2019.11.02.15.42.21.622.0 ]--
r 55                 return fromCost + findHe
--[ 2019.11.02.15.42.21.684.0 ]--
r 55                 return fromCost + findHei
--[ 2019.11.02.15.42.21.825.0 ]--
r 55                 return fromCost + findHeig
--[ 2019.11.02.15.42.21.887.0 ]--
r 55                 return fromCost + findHeigh
--[ 2019.11.02.15.42.22.012.0 ]--
r 55                 return fromCost + findHeight
--[ 2019.11.02.15.42.22.233.0 ]--
r 55                 return fromCost + findHeightD
--[ 2019.11.02.15.42.22.558.0 ]--
r 55                 return fromCost + findHeightDi
--[ 2019.11.02.15.42.22.651.0 ]--
r 55                 return fromCost + findHeightDif
--[ 2019.11.02.15.42.22.794.0 ]--
r 55                 return fromCost + findHeightDiff
--[ 2019.11.02.15.42.23.014.0 ]--
r 55                 return fromCost + findHeightDiff()
--[ 2019.11.02.15.42.26.518.0 ]--
r 55                 return fromCost + findHeightDiff(t)
--[ 2019.11.02.15.42.26.573.0 ]--
r 55                 return fromCost + findHeightDiff(th)
--[ 2019.11.02.15.42.26.651.0 ]--
r 55                 return fromCost + findHeightDiff(thi)
--[ 2019.11.02.15.42.26.729.0 ]--
r 55                 return fromCost + findHeightDiff(this)
--[ 2019.11.02.15.42.26.854.0 ]--
r 55                 return fromCost + findHeightDiff(this,)
--[ 2019.11.02.15.42.26.948.0 ]--
r 55                 return fromCost + findHeightDiff(this, )
--[ 2019.11.02.15.42.28.670.0 ]--
r 55                 return fromCost + findHeightDiff(this, b)
--[ 2019.11.02.15.42.29.932.0 ]--
r 55                 return fromCost + findHeightDiff(this, b) 
--[ 2019.11.02.15.42.30.119.0 ]--
r 55                 return fromCost + findHeightDiff(this, b) +
--[ 2019.11.02.15.42.30.166.0 ]--
r 55                 return fromCost + findHeightDiff(this, b) + 
--[ 2019.11.02.15.42.44.558.0 ]--
r 55                 return fromCost + findHeightDiff(this, b) + 1
--[ 2019.11.02.15.42.44.760.0 ]--
r 55                 return fromCost + findHeightDiff(this, b) + 1;
--[ 2019.11.02.15.44.15.248.0 ]--
r 96             for (Coord c : coords) {
--[ 2019.11.02.15.44.17.541.0 ]--
r 97                 s.push(new PFNode(c, this));
--[ 2019.11.02.15.44.50.979.0 ]--
r 50 
r 58 
r 168 
--[ 2019.11.02.15.44.52.496.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.02.15.45.05.199.0 ]--
+ 164         
--[ 2019.11.02.15.45.05.700.0 ]--
r 164         S
--[ 2019.11.02.15.45.05.929.0 ]--
r 164         St
--[ 2019.11.02.15.45.06.116.0 ]--
r 164         Std
--[ 2019.11.02.15.45.06.259.0 ]--
r 164         StdO
--[ 2019.11.02.15.45.06.463.0 ]--
r 164         StdOu
--[ 2019.11.02.15.45.06.588.0 ]--
r 164         StdOut
--[ 2019.11.02.15.45.06.714.0 ]--
r 164         StdOut.
--[ 2019.11.02.15.45.06.912.0 ]--
r 164         StdOut.p
--[ 2019.11.02.15.45.07.033.0 ]--
r 164         StdOut.pr
--[ 2019.11.02.15.45.07.115.0 ]--
r 164         StdOut.pri
--[ 2019.11.02.15.45.07.227.0 ]--
r 164         StdOut.prin
--[ 2019.11.02.15.45.07.308.0 ]--
r 164         StdOut.print
--[ 2019.11.02.15.45.07.393.0 ]--
r 164         StdOut.printl
--[ 2019.11.02.15.45.07.480.0 ]--
r 164         StdOut.println
--[ 2019.11.02.15.45.07.677.0 ]--
r 164         StdOut.println()
--[ 2019.11.02.15.45.07.883.0 ]--
r 164         StdOut.println("")
--[ 2019.11.02.15.45.08.884.0 ]--
r 164         StdOut.println("y")
--[ 2019.11.02.15.45.08.977.0 ]--
r 164         StdOut.println("ye")
--[ 2019.11.02.15.45.09.149.0 ]--
r 164         StdOut.println("yee")
--[ 2019.11.02.15.45.09.244.0 ]--
r 164         StdOut.println("yeet")
--[ 2019.11.02.15.45.09.548.0 ]--
r 164         StdOut.println("yeet"0)
--[ 2019.11.02.15.45.09.950.0 ]--
r 164         StdOut.println("yeet")
--[ 2019.11.02.15.45.10.363.0 ]--
r 164         StdOut.println("yeet");
--[ 2019.11.02.15.45.14.683.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.02.15.45.27.617.0 ]--
+ 164         
r 165         
--[ 2019.11.02.15.45.28.733.0 ]--
- 164
--[ 2019.11.02.15.45.31.206.0 ]--
r 164         p
--[ 2019.11.02.15.45.31.349.0 ]--
r 164         pq
--[ 2019.11.02.15.45.32.154.0 ]--
r 164         p
--[ 2019.11.02.15.45.32.283.0 ]--
r 164         
--[ 2019.11.02.15.45.32.548.0 ]--
r 164         f
--[ 2019.11.02.15.45.32.668.0 ]--
r 164         fo
--[ 2019.11.02.15.45.32.792.0 ]--
r 164         for
--[ 2019.11.02.15.45.32.867.0 ]--
r 164         for 
--[ 2019.11.02.15.45.33.127.0 ]--
r 164         for ()
--[ 2019.11.02.15.45.33.977.0 ]--
r 164         for (P)
--[ 2019.11.02.15.45.34.102.0 ]--
r 164         for (PF)
--[ 2019.11.02.15.45.34.784.0 ]--
r 164         for (PFN)
--[ 2019.11.02.15.45.35.231.0 ]--
r 164         for (PFNo)
--[ 2019.11.02.15.45.35.309.0 ]--
r 164         for (PFNod)
--[ 2019.11.02.15.45.35.529.0 ]--
r 164         for (PFNode)
--[ 2019.11.02.15.45.35.579.0 ]--
r 164         for (PFNode )
--[ 2019.11.02.15.45.37.193.0 ]--
r 164         for (PFNode n)
--[ 2019.11.02.15.45.38.412.0 ]--
r 164         for (PFNode n )
--[ 2019.11.02.15.45.39.185.0 ]--
r 164         for (PFNode n :)
--[ 2019.11.02.15.45.39.406.0 ]--
r 164         for (PFNode n : )
--[ 2019.11.02.15.45.40.134.0 ]--
r 164         for (PFNode n : p)
--[ 2019.11.02.15.45.40.228.0 ]--
r 164         for (PFNode n : pq)
--[ 2019.11.02.15.45.40.948.0 ]--
r 164         for (PFNode n : pq) 
--[ 2019.11.02.15.45.41.040.0 ]--
r 164         for (PFNode n : pq) {
--[ 2019.11.02.15.45.41.228.0 ]--
+ 165 
+ 166 }
--[ 2019.11.02.15.45.41.275.0 ]--
r 166         }
--[ 2019.11.02.15.45.41.322.0 ]--
r 165             
--[ 2019.11.02.15.45.43.019.0 ]--
r 165             S
--[ 2019.11.02.15.45.43.238.0 ]--
r 165             St
--[ 2019.11.02.15.45.43.458.0 ]--
r 165             Std
--[ 2019.11.02.15.45.43.599.0 ]--
r 165             StdO
--[ 2019.11.02.15.45.43.841.0 ]--
r 165             StdOu
--[ 2019.11.02.15.45.43.929.0 ]--
r 165             StdOut
--[ 2019.11.02.15.45.44.031.0 ]--
r 165             StdOut.
--[ 2019.11.02.15.45.44.261.0 ]--
r 165             StdOut.p
--[ 2019.11.02.15.45.44.379.0 ]--
r 165             StdOut.pr
--[ 2019.11.02.15.45.44.425.0 ]--
r 165             StdOut.pri
--[ 2019.11.02.15.45.44.583.0 ]--
r 165             StdOut.prin
--[ 2019.11.02.15.45.44.630.0 ]--
r 165             StdOut.print
--[ 2019.11.02.15.45.44.711.0 ]--
r 165             StdOut.printl
--[ 2019.11.02.15.45.44.800.0 ]--
r 165             StdOut.println
--[ 2019.11.02.15.45.45.000.0 ]--
r 165             StdOut.println()
--[ 2019.11.02.15.45.45.438.0 ]--
r 165             StdOut.println("")
--[ 2019.11.02.15.45.46.440.0 ]--
r 165             StdOut.println("n")
--[ 2019.11.02.15.45.46.479.0 ]--
r 165             StdOut.println("no")
--[ 2019.11.02.15.45.46.573.0 ]--
r 165             StdOut.println("nod")
--[ 2019.11.02.15.45.46.778.0 ]--
r 165             StdOut.println("node")
--[ 2019.11.02.15.45.46.916.0 ]--
r 165             StdOut.println("node:")
--[ 2019.11.02.15.45.47.063.0 ]--
r 165             StdOut.println("node: ")
--[ 2019.11.02.15.45.47.571.0 ]--
r 165             StdOut.println("node: " )
--[ 2019.11.02.15.45.47.751.0 ]--
r 165             StdOut.println("node: " +)
--[ 2019.11.02.15.45.47.818.0 ]--
r 165             StdOut.println("node: " + )
--[ 2019.11.02.15.45.49.238.0 ]--
r 165             StdOut.println("node: " + n)
--[ 2019.11.02.15.45.49.488.0 ]--
r 165             StdOut.println("node: " + n.)
--[ 2019.11.02.15.45.50.020.0 ]--
r 165             StdOut.println("node: " + n.g)
--[ 2019.11.02.15.45.50.107.0 ]--
r 165             StdOut.println("node: " + n.ge)
--[ 2019.11.02.15.45.50.279.0 ]--
r 165             StdOut.println("node: " + n.get)
--[ 2019.11.02.15.45.50.562.0 ]--
r 165             StdOut.println("node: " + n.getL)
--[ 2019.11.02.15.45.50.712.0 ]--
r 165             StdOut.println("node: " + n.getLo)
--[ 2019.11.02.15.45.50.775.0 ]--
r 165             StdOut.println("node: " + n.getLoc)
--[ 2019.11.02.15.45.51.026.0 ]--
r 165             StdOut.println("node: " + n.getLoc())
--[ 2019.11.02.15.45.51.708.0 ]--
r 165             StdOut.println("node: " + n.getLoc());
--[ 2019.11.02.15.45.54.975.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.02.15.46.36.841.0 ]--
UpdateTree (AD): 1 0
+ /heightmaps/writeupTest.txt

--[ 2019.11.02.15.46.45.243.0 ]--
UpdateTree (AD): 0 1
- /heightmaps/writeupTest.txt

--[ 2019.11.02.15.47.09.997.0 ]--
UpdateTree (AD): 1 0
+ /heightmaps/writeupTest.emap

--[ 2019.11.02.15.47.38.869.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 46     private final static String emapFilename = emaps[0;        // change index to load a different elevation map
--[ 2019.11.02.15.47.41.112.0 ]--
r 46     private final static String emapFilename = emaps[0];        // change index to load a different elevation map
--[ 2019.11.02.15.47.42.058.0 ]--
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.02.15.47.43.314.0 ]--
r 46     private final static String emapFilename = emaps[3];        // change index to load a different elevation map
--[ 2019.11.02.15.47.50.367.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.02.15.47.58.502.0 ]--
UpdateTree (AD): 1 0
+ /out/production/P04_Pathfinding/writeupTest.emap

--[ 2019.11.02.15.48.01.338.0 ]--
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.02.15.48.03.932.0 ]--
r 46     private final static String emapFilename = emaps[6];        // change index to load a different elevation map
--[ 2019.11.02.15.48.08.286.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.02.15.48.16.541.0 ]--
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.02.15.48.17.596.0 ]--
r 46     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2019.11.02.15.48.17.857.0 ]--
r 46     private final static String emapFilename = emaps[12];        // change index to load a different elevation map
--[ 2019.11.02.15.48.20.944.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.02.15.48.29.755.0 ]--
+ 44             
--[ 2019.11.02.15.48.30.823.0 ]--
r 44             ""
--[ 2019.11.02.15.48.31.286.0 ]--
r 44             "w"
--[ 2019.11.02.15.48.31.391.0 ]--
r 44             "wr"
--[ 2019.11.02.15.48.31.579.0 ]--
r 44             "wri"
--[ 2019.11.02.15.48.32.224.0 ]--
r 44             "writ"
--[ 2019.11.02.15.48.32.309.0 ]--
r 44             "write"
--[ 2019.11.02.15.48.32.408.0 ]--
r 44             "writeu"
--[ 2019.11.02.15.48.32.474.0 ]--
r 44             "writeup"
--[ 2019.11.02.15.48.32.746.0 ]--
r 44             "writeupT"
--[ 2019.11.02.15.48.33.016.0 ]--
r 44             "writeupTe"
--[ 2019.11.02.15.48.33.079.0 ]--
r 44             "writeupTes"
--[ 2019.11.02.15.48.33.173.0 ]--
r 44             "writeupTest"
--[ 2019.11.02.15.48.35.014.0 ]--
r 44             "writeupTest."
--[ 2019.11.02.15.48.35.249.0 ]--
r 44             "writeupTest.e"
--[ 2019.11.02.15.48.35.343.0 ]--
r 44             "writeupTest.em"
--[ 2019.11.02.15.48.35.437.0 ]--
r 44             "writeupTest.ema"
--[ 2019.11.02.15.48.35.578.0 ]--
r 44             "writeupTest.emap"
--[ 2019.11.02.15.48.37.590.0 ]--
r 44             "writeupTest.emap",
--[ 2019.11.02.15.48.38.407.0 ]--
r 44             "writeupTest.emap", 
--[ 2019.11.02.15.48.38.825.0 ]--
r 44             "writeupTest.emap",     
--[ 2019.11.02.15.48.39.467.0 ]--
r 44             "writeupTest.emap",     /
--[ 2019.11.02.15.48.39.619.0 ]--
r 44             "writeupTest.emap",     //
--[ 2019.11.02.15.48.39.777.0 ]--
r 44             "writeupTest.emap",     // 
--[ 2019.11.02.15.48.40.227.0 ]--
r 44             "writeupTest.emap",     // 1
--[ 2019.11.02.15.48.40.258.0 ]--
r 44             "writeupTest.emap",     // 12
--[ 2019.11.02.15.48.40.446.0 ]--
r 44             "writeupTest.emap",     // 12 
--[ 2019.11.02.15.48.40.767.0 ]--
r 44             "writeupTest.emap",     // 12 (
--[ 2019.11.02.15.48.42.471.0 ]--
r 44             "writeupTest.emap",     // 12 
--[ 2019.11.02.15.48.42.825.0 ]--
r 44             "writeupTest.emap",     // 12  
--[ 2019.11.02.15.48.43.467.0 ]--
r 44             "writeupTest.emap",     // 12  (
--[ 2019.11.02.15.48.44.397.0 ]--
r 44             "writeupTest.emap",     // 12  (b
--[ 2019.11.02.15.48.44.482.0 ]--
r 44             "writeupTest.emap",     // 12  (ba
--[ 2019.11.02.15.48.44.595.0 ]--
r 44             "writeupTest.emap",     // 12  (bas
--[ 2019.11.02.15.48.44.658.0 ]--
r 44             "writeupTest.emap",     // 12  (base
--[ 2019.11.02.15.48.44.861.0 ]--
r 44             "writeupTest.emap",     // 12  (based
--[ 2019.11.02.15.48.44.931.0 ]--
r 44             "writeupTest.emap",     // 12  (based 
--[ 2019.11.02.15.48.45.095.0 ]--
r 44             "writeupTest.emap",     // 12  (based o
--[ 2019.11.02.15.48.45.132.0 ]--
r 44             "writeupTest.emap",     // 12  (based on
--[ 2019.11.02.15.48.45.195.0 ]--
r 44             "writeupTest.emap",     // 12  (based on 
--[ 2019.11.02.15.48.45.319.0 ]--
r 44             "writeupTest.emap",     // 12  (based on t
--[ 2019.11.02.15.48.45.429.0 ]--
r 44             "writeupTest.emap",     // 12  (based on th
--[ 2019.11.02.15.48.45.476.0 ]--
r 44             "writeupTest.emap",     // 12  (based on the
--[ 2019.11.02.15.48.45.538.0 ]--
r 44             "writeupTest.emap",     // 12  (based on the 
--[ 2019.11.02.15.48.45.648.0 ]--
r 44             "writeupTest.emap",     // 12  (based on the w
--[ 2019.11.02.15.48.45.804.0 ]--
r 44             "writeupTest.emap",     // 12  (based on the wr
--[ 2019.11.02.15.48.45.851.0 ]--
r 44             "writeupTest.emap",     // 12  (based on the wri
--[ 2019.11.02.15.48.45.991.0 ]--
r 44             "writeupTest.emap",     // 12  (based on the writ
--[ 2019.11.02.15.48.46.038.0 ]--
r 44             "writeupTest.emap",     // 12  (based on the write
--[ 2019.11.02.15.48.46.101.0 ]--
r 44             "writeupTest.emap",     // 12  (based on the writeu
--[ 2019.11.02.15.48.46.179.0 ]--
r 44             "writeupTest.emap",     // 12  (based on the writeup
--[ 2019.11.02.15.48.46.383.0 ]--
r 44             "writeupTest.emap",     // 12  (based on the writeup)
--[ 2019.11.02.15.48.48.881.0 ]--
r 44             "writeupTest.emap",     // 12  (based on the writeup
--[ 2019.11.02.15.48.49.336.0 ]--
r 44             "writeupTest.emap",     // 12  (based on the writeu
--[ 2019.11.02.15.48.49.389.0 ]--
r 44             "writeupTest.emap",     // 12  (based on the write
--[ 2019.11.02.15.48.49.420.0 ]--
r 44             "writeupTest.emap",     // 12  (based on the writ
--[ 2019.11.02.15.48.49.452.0 ]--
r 44             "writeupTest.emap",     // 12  (based on the wri
--[ 2019.11.02.15.48.49.483.0 ]--
r 44             "writeupTest.emap",     // 12  (based on the wr
--[ 2019.11.02.15.48.49.498.0 ]--
r 44             "writeupTest.emap",     // 12  (based on the w
--[ 2019.11.02.15.48.49.530.0 ]--
r 44             "writeupTest.emap",     // 12  (based on the 
--[ 2019.11.02.15.48.49.561.0 ]--
r 44             "writeupTest.emap",     // 12  (based on the
--[ 2019.11.02.15.48.49.592.0 ]--
r 44             "writeupTest.emap",     // 12  (based on th
--[ 2019.11.02.15.48.49.624.0 ]--
r 44             "writeupTest.emap",     // 12  (based on t
--[ 2019.11.02.15.48.49.655.0 ]--
r 44             "writeupTest.emap",     // 12  (based on 
--[ 2019.11.02.15.48.49.686.0 ]--
r 44             "writeupTest.emap",     // 12  (based on
--[ 2019.11.02.15.48.49.717.0 ]--
r 44             "writeupTest.emap",     // 12  (based o
--[ 2019.11.02.15.48.49.748.0 ]--
r 44             "writeupTest.emap",     // 12  (based 
--[ 2019.11.02.15.48.49.795.0 ]--
r 44             "writeupTest.emap",     // 12  (based
--[ 2019.11.02.15.48.49.873.0 ]--
r 44             "writeupTest.emap",     // 12  (bas
--[ 2019.11.02.15.48.49.983.0 ]--
r 44             "writeupTest.emap",     // 12  (ba
--[ 2019.11.02.15.48.50.045.0 ]--
r 44             "writeupTest.emap",     // 12  (b
--[ 2019.11.02.15.48.50.250.0 ]--
r 44             "writeupTest.emap",     // 12  (
--[ 2019.11.02.15.48.50.897.0 ]--
r 44             "writeupTest.emap",     // 12  (ma
--[ 2019.11.02.15.48.51.038.0 ]--
r 44             "writeupTest.emap",     // 12  (map
--[ 2019.11.02.15.48.51.100.0 ]--
r 44             "writeupTest.emap",     // 12  (map 
--[ 2019.11.02.15.48.51.210.0 ]--
r 44             "writeupTest.emap",     // 12  (map f
--[ 2019.11.02.15.48.51.383.0 ]--
r 44             "writeupTest.emap",     // 12  (map fr
--[ 2019.11.02.15.48.51.474.0 ]--
r 44             "writeupTest.emap",     // 12  (map fro
--[ 2019.11.02.15.48.51.552.0 ]--
r 44             "writeupTest.emap",     // 12  (map from
--[ 2019.11.02.15.48.51.614.0 ]--
r 44             "writeupTest.emap",     // 12  (map from 
--[ 2019.11.02.15.48.51.724.0 ]--
r 44             "writeupTest.emap",     // 12  (map from w
--[ 2019.11.02.15.48.51.849.0 ]--
r 44             "writeupTest.emap",     // 12  (map from wr
--[ 2019.11.02.15.48.51.911.0 ]--
r 44             "writeupTest.emap",     // 12  (map from wri
--[ 2019.11.02.15.48.52.082.0 ]--
r 44             "writeupTest.emap",     // 12  (map from writ
--[ 2019.11.02.15.48.52.129.0 ]--
r 44             "writeupTest.emap",     // 12  (map from write
--[ 2019.11.02.15.48.52.176.0 ]--
r 44             "writeupTest.emap",     // 12  (map from writeu
--[ 2019.11.02.15.48.52.254.0 ]--
r 44             "writeupTest.emap",     // 12  (map from writeup
--[ 2019.11.02.15.48.53.145.0 ]--
r 44             "writeupTest.emap",     // 12  (map from writeup)
--[ 2019.11.02.15.49.48.614.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.02.15.50.37.028.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.02.15.55.30.298.0 ]--
:/src/Pathfinder.java
+ 163             
--[ 2019.11.02.15.55.35.369.0 ]--
r 163             b
--[ 2019.11.02.15.55.35.533.0 ]--
r 163             bo
--[ 2019.11.02.15.55.35.673.0 ]--
r 163             boa
--[ 2019.11.02.15.55.35.736.0 ]--
r 163             boar
--[ 2019.11.02.15.55.35.923.0 ]--
r 163             board
--[ 2019.11.02.15.55.35.970.0 ]--
r 163             board[]
--[ 2019.11.02.15.55.36.206.0 ]--
r 163             board[c]
--[ 2019.11.02.15.55.36.353.0 ]--
r 163             board[c.]
--[ 2019.11.02.15.55.36.605.0 ]--
r 163             board[c.g]
--[ 2019.11.02.15.55.36.683.0 ]--
r 163             board[c.ge]
--[ 2019.11.02.15.55.36.824.0 ]--
r 163             board[c.get]
--[ 2019.11.02.15.55.37.094.0 ]--
r 163             board[c.getI]
--[ 2019.11.02.15.55.37.424.0 ]--
r 163             board[c.getI()]
--[ 2019.11.02.15.55.38.756.0 ]--
r 163             board[c.getI()][]
--[ 2019.11.02.15.55.39.132.0 ]--
r 163             board[c.getI()][c]
--[ 2019.11.02.15.55.39.259.0 ]--
r 163             board[c.getI()][c.]
--[ 2019.11.02.15.55.39.462.0 ]--
r 163             board[c.getI()][c.g]
--[ 2019.11.02.15.55.39.526.0 ]--
r 163             board[c.getI()][c.ge]
--[ 2019.11.02.15.55.39.682.0 ]--
r 163             board[c.getI()][c.get]
--[ 2019.11.02.15.55.39.902.0 ]--
r 163             board[c.getI()][c.getJ]
--[ 2019.11.02.15.55.40.293.0 ]--
r 163             board[c.getI()][c.getJ()]
--[ 2019.11.02.15.55.41.436.0 ]--
r 163             board[c.getI()][c.getJ()] 
--[ 2019.11.02.15.55.41.561.0 ]--
r 163             board[c.getI()][c.getJ()] =
--[ 2019.11.02.15.55.41.592.0 ]--
r 163             board[c.getI()][c.getJ()] = 
--[ 2019.11.02.15.55.42.577.0 ]--
r 163             board[c.getI()][c.getJ()] = c
--[ 2019.11.02.15.55.42.682.0 ]--
r 163             board[c.getI()][c.getJ()] = c.
--[ 2019.11.02.15.55.44.588.0 ]--
r 163             board[c.getI()][c.getJ()] = c.g
--[ 2019.11.02.15.55.44.700.0 ]--
r 163             board[c.getI()][c.getJ()] = c.ge
--[ 2019.11.02.15.55.44.839.0 ]--
r 163             board[c.getI()][c.getJ()] = c.get
--[ 2019.11.02.15.55.45.688.0 ]--
r 163             board[c.getI()][c.getJ()] = c.ge
--[ 2019.11.02.15.55.45.880.0 ]--
r 163             board[c.getI()][c.getJ()] = c.g
--[ 2019.11.02.15.55.46.052.0 ]--
r 163             board[c.getI()][c.getJ()] = c.
--[ 2019.11.02.15.55.46.194.0 ]--
r 163             board[c.getI()][c.getJ()] = c
--[ 2019.11.02.15.55.46.335.0 ]--
r 163             board[c.getI()][c.getJ()] = 
--[ 2019.11.02.15.55.48.522.0 ]--
r 163             board[c.getI()][c.getJ()] = c
--[ 2019.11.02.15.55.48.836.0 ]--
r 163             board[c.getI()][c.getJ()] = cN
--[ 2019.11.02.15.55.48.979.0 ]--
r 163             board[c.getI()][c.getJ()] = cNo
--[ 2019.11.02.15.55.49.090.0 ]--
r 163             board[c.getI()][c.getJ()] = cNod
--[ 2019.11.02.15.55.49.328.0 ]--
r 163             board[c.getI()][c.getJ()] = cNode
--[ 2019.11.02.15.55.49.404.0 ]--
r 163             board[c.getI()][c.getJ()] = cNode.
--[ 2019.11.02.15.55.49.560.0 ]--
r 163             board[c.getI()][c.getJ()] = cNode.g
--[ 2019.11.02.15.55.49.607.0 ]--
r 163             board[c.getI()][c.getJ()] = cNode.ge
--[ 2019.11.02.15.55.49.780.0 ]--
r 163             board[c.getI()][c.getJ()] = cNode.get
--[ 2019.11.02.15.55.50.014.0 ]--
r 163             board[c.getI()][c.getJ()] = cNode.getC
--[ 2019.11.02.15.55.50.202.0 ]--
r 163             board[c.getI()][c.getJ()] = cNode.getCo
--[ 2019.11.02.15.55.50.423.0 ]--
r 163             board[c.getI()][c.getJ()] = cNode.getCos
--[ 2019.11.02.15.55.50.581.0 ]--
r 163             board[c.getI()][c.getJ()] = cNode.getCost
--[ 2019.11.02.15.55.50.832.0 ]--
r 163             board[c.getI()][c.getJ()] = cNode.getCost()
--[ 2019.11.02.15.55.51.083.0 ]--
r 163             board[c.getI()][c.getJ()] = cNode.getCost();
--[ 2019.11.02.16.02.48.178.0 ]--
+ 158         
--[ 2019.11.02.16.02.48.588.0 ]--
r 158         N
--[ 2019.11.02.16.02.48.793.0 ]--
r 158         No
--[ 2019.11.02.16.02.49.288.0 ]--
r 158         N
--[ 2019.11.02.16.02.49.500.0 ]--
r 158         
--[ 2019.11.02.16.02.49.931.0 ]--
r 158         P
--[ 2019.11.02.16.02.50.028.0 ]--
r 158         PF
--[ 2019.11.02.16.02.50.167.0 ]--
r 158         PFN
--[ 2019.11.02.16.02.50.743.0 ]--
r 158         PF
--[ 2019.11.02.16.02.50.937.0 ]--
r 158         P
--[ 2019.11.02.16.02.51.067.0 ]--
r 158         
--[ 2019.11.02.16.02.52.361.0 ]--
r 158         P
--[ 2019.11.02.16.02.52.491.0 ]--
r 158         PF
--[ 2019.11.02.16.02.52.871.0 ]--
r 158         PFN
--[ 2019.11.02.16.02.53.234.0 ]--
r 158         PFNo
--[ 2019.11.02.16.02.53.313.0 ]--
r 158         PFNod
--[ 2019.11.02.16.02.53.525.0 ]--
r 158         PFNode
--[ 2019.11.02.16.02.53.604.0 ]--
r 158         PFNode 
--[ 2019.11.02.16.02.53.706.0 ]--
r 158         PFNode s
--[ 2019.11.02.16.02.53.839.0 ]--
r 158         PFNode st
--[ 2019.11.02.16.02.53.954.0 ]--
r 158         PFNode sta
--[ 2019.11.02.16.02.54.078.0 ]--
r 158         PFNode star
--[ 2019.11.02.16.02.54.261.0 ]--
r 158         PFNode start
--[ 2019.11.02.16.02.54.448.0 ]--
r 158         PFNode startN
--[ 2019.11.02.16.02.54.605.0 ]--
r 158         PFNode startNo
--[ 2019.11.02.16.02.54.666.0 ]--
r 158         PFNode startNod
--[ 2019.11.02.16.02.54.872.0 ]--
r 158         PFNode startNode
--[ 2019.11.02.16.02.54.946.0 ]--
r 158         PFNode startNode 
--[ 2019.11.02.16.02.55.063.0 ]--
r 158         PFNode startNode
--[ 2019.11.02.16.02.55.117.0 ]--
r 158         PFNode startNode 
--[ 2019.11.02.16.02.56.026.0 ]--
r 158         PFNode startNode
--[ 2019.11.02.16.02.56.509.0 ]--
r 158         PFNode startNod
--[ 2019.11.02.16.02.56.551.0 ]--
r 158         PFNode startNo
--[ 2019.11.02.16.02.56.575.0 ]--
r 158         PFNode startN
--[ 2019.11.02.16.02.56.601.0 ]--
r 158         PFNode start
--[ 2019.11.02.16.02.56.634.0 ]--
r 158         PFNode star
--[ 2019.11.02.16.02.56.668.0 ]--
r 158         PFNode sta
--[ 2019.11.02.16.02.56.703.0 ]--
r 158         PFNode st
--[ 2019.11.02.16.02.56.733.0 ]--
r 158         PFNode s
--[ 2019.11.02.16.02.56.766.0 ]--
r 158         PFNode 
--[ 2019.11.02.16.02.56.806.0 ]--
r 158         PFNode
--[ 2019.11.02.16.02.56.833.0 ]--
r 158         PFNod
--[ 2019.11.02.16.02.56.875.0 ]--
r 158         PFNo
--[ 2019.11.02.16.02.57.066.0 ]--
r 158         PFN
--[ 2019.11.02.16.02.57.219.0 ]--
r 158         PF
--[ 2019.11.02.16.02.57.386.0 ]--
r 158         P
--[ 2019.11.02.16.02.57.562.0 ]--
r 158         
--[ 2019.11.02.16.02.57.903.0 ]--
r 158         c
--[ 2019.11.02.16.02.58.003.0 ]--
r 158         co
--[ 2019.11.02.16.02.58.146.0 ]--
r 158         coo
--[ 2019.11.02.16.02.58.350.0 ]--
r 158         co
--[ 2019.11.02.16.02.58.537.0 ]--
r 158         c
--[ 2019.11.02.16.02.58.696.0 ]--
r 158         
--[ 2019.11.02.16.02.59.059.0 ]--
r 158         C
--[ 2019.11.02.16.02.59.287.0 ]--
r 158         Co
--[ 2019.11.02.16.02.59.550.0 ]--
r 158         Coor
--[ 2019.11.02.16.02.59.796.0 ]--
r 158         Coord
--[ 2019.11.02.16.02.59.827.0 ]--
r 158         Coord 
--[ 2019.11.02.16.03.00.410.0 ]--
r 158         Coord c
--[ 2019.11.02.16.03.00.512.0 ]--
r 158         Coord cu
--[ 2019.11.02.16.03.00.662.0 ]--
r 158         Coord cur
--[ 2019.11.02.16.03.00.834.0 ]--
r 158         Coord curr
--[ 2019.11.02.16.03.00.909.0 ]--
r 158         Coord curre
--[ 2019.11.02.16.03.01.071.0 ]--
r 158         Coord curren
--[ 2019.11.02.16.03.01.093.0 ]--
r 158         Coord current
--[ 2019.11.02.16.03.01.347.0 ]--
r 158         Coord currentL
--[ 2019.11.02.16.03.01.500.0 ]--
r 158         Coord currentLo
--[ 2019.11.02.16.03.01.552.0 ]--
r 158         Coord currentLoc
--[ 2019.11.02.16.03.01.669.0 ]--
r 158         Coord currentLoc 
--[ 2019.11.02.16.03.01.799.0 ]--
r 158         Coord currentLoc =
--[ 2019.11.02.16.03.01.883.0 ]--
r 158         Coord currentLoc = 
--[ 2019.11.02.16.03.02.604.0 ]--
r 158         Coord currentLoc = s
--[ 2019.11.02.16.03.02.690.0 ]--
r 158         Coord currentLoc = st
--[ 2019.11.02.16.03.02.772.0 ]--
r 158         Coord currentLoc = sta
--[ 2019.11.02.16.03.02.889.0 ]--
r 158         Coord currentLoc = star
--[ 2019.11.02.16.03.03.082.0 ]--
r 158         Coord currentLoc = start
--[ 2019.11.02.16.03.03.137.0 ]--
r 158         Coord currentLoc = start;
--[ 2019.11.02.16.03.03.486.0 ]--
r 158         Coord currentLoc = start
--[ 2019.11.02.16.03.03.670.0 ]--
r 158         Coord currentLoc = star
--[ 2019.11.02.16.03.03.822.0 ]--
r 158         Coord currentLoc = sta
--[ 2019.11.02.16.03.03.980.0 ]--
r 158         Coord currentLoc = st
--[ 2019.11.02.16.03.04.163.0 ]--
r 158         Coord currentLoc = s
--[ 2019.11.02.16.03.04.312.0 ]--
r 158         Coord currentLoc = 
--[ 2019.11.02.16.03.04.548.0 ]--
r 158         Coord currentLoc = g
--[ 2019.11.02.16.03.04.646.0 ]--
r 158         Coord currentLoc = ge
--[ 2019.11.02.16.03.04.780.0 ]--
r 158         Coord currentLoc = get
--[ 2019.11.02.16.03.05.509.0 ]--
r 158         Coord currentLoc = getP
--[ 2019.11.02.16.03.05.698.0 ]--
r 158         Coord currentLoc = getPa
--[ 2019.11.02.16.03.05.760.0 ]--
r 158         Coord currentLoc = getPat
--[ 2019.11.02.16.03.05.827.0 ]--
r 158         Coord currentLoc = getPath
--[ 2019.11.02.16.03.06.032.0 ]--
r 158         Coord currentLoc = getPathS
--[ 2019.11.02.16.03.06.262.0 ]--
r 158         Coord currentLoc = getPathSt
--[ 2019.11.02.16.03.06.352.0 ]--
r 158         Coord currentLoc = getPathSta
--[ 2019.11.02.16.03.06.508.0 ]--
r 158         Coord currentLoc = getPathStar
--[ 2019.11.02.16.03.06.693.0 ]--
r 158         Coord currentLoc = getPathStart
--[ 2019.11.02.16.03.06.873.0 ]--
r 158         Coord currentLoc = getPathStart()
--[ 2019.11.02.16.03.07.126.0 ]--
r 158         Coord currentLoc = getPathStart();
--[ 2019.11.02.16.03.07.465.0 ]--
+ 159         
--[ 2019.11.02.16.03.11.519.0 ]--
r 159         w
--[ 2019.11.02.16.03.11.758.0 ]--
r 159         whi
--[ 2019.11.02.16.03.11.848.0 ]--
r 159         whil
--[ 2019.11.02.16.03.11.919.0 ]--
r 159         while
--[ 2019.11.02.16.03.12.003.0 ]--
r 159         while 
--[ 2019.11.02.16.03.12.162.0 ]--
r 159         while ()
--[ 2019.11.02.16.03.12.268.0 ]--
r 159         while (t)
--[ 2019.11.02.16.03.12.483.0 ]--
r 159         while (tr)
--[ 2019.11.02.16.03.12.568.0 ]--
r 159         while (tru)
--[ 2019.11.02.16.03.12.639.0 ]--
r 159         while (true)
--[ 2019.11.02.16.03.13.059.0 ]--
r 159         while (true) 
--[ 2019.11.02.16.03.13.221.0 ]--
r 159         while (true) {
--[ 2019.11.02.16.03.13.338.0 ]--
+ 160 
+ 161 }
--[ 2019.11.02.16.03.13.394.0 ]--
r 161         }
--[ 2019.11.02.16.03.13.419.0 ]--
r 160             
--[ 2019.11.02.16.03.27.280.0 ]--
r 160             P
--[ 2019.11.02.16.03.27.523.0 ]--
r 160             PF
--[ 2019.11.02.16.03.27.554.0 ]--
r 160             PFN
--[ 2019.11.02.16.03.27.806.0 ]--
r 160             PFNo
--[ 2019.11.02.16.03.27.947.0 ]--
r 160             PFNod
--[ 2019.11.02.16.03.28.145.0 ]--
r 160             PFNode
--[ 2019.11.02.16.03.28.195.0 ]--
r 160             PFNode 
--[ 2019.11.02.16.03.28.331.0 ]--
r 160             PFNode c
--[ 2019.11.02.16.03.28.402.0 ]--
r 160             PFNode cu
--[ 2019.11.02.16.03.28.584.0 ]--
r 160             PFNode cur
--[ 2019.11.02.16.03.28.779.0 ]--
r 160             PFNode curr
--[ 2019.11.02.16.03.29.039.0 ]--
r 160             PFNode curre
--[ 2019.11.02.16.03.29.191.0 ]--
r 160             PFNode curren
--[ 2019.11.02.16.03.29.243.0 ]--
r 160             PFNode current
--[ 2019.11.02.16.03.29.435.0 ]--
r 160             PFNode currentN
--[ 2019.11.02.16.03.29.624.0 ]--
r 160             PFNode currentNo
--[ 2019.11.02.16.03.29.679.0 ]--
r 160             PFNode currentNod
--[ 2019.11.02.16.03.29.843.0 ]--
r 160             PFNode currentNode
--[ 2019.11.02.16.03.29.873.0 ]--
r 160             PFNode currentNode 
--[ 2019.11.02.16.03.30.005.0 ]--
r 160             PFNode currentNode =
--[ 2019.11.02.16.03.30.063.0 ]--
r 160             PFNode currentNode = 
--[ 2019.11.02.16.03.32.151.0 ]--
r 160             PFNode currentNode = n
--[ 2019.11.02.16.03.32.255.0 ]--
r 160             PFNode currentNode = ne
--[ 2019.11.02.16.03.32.320.0 ]--
r 160             PFNode currentNode = new
--[ 2019.11.02.16.03.32.655.0 ]--
r 160             PFNode currentNode = ne
--[ 2019.11.02.16.03.33.158.0 ]--
r 160             PFNode currentNode = n
--[ 2019.11.02.16.03.33.191.0 ]--
r 160             PFNode currentNode = 
--[ 2019.11.02.16.03.33.221.0 ]--
r 160             PFNode currentNode =
--[ 2019.11.02.16.03.33.260.0 ]--
r 160             PFNode currentNode 
--[ 2019.11.02.16.03.33.291.0 ]--
r 160             PFNode currentNode
--[ 2019.11.02.16.03.33.320.0 ]--
r 160             PFNode currentNod
--[ 2019.11.02.16.03.33.355.0 ]--
r 160             PFNode currentNo
--[ 2019.11.02.16.03.33.387.0 ]--
r 160             PFNode currentN
--[ 2019.11.02.16.03.33.421.0 ]--
r 160             PFNode current
--[ 2019.11.02.16.03.33.454.0 ]--
r 160             PFNode curren
--[ 2019.11.02.16.03.33.489.0 ]--
r 160             PFNode curre
--[ 2019.11.02.16.03.33.518.0 ]--
r 160             PFNode curr
--[ 2019.11.02.16.03.33.554.0 ]--
r 160             PFNode cur
--[ 2019.11.02.16.03.33.586.0 ]--
r 160             PFNode cu
--[ 2019.11.02.16.03.33.620.0 ]--
r 160             PFNode c
--[ 2019.11.02.16.03.33.653.0 ]--
r 160             PFNode 
--[ 2019.11.02.16.03.33.686.0 ]--
r 160             PFNode
--[ 2019.11.02.16.03.33.718.0 ]--
r 160             PFNod
--[ 2019.11.02.16.03.33.756.0 ]--
r 160             PFNo
--[ 2019.11.02.16.03.33.898.0 ]--
r 160             PFN
--[ 2019.11.02.16.03.34.100.0 ]--
r 160             PF
--[ 2019.11.02.16.03.34.267.0 ]--
r 160             P
--[ 2019.11.02.16.03.34.595.0 ]--
r 160             
--[ 2019.11.02.16.03.35.312.0 ]--
r 160             i
--[ 2019.11.02.16.03.35.388.0 ]--
r 160             if
--[ 2019.11.02.16.03.35.489.0 ]--
r 160             if 
--[ 2019.11.02.16.03.35.667.0 ]--
r 160             if ()
--[ 2019.11.02.16.03.35.831.0 ]--
r 160             if (c)
--[ 2019.11.02.16.03.35.922.0 ]--
r 160             if (cu)
--[ 2019.11.02.16.03.36.079.0 ]--
r 160             if (cur)
--[ 2019.11.02.16.03.36.270.0 ]--
r 160             if (curr)
--[ 2019.11.02.16.03.36.322.0 ]--
r 160             if (curre)
--[ 2019.11.02.16.03.36.523.0 ]--
r 160             if (curren)
--[ 2019.11.02.16.03.36.580.0 ]--
r 160             if (current)
--[ 2019.11.02.16.03.36.833.0 ]--
r 160             if (currentL)
--[ 2019.11.02.16.03.37.078.0 ]--
r 160             if (currentLo)
--[ 2019.11.02.16.03.37.163.0 ]--
r 160             if (currentLoc)
--[ 2019.11.02.16.03.37.226.0 ]--
r 160             if (currentLoc )
--[ 2019.11.02.16.03.37.344.0 ]--
r 160             if (currentLoc =)
--[ 2019.11.02.16.03.37.606.0 ]--
r 160             if (currentLoc == )
--[ 2019.11.02.16.03.37.731.0 ]--
r 160             if (currentLoc == p)
--[ 2019.11.02.16.03.38.064.0 ]--
r 160             if (currentLoc == )
--[ 2019.11.02.16.03.38.256.0 ]--
r 160             if (currentLoc == g)
--[ 2019.11.02.16.03.38.313.0 ]--
r 160             if (currentLoc == ge)
--[ 2019.11.02.16.03.38.487.0 ]--
r 160             if (currentLoc == get)
--[ 2019.11.02.16.03.38.640.0 ]--
r 160             if (currentLoc == getP)
--[ 2019.11.02.16.03.38.829.0 ]--
r 160             if (currentLoc == getPa)
--[ 2019.11.02.16.03.38.907.0 ]--
r 160             if (currentLoc == getPat)
--[ 2019.11.02.16.03.39.037.0 ]--
r 160             if (currentLoc == getPath)
--[ 2019.11.02.16.03.39.123.0 ]--
r 160             if (currentLoc == getPatha)
--[ 2019.11.02.16.03.39.518.0 ]--
r 160             if (currentLoc == getPath)
--[ 2019.11.02.16.03.39.773.0 ]--
r 160             if (currentLoc == getPathS)
--[ 2019.11.02.16.03.39.929.0 ]--
r 160             if (currentLoc == getPathSt)
--[ 2019.11.02.16.03.40.118.0 ]--
r 160             if (currentLoc == getPathSta)
--[ 2019.11.02.16.03.40.195.0 ]--
r 160             if (currentLoc == getPathStar)
--[ 2019.11.02.16.03.40.379.0 ]--
r 160             if (currentLoc == getPathStart)
--[ 2019.11.02.16.03.40.516.0 ]--
r 160             if (currentLoc == getPathStart())
--[ 2019.11.02.16.03.41.174.0 ]--
r 160             if (currentLoc == getPathStart()) 
--[ 2019.11.02.16.03.41.251.0 ]--
r 160             if (currentLoc == getPathStart()) {
--[ 2019.11.02.16.03.41.434.0 ]--
+ 161 
+ 162 }
--[ 2019.11.02.16.03.41.492.0 ]--
r 162             }
--[ 2019.11.02.16.03.41.514.0 ]--
r 161                 
--[ 2019.11.02.16.03.41.900.0 ]--
- 161
--[ 2019.11.02.16.03.42.070.0 ]--
r 160             if (currentLoc == getPathStart()) 
--[ 2019.11.02.16.03.43.536.0 ]--
r 161             }\
--[ 2019.11.02.16.03.43.991.0 ]--
r 161             }
--[ 2019.11.02.16.03.44.183.0 ]--
r 161             
--[ 2019.11.02.16.03.44.371.0 ]--
- 160
r 160             if (currentLoc == getPathStart())
--[ 2019.11.02.16.03.45.817.0 ]--
r 160             if (currentLoc == getPathStart()) 
--[ 2019.11.02.16.03.49.273.0 ]--
+ 160             
--[ 2019.11.02.16.03.50.319.0 ]--
r 160             C
--[ 2019.11.02.16.03.50.504.0 ]--
r 160             Co
--[ 2019.11.02.16.03.50.633.0 ]--
r 160             Coo
--[ 2019.11.02.16.03.50.710.0 ]--
r 160             Coor
--[ 2019.11.02.16.03.50.894.0 ]--
r 160             Coord
--[ 2019.11.02.16.03.50.967.0 ]--
r 160             Coord 
--[ 2019.11.02.16.03.51.115.0 ]--
r 160             Coord c
--[ 2019.11.02.16.03.51.177.0 ]--
r 160             Coord cu
--[ 2019.11.02.16.03.51.362.0 ]--
r 160             Coord cur
--[ 2019.11.02.16.03.51.531.0 ]--
r 160             Coord curr
--[ 2019.11.02.16.03.51.618.0 ]--
r 160             Coord curre
--[ 2019.11.02.16.03.51.735.0 ]--
r 160             Coord curren
--[ 2019.11.02.16.03.51.778.0 ]--
r 160             Coord current
--[ 2019.11.02.16.03.51.947.0 ]--
r 160             Coord currentL
--[ 2019.11.02.16.03.52.079.0 ]--
r 160             Coord currentLo
--[ 2019.11.02.16.03.52.147.0 ]--
r 160             Coord currentLoc
--[ 2019.11.02.16.03.52.242.0 ]--
r 160             Coord currentLoc;
--[ 2019.11.02.16.03.52.734.0 ]--
r 160             Coord currentLoc
--[ 2019.11.02.16.03.53.223.0 ]--
r 160             Coord currentLo
--[ 2019.11.02.16.03.53.256.0 ]--
r 160             Coord currentL
--[ 2019.11.02.16.03.53.289.0 ]--
r 160             Coord current
--[ 2019.11.02.16.03.53.321.0 ]--
r 160             Coord curren
--[ 2019.11.02.16.03.53.354.0 ]--
r 160             Coord curre
--[ 2019.11.02.16.03.53.388.0 ]--
r 160             Coord curr
--[ 2019.11.02.16.03.53.420.0 ]--
r 160             Coord cur
--[ 2019.11.02.16.03.53.454.0 ]--
r 160             Coord cu
--[ 2019.11.02.16.03.53.488.0 ]--
r 160             Coord c
--[ 2019.11.02.16.03.53.520.0 ]--
r 160             Coord 
--[ 2019.11.02.16.03.53.556.0 ]--
r 160             Coord
--[ 2019.11.02.16.03.53.587.0 ]--
r 160             Coor
--[ 2019.11.02.16.03.53.617.0 ]--
r 160             Coo
--[ 2019.11.02.16.03.53.822.0 ]--
r 160             Co
--[ 2019.11.02.16.03.54.034.0 ]--
r 160             C
--[ 2019.11.02.16.03.54.280.0 ]--
r 160             
--[ 2019.11.02.16.03.54.970.0 ]--
r 160             P
--[ 2019.11.02.16.03.55.076.0 ]--
r 160             PF
--[ 2019.11.02.16.03.55.210.0 ]--
r 160             PFN
--[ 2019.11.02.16.03.55.516.0 ]--
r 160             PFNo
--[ 2019.11.02.16.03.55.612.0 ]--
r 160             PFNod
--[ 2019.11.02.16.03.55.823.0 ]--
r 160             PFNode
--[ 2019.11.02.16.03.55.912.0 ]--
r 160             PFNode 
--[ 2019.11.02.16.03.56.047.0 ]--
r 160             PFNode c
--[ 2019.11.02.16.03.56.092.0 ]--
r 160             PFNode cu
--[ 2019.11.02.16.03.56.303.0 ]--
r 160             PFNode cur
--[ 2019.11.02.16.03.56.460.0 ]--
r 160             PFNode curr
--[ 2019.11.02.16.03.56.531.0 ]--
r 160             PFNode curre
--[ 2019.11.02.16.03.56.674.0 ]--
r 160             PFNode curren
--[ 2019.11.02.16.03.56.749.0 ]--
r 160             PFNode current
--[ 2019.11.02.16.03.57.220.0 ]--
r 160             PFNode currentN
--[ 2019.11.02.16.03.57.422.0 ]--
r 160             PFNode currentNo
--[ 2019.11.02.16.03.57.488.0 ]--
r 160             PFNode currentNod
--[ 2019.11.02.16.03.57.645.0 ]--
r 160             PFNode currentNode
--[ 2019.11.02.16.03.57.706.0 ]--
r 160             PFNode currentNode;
--[ 2019.11.02.16.04.07.801.0 ]--
r 161             if (currentLoc == getPathStart()) c
--[ 2019.11.02.16.04.08.020.0 ]--
r 161             if (currentLoc == getPathStart()) cu
--[ 2019.11.02.16.04.08.227.0 ]--
r 161             if (currentLoc == getPathStart()) cur
--[ 2019.11.02.16.04.08.423.0 ]--
r 161             if (currentLoc == getPathStart()) curr
--[ 2019.11.02.16.04.08.473.0 ]--
r 161             if (currentLoc == getPathStart()) curre
--[ 2019.11.02.16.04.08.626.0 ]--
r 161             if (currentLoc == getPathStart()) curren
--[ 2019.11.02.16.04.08.664.0 ]--
r 161             if (currentLoc == getPathStart()) current
--[ 2019.11.02.16.04.08.827.0 ]--
r 161             if (currentLoc == getPathStart()) currentN
--[ 2019.11.02.16.04.09.010.0 ]--
r 161             if (currentLoc == getPathStart()) currentNo
--[ 2019.11.02.16.04.09.063.0 ]--
r 161             if (currentLoc == getPathStart()) currentNod
--[ 2019.11.02.16.04.09.260.0 ]--
r 161             if (currentLoc == getPathStart()) currentNode
--[ 2019.11.02.16.04.09.318.0 ]--
r 161             if (currentLoc == getPathStart()) currentNode 
--[ 2019.11.02.16.04.09.431.0 ]--
r 161             if (currentLoc == getPathStart()) currentNode =
--[ 2019.11.02.16.04.09.500.0 ]--
r 161             if (currentLoc == getPathStart()) currentNode = 
--[ 2019.11.02.16.04.09.762.0 ]--
r 161             if (currentLoc == getPathStart()) currentNode = n
--[ 2019.11.02.16.04.09.875.0 ]--
r 161             if (currentLoc == getPathStart()) currentNode = ne
--[ 2019.11.02.16.04.09.952.0 ]--
r 161             if (currentLoc == getPathStart()) currentNode = new
--[ 2019.11.02.16.04.10.097.0 ]--
r 161             if (currentLoc == getPathStart()) currentNode = new 
--[ 2019.11.02.16.04.10.645.0 ]--
r 161             if (currentLoc == getPathStart()) currentNode = new P
--[ 2019.11.02.16.04.10.715.0 ]--
r 161             if (currentLoc == getPathStart()) currentNode = new PF
--[ 2019.11.02.16.04.10.915.0 ]--
r 161             if (currentLoc == getPathStart()) currentNode = new PFN
--[ 2019.11.02.16.04.11.299.0 ]--
r 161             if (currentLoc == getPathStart()) currentNode = new PFNo
--[ 2019.11.02.16.04.11.392.0 ]--
r 161             if (currentLoc == getPathStart()) currentNode = new PFNod
--[ 2019.11.02.16.04.11.603.0 ]--
r 161             if (currentLoc == getPathStart()) currentNode = new PFNode
--[ 2019.11.02.16.04.11.754.0 ]--
r 161             if (currentLoc == getPathStart()) currentNode = new PFNode()
--[ 2019.11.02.16.04.12.953.0 ]--
r 161             if (currentLoc == getPathStart()) currentNode = new PFNode(c)
--[ 2019.11.02.16.04.13.154.0 ]--
r 161             if (currentLoc == getPathStart()) currentNode = new PFNode(cu)
--[ 2019.11.02.16.04.13.495.0 ]--
r 161             if (currentLoc == getPathStart()) currentNode = new PFNode(cur)
--[ 2019.11.02.16.04.14.120.0 ]--
r 161             if (currentLoc == getPathStart()) currentNode = new PFNode(curr)
--[ 2019.11.02.16.04.14.273.0 ]--
r 161             if (currentLoc == getPathStart()) currentNode = new PFNode(curre)
--[ 2019.11.02.16.04.14.417.0 ]--
r 161             if (currentLoc == getPathStart()) currentNode = new PFNode(curren)
--[ 2019.11.02.16.04.14.469.0 ]--
r 161             if (currentLoc == getPathStart()) currentNode = new PFNode(current)
--[ 2019.11.02.16.04.14.656.0 ]--
r 161             if (currentLoc == getPathStart()) currentNode = new PFNode(currentL)
--[ 2019.11.02.16.04.14.795.0 ]--
r 161             if (currentLoc == getPathStart()) currentNode = new PFNode(currentLo)
--[ 2019.11.02.16.04.14.834.0 ]--
r 161             if (currentLoc == getPathStart()) currentNode = new PFNode(currentLoc)
--[ 2019.11.02.16.04.14.977.0 ]--
r 161             if (currentLoc == getPathStart()) currentNode = new PFNode(currentLoc,)
--[ 2019.11.02.16.04.15.059.0 ]--
r 161             if (currentLoc == getPathStart()) currentNode = new PFNode(currentLoc, )
--[ 2019.11.02.16.04.15.172.0 ]--
r 161             if (currentLoc == getPathStart()) currentNode = new PFNode(currentLoc, n)
--[ 2019.11.02.16.04.15.436.0 ]--
r 161             if (currentLoc == getPathStart()) currentNode = new PFNode(currentLoc, nu)
--[ 2019.11.02.16.04.15.576.0 ]--
r 161             if (currentLoc == getPathStart()) currentNode = new PFNode(currentLoc, nul)
--[ 2019.11.02.16.04.15.721.0 ]--
r 161             if (currentLoc == getPathStart()) currentNode = new PFNode(currentLoc, null)
--[ 2019.11.02.16.04.16.659.0 ]--
r 161             if (currentLoc == getPathStart()) currentNode = new PFNode(currentLoc, null);
--[ 2019.11.02.16.04.18.847.0 ]--
+ 162             
--[ 2019.11.02.16.04.21.344.0 ]--
r 162             e
--[ 2019.11.02.16.04.21.445.0 ]--
r 162             el
--[ 2019.11.02.16.04.21.571.0 ]--
r 162             els
--[ 2019.11.02.16.04.21.608.0 ]--
r 162             else
--[ 2019.11.02.16.04.21.674.0 ]--
r 162             else 
--[ 2019.11.02.16.04.23.075.0 ]--
r 162             else c
--[ 2019.11.02.16.04.23.211.0 ]--
r 162             else cu
--[ 2019.11.02.16.04.23.335.0 ]--
r 162             else cur
--[ 2019.11.02.16.04.23.505.0 ]--
r 162             else curr
--[ 2019.11.02.16.04.23.584.0 ]--
r 162             else curre
--[ 2019.11.02.16.04.23.738.0 ]--
r 162             else curren
--[ 2019.11.02.16.04.23.771.0 ]--
r 162             else current
--[ 2019.11.02.16.04.24.033.0 ]--
r 162             else currentN
--[ 2019.11.02.16.04.24.221.0 ]--
r 162             else currentNo
--[ 2019.11.02.16.04.24.278.0 ]--
r 162             else currentNod
--[ 2019.11.02.16.04.24.463.0 ]--
r 162             else currentNode
--[ 2019.11.02.16.04.24.547.0 ]--
r 162             else currentNode 
--[ 2019.11.02.16.04.24.675.0 ]--
r 162             else currentNode =
--[ 2019.11.02.16.04.24.783.0 ]--
r 162             else currentNode = 
--[ 2019.11.02.16.04.24.890.0 ]--
r 162             else currentNode = n
--[ 2019.11.02.16.04.24.931.0 ]--
r 162             else currentNode = ne
--[ 2019.11.02.16.04.25.025.0 ]--
r 162             else currentNode = new
--[ 2019.11.02.16.04.25.368.0 ]--
r 162             else currentNode = new 
--[ 2019.11.02.16.04.25.576.0 ]--
r 162             else currentNode = new P
--[ 2019.11.02.16.04.25.667.0 ]--
r 162             else currentNode = new PF
--[ 2019.11.02.16.04.25.802.0 ]--
r 162             else currentNode = new PFN
--[ 2019.11.02.16.04.26.063.0 ]--
r 162             else currentNode = new PFNo
--[ 2019.11.02.16.04.26.159.0 ]--
r 162             else currentNode = new PFNod
--[ 2019.11.02.16.04.26.352.0 ]--
r 162             else currentNode = new PFNode
--[ 2019.11.02.16.04.26.501.0 ]--
r 162             else currentNode = new PFNode()
--[ 2019.11.02.16.04.26.671.0 ]--
r 162             else currentNode = new PFNode(c)
--[ 2019.11.02.16.04.26.734.0 ]--
r 162             else currentNode = new PFNode(cu)
--[ 2019.11.02.16.04.26.896.0 ]--
r 162             else currentNode = new PFNode(cur)
--[ 2019.11.02.16.04.27.060.0 ]--
r 162             else currentNode = new PFNode(curr)
--[ 2019.11.02.16.04.27.127.0 ]--
r 162             else currentNode = new PFNode(curre)
--[ 2019.11.02.16.04.27.233.0 ]--
r 162             else currentNode = new PFNode(curren)
--[ 2019.11.02.16.04.27.350.0 ]--
r 162             else currentNode = new PFNode(current)
--[ 2019.11.02.16.04.27.494.0 ]--
r 162             else currentNode = new PFNode(currentL)
--[ 2019.11.02.16.04.27.640.0 ]--
r 162             else currentNode = new PFNode(currentLo)
--[ 2019.11.02.16.04.27.695.0 ]--
r 162             else currentNode = new PFNode(currentLoc)
--[ 2019.11.02.16.04.27.820.0 ]--
r 162             else currentNode = new PFNode(currentLoc,)
--[ 2019.11.02.16.04.27.875.0 ]--
r 162             else currentNode = new PFNode(currentLoc, )
--[ 2019.11.02.16.05.02.259.0 ]--
r 162             else currentNode = new PFNode(currentLoc, 
--[ 2019.11.02.16.05.02.759.0 ]--
r 162             else currentNode = new PFNode(currentLoc,
--[ 2019.11.02.16.05.02.791.0 ]--
r 162             else currentNode = new PFNode(currentLoc
--[ 2019.11.02.16.05.02.824.0 ]--
r 162             else currentNode = new PFNode(currentLo
--[ 2019.11.02.16.05.02.858.0 ]--
r 162             else currentNode = new PFNode(currentL
--[ 2019.11.02.16.05.02.887.0 ]--
r 162             else currentNode = new PFNode(current
--[ 2019.11.02.16.05.02.923.0 ]--
r 162             else currentNode = new PFNode(curren
--[ 2019.11.02.16.05.02.956.0 ]--
r 162             else currentNode = new PFNode(curre
--[ 2019.11.02.16.05.02.990.0 ]--
r 162             else currentNode = new PFNode(curr
--[ 2019.11.02.16.05.03.023.0 ]--
r 162             else currentNode = new PFNode(cur
--[ 2019.11.02.16.05.03.053.0 ]--
r 162             else currentNode = new PFNode(cu
--[ 2019.11.02.16.05.03.088.0 ]--
r 162             else currentNode = new PFNode(c
--[ 2019.11.02.16.05.03.124.0 ]--
r 162             else currentNode = new PFNode(
--[ 2019.11.02.16.05.03.153.0 ]--
r 162             else currentNode = new PFNode
--[ 2019.11.02.16.05.03.187.0 ]--
r 162             else currentNode = new PFNod
--[ 2019.11.02.16.05.03.223.0 ]--
r 162             else currentNode = new PFNo
--[ 2019.11.02.16.05.03.253.0 ]--
r 162             else currentNode = new PFN
--[ 2019.11.02.16.05.03.286.0 ]--
r 162             else currentNode = new PF
--[ 2019.11.02.16.05.03.327.0 ]--
r 162             else currentNode = new P
--[ 2019.11.02.16.05.03.367.0 ]--
r 162             else currentNode = new 
--[ 2019.11.02.16.05.03.394.0 ]--
r 162             else currentNode = new
--[ 2019.11.02.16.05.03.423.0 ]--
r 162             else currentNode = ne
--[ 2019.11.02.16.05.03.452.0 ]--
r 162             else currentNode = n
--[ 2019.11.02.16.05.03.484.0 ]--
r 162             else currentNode = 
--[ 2019.11.02.16.05.03.517.0 ]--
r 162             else currentNode =
--[ 2019.11.02.16.05.04.143.0 ]--
r 162             else currentNode 
--[ 2019.11.02.16.05.04.615.0 ]--
r 162             else currentNode
--[ 2019.11.02.16.05.04.649.0 ]--
r 162             else currentNod
--[ 2019.11.02.16.05.04.681.0 ]--
r 162             else currentNo
--[ 2019.11.02.16.05.04.715.0 ]--
r 162             else currentN
--[ 2019.11.02.16.05.04.748.0 ]--
r 162             else current
--[ 2019.11.02.16.05.04.781.0 ]--
r 162             else curren
--[ 2019.11.02.16.05.04.967.0 ]--
r 162             else curre
--[ 2019.11.02.16.05.05.174.0 ]--
r 162             else curr
--[ 2019.11.02.16.05.05.341.0 ]--
r 162             else cur
--[ 2019.11.02.16.05.05.533.0 ]--
r 162             else cu
--[ 2019.11.02.16.05.05.704.0 ]--
r 162             else c
--[ 2019.11.02.16.05.05.881.0 ]--
r 162             else 
--[ 2019.11.02.16.05.11.562.0 ]--
r 162             else c
--[ 2019.11.02.16.05.11.849.0 ]--
r 162             else cu
--[ 2019.11.02.16.05.11.945.0 ]--
r 162             else cur
--[ 2019.11.02.16.05.12.108.0 ]--
r 162             else curr
--[ 2019.11.02.16.05.12.186.0 ]--
r 162             else curre
--[ 2019.11.02.16.05.12.305.0 ]--
r 162             else curren
--[ 2019.11.02.16.05.12.521.0 ]--
r 162             else currentN
--[ 2019.11.02.16.05.12.647.0 ]--
r 162             else currentNo
--[ 2019.11.02.16.05.12.753.0 ]--
r 162             else currentNod
--[ 2019.11.02.16.05.12.947.0 ]--
r 162             else currentNode
--[ 2019.11.02.16.05.13.003.0 ]--
r 162             else currentNode 
--[ 2019.11.02.16.05.13.119.0 ]--
r 162             else currentNode =
--[ 2019.11.02.16.05.13.172.0 ]--
r 162             else currentNode = 
--[ 2019.11.02.16.05.14.766.0 ]--
r 162             else currentNode = g
--[ 2019.11.02.16.05.14.878.0 ]--
r 162             else currentNode = ge
--[ 2019.11.02.16.05.15.044.0 ]--
r 162             else currentNode = get
--[ 2019.11.02.16.05.15.317.0 ]--
r 162             else currentNode = getL
--[ 2019.11.02.16.05.15.468.0 ]--
r 162             else currentNode = getLo
--[ 2019.11.02.16.05.15.529.0 ]--
r 162             else currentNode = getLoc
--[ 2019.11.02.16.05.15.726.0 ]--
r 162             else currentNode = getLo
--[ 2019.11.02.16.05.16.229.0 ]--
r 162             else currentNode = getL
--[ 2019.11.02.16.05.16.262.0 ]--
r 162             else currentNode = get
--[ 2019.11.02.16.05.16.285.0 ]--
r 162             else currentNode = ge
--[ 2019.11.02.16.05.16.313.0 ]--
r 162             else currentNode = g
--[ 2019.11.02.16.05.16.509.0 ]--
r 162             else currentNode = 
--[ 2019.11.02.16.05.28.944.0 ]--
r 162             else currentNode = p
--[ 2019.11.02.16.05.29.138.0 ]--
r 162             else currentNode = pq
--[ 2019.11.02.16.05.29.164.0 ]--
r 162             else currentNode = pq.
--[ 2019.11.02.16.05.29.303.0 ]--
r 162             else currentNode = pq.g
--[ 2019.11.02.16.05.29.418.0 ]--
r 162             else currentNode = pq.ge
--[ 2019.11.02.16.05.29.560.0 ]--
r 162             else currentNode = pq.get
--[ 2019.11.02.16.05.30.081.0 ]--
r 162             else currentNode = pq.ge
--[ 2019.11.02.16.05.30.273.0 ]--
r 162             else currentNode = pq.g
--[ 2019.11.02.16.05.30.410.0 ]--
r 162             else currentNode = pq.
--[ 2019.11.02.16.05.30.877.0 ]--
r 162             else currentNode = pq.m
--[ 2019.11.02.16.05.30.942.0 ]--
r 162             else currentNode = pq.mi
--[ 2019.11.02.16.05.31.080.0 ]--
r 162             else currentNode = pq.min
--[ 2019.11.02.16.05.31.502.0 ]--
r 162             else currentNode = pq.min()
--[ 2019.11.02.16.05.31.768.0 ]--
r 162             else currentNode = pq.min();
--[ 2019.11.02.16.05.34.213.0 ]--
+ 163             
--[ 2019.11.02.16.05.39.865.0 ]--
+ 163             
--[ 2019.11.02.16.05.40.088.0 ]--
+ 163             
--[ 2019.11.02.16.05.40.378.0 ]--
r 165             b
--[ 2019.11.02.16.05.40.673.0 ]--
r 165             br
--[ 2019.11.02.16.05.40.768.0 ]--
r 165             bre
--[ 2019.11.02.16.05.40.815.0 ]--
r 165             brea
--[ 2019.11.02.16.05.40.841.0 ]--
r 165             break
--[ 2019.11.02.16.05.40.951.0 ]--
r 165             break;
--[ 2019.11.02.16.05.43.433.0 ]--
+ 163             
--[ 2019.11.02.16.05.53.753.0 ]--
r 163             C
--[ 2019.11.02.16.05.53.970.0 ]--
r 163             Co
--[ 2019.11.02.16.05.54.094.0 ]--
r 163             Coo
--[ 2019.11.02.16.05.54.203.0 ]--
r 163             Coor
--[ 2019.11.02.16.05.54.429.0 ]--
r 163             Coord
--[ 2019.11.02.16.05.55.084.0 ]--
r 163             Coord[]
--[ 2019.11.02.16.05.55.914.0 ]--
r 163             Coord[] 
--[ 2019.11.02.16.05.56.123.0 ]--
r 163             Coord[] n
--[ 2019.11.02.16.05.56.194.0 ]--
r 163             Coord[] ne
--[ 2019.11.02.16.05.56.298.0 ]--
r 163             Coord[] nei
--[ 2019.11.02.16.05.56.395.0 ]--
r 163             Coord[] neig
--[ 2019.11.02.16.05.56.506.0 ]--
r 163             Coord[] neigh
--[ 2019.11.02.16.05.56.612.0 ]--
r 163             Coord[] neighb
--[ 2019.11.02.16.05.56.682.0 ]--
r 163             Coord[] neighbo
--[ 2019.11.02.16.05.56.836.0 ]--
r 163             Coord[] neighbor
--[ 2019.11.02.16.05.56.931.0 ]--
r 163             Coord[] neighbors
--[ 2019.11.02.16.05.57.050.0 ]--
r 163             Coord[] neighbors 
--[ 2019.11.02.16.05.57.153.0 ]--
r 163             Coord[] neighbors =
--[ 2019.11.02.16.05.57.239.0 ]--
r 163             Coord[] neighbors = 
--[ 2019.11.02.16.05.57.410.0 ]--
r 163             Coord[] neighbors = f
--[ 2019.11.02.16.05.57.551.0 ]--
r 163             Coord[] neighbors = fi
--[ 2019.11.02.16.05.57.641.0 ]--
r 163             Coord[] neighbors = fin
--[ 2019.11.02.16.05.57.693.0 ]--
r 163             Coord[] neighbors = find
--[ 2019.11.02.16.05.57.889.0 ]--
r 163             Coord[] neighbors = findN
--[ 2019.11.02.16.05.58.055.0 ]--
r 163             Coord[] neighbors = findNe
--[ 2019.11.02.16.05.58.143.0 ]--
r 163             Coord[] neighbors = findNei
--[ 2019.11.02.16.05.58.255.0 ]--
r 163             Coord[] neighbors = findNeig
--[ 2019.11.02.16.05.58.311.0 ]--
r 163             Coord[] neighbors = findNeigh
--[ 2019.11.02.16.05.58.538.0 ]--
r 163             Coord[] neighbors = findNeighb
--[ 2019.11.02.16.05.58.623.0 ]--
r 163             Coord[] neighbors = findNeighbo
--[ 2019.11.02.16.05.58.752.0 ]--
r 163             Coord[] neighbors = findNeighbor
--[ 2019.11.02.16.05.58.877.0 ]--
r 163             Coord[] neighbors = findNeighbors
--[ 2019.11.02.16.05.59.218.0 ]--
r 163             Coord[] neighbors = findNeighbors()
--[ 2019.11.02.16.05.59.438.0 ]--
r 163             Coord[] neighbors = findNeighbors(c)
--[ 2019.11.02.16.05.59.486.0 ]--
r 163             Coord[] neighbors = findNeighbors(cu)
--[ 2019.11.02.16.05.59.706.0 ]--
r 163             Coord[] neighbors = findNeighbors(cur)
--[ 2019.11.02.16.05.59.841.0 ]--
r 163             Coord[] neighbors = findNeighbors(curr)
--[ 2019.11.02.16.05.59.920.0 ]--
r 163             Coord[] neighbors = findNeighbors(curre)
--[ 2019.11.02.16.06.00.048.0 ]--
r 163             Coord[] neighbors = findNeighbors(curren)
--[ 2019.11.02.16.06.00.121.0 ]--
r 163             Coord[] neighbors = findNeighbors(current)
--[ 2019.11.02.16.06.00.320.0 ]--
r 163             Coord[] neighbors = findNeighbors(currentN)
--[ 2019.11.02.16.06.00.712.0 ]--
r 163             Coord[] neighbors = findNeighbors(current)
--[ 2019.11.02.16.06.01.199.0 ]--
r 163             Coord[] neighbors = findNeighbors(currentL)
--[ 2019.11.02.16.06.01.361.0 ]--
r 163             Coord[] neighbors = findNeighbors(currentLo)
--[ 2019.11.02.16.06.01.435.0 ]--
r 163             Coord[] neighbors = findNeighbors(currentLoc)
--[ 2019.11.02.16.06.01.823.0 ]--
r 163             Coord[] neighbors = findNeighbors(currentLoc);
--[ 2019.11.02.16.06.02.056.0 ]--
+ 164             
--[ 2019.11.02.16.06.13.438.0 ]--
r 162             else {currentNode = pq.min();
--[ 2019.11.02.16.06.13.777.0 ]--
r 162             else { currentNode = pq.min();
--[ 2019.11.02.16.06.13.928.0 ]--
+ 162             else { 
r 163                 currentNode = pq.min();
--[ 2019.11.02.16.06.16.425.0 ]--
+ 164                 
--[ 2019.11.02.16.06.16.914.0 ]--
- 164
--[ 2019.11.02.16.06.17.672.0 ]--
+ 164                 
--[ 2019.11.02.16.06.18.198.0 ]--
r 164                 }
--[ 2019.11.02.16.06.18.277.0 ]--
r 162             else {
--[ 2019.11.02.16.06.18.290.0 ]--
r 164             }
--[ 2019.11.02.16.06.20.633.0 ]--
+ 164                 
--[ 2019.11.02.16.06.20.823.0 ]--
r 164                 c
--[ 2019.11.02.16.06.21.042.0 ]--
r 164                 cu
--[ 2019.11.02.16.06.21.128.0 ]--
r 164                 cur
--[ 2019.11.02.16.06.21.315.0 ]--
r 164                 curr
--[ 2019.11.02.16.06.21.398.0 ]--
r 164                 curre
--[ 2019.11.02.16.06.21.605.0 ]--
r 164                 curren
--[ 2019.11.02.16.06.21.644.0 ]--
r 164                 current
--[ 2019.11.02.16.06.21.878.0 ]--
r 164                 currentL
--[ 2019.11.02.16.06.22.044.0 ]--
r 164                 currentLo
--[ 2019.11.02.16.06.22.111.0 ]--
r 164                 currentLoc
--[ 2019.11.02.16.06.22.201.0 ]--
r 164                 currentLoc 
--[ 2019.11.02.16.06.22.344.0 ]--
r 164                 currentLoc =
--[ 2019.11.02.16.06.22.410.0 ]--
r 164                 currentLoc = 
--[ 2019.11.02.16.06.22.550.0 ]--
r 164                 currentLoc = c
--[ 2019.11.02.16.06.22.626.0 ]--
r 164                 currentLoc = cu
--[ 2019.11.02.16.06.22.800.0 ]--
r 164                 currentLoc = cur
--[ 2019.11.02.16.06.22.989.0 ]--
r 164                 currentLoc = curr
--[ 2019.11.02.16.06.23.064.0 ]--
r 164                 currentLoc = curre
--[ 2019.11.02.16.06.23.222.0 ]--
r 164                 currentLoc = curren
--[ 2019.11.02.16.06.23.285.0 ]--
r 164                 currentLoc = current
--[ 2019.11.02.16.06.23.554.0 ]--
r 164                 currentLoc = currentN
--[ 2019.11.02.16.06.23.817.0 ]--
r 164                 currentLoc = currentNod
--[ 2019.11.02.16.06.23.921.0 ]--
r 164                 currentLoc = currentNode
--[ 2019.11.02.16.06.24.034.0 ]--
r 164                 currentLoc = currentNode.
--[ 2019.11.02.16.06.25.178.0 ]--
r 164                 currentLoc = currentNode.g
--[ 2019.11.02.16.06.25.240.0 ]--
r 164                 currentLoc = currentNode.ge
--[ 2019.11.02.16.06.25.418.0 ]--
r 164                 currentLoc = currentNode.get
--[ 2019.11.02.16.06.25.605.0 ]--
r 164                 currentLoc = currentNode.getL
--[ 2019.11.02.16.06.25.772.0 ]--
r 164                 currentLoc = currentNode.getLo
--[ 2019.11.02.16.06.25.843.0 ]--
r 164                 currentLoc = currentNode.getLoc
--[ 2019.11.02.16.06.26.044.0 ]--
r 164                 currentLoc = currentNode.getLoc()
--[ 2019.11.02.16.06.26.310.0 ]--
r 164                 currentLoc = currentNode.getLoc();
--[ 2019.11.02.16.06.26.355.0 ]--
r 164                 currentLoc = currentNode.getLoc();.
--[ 2019.11.02.16.06.27.835.0 ]--
r 164                 currentLoc = currentNode.getLoc();
--[ 2019.11.02.16.06.44.505.0 ]--
r 167             f
--[ 2019.11.02.16.06.44.767.0 ]--
r 167             for
--[ 2019.11.02.16.06.44.905.0 ]--
r 167             for 
--[ 2019.11.02.16.06.45.081.0 ]--
r 167             for ()
--[ 2019.11.02.16.06.45.357.0 ]--
r 167             for (C)
--[ 2019.11.02.16.06.45.553.0 ]--
r 167             for (Co)
--[ 2019.11.02.16.06.45.679.0 ]--
r 167             for (Coo)
--[ 2019.11.02.16.06.45.772.0 ]--
r 167             for (Coor)
--[ 2019.11.02.16.06.45.992.0 ]--
r 167             for (Coord)
--[ 2019.11.02.16.06.46.071.0 ]--
r 167             for (Coord )
--[ 2019.11.02.16.06.46.197.0 ]--
r 167             for (Coord c)
--[ 2019.11.02.16.06.46.375.0 ]--
r 167             for (Coord c )
--[ 2019.11.02.16.06.46.573.0 ]--
r 167             for (Coord c :)
--[ 2019.11.02.16.06.46.628.0 ]--
r 167             for (Coord c : )
--[ 2019.11.02.16.06.46.762.0 ]--
r 167             for (Coord c : n)
--[ 2019.11.02.16.06.46.836.0 ]--
r 167             for (Coord c : ne)
--[ 2019.11.02.16.06.46.985.0 ]--
r 167             for (Coord c : nei)
--[ 2019.11.02.16.06.47.034.0 ]--
r 167             for (Coord c : neig)
--[ 2019.11.02.16.06.47.194.0 ]--
r 167             for (Coord c : neigh)
--[ 2019.11.02.16.06.47.257.0 ]--
r 167             for (Coord c : neighb)
--[ 2019.11.02.16.06.47.405.0 ]--
r 167             for (Coord c : neighbo)
--[ 2019.11.02.16.06.47.473.0 ]--
r 167             for (Coord c : neighbor)
--[ 2019.11.02.16.06.47.562.0 ]--
r 167             for (Coord c : neighbors)
--[ 2019.11.02.16.06.48.726.0 ]--
r 167             for (Coord c : neighbors) 
--[ 2019.11.02.16.06.48.883.0 ]--
r 167             for (Coord c : neighbors) {
--[ 2019.11.02.16.06.49.075.0 ]--
+ 168 
+ 169 }
--[ 2019.11.02.16.06.49.132.0 ]--
r 169             }
--[ 2019.11.02.16.06.49.153.0 ]--
r 168                 
--[ 2019.11.02.16.06.55.159.0 ]--
r 168                 P
--[ 2019.11.02.16.06.55.390.0 ]--
r 168                 PF
--[ 2019.11.02.16.06.55.424.0 ]--
r 168                 PFN
--[ 2019.11.02.16.06.55.775.0 ]--
r 168                 PFNo
--[ 2019.11.02.16.06.55.849.0 ]--
r 168                 PFNod
--[ 2019.11.02.16.06.56.059.0 ]--
r 168                 PFNode
--[ 2019.11.02.16.06.56.154.0 ]--
r 168                 PFNode 
--[ 2019.11.02.16.06.56.268.0 ]--
r 168                 PFNode c
--[ 2019.11.02.16.06.56.545.0 ]--
r 168                 PFNode cN
--[ 2019.11.02.16.06.56.694.0 ]--
r 168                 PFNode cNo
--[ 2019.11.02.16.06.56.786.0 ]--
r 168                 PFNode cNod
--[ 2019.11.02.16.06.56.971.0 ]--
r 168                 PFNode cNode
--[ 2019.11.02.16.06.57.058.0 ]--
r 168                 PFNode cNode 
--[ 2019.11.02.16.06.57.179.0 ]--
r 168                 PFNode cNode =
--[ 2019.11.02.16.06.57.279.0 ]--
r 168                 PFNode cNode = 
--[ 2019.11.02.16.06.57.419.0 ]--
r 168                 PFNode cNode = n
--[ 2019.11.02.16.06.57.490.0 ]--
r 168                 PFNode cNode = ne
--[ 2019.11.02.16.06.57.562.0 ]--
r 168                 PFNode cNode = new
--[ 2019.11.02.16.06.57.679.0 ]--
r 168                 PFNode cNode = new 
--[ 2019.11.02.16.06.58.116.0 ]--
r 168                 PFNode cNode = new P
--[ 2019.11.02.16.06.58.197.0 ]--
r 168                 PFNode cNode = new PF
--[ 2019.11.02.16.06.58.354.0 ]--
r 168                 PFNode cNode = new PFN
--[ 2019.11.02.16.06.58.708.0 ]--
r 168                 PFNode cNode = new PFNo
--[ 2019.11.02.16.06.58.799.0 ]--
r 168                 PFNode cNode = new PFNod
--[ 2019.11.02.16.06.58.989.0 ]--
r 168                 PFNode cNode = new PFNode
--[ 2019.11.02.16.06.59.142.0 ]--
r 168                 PFNode cNode = new PFNode()
--[ 2019.11.02.16.06.59.458.0 ]--
r 168                 PFNode cNode = new PFNode(c)
--[ 2019.11.02.16.06.59.653.0 ]--
r 168                 PFNode cNode = new PFNode(c,)
--[ 2019.11.02.16.06.59.755.0 ]--
r 168                 PFNode cNode = new PFNode(c, )
--[ 2019.11.02.16.07.00.051.0 ]--
r 168                 PFNode cNode = new PFNode(c, s)
--[ 2019.11.02.16.07.00.489.0 ]--
r 168                 PFNode cNode = new PFNode(c, )
--[ 2019.11.02.16.07.01.521.0 ]--
r 168                 PFNode cNode = new PFNode(c, c)
--[ 2019.11.02.16.07.01.627.0 ]--
r 168                 PFNode cNode = new PFNode(c, cu)
--[ 2019.11.02.16.07.01.802.0 ]--
r 168                 PFNode cNode = new PFNode(c, cur)
--[ 2019.11.02.16.07.01.968.0 ]--
r 168                 PFNode cNode = new PFNode(c, curr)
--[ 2019.11.02.16.07.02.032.0 ]--
r 168                 PFNode cNode = new PFNode(c, curre)
--[ 2019.11.02.16.07.02.180.0 ]--
r 168                 PFNode cNode = new PFNode(c, curren)
--[ 2019.11.02.16.07.02.212.0 ]--
r 168                 PFNode cNode = new PFNode(c, current)
--[ 2019.11.02.16.07.02.406.0 ]--
r 168                 PFNode cNode = new PFNode(c, currentN)
--[ 2019.11.02.16.07.02.548.0 ]--
r 168                 PFNode cNode = new PFNode(c, currentNo)
--[ 2019.11.02.16.07.02.591.0 ]--
r 168                 PFNode cNode = new PFNode(c, currentNod)
--[ 2019.11.02.16.07.02.763.0 ]--
r 168                 PFNode cNode = new PFNode(c, currentNode)
--[ 2019.11.02.16.07.03.090.0 ]--
r 168                 PFNode cNode = new PFNode(c, currentNode);
--[ 2019.11.02.16.07.03.463.0 ]--
+ 169                 
--[ 2019.11.02.16.07.05.648.0 ]--
r 169                 p
--[ 2019.11.02.16.07.05.913.0 ]--
r 169                 pq
--[ 2019.11.02.16.07.05.940.0 ]--
r 169                 pq.
--[ 2019.11.02.16.07.06.153.0 ]--
r 169                 pq.i
--[ 2019.11.02.16.07.06.255.0 ]--
r 169                 pq.in
--[ 2019.11.02.16.07.06.327.0 ]--
r 169                 pq.ins
--[ 2019.11.02.16.07.06.428.0 ]--
r 169                 pq.inse
--[ 2019.11.02.16.07.06.511.0 ]--
r 169                 pq.inser
--[ 2019.11.02.16.07.06.732.0 ]--
r 169                 pq.insert
--[ 2019.11.02.16.07.06.883.0 ]--
r 169                 pq.insert()
--[ 2019.11.02.16.07.07.155.0 ]--
r 169                 pq.insert(c)
--[ 2019.11.02.16.07.07.378.0 ]--
r 169                 pq.insert(cN)
--[ 2019.11.02.16.07.07.529.0 ]--
r 169                 pq.insert(cNo)
--[ 2019.11.02.16.07.07.608.0 ]--
r 169                 pq.insert(cNod)
--[ 2019.11.02.16.07.07.803.0 ]--
r 169                 pq.insert(cNode)
--[ 2019.11.02.16.07.08.092.0 ]--
r 169                 pq.insert(cNode);
--[ 2019.11.02.16.07.08.300.0 ]--
+ 170                 
--[ 2019.11.02.16.07.09.296.0 ]--
r 170                 b
--[ 2019.11.02.16.07.09.344.0 ]--
r 170                 bo
--[ 2019.11.02.16.07.09.534.0 ]--
r 170                 boa
--[ 2019.11.02.16.07.09.607.0 ]--
r 170                 boar
--[ 2019.11.02.16.07.09.783.0 ]--
r 170                 board
--[ 2019.11.02.16.07.09.877.0 ]--
r 170                 board[]
--[ 2019.11.02.16.07.09.979.0 ]--
r 170                 board[c]
--[ 2019.11.02.16.07.10.132.0 ]--
r 170                 board[c.]
--[ 2019.11.02.16.07.10.311.0 ]--
r 170                 board[c.g]
--[ 2019.11.02.16.07.10.382.0 ]--
r 170                 board[c.ge]
--[ 2019.11.02.16.07.10.537.0 ]--
r 170                 board[c.get]
--[ 2019.11.02.16.07.10.753.0 ]--
r 170                 board[c.getI]
--[ 2019.11.02.16.07.11.117.0 ]--
r 170                 board[c.getI()]
--[ 2019.11.02.16.07.11.779.0 ]--
r 170                 board[c.getI()][]
--[ 2019.11.02.16.07.12.115.0 ]--
r 170                 board[c.getI()][c]
--[ 2019.11.02.16.07.12.266.0 ]--
r 170                 board[c.getI()][c.]
--[ 2019.11.02.16.07.12.407.0 ]--
r 170                 board[c.getI()][c.g]
--[ 2019.11.02.16.07.12.485.0 ]--
r 170                 board[c.getI()][c.ge]
--[ 2019.11.02.16.07.12.639.0 ]--
r 170                 board[c.getI()][c.get]
--[ 2019.11.02.16.07.12.839.0 ]--
r 170                 board[c.getI()][c.getJ]
--[ 2019.11.02.16.07.13.166.0 ]--
r 170                 board[c.getI()][c.getJ()]
--[ 2019.11.02.16.07.14.224.0 ]--
r 170                 board[c.getI()][c.getJ()] 
--[ 2019.11.02.16.07.14.298.0 ]--
r 170                 board[c.getI()][c.getJ()] =
--[ 2019.11.02.16.07.14.429.0 ]--
r 170                 board[c.getI()][c.getJ()] = 
--[ 2019.11.02.16.07.14.565.0 ]--
r 170                 board[c.getI()][c.getJ()] = c
--[ 2019.11.02.16.07.15.037.0 ]--
r 170                 board[c.getI()][c.getJ()] = cN
--[ 2019.11.02.16.07.15.207.0 ]--
r 170                 board[c.getI()][c.getJ()] = cNo
--[ 2019.11.02.16.07.15.296.0 ]--
r 170                 board[c.getI()][c.getJ()] = cNod
--[ 2019.11.02.16.07.15.503.0 ]--
r 170                 board[c.getI()][c.getJ()] = cNode
--[ 2019.11.02.16.07.15.718.0 ]--
r 170                 board[c.getI()][c.getJ()] = cNode.
--[ 2019.11.02.16.07.15.920.0 ]--
r 170                 board[c.getI()][c.getJ()] = cNode.g
--[ 2019.11.02.16.07.15.980.0 ]--
r 170                 board[c.getI()][c.getJ()] = cNode.ge
--[ 2019.11.02.16.07.16.115.0 ]--
r 170                 board[c.getI()][c.getJ()] = cNode.get
--[ 2019.11.02.16.07.16.384.0 ]--
r 170                 board[c.getI()][c.getJ()] = cNode.getC
--[ 2019.11.02.16.07.16.510.0 ]--
r 170                 board[c.getI()][c.getJ()] = cNode.getCo
--[ 2019.11.02.16.07.16.734.0 ]--
r 170                 board[c.getI()][c.getJ()] = cNode.getCos
--[ 2019.11.02.16.07.16.797.0 ]--
r 170                 board[c.getI()][c.getJ()] = cNode.getCost
--[ 2019.11.02.16.07.17.062.0 ]--
r 170                 board[c.getI()][c.getJ()] = cNode.getCost()
--[ 2019.11.02.16.07.17.286.0 ]--
r 170                 board[c.getI()][c.getJ()] = cNode.getCost();
--[ 2019.11.02.16.07.20.432.0 ]--
+ 172             
--[ 2019.11.02.16.07.54.657.0 ]--
+ 166             
--[ 2019.11.02.16.07.55.745.0 ]--
r 166             i
--[ 2019.11.02.16.07.55.809.0 ]--
r 166             if
--[ 2019.11.02.16.07.55.926.0 ]--
r 166             if 
--[ 2019.11.02.16.07.56.072.0 ]--
r 166             if ()
--[ 2019.11.02.16.07.56.871.0 ]--
r 166             if (c)
--[ 2019.11.02.16.07.56.962.0 ]--
r 166             if (cu)
--[ 2019.11.02.16.07.57.149.0 ]--
r 166             if (cur)
--[ 2019.11.02.16.07.57.339.0 ]--
r 166             if (curr)
--[ 2019.11.02.16.07.57.410.0 ]--
r 166             if (curre)
--[ 2019.11.02.16.07.57.604.0 ]--
r 166             if (curren)
--[ 2019.11.02.16.07.57.665.0 ]--
r 166             if (current)
--[ 2019.11.02.16.07.58.339.0 ]--
r 166             if (curren)
--[ 2019.11.02.16.07.58.573.0 ]--
r 166             if (curre)
--[ 2019.11.02.16.07.58.739.0 ]--
r 166             if (curr)
--[ 2019.11.02.16.07.58.908.0 ]--
r 166             if (cur)
--[ 2019.11.02.16.07.59.072.0 ]--
r 166             if (cu)
--[ 2019.11.02.16.07.59.233.0 ]--
r 166             if (c)
--[ 2019.11.02.16.07.59.430.0 ]--
r 166             if ()
--[ 2019.11.02.16.08.00.328.0 ]--
r 166             if (b)
--[ 2019.11.02.16.08.00.418.0 ]--
r 166             if (bo)
--[ 2019.11.02.16.08.00.554.0 ]--
r 166             if (boa)
--[ 2019.11.02.16.08.00.603.0 ]--
r 166             if (boar)
--[ 2019.11.02.16.08.00.772.0 ]--
r 166             if (board)
--[ 2019.11.02.16.08.00.838.0 ]--
r 166             if (board[])
--[ 2019.11.02.16.08.00.971.0 ]--
r 166             if (board[c])
--[ 2019.11.02.16.08.01.074.0 ]--
r 166             if (board[cu])
--[ 2019.11.02.16.08.01.223.0 ]--
r 166             if (board[cur])
--[ 2019.11.02.16.08.01.443.0 ]--
r 166             if (board[curr])
--[ 2019.11.02.16.08.01.511.0 ]--
r 166             if (board[curre])
--[ 2019.11.02.16.08.01.633.0 ]--
r 166             if (board[curren])
--[ 2019.11.02.16.08.01.719.0 ]--
r 166             if (board[current])
--[ 2019.11.02.16.08.01.895.0 ]--
r 166             if (board[currentL])
--[ 2019.11.02.16.08.02.035.0 ]--
r 166             if (board[currentLo])
--[ 2019.11.02.16.08.02.094.0 ]--
r 166             if (board[currentLoc])
--[ 2019.11.02.16.08.02.245.0 ]--
r 166             if (board[currentLoc.])
--[ 2019.11.02.16.08.02.409.0 ]--
r 166             if (board[currentLoc.g])
--[ 2019.11.02.16.08.02.474.0 ]--
r 166             if (board[currentLoc.ge])
--[ 2019.11.02.16.08.02.643.0 ]--
r 166             if (board[currentLoc.get])
--[ 2019.11.02.16.08.02.886.0 ]--
r 166             if (board[currentLoc.getI])
--[ 2019.11.02.16.08.03.327.0 ]--
r 166             if (board[currentLoc.getI()])
--[ 2019.11.02.16.08.04.224.0 ]--
r 166             if (board[currentLoc.getI()][])
--[ 2019.11.02.16.08.04.656.0 ]--
r 166             if (board[currentLoc.getI()][b])
--[ 2019.11.02.16.08.04.911.0 ]--
r 166             if (board[currentLoc.getI()][boa])
--[ 2019.11.02.16.08.04.939.0 ]--
r 166             if (board[currentLoc.getI()][boar])
--[ 2019.11.02.16.08.05.147.0 ]--
r 166             if (board[currentLoc.getI()][board])
--[ 2019.11.02.16.08.05.221.0 ]--
r 166             if (board[currentLoc.getI()][board.])
--[ 2019.11.02.16.08.05.563.0 ]--
r 166             if (board[currentLoc.getI()][board.c])
--[ 2019.11.02.16.08.05.710.0 ]--
r 166             if (board[currentLoc.getI()][board.cu])
--[ 2019.11.02.16.08.05.846.0 ]--
r 166             if (board[currentLoc.getI()][board.cur])
--[ 2019.11.02.16.08.06.010.0 ]--
r 166             if (board[currentLoc.getI()][board.curr])
--[ 2019.11.02.16.08.06.108.0 ]--
r 166             if (board[currentLoc.getI()][board.curre])
--[ 2019.11.02.16.08.06.194.0 ]--
r 166             if (board[currentLoc.getI()][board.curren])
--[ 2019.11.02.16.08.06.273.0 ]--
r 166             if (board[currentLoc.getI()][board.current])
--[ 2019.11.02.16.08.06.439.0 ]--
r 166             if (board[currentLoc.getI()][board.currentL])
--[ 2019.11.02.16.08.06.601.0 ]--
r 166             if (board[currentLoc.getI()][board.currentLo])
--[ 2019.11.02.16.08.06.667.0 ]--
r 166             if (board[currentLoc.getI()][board.currentLoc])
--[ 2019.11.02.16.08.06.826.0 ]--
r 166             if (board[currentLoc.getI()][board.currentLoc.])
--[ 2019.11.02.16.08.06.957.0 ]--
r 166             if (board[currentLoc.getI()][board.currentLoc.g])
--[ 2019.11.02.16.08.07.027.0 ]--
r 166             if (board[currentLoc.getI()][board.currentLoc.ge])
--[ 2019.11.02.16.08.07.179.0 ]--
r 166             if (board[currentLoc.getI()][board.currentLoc.get])
--[ 2019.11.02.16.08.07.395.0 ]--
r 166             if (board[currentLoc.getI()][board.currentLoc.getJ])
--[ 2019.11.02.16.08.07.771.0 ]--
r 166             if (board[currentLoc.getI()][board.currentLoc.getJ()])
--[ 2019.11.02.16.08.09.104.0 ]--
r 166             if (board[currentLoc.getI()][board.currentLoc.getJ())
--[ 2019.11.02.16.08.09.592.0 ]--
r 166             if (board[currentLoc.getI()][board.currentLoc.getJ()
--[ 2019.11.02.16.08.09.625.0 ]--
r 166             if (board[currentLoc.getI()][board.currentLoc.getJ
--[ 2019.11.02.16.08.09.657.0 ]--
r 166             if (board[currentLoc.getI()][board.currentLoc.get
--[ 2019.11.02.16.08.09.690.0 ]--
r 166             if (board[currentLoc.getI()][board.currentLoc.ge
--[ 2019.11.02.16.08.09.722.0 ]--
r 166             if (board[currentLoc.getI()][board.currentLoc.g
--[ 2019.11.02.16.08.09.755.0 ]--
r 166             if (board[currentLoc.getI()][board.currentLoc.
--[ 2019.11.02.16.08.09.790.0 ]--
r 166             if (board[currentLoc.getI()][board.currentLoc
--[ 2019.11.02.16.08.09.822.0 ]--
r 166             if (board[currentLoc.getI()][board.currentLo
--[ 2019.11.02.16.08.09.856.0 ]--
r 166             if (board[currentLoc.getI()][board.currentL
--[ 2019.11.02.16.08.09.889.0 ]--
r 166             if (board[currentLoc.getI()][board.current
--[ 2019.11.02.16.08.09.923.0 ]--
r 166             if (board[currentLoc.getI()][board.curren
--[ 2019.11.02.16.08.09.954.0 ]--
r 166             if (board[currentLoc.getI()][board.curre
--[ 2019.11.02.16.08.09.987.0 ]--
r 166             if (board[currentLoc.getI()][board.curr
--[ 2019.11.02.16.08.10.021.0 ]--
r 166             if (board[currentLoc.getI()][board.cur
--[ 2019.11.02.16.08.10.053.0 ]--
r 166             if (board[currentLoc.getI()][board.cu
--[ 2019.11.02.16.08.10.086.0 ]--
r 166             if (board[currentLoc.getI()][board.c
--[ 2019.11.02.16.08.10.123.0 ]--
r 166             if (board[currentLoc.getI()][board.
--[ 2019.11.02.16.08.10.160.0 ]--
r 166             if (board[currentLoc.getI()][board
--[ 2019.11.02.16.08.10.187.0 ]--
r 166             if (board[currentLoc.getI()][boar
--[ 2019.11.02.16.08.10.227.0 ]--
r 166             if (board[currentLoc.getI()][boa
--[ 2019.11.02.16.08.10.250.0 ]--
r 166             if (board[currentLoc.getI()][bo
--[ 2019.11.02.16.08.10.283.0 ]--
r 166             if (board[currentLoc.getI()][b
--[ 2019.11.02.16.08.10.317.0 ]--
r 166             if (board[currentLoc.getI()][
--[ 2019.11.02.16.08.10.350.0 ]--
r 166             if (board[currentLoc.getI()]
--[ 2019.11.02.16.08.10.383.0 ]--
r 166             if (board[currentLoc.getI()
--[ 2019.11.02.16.08.10.418.0 ]--
r 166             if (board[currentLoc.getI(
--[ 2019.11.02.16.08.10.449.0 ]--
r 166             if (board[currentLoc.getI
--[ 2019.11.02.16.08.10.483.0 ]--
r 166             if (board[currentLoc.get
--[ 2019.11.02.16.08.10.515.0 ]--
r 166             if (board[currentLoc.ge
--[ 2019.11.02.16.08.10.548.0 ]--
r 166             if (board[currentLoc.g
--[ 2019.11.02.16.08.10.581.0 ]--
r 166             if (board[currentLoc.
--[ 2019.11.02.16.08.10.616.0 ]--
r 166             if (board[currentLoc
--[ 2019.11.02.16.08.10.648.0 ]--
r 166             if (board[currentLo
--[ 2019.11.02.16.08.10.680.0 ]--
r 166             if (board[currentL
--[ 2019.11.02.16.08.10.713.0 ]--
r 166             if (board[current
--[ 2019.11.02.16.08.10.746.0 ]--
r 166             if (board[curren
--[ 2019.11.02.16.08.10.779.0 ]--
r 166             if (board[curre
--[ 2019.11.02.16.08.10.812.0 ]--
r 166             if (board[curr
--[ 2019.11.02.16.08.10.845.0 ]--
r 166             if (board[cur
--[ 2019.11.02.16.08.10.893.0 ]--
r 166             if (board[cu
--[ 2019.11.02.16.08.10.922.0 ]--
r 166             if (board[c
--[ 2019.11.02.16.08.10.947.0 ]--
r 166             if (board[
--[ 2019.11.02.16.08.10.985.0 ]--
r 166             if (board
--[ 2019.11.02.16.08.11.013.0 ]--
r 166             if (boar
--[ 2019.11.02.16.08.11.064.0 ]--
r 166             if (boa
--[ 2019.11.02.16.08.11.089.0 ]--
r 166             if (bo
--[ 2019.11.02.16.08.11.119.0 ]--
r 166             if (b
--[ 2019.11.02.16.08.11.261.0 ]--
r 166             if (
--[ 2019.11.02.16.08.11.819.0 ]--
r 166             if (c
--[ 2019.11.02.16.08.11.974.0 ]--
r 166             if (cu
--[ 2019.11.02.16.08.12.122.0 ]--
r 166             if (cur
--[ 2019.11.02.16.08.12.256.0 ]--
r 166             if (curr
--[ 2019.11.02.16.08.12.427.0 ]--
r 166             if (curre
--[ 2019.11.02.16.08.12.589.0 ]--
r 166             if (curren
--[ 2019.11.02.16.08.12.645.0 ]--
r 166             if (current
--[ 2019.11.02.16.08.12.878.0 ]--
r 166             if (currentL
--[ 2019.11.02.16.08.13.026.0 ]--
r 166             if (currentLo
--[ 2019.11.02.16.08.13.079.0 ]--
r 166             if (currentLoc
--[ 2019.11.02.16.08.13.147.0 ]--
r 166             if (currentLoc 
--[ 2019.11.02.16.08.13.235.0 ]--
r 166             if (currentLoc =
--[ 2019.11.02.16.08.13.402.0 ]--
r 166             if (currentLoc ==
--[ 2019.11.02.16.08.13.522.0 ]--
r 166             if (currentLoc == 
--[ 2019.11.02.16.08.15.156.0 ]--
r 166             if (currentLoc == g
--[ 2019.11.02.16.08.15.388.0 ]--
r 166             if (currentLoc == get
--[ 2019.11.02.16.08.15.605.0 ]--
r 166             if (currentLoc == getP
--[ 2019.11.02.16.08.15.732.0 ]--
r 166             if (currentLoc == getPa
--[ 2019.11.02.16.08.15.819.0 ]--
r 166             if (currentLoc == getPat
--[ 2019.11.02.16.08.15.890.0 ]--
r 166             if (currentLoc == getPath
--[ 2019.11.02.16.08.16.321.0 ]--
r 166             if (currentLoc == getPathE
--[ 2019.11.02.16.08.16.508.0 ]--
r 166             if (currentLoc == getPathEn
--[ 2019.11.02.16.08.16.601.0 ]--
r 166             if (currentLoc == getPathEnd
--[ 2019.11.02.16.08.16.873.0 ]--
r 166             if (currentLoc == getPathEnd()
--[ 2019.11.02.16.08.16.925.0 ]--
r 166             if (currentLoc == getPathEnd())
--[ 2019.11.02.16.08.18.456.0 ]--
r 166             if (currentLoc == getPathEnd()) 
--[ 2019.11.02.16.08.19.774.0 ]--
r 166             if (currentLoc == getPathEnd()) b
--[ 2019.11.02.16.08.20.044.0 ]--
r 166             if (currentLoc == getPathEnd()) br
--[ 2019.11.02.16.08.20.114.0 ]--
r 166             if (currentLoc == getPathEnd()) bre
--[ 2019.11.02.16.08.20.192.0 ]--
r 166             if (currentLoc == getPathEnd()) brea
--[ 2019.11.02.16.08.20.216.0 ]--
r 166             if (currentLoc == getPathEnd()) break
--[ 2019.11.02.16.08.20.392.0 ]--
r 166             if (currentLoc == getPathEnd()) break;
--[ 2019.11.02.16.09.02.865.0 ]--
+ 173             
--[ 2019.11.02.16.09.03.881.0 ]--
r 173             p
--[ 2019.11.02.16.09.04.091.0 ]--
r 173             pq
--[ 2019.11.02.16.09.04.128.0 ]--
r 173             pq.
--[ 2019.11.02.16.09.04.404.0 ]--
r 173             pq
--[ 2019.11.02.16.09.04.558.0 ]--
r 173             p
--[ 2019.11.02.16.09.04.715.0 ]--
r 173             
--[ 2019.11.02.16.09.07.368.0 ]--
r 173             i
--[ 2019.11.02.16.09.07.426.0 ]--
r 173             if
--[ 2019.11.02.16.09.07.586.0 ]--
r 173             if 
--[ 2019.11.02.16.09.07.764.0 ]--
r 173             if ()
--[ 2019.11.02.16.09.07.933.0 ]--
r 173             if (c)
--[ 2019.11.02.16.09.08.034.0 ]--
r 173             if (cu)
--[ 2019.11.02.16.09.08.201.0 ]--
r 173             if (cur)
--[ 2019.11.02.16.09.08.402.0 ]--
r 173             if (curr)
--[ 2019.11.02.16.09.08.463.0 ]--
r 173             if (curre)
--[ 2019.11.02.16.09.08.619.0 ]--
r 173             if (curren)
--[ 2019.11.02.16.09.08.687.0 ]--
r 173             if (current)
--[ 2019.11.02.16.09.08.921.0 ]--
r 173             if (currentL)
--[ 2019.11.02.16.09.09.084.0 ]--
r 173             if (currentLo)
--[ 2019.11.02.16.09.09.170.0 ]--
r 173             if (currentLoc)
--[ 2019.11.02.16.09.09.309.0 ]--
r 173             if (currentLoc )
--[ 2019.11.02.16.09.09.639.0 ]--
r 173             if (currentLoc !)
--[ 2019.11.02.16.09.09.887.0 ]--
r 173             if (currentLoc !=)
--[ 2019.11.02.16.09.09.996.0 ]--
r 173             if (currentLoc != )
--[ 2019.11.02.16.09.10.585.0 ]--
r 173             if (currentLoc != g)
--[ 2019.11.02.16.09.10.695.0 ]--
r 173             if (currentLoc != ge)
--[ 2019.11.02.16.09.10.854.0 ]--
r 173             if (currentLoc != get)
--[ 2019.11.02.16.09.11.131.0 ]--
r 173             if (currentLoc != getp)
--[ 2019.11.02.16.09.11.267.0 ]--
r 173             if (currentLoc != getpa)
--[ 2019.11.02.16.09.11.328.0 ]--
r 173             if (currentLoc != getpat)
--[ 2019.11.02.16.09.11.403.0 ]--
r 173             if (currentLoc != getpath)
--[ 2019.11.02.16.09.11.675.0 ]--
r 173             if (currentLoc != getpathS)
--[ 2019.11.02.16.09.11.879.0 ]--
r 173             if (currentLoc != getpathSt)
--[ 2019.11.02.16.09.12.024.0 ]--
r 173             if (currentLoc != getpathSta)
--[ 2019.11.02.16.09.12.087.0 ]--
r 173             if (currentLoc != getpathStar)
--[ 2019.11.02.16.09.12.290.0 ]--
r 173             if (currentLoc != getpathStart)
--[ 2019.11.02.16.09.12.746.0 ]--
r 173             if (currentLoc != getpathStar)
--[ 2019.11.02.16.09.13.241.0 ]--
r 173             if (currentLoc != getpathSta)
--[ 2019.11.02.16.09.13.514.0 ]--
r 173             if (currentLoc != getpath)
--[ 2019.11.02.16.09.13.705.0 ]--
r 173             if (currentLoc != getpat)
--[ 2019.11.02.16.09.13.885.0 ]--
r 173             if (currentLoc != getpa)
--[ 2019.11.02.16.09.14.064.0 ]--
r 173             if (currentLoc != getp)
--[ 2019.11.02.16.09.14.242.0 ]--
r 173             if (currentLoc != get)
--[ 2019.11.02.16.09.14.421.0 ]--
r 173             if (currentLoc != ge)
--[ 2019.11.02.16.09.15.050.0 ]--
r 173             if (currentLoc != get)
--[ 2019.11.02.16.09.15.323.0 ]--
r 173             if (currentLoc != getP)
--[ 2019.11.02.16.09.15.493.0 ]--
r 173             if (currentLoc != getPa)
--[ 2019.11.02.16.09.15.564.0 ]--
r 173             if (currentLoc != getPat)
--[ 2019.11.02.16.09.15.657.0 ]--
r 173             if (currentLoc != getPath)
--[ 2019.11.02.16.09.15.880.0 ]--
r 173             if (currentLoc != getPathS)
--[ 2019.11.02.16.09.16.103.0 ]--
r 173             if (currentLoc != getPathSt)
--[ 2019.11.02.16.09.16.199.0 ]--
r 173             if (currentLoc != getPathSta)
--[ 2019.11.02.16.09.16.330.0 ]--
r 173             if (currentLoc != getPathStar)
--[ 2019.11.02.16.09.16.515.0 ]--
r 173             if (currentLoc != getPathStart)
--[ 2019.11.02.16.09.16.711.0 ]--
r 173             if (currentLoc != getPathStart())
--[ 2019.11.02.16.09.17.616.0 ]--
r 173             if (currentLoc != getPathStart()) 
--[ 2019.11.02.16.09.20.222.0 ]--
r 173             if (currentLoc != getPathStart()) p
--[ 2019.11.02.16.09.20.311.0 ]--
r 173             if (currentLoc != getPathStart()) pq
--[ 2019.11.02.16.09.20.480.0 ]--
r 173             if (currentLoc != getPathStart()) pq.
--[ 2019.11.02.16.09.21.413.0 ]--
r 173             if (currentLoc != getPathStart()) pq.d
--[ 2019.11.02.16.09.21.602.0 ]--
r 173             if (currentLoc != getPathStart()) pq.de
--[ 2019.11.02.16.09.21.660.0 ]--
r 173             if (currentLoc != getPathStart()) pq.del
--[ 2019.11.02.16.09.21.923.0 ]--
r 173             if (currentLoc != getPathStart()) pq.delM
--[ 2019.11.02.16.09.22.109.0 ]--
r 173             if (currentLoc != getPathStart()) pq.delMi
--[ 2019.11.02.16.09.22.178.0 ]--
r 173             if (currentLoc != getPathStart()) pq.delMin
--[ 2019.11.02.16.09.22.564.0 ]--
r 173             if (currentLoc != getPathStart()) pq.delMin()
--[ 2019.11.02.16.09.22.830.0 ]--
r 173             if (currentLoc != getPathStart()) pq.delMin();
--[ 2019.11.02.16.09.30.201.0 ]--
- 174
- 174
- 174
r 174 
--[ 2019.11.02.16.09.30.569.0 ]--
- 174
--[ 2019.11.02.16.09.36.065.0 ]--
+ 175         
--[ 2019.11.02.16.09.36.400.0 ]--
r 175         /
--[ 2019.11.02.16.09.36.612.0 ]--
r 175         /*
--[ 2019.11.02.16.09.38.227.0 ]--
+ 186         
+ 187          */
--[ 2019.11.02.16.09.47.167.0 ]--
- 193
- 193
- 193
- 193
- 193
r 193         
--[ 2019.11.02.16.09.48.497.0 ]--
r 193         r
--[ 2019.11.02.16.09.48.587.0 ]--
r 193         re
--[ 2019.11.02.16.09.48.725.0 ]--
r 193         ret
--[ 2019.11.02.16.09.48.810.0 ]--
r 193         retu
--[ 2019.11.02.16.09.48.919.0 ]--
r 193         retur
--[ 2019.11.02.16.09.48.991.0 ]--
r 193         return
--[ 2019.11.02.16.09.49.114.0 ]--
r 193         return 
--[ 2019.11.02.16.09.49.150.0 ]--
r 193         return f
--[ 2019.11.02.16.09.49.343.0 ]--
r 193         return fa
--[ 2019.11.02.16.09.49.410.0 ]--
r 193         return fal
--[ 2019.11.02.16.09.49.486.0 ]--
r 193         return fals
--[ 2019.11.02.16.09.49.544.0 ]--
r 193         return false
--[ 2019.11.02.16.09.49.603.0 ]--
r 193         return false;
--[ 2019.11.02.16.09.52.218.0 ]--
r 186 
--[ 2019.11.02.16.09.53.784.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.02.16.10.00.379.0 ]--
+ 160             
--[ 2019.11.02.16.10.00.851.0 ]--
r 160             S
--[ 2019.11.02.16.10.01.044.0 ]--
r 160             St
--[ 2019.11.02.16.10.01.285.0 ]--
r 160             Std
--[ 2019.11.02.16.10.01.411.0 ]--
r 160             StdO
--[ 2019.11.02.16.10.01.615.0 ]--
r 160             StdOu
--[ 2019.11.02.16.10.01.720.0 ]--
r 160             StdOut
--[ 2019.11.02.16.10.01.831.0 ]--
r 160             StdOut.
--[ 2019.11.02.16.10.02.036.0 ]--
r 160             StdOut.p
--[ 2019.11.02.16.10.02.191.0 ]--
r 160             StdOut.pr
--[ 2019.11.02.16.10.02.291.0 ]--
r 160             StdOut.pri
--[ 2019.11.02.16.10.02.376.0 ]--
r 160             StdOut.prin
--[ 2019.11.02.16.10.04.655.0 ]--
r 160             StdOut.println("goodbye, s")
--[ 2019.11.02.16.10.04.744.0 ]--
r 160             StdOut.println("goodbye, sa")
--[ 2019.11.02.16.10.04.784.0 ]--
r 160             StdOut.println("goodbye, san")
--[ 2019.11.02.16.10.04.866.0 ]--
r 160             StdOut.println("goodbye, sani")
--[ 2019.11.02.16.10.04.985.0 ]--
r 160             StdOut.println("goodbye, sanit")
--[ 2019.11.02.16.10.05.099.0 ]--
r 160             StdOut.println("goodbye, sanity")
--[ 2019.11.02.16.10.05.378.0 ]--
r 160             StdOut.println("goodbye, sanity!")
--[ 2019.11.02.16.10.07.631.0 ]--
r 160             StdOut.println("goodbye, sanity!");
--[ 2019.11.02.16.10.13.090.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.02.16.11.09.490.0 ]--
+ 161             
--[ 2019.11.02.16.11.10.044.0 ]--
r 161             St
--[ 2019.11.02.16.11.10.301.0 ]--
r 161             StdO
--[ 2019.11.02.16.11.10.321.0 ]--
r 161             StdOu
--[ 2019.11.02.16.11.10.421.0 ]--
r 161             StdOut
--[ 2019.11.02.16.11.11.598.0 ]--
r 161             StdOut.
--[ 2019.11.02.16.11.11.666.0 ]--
r 161             StdOut.println
--[ 2019.11.02.16.11.11.872.0 ]--
r 161             StdOut.println9
--[ 2019.11.02.16.11.11.917.0 ]--
r 161             StdOut.println9""
--[ 2019.11.02.16.11.12.109.0 ]--
r 161             StdOut.println9"c"
--[ 2019.11.02.16.11.12.554.0 ]--
r 161             StdOut.println9"curr"
--[ 2019.11.02.16.11.12.597.0 ]--
r 161             StdOut.println9"curre"
--[ 2019.11.02.16.11.14.673.0 ]--
r 161             StdOut.println
--[ 2019.11.02.16.11.14.702.0 ]--
r 161             StdOut.printl
--[ 2019.11.02.16.11.16.018.0 ]--
r 161             StdOut.printll
--[ 2019.11.02.16.11.16.078.0 ]--
r 161             StdOut.printl
--[ 2019.11.02.16.11.16.920.0 ]--
r 161             StdOut.println()
--[ 2019.11.02.16.11.18.270.0 ]--
r 161             StdOut.println("current")
--[ 2019.11.02.16.11.20.232.0 ]--
r 161             StdOut.println("current node:")
--[ 2019.11.02.16.11.24.383.0 ]--
r 161             StdOut.println("current node: ")
--[ 2019.11.02.16.11.26.397.0 ]--
r 161             StdOut.println("current node: " )
--[ 2019.11.02.16.11.26.555.0 ]--
r 161             StdOut.println("current node: " +)
--[ 2019.11.02.16.11.26.626.0 ]--
r 161             StdOut.println("current node: " + )
--[ 2019.11.02.16.11.28.894.0 ]--
r 161             StdOut.println("current node: " + c)
--[ 2019.11.02.16.11.29.016.0 ]--
r 161             StdOut.println("current node: " + cu)
--[ 2019.11.02.16.11.29.195.0 ]--
r 161             StdOut.println("current node: " + cur)
--[ 2019.11.02.16.11.29.367.0 ]--
r 161             StdOut.println("current node: " + curr)
--[ 2019.11.02.16.11.29.470.0 ]--
r 161             StdOut.println("current node: " + curre)
--[ 2019.11.02.16.11.29.661.0 ]--
r 161             StdOut.println("current node: " + curren)
--[ 2019.11.02.16.11.29.704.0 ]--
r 161             StdOut.println("current node: " + current)
--[ 2019.11.02.16.11.29.889.0 ]--
r 161             StdOut.println("current node: " + currentL)
--[ 2019.11.02.16.11.30.122.0 ]--
r 161             StdOut.println("current node: " + currentLo)
--[ 2019.11.02.16.11.30.184.0 ]--
r 161             StdOut.println("current node: " + currentLoc)
--[ 2019.11.02.16.11.30.518.0 ]--
r 161             StdOut.println("current node: " + currentLoc())
--[ 2019.11.02.16.11.30.824.0 ]--
r 161             StdOut.println("current node: " + currentLoc());
--[ 2019.11.02.16.11.31.340.0 ]--
r 161             StdOut.println("current node: " + currentLoc())
--[ 2019.11.02.16.11.31.830.0 ]--
r 161             StdOut.println("current node: " + currentLoc()
--[ 2019.11.02.16.11.31.875.0 ]--
r 161             StdOut.println("current node: " + currentLoc(
--[ 2019.11.02.16.11.31.949.0 ]--
r 161             StdOut.println("current node: " + currentLo
--[ 2019.11.02.16.11.31.999.0 ]--
r 161             StdOut.println("current node: " + current
--[ 2019.11.02.16.11.32.027.0 ]--
r 161             StdOut.println("current node: " + curren
--[ 2019.11.02.16.11.32.060.0 ]--
r 161             StdOut.println("current node: " + curre
--[ 2019.11.02.16.11.32.093.0 ]--
r 161             StdOut.println("current node: " + curr
--[ 2019.11.02.16.11.32.127.0 ]--
r 161             StdOut.println("current node: " + cur
--[ 2019.11.02.16.11.32.163.0 ]--
r 161             StdOut.println("current node: " + cu
--[ 2019.11.02.16.11.32.195.0 ]--
r 161             StdOut.println("current node: " + c
--[ 2019.11.02.16.11.32.227.0 ]--
r 161             StdOut.println("current node: " + 
--[ 2019.11.02.16.11.32.265.0 ]--
r 161             StdOut.println("current node: " +
--[ 2019.11.02.16.11.32.293.0 ]--
r 161             StdOut.println("current node: " 
--[ 2019.11.02.16.11.32.325.0 ]--
r 161             StdOut.println("current node: "
--[ 2019.11.02.16.11.32.362.0 ]--
r 161             StdOut.println("current node: 
--[ 2019.11.02.16.11.32.391.0 ]--
r 161             StdOut.println("current node:
--[ 2019.11.02.16.11.32.424.0 ]--
r 161             StdOut.println("current node
--[ 2019.11.02.16.11.32.456.0 ]--
r 161             StdOut.println("current nod
--[ 2019.11.02.16.11.32.490.0 ]--
r 161             StdOut.println("current no
--[ 2019.11.02.16.11.32.523.0 ]--
r 161             StdOut.println("current n
--[ 2019.11.02.16.11.32.556.0 ]--
r 161             StdOut.println("current 
--[ 2019.11.02.16.11.32.589.0 ]--
r 161             StdOut.println("current
--[ 2019.11.02.16.11.32.622.0 ]--
r 161             StdOut.println("curren
--[ 2019.11.02.16.11.32.655.0 ]--
r 161             StdOut.println("curre
--[ 2019.11.02.16.11.32.689.0 ]--
r 161             StdOut.println("curr
--[ 2019.11.02.16.11.32.722.0 ]--
r 161             StdOut.println("cur
--[ 2019.11.02.16.11.32.754.0 ]--
r 161             StdOut.println("cu
--[ 2019.11.02.16.11.32.788.0 ]--
r 161             StdOut.println("c
--[ 2019.11.02.16.11.32.820.0 ]--
r 161             StdOut.println("
--[ 2019.11.02.16.11.32.852.0 ]--
r 161             StdOut.println(
--[ 2019.11.02.16.11.32.889.0 ]--
r 161             StdOut.println
--[ 2019.11.02.16.11.32.920.0 ]--
r 161             StdOut.printl
--[ 2019.11.02.16.11.32.952.0 ]--
r 161             StdOut.print
--[ 2019.11.02.16.11.32.984.0 ]--
r 161             StdOut.prin
--[ 2019.11.02.16.11.33.017.0 ]--
r 161             StdOut.pri
--[ 2019.11.02.16.11.33.051.0 ]--
r 161             StdOut.pr
--[ 2019.11.02.16.11.33.085.0 ]--
r 161             StdOut.p
--[ 2019.11.02.16.11.33.121.0 ]--
r 161             StdOut.
--[ 2019.11.02.16.11.33.151.0 ]--
r 161             StdOut
--[ 2019.11.02.16.11.33.188.0 ]--
r 161             StdOu
--[ 2019.11.02.16.11.33.218.0 ]--
r 161             StdO
--[ 2019.11.02.16.11.33.249.0 ]--
r 161             Std
--[ 2019.11.02.16.11.33.462.0 ]--
r 161             St
--[ 2019.11.02.16.11.33.677.0 ]--
r 161             S
--[ 2019.11.02.16.11.33.883.0 ]--
r 161             
--[ 2019.11.02.16.11.34.097.0 ]--
- 161
--[ 2019.11.02.16.11.37.584.0 ]--
+ 167             
--[ 2019.11.02.16.11.37.960.0 ]--
r 167             S
--[ 2019.11.02.16.11.38.216.0 ]--
r 167             St
--[ 2019.11.02.16.11.38.412.0 ]--
r 167             Std
--[ 2019.11.02.16.11.38.580.0 ]--
r 167             StdO
--[ 2019.11.02.16.11.38.773.0 ]--
r 167             StdOu
--[ 2019.11.02.16.11.38.848.0 ]--
r 167             StdOut
--[ 2019.11.02.16.11.38.997.0 ]--
r 167             StdOut.
--[ 2019.11.02.16.11.39.206.0 ]--
r 167             StdOut.p
--[ 2019.11.02.16.11.39.321.0 ]--
r 167             StdOut.pr
--[ 2019.11.02.16.11.39.494.0 ]--
r 167             StdOut.pri
--[ 2019.11.02.16.11.39.567.0 ]--
r 167             StdOut.prin
--[ 2019.11.02.16.11.39.720.0 ]--
r 167             StdOut.print
--[ 2019.11.02.16.11.39.771.0 ]--
r 167             StdOut.printl
--[ 2019.11.02.16.11.39.839.0 ]--
r 167             StdOut.println
--[ 2019.11.02.16.11.40.029.0 ]--
r 167             StdOut.println()
--[ 2019.11.02.16.11.40.198.0 ]--
r 167             StdOut.println("")
--[ 2019.11.02.16.11.40.366.0 ]--
r 167             StdOut.println("c")
--[ 2019.11.02.16.11.40.442.0 ]--
r 167             StdOut.println("cu")
--[ 2019.11.02.16.11.40.645.0 ]--
r 167             StdOut.println("cur")
--[ 2019.11.02.16.11.40.843.0 ]--
r 167             StdOut.println("curr")
--[ 2019.11.02.16.11.40.921.0 ]--
r 167             StdOut.println("curre")
--[ 2019.11.02.16.11.41.101.0 ]--
r 167             StdOut.println("curren")
--[ 2019.11.02.16.11.41.150.0 ]--
r 167             StdOut.println("current")
--[ 2019.11.02.16.11.41.242.0 ]--
r 167             StdOut.println("current ")
--[ 2019.11.02.16.11.41.347.0 ]--
r 167             StdOut.println("current l")
--[ 2019.11.02.16.11.41.501.0 ]--
r 167             StdOut.println("current lo")
--[ 2019.11.02.16.11.41.538.0 ]--
r 167             StdOut.println("current loc")
--[ 2019.11.02.16.11.41.733.0 ]--
r 167             StdOut.println("current loc:")
--[ 2019.11.02.16.11.41.862.0 ]--
r 167             StdOut.println("current loc: ")
--[ 2019.11.02.16.11.42.346.0 ]--
r 167             StdOut.println("current loc: " )
--[ 2019.11.02.16.11.42.513.0 ]--
r 167             StdOut.println("current loc: " +)
--[ 2019.11.02.16.11.42.655.0 ]--
r 167             StdOut.println("current loc: " + )
--[ 2019.11.02.16.11.43.158.0 ]--
r 167             StdOut.println("current loc: " + c)
--[ 2019.11.02.16.11.43.414.0 ]--
r 167             StdOut.println("current loc: " + cu)
--[ 2019.11.02.16.11.44.117.0 ]--
r 167             StdOut.println("current loc: " + cur)
--[ 2019.11.02.16.11.44.336.0 ]--
r 167             StdOut.println("current loc: " + curr)
--[ 2019.11.02.16.11.44.442.0 ]--
r 167             StdOut.println("current loc: " + curre)
--[ 2019.11.02.16.11.44.588.0 ]--
r 167             StdOut.println("current loc: " + curren)
--[ 2019.11.02.16.11.44.641.0 ]--
r 167             StdOut.println("current loc: " + current)
--[ 2019.11.02.16.11.44.858.0 ]--
r 167             StdOut.println("current loc: " + currentL)
--[ 2019.11.02.16.11.45.026.0 ]--
r 167             StdOut.println("current loc: " + currentLo)
--[ 2019.11.02.16.11.45.067.0 ]--
r 167             StdOut.println("current loc: " + currentLoc)
--[ 2019.11.02.16.11.45.839.0 ]--
r 167             StdOut.println("current loc: " + currentLoc )
--[ 2019.11.02.16.11.45.981.0 ]--
r 167             StdOut.println("current loc: " + currentLoc +)
--[ 2019.11.02.16.11.46.082.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + )
--[ 2019.11.02.16.11.46.870.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + "")
--[ 2019.11.02.16.11.47.228.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " ")
--[ 2019.11.02.16.11.48.512.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " c")
--[ 2019.11.02.16.11.48.572.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " co")
--[ 2019.11.02.16.11.48.710.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cos")
--[ 2019.11.02.16.11.48.817.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost")
--[ 2019.11.02.16.11.49.606.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost:")
--[ 2019.11.02.16.11.49.821.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: ")
--[ 2019.11.02.16.11.50.655.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " )
--[ 2019.11.02.16.11.50.814.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " +)
--[ 2019.11.02.16.11.50.932.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + )
--[ 2019.11.02.16.11.51.734.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + c)
--[ 2019.11.02.16.11.51.887.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + cu)
--[ 2019.11.02.16.11.52.020.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + cur)
--[ 2019.11.02.16.11.52.219.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + curr)
--[ 2019.11.02.16.11.52.268.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + curre)
--[ 2019.11.02.16.11.52.457.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + current)
--[ 2019.11.02.16.11.52.653.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + currentN)
--[ 2019.11.02.16.11.52.811.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + currentNo)
--[ 2019.11.02.16.11.52.877.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + currentNod)
--[ 2019.11.02.16.11.53.062.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode)
--[ 2019.11.02.16.11.53.186.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.)
--[ 2019.11.02.16.11.53.616.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.g)
--[ 2019.11.02.16.11.53.716.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.ge)
--[ 2019.11.02.16.11.53.894.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.get)
--[ 2019.11.02.16.11.55.211.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getC)
--[ 2019.11.02.16.11.55.498.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCo)
--[ 2019.11.02.16.11.55.671.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCos)
--[ 2019.11.02.16.11.55.732.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCost)
--[ 2019.11.02.16.11.55.973.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCost())
--[ 2019.11.02.16.11.56.458.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCost());
--[ 2019.11.02.16.12.00.046.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCost();
--[ 2019.11.02.16.12.00.529.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCost);
--[ 2019.11.02.16.12.00.559.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCos);
--[ 2019.11.02.16.12.00.592.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCo);
--[ 2019.11.02.16.12.00.625.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getC);
--[ 2019.11.02.16.12.00.658.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.get);
--[ 2019.11.02.16.12.00.716.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.ge);
--[ 2019.11.02.16.12.00.751.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.g);
--[ 2019.11.02.16.12.00.768.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.);
--[ 2019.11.02.16.12.00.790.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode);
--[ 2019.11.02.16.12.00.823.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + currentNod);
--[ 2019.11.02.16.12.00.856.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + currentNo);
--[ 2019.11.02.16.12.00.889.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + currentN);
--[ 2019.11.02.16.12.00.922.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + current);
--[ 2019.11.02.16.12.00.963.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + curren);
--[ 2019.11.02.16.12.01.035.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + curr);
--[ 2019.11.02.16.12.01.056.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + cur);
--[ 2019.11.02.16.12.01.194.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + cu);
--[ 2019.11.02.16.12.01.390.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + c);
--[ 2019.11.02.16.12.01.547.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + );
--[ 2019.11.02.16.12.01.837.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + b);
--[ 2019.11.02.16.12.02.017.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + bo);
--[ 2019.11.02.16.12.02.076.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + boa);
--[ 2019.11.02.16.12.02.143.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + boar);
--[ 2019.11.02.16.12.02.327.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board);
--[ 2019.11.02.16.12.02.370.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[]);
--[ 2019.11.02.16.12.02.930.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[c]);
--[ 2019.11.02.16.12.03.049.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[cu]);
--[ 2019.11.02.16.12.03.197.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[cur]);
--[ 2019.11.02.16.12.03.408.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[curr]);
--[ 2019.11.02.16.12.03.477.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[curre]);
--[ 2019.11.02.16.12.03.631.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[curren]);
--[ 2019.11.02.16.12.03.725.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[current]);
--[ 2019.11.02.16.12.03.918.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentL]);
--[ 2019.11.02.16.12.04.054.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLo]);
--[ 2019.11.02.16.12.04.135.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc]);
--[ 2019.11.02.16.12.04.263.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.]);
--[ 2019.11.02.16.12.04.419.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.g]);
--[ 2019.11.02.16.12.04.490.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.ge]);
--[ 2019.11.02.16.12.04.658.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.get]);
--[ 2019.11.02.16.12.04.840.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.getI]);
--[ 2019.11.02.16.12.05.110.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.getI()]);
--[ 2019.11.02.16.12.05.479.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.getI())]);
--[ 2019.11.02.16.12.06.106.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.getI()]);
--[ 2019.11.02.16.12.07.184.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.getI()][]);
--[ 2019.11.02.16.12.07.240.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.getI()][[]]);
--[ 2019.11.02.16.12.08.151.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.getI()][]);
--[ 2019.11.02.16.12.09.113.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.getI()][b]);
--[ 2019.11.02.16.12.09.206.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.getI()][bo]);
--[ 2019.11.02.16.12.09.402.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.getI()][boa]);
--[ 2019.11.02.16.12.09.443.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.getI()][boar]);
--[ 2019.11.02.16.12.09.833.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.getI()][boa]);
--[ 2019.11.02.16.12.09.994.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.getI()][bo]);
--[ 2019.11.02.16.12.10.174.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.getI()][b]);
--[ 2019.11.02.16.12.10.333.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.getI()][]);
--[ 2019.11.02.16.12.10.554.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.getI()][c]);
--[ 2019.11.02.16.12.10.697.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.getI()][cu]);
--[ 2019.11.02.16.12.10.837.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.getI()][cur]);
--[ 2019.11.02.16.12.11.020.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.getI()][curr]);
--[ 2019.11.02.16.12.11.154.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.getI()][curre]);
--[ 2019.11.02.16.12.11.200.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.getI()][curren]);
--[ 2019.11.02.16.12.11.288.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.getI()][current]);
--[ 2019.11.02.16.12.11.501.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.getI()][currentL]);
--[ 2019.11.02.16.12.11.659.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.getI()][currentLo]);
--[ 2019.11.02.16.12.11.717.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.getI()][currentLoc]);
--[ 2019.11.02.16.12.11.856.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.getI()][currentLoc.]);
--[ 2019.11.02.16.12.11.979.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.getI()][currentLoc.g]);
--[ 2019.11.02.16.12.12.057.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.getI()][currentLoc.ge]);
--[ 2019.11.02.16.12.12.224.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.getI()][currentLoc.get]);
--[ 2019.11.02.16.12.12.417.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.getI()][currentLoc.getJ]);
--[ 2019.11.02.16.12.12.716.0 ]--
r 167             StdOut.println("current loc: " + currentLoc + " cost: " + board[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.02.16.12.19.763.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.02.16.12.53.884.0 ]--
+ 176             
--[ 2019.11.02.16.12.54.863.0 ]--
r 176             e
--[ 2019.11.02.16.12.54.968.0 ]--
r 176             el
--[ 2019.11.02.16.12.55.094.0 ]--
r 176             els
--[ 2019.11.02.16.12.55.145.0 ]--
r 176             else
--[ 2019.11.02.16.12.55.180.0 ]--
r 176             else 
--[ 2019.11.02.16.13.12.633.0 ]--
r 164                 currentNode = pq.d();
--[ 2019.11.02.16.13.12.881.0 ]--
r 164                 currentNode = pq.del();
--[ 2019.11.02.16.13.13.057.0 ]--
r 164                 currentNode = pq.delM();
--[ 2019.11.02.16.13.13.315.0 ]--
r 164                 currentNode = pq.delMi();
--[ 2019.11.02.16.13.13.414.0 ]--
r 164                 currentNode = pq.delMin();
--[ 2019.11.02.16.13.16.925.0 ]--
- 175
r 175 
--[ 2019.11.02.16.13.17.128.0 ]--
- 175
--[ 2019.11.02.16.13.39.449.0 ]--
+ 171                 
--[ 2019.11.02.16.13.39.881.0 ]--
r 171                 i
--[ 2019.11.02.16.13.39.968.0 ]--
r 171                 if
--[ 2019.11.02.16.13.40.090.0 ]--
r 171                 if 
--[ 2019.11.02.16.13.40.266.0 ]--
r 171                 if ()
--[ 2019.11.02.16.13.40.566.0 ]--
r 171                 if (b)
--[ 2019.11.02.16.13.40.618.0 ]--
r 171                 if (bo)
--[ 2019.11.02.16.13.40.799.0 ]--
r 171                 if (boa)
--[ 2019.11.02.16.13.40.842.0 ]--
r 171                 if (boar)
--[ 2019.11.02.16.13.41.038.0 ]--
r 171                 if (board)
--[ 2019.11.02.16.13.41.122.0 ]--
r 171                 if (board[])
--[ 2019.11.02.16.13.41.287.0 ]--
r 171                 if (board[c])
--[ 2019.11.02.16.13.41.451.0 ]--
r 171                 if (board[c.])
--[ 2019.11.02.16.13.41.555.0 ]--
r 171                 if (board[c.g])
--[ 2019.11.02.16.13.41.634.0 ]--
r 171                 if (board[c.ge])
--[ 2019.11.02.16.13.41.799.0 ]--
r 171                 if (board[c.get])
--[ 2019.11.02.16.13.42.014.0 ]--
r 171                 if (board[c.getI])
--[ 2019.11.02.16.13.42.365.0 ]--
r 171                 if (board[c.getI()])
--[ 2019.11.02.16.13.43.133.0 ]--
r 171                 if (board[c.getI()]])
--[ 2019.11.02.16.13.43.678.0 ]--
r 171                 if (board[c.getI()])
--[ 2019.11.02.16.13.44.078.0 ]--
r 171                 if (board[c.getI()][])
--[ 2019.11.02.16.13.44.703.0 ]--
r 171                 if (board[c.getI()][b])
--[ 2019.11.02.16.13.44.772.0 ]--
r 171                 if (board[c.getI()][bo])
--[ 2019.11.02.16.13.44.973.0 ]--
r 171                 if (board[c.getI()][boa])
--[ 2019.11.02.16.13.45.272.0 ]--
r 171                 if (board[c.getI()][bo])
--[ 2019.11.02.16.13.45.465.0 ]--
r 171                 if (board[c.getI()][b])
--[ 2019.11.02.16.13.45.617.0 ]--
r 171                 if (board[c.getI()][])
--[ 2019.11.02.16.13.45.823.0 ]--
r 171                 if (board[c.getI()][c])
--[ 2019.11.02.16.13.45.992.0 ]--
r 171                 if (board[c.getI()][c.])
--[ 2019.11.02.16.13.46.356.0 ]--
r 171                 if (board[c.getI()][c.g])
--[ 2019.11.02.16.13.46.456.0 ]--
r 171                 if (board[c.getI()][c.ge])
--[ 2019.11.02.16.13.46.625.0 ]--
r 171                 if (board[c.getI()][c.get])
--[ 2019.11.02.16.13.46.848.0 ]--
r 171                 if (board[c.getI()][c.getJ])
--[ 2019.11.02.16.13.47.198.0 ]--
r 171                 if (board[c.getI()][c.getJ()])
--[ 2019.11.02.16.13.48.182.0 ]--
r 171                 if (board[c.getI()][c.getJ()]_)
--[ 2019.11.02.16.13.48.895.0 ]--
r 171                 if (board[c.getI()][c.getJ()])
--[ 2019.11.02.16.13.49.243.0 ]--
r 171                 if (board[c.getI()][c.getJ()] )
--[ 2019.11.02.16.13.49.500.0 ]--
r 171                 if (board[c.getI()][c.getJ()] !)
--[ 2019.11.02.16.13.49.734.0 ]--
r 171                 if (board[c.getI()][c.getJ()] !=)
--[ 2019.11.02.16.13.49.803.0 ]--
r 171                 if (board[c.getI()][c.getJ()] != )
--[ 2019.11.02.16.13.50.351.0 ]--
r 171                 if (board[c.getI()][c.getJ()] != n)
--[ 2019.11.02.16.13.50.638.0 ]--
r 171                 if (board[c.getI()][c.getJ()] != nu)
--[ 2019.11.02.16.13.50.803.0 ]--
r 171                 if (board[c.getI()][c.getJ()] != nul)
--[ 2019.11.02.16.13.50.945.0 ]--
r 171                 if (board[c.getI()][c.getJ()] != null)
--[ 2019.11.02.16.13.52.016.0 ]--
r 171                 if (board[c.getI()][c.getJ()] != null) 
--[ 2019.11.02.16.13.52.099.0 ]--
r 171                 if (board[c.getI()][c.getJ()] != null) {
--[ 2019.11.02.16.13.54.400.0 ]--
+ 175                 
--[ 2019.11.02.16.13.56.491.0 ]--
r 175                 }
--[ 2019.11.02.16.13.56.577.0 ]--
r 172                     PFNode cNode = new PFNode(c, currentNode);
--[ 2019.11.02.16.13.56.591.0 ]--
r 173                     pq.insert(cNode);
--[ 2019.11.02.16.13.56.603.0 ]--
r 174                     board[c.getI()][c.getJ()] = cNode.getCost();
--[ 2019.11.02.16.14.23.334.0 ]--
r 109         board = new int[N][N];b
--[ 2019.11.02.16.14.23.742.0 ]--
r 109         board = new int[N][N];
--[ 2019.11.02.16.14.23.992.0 ]--
+ 110         
--[ 2019.11.02.16.14.24.162.0 ]--
r 110         b
--[ 2019.11.02.16.14.24.344.0 ]--
r 110         bo
--[ 2019.11.02.16.14.24.434.0 ]--
r 110         boa
--[ 2019.11.02.16.14.24.477.0 ]--
r 110         boar
--[ 2019.11.02.16.14.24.689.0 ]--
r 110         board
--[ 2019.11.02.16.14.24.754.0 ]--
r 110         board 
--[ 2019.11.02.16.14.24.852.0 ]--
r 110         board =
--[ 2019.11.02.16.14.24.966.0 ]--
r 110         board = 
--[ 2019.11.02.16.14.25.055.0 ]--
r 110         board = n
--[ 2019.11.02.16.14.25.312.0 ]--
r 110         board = nu
--[ 2019.11.02.16.14.25.515.0 ]--
r 110         board = nul
--[ 2019.11.02.16.14.25.614.0 ]--
r 110         board = null
--[ 2019.11.02.16.14.25.690.0 ]--
r 110         board = null;
--[ 2019.11.02.16.14.30.239.0 ]--
r 110         f
--[ 2019.11.02.16.14.30.326.0 ]--
r 110         fo
--[ 2019.11.02.16.14.30.431.0 ]--
r 110         for
--[ 2019.11.02.16.14.30.482.0 ]--
r 110         for 
--[ 2019.11.02.16.14.30.654.0 ]--
r 110         for ()
--[ 2019.11.02.16.14.30.897.0 ]--
r 110         for (i)
--[ 2019.11.02.16.14.30.995.0 ]--
r 110         for (in)
--[ 2019.11.02.16.14.31.079.0 ]--
r 110         for (int)
--[ 2019.11.02.16.14.31.121.0 ]--
r 110         for (int )
--[ 2019.11.02.16.14.31.228.0 ]--
r 110         for (int i)
--[ 2019.11.02.16.14.31.373.0 ]--
r 110         for (int i )
--[ 2019.11.02.16.14.31.435.0 ]--
r 110         for (int i =)
--[ 2019.11.02.16.14.31.573.0 ]--
r 110         for (int i = )
--[ 2019.11.02.16.14.31.658.0 ]--
r 110         for (int i = 0)
--[ 2019.11.02.16.14.31.957.0 ]--
r 110         for (int i = 0;)
--[ 2019.11.02.16.14.32.089.0 ]--
r 110         for (int i = 0; )
--[ 2019.11.02.16.14.32.230.0 ]--
r 110         for (int i = 0; i)
--[ 2019.11.02.16.14.32.335.0 ]--
r 110         for (int i = 0; i )
--[ 2019.11.02.16.14.32.533.0 ]--
r 110         for (int i = 0; i <)
--[ 2019.11.02.16.14.32.610.0 ]--
r 110         for (int i = 0; i < )
--[ 2019.11.02.16.14.32.838.0 ]--
r 110         for (int i = 0; i < N)
--[ 2019.11.02.16.14.33.308.0 ]--
r 110         for (int i = 0; i < N;)
--[ 2019.11.02.16.14.33.405.0 ]--
r 110         for (int i = 0; i < N; )
--[ 2019.11.02.16.14.33.620.0 ]--
r 110         for (int i = 0; i < N; i)
--[ 2019.11.02.16.14.33.827.0 ]--
r 110         for (int i = 0; i < N; i+)
--[ 2019.11.02.16.14.33.941.0 ]--
r 110         for (int i = 0; i < N; i++)
--[ 2019.11.02.16.14.34.455.0 ]--
r 110         for (int i = 0; i < N; i++) 
--[ 2019.11.02.16.14.34.611.0 ]--
r 110         for (int i = 0; i < N; i++) {
--[ 2019.11.02.16.14.34.792.0 ]--
+ 111 
+ 112 }
--[ 2019.11.02.16.14.34.809.0 ]--
r 112         }
--[ 2019.11.02.16.14.34.830.0 ]--
r 111             
--[ 2019.11.02.16.14.35.399.0 ]--
r 111             f
--[ 2019.11.02.16.14.35.469.0 ]--
r 111             fo
--[ 2019.11.02.16.14.35.588.0 ]--
r 111             for
--[ 2019.11.02.16.14.35.670.0 ]--
r 111             for 
--[ 2019.11.02.16.14.35.816.0 ]--
r 111             for ()
--[ 2019.11.02.16.14.36.044.0 ]--
r 111             for (i)
--[ 2019.11.02.16.14.36.147.0 ]--
r 111             for (in)
--[ 2019.11.02.16.14.36.200.0 ]--
r 111             for (int)
--[ 2019.11.02.16.14.36.258.0 ]--
r 111             for (int )
--[ 2019.11.02.16.14.36.390.0 ]--
r 111             for (int j)
--[ 2019.11.02.16.14.36.483.0 ]--
r 111             for (int j )
--[ 2019.11.02.16.14.36.582.0 ]--
r 111             for (int j =)
--[ 2019.11.02.16.14.36.682.0 ]--
r 111             for (int j = )
--[ 2019.11.02.16.14.37.098.0 ]--
r 111             for (int j = 0)
--[ 2019.11.02.16.14.37.791.0 ]--
r 111             for (int j = 0;)
--[ 2019.11.02.16.14.37.850.0 ]--
r 111             for (int j = 0; )
--[ 2019.11.02.16.14.38.121.0 ]--
r 111             for (int j = 0; j)
--[ 2019.11.02.16.14.38.234.0 ]--
r 111             for (int j = 0; j )
--[ 2019.11.02.16.14.38.440.0 ]--
r 111             for (int j = 0; j <)
--[ 2019.11.02.16.14.38.506.0 ]--
r 111             for (int j = 0; j < )
--[ 2019.11.02.16.14.38.679.0 ]--
r 111             for (int j = 0; j < N)
--[ 2019.11.02.16.14.38.948.0 ]--
r 111             for (int j = 0; j < N;)
--[ 2019.11.02.16.14.39.046.0 ]--
r 111             for (int j = 0; j < N; )
--[ 2019.11.02.16.14.39.244.0 ]--
r 111             for (int j = 0; j < N; j)
--[ 2019.11.02.16.14.39.608.0 ]--
r 111             for (int j = 0; j < N; j+)
--[ 2019.11.02.16.14.39.738.0 ]--
r 111             for (int j = 0; j < N; j++)
--[ 2019.11.02.16.14.40.130.0 ]--
r 111             for (int j = 0; j < N; j++) 
--[ 2019.11.02.16.14.40.287.0 ]--
r 111             for (int j = 0; j < N; j++) {
--[ 2019.11.02.16.14.40.457.0 ]--
+ 112 
+ 113 }
--[ 2019.11.02.16.14.40.472.0 ]--
r 113             }
--[ 2019.11.02.16.14.40.495.0 ]--
r 112                 
--[ 2019.11.02.16.14.43.128.0 ]--
r 112                 b
--[ 2019.11.02.16.14.43.235.0 ]--
r 112                 bo
--[ 2019.11.02.16.14.43.329.0 ]--
r 112                 boa
--[ 2019.11.02.16.14.43.415.0 ]--
r 112                 boar
--[ 2019.11.02.16.14.43.611.0 ]--
r 112                 board
--[ 2019.11.02.16.14.43.632.0 ]--
r 112                 board[]
--[ 2019.11.02.16.14.43.854.0 ]--
r 112                 board[i]
--[ 2019.11.02.16.14.44.284.0 ]--
r 112                 board[i][]
--[ 2019.11.02.16.14.44.534.0 ]--
r 112                 board[i][j]
--[ 2019.11.02.16.14.44.936.0 ]--
r 112                 board[i][j] 
--[ 2019.11.02.16.14.45.090.0 ]--
r 112                 board[i][j] =
--[ 2019.11.02.16.14.45.237.0 ]--
r 112                 board[i][j] ==
--[ 2019.11.02.16.14.45.372.0 ]--
r 112                 board[i][j] == 
--[ 2019.11.02.16.14.45.503.0 ]--
r 112                 board[i][j] == n
--[ 2019.11.02.16.14.45.724.0 ]--
r 112                 board[i][j] == nu
--[ 2019.11.02.16.14.45.910.0 ]--
r 112                 board[i][j] == nul
--[ 2019.11.02.16.14.46.040.0 ]--
r 112                 board[i][j] == null
--[ 2019.11.02.16.14.46.106.0 ]--
r 112                 board[i][j] == null;
--[ 2019.11.02.16.14.52.614.0 ]--
r 112                 board[i][j] = null;
--[ 2019.11.02.16.15.07.606.0 ]--
r 112                 board[i][j] = -;
--[ 2019.11.02.16.15.07.804.0 ]--
r 112                 board[i][j] = -1;
--[ 2019.11.02.16.15.13.190.0 ]--
r 176                 if (board[c.getI()][c.getJ()] <!= null>) {
--[ 2019.11.02.16.15.13.266.0 ]--
r 176                 if (board[c.getI()][c.getJ()] < >) {
--[ 2019.11.02.16.15.13.531.0 ]--
r 176                 if (board[c.getI()][c.getJ()] < 0>) {
--[ 2019.11.02.16.15.14.754.0 ]--
r 176                 if (board[c.getI()][c.getJ()] < 0\>) {
--[ 2019.11.02.16.15.15.061.0 ]--
r 176                 if (board[c.getI()][c.getJ()] < 0>) {
--[ 2019.11.02.16.15.15.279.0 ]--
r 176                 if (board[c.getI()][c.getJ()] < >) {
--[ 2019.11.02.16.15.15.450.0 ]--
r 176                 if (board[c.getI()][c.getJ()] <>) {
--[ 2019.11.02.16.15.15.640.0 ]--
r 176                 if (board[c.getI()][c.getJ()] >) {
--[ 2019.11.02.16.15.17.350.0 ]--
r 176                 if (board[c.getI()][c.getJ()] >=) {
--[ 2019.11.02.16.15.17.470.0 ]--
r 176                 if (board[c.getI()][c.getJ()] >= ) {
--[ 2019.11.02.16.15.17.607.0 ]--
r 176                 if (board[c.getI()][c.getJ()] >= 0) {
--[ 2019.11.02.16.15.24.679.0 ]--
r 176                 if (board[c.getI()][c.getJ()] > 0) {
--[ 2019.11.02.16.15.24.870.0 ]--
r 176                 if (board[c.getI()][c.getJ()]  0) {
--[ 2019.11.02.16.15.25.670.0 ]--
r 176                 if (board[c.getI()][c.getJ()] < 0) {
--[ 2019.11.02.16.17.59.491.0 ]--
+ 164         
--[ 2019.11.02.16.17.59.858.0 ]--
r 164         b
--[ 2019.11.02.16.17.59.937.0 ]--
r 164         bo
--[ 2019.11.02.16.18.00.102.0 ]--
r 164         boo
--[ 2019.11.02.16.18.00.280.0 ]--
r 164         bool
--[ 2019.11.02.16.18.00.352.0 ]--
r 164         boole
--[ 2019.11.02.16.18.00.476.0 ]--
r 164         boolea
--[ 2019.11.02.16.18.00.516.0 ]--
r 164         boolean
--[ 2019.11.02.16.18.00.605.0 ]--
r 164         boolean 
--[ 2019.11.02.16.18.00.970.0 ]--
r 164         boolean a
--[ 2019.11.02.16.18.01.232.0 ]--
r 164         boolean at
--[ 2019.11.02.16.18.01.583.0 ]--
r 164         boolean atS
--[ 2019.11.02.16.18.01.725.0 ]--
r 164         boolean atSt
--[ 2019.11.02.16.18.01.854.0 ]--
r 164         boolean atSta
--[ 2019.11.02.16.18.01.933.0 ]--
r 164         boolean atStar
--[ 2019.11.02.16.18.02.102.0 ]--
r 164         boolean atStart
--[ 2019.11.02.16.18.02.164.0 ]--
r 164         boolean atStart;
--[ 2019.11.02.16.18.02.458.0 ]--
r 164         boolean atStart
--[ 2019.11.02.16.18.02.716.0 ]--
r 164         boolean atStart 
--[ 2019.11.02.16.18.02.799.0 ]--
r 164         boolean atStart =
--[ 2019.11.02.16.18.02.873.0 ]--
r 164         boolean atStart = 
--[ 2019.11.02.16.18.03.783.0 ]--
r 164         boolean atStart = t
--[ 2019.11.02.16.18.03.996.0 ]--
r 164         boolean atStart = tr
--[ 2019.11.02.16.18.04.052.0 ]--
r 164         boolean atStart = tru
--[ 2019.11.02.16.18.04.174.0 ]--
r 164         boolean atStart = true
--[ 2019.11.02.16.18.04.218.0 ]--
r 164         boolean atStart = true;
--[ 2019.11.02.16.18.13.837.0 ]--
r 168             if (a) currentNode = new PFNode(currentLoc, null);
--[ 2019.11.02.16.18.14.051.0 ]--
r 168             if (at) currentNode = new PFNode(currentLoc, null);
--[ 2019.11.02.16.18.14.278.0 ]--
r 168             if (atS) currentNode = new PFNode(currentLoc, null);
--[ 2019.11.02.16.18.14.427.0 ]--
r 168             if (atSt) currentNode = new PFNode(currentLoc, null);
--[ 2019.11.02.16.18.14.530.0 ]--
r 168             if (atSta) currentNode = new PFNode(currentLoc, null);
--[ 2019.11.02.16.18.14.614.0 ]--
r 168             if (atStar) currentNode = new PFNode(currentLoc, null);
--[ 2019.11.02.16.18.14.824.0 ]--
r 168             if (atStart) currentNode = new PFNode(currentLoc, null);
--[ 2019.11.02.16.18.18.325.0 ]--
+ 183             
--[ 2019.11.02.16.18.18.527.0 ]--
r 183             a
--[ 2019.11.02.16.18.18.643.0 ]--
r 183             at
--[ 2019.11.02.16.18.18.909.0 ]--
r 183             atS
--[ 2019.11.02.16.18.19.107.0 ]--
r 183             atSt
--[ 2019.11.02.16.18.19.240.0 ]--
r 183             atSta
--[ 2019.11.02.16.18.19.287.0 ]--
r 183             atStar
--[ 2019.11.02.16.18.19.498.0 ]--
r 183             atStart
--[ 2019.11.02.16.18.19.571.0 ]--
r 183             atStart 
--[ 2019.11.02.16.18.19.628.0 ]--
r 183             atStart =
--[ 2019.11.02.16.18.19.774.0 ]--
r 183             atStart = 
--[ 2019.11.02.16.18.19.897.0 ]--
r 183             atStart = f
--[ 2019.11.02.16.18.19.976.0 ]--
r 183             atStart = fa
--[ 2019.11.02.16.18.20.046.0 ]--
r 183             atStart = fal
--[ 2019.11.02.16.18.20.178.0 ]--
r 183             atStart = fals
--[ 2019.11.02.16.18.20.233.0 ]--
r 183             atStart = false
--[ 2019.11.02.16.18.20.274.0 ]--
r 183             atStart = false;
--[ 2019.11.02.16.18.29.751.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.02.16.18.59.336.0 ]--
+ 200     
--[ 2019.11.02.16.18.59.538.0 ]--
+ 200     
--[ 2019.11.02.16.18.59.904.0 ]--
r 201     p
--[ 2019.11.02.16.18.59.981.0 ]--
r 201     pu
--[ 2019.11.02.16.19.00.034.0 ]--
r 201     pub
--[ 2019.11.02.16.19.00.225.0 ]--
r 201     publ
--[ 2019.11.02.16.19.00.263.0 ]--
r 201     publi
--[ 2019.11.02.16.19.00.438.0 ]--
r 201     public
--[ 2019.11.02.16.19.00.594.0 ]--
r 201     public 
--[ 2019.11.02.16.19.01.215.0 ]--
r 201     public b
--[ 2019.11.02.16.19.01.295.0 ]--
r 201     public bo
--[ 2019.11.02.16.19.01.487.0 ]--
r 201     public boo
--[ 2019.11.02.16.19.01.662.0 ]--
r 201     public bo
--[ 2019.11.02.16.19.01.814.0 ]--
r 201     public b
--[ 2019.11.02.16.19.01.979.0 ]--
r 201     public 
--[ 2019.11.02.16.19.02.483.0 ]--
r 201     public b
--[ 2019.11.02.16.19.02.547.0 ]--
r 201     public bo
--[ 2019.11.02.16.19.02.705.0 ]--
r 201     public boo
--[ 2019.11.02.16.19.02.882.0 ]--
r 201     public bool
--[ 2019.11.02.16.19.02.947.0 ]--
r 201     public boole
--[ 2019.11.02.16.19.03.031.0 ]--
r 201     public boolea
--[ 2019.11.02.16.19.03.103.0 ]--
r 201     public boolean
--[ 2019.11.02.16.19.03.159.0 ]--
r 201     public boolean 
--[ 2019.11.02.16.19.03.300.0 ]--
r 201     public boolean v
--[ 2019.11.02.16.19.03.394.0 ]--
r 201     public boolean va
--[ 2019.11.02.16.19.03.479.0 ]--
r 201     public boolean val
--[ 2019.11.02.16.19.03.547.0 ]--
r 201     public boolean vali
--[ 2019.11.02.16.19.03.641.0 ]--
r 201     public boolean valid
--[ 2019.11.02.16.19.04.167.0 ]--
r 201     public boolean valida
--[ 2019.11.02.16.19.04.258.0 ]--
r 201     public boolean validat
--[ 2019.11.02.16.19.04.397.0 ]--
r 201     public boolean validate
--[ 2019.11.02.16.19.04.703.0 ]--
r 201     public boolean validateC
--[ 2019.11.02.16.19.04.883.0 ]--
r 201     public boolean validateCo
--[ 2019.11.02.16.19.05.037.0 ]--
r 201     public boolean validateCoo
--[ 2019.11.02.16.19.05.102.0 ]--
r 201     public boolean validateCoor
--[ 2019.11.02.16.19.05.293.0 ]--
r 201     public boolean validateCoord
--[ 2019.11.02.16.19.05.542.0 ]--
r 201     public boolean validateCoord()
--[ 2019.11.02.16.19.06.110.0 ]--
r 201     public boolean validateCoord(C)
--[ 2019.11.02.16.19.06.235.0 ]--
r 201     public boolean validateCoord(Co)
--[ 2019.11.02.16.19.06.392.0 ]--
r 201     public boolean validateCoord(Coo)
--[ 2019.11.02.16.19.06.464.0 ]--
r 201     public boolean validateCoord(Coor)
--[ 2019.11.02.16.19.06.692.0 ]--
r 201     public boolean validateCoord(Coorc)
--[ 2019.11.02.16.19.06.775.0 ]--
r 201     public boolean validateCoord(Coorc )
--[ 2019.11.02.16.19.07.276.0 ]--
r 201     public boolean validateCoord(Coorc c)
--[ 2019.11.02.16.19.07.506.0 ]--
r 201     public boolean validateCoord(Coorc )
--[ 2019.11.02.16.19.07.658.0 ]--
r 201     public boolean validateCoord(Coorc)
--[ 2019.11.02.16.19.07.813.0 ]--
r 201     public boolean validateCoord(Coor)
--[ 2019.11.02.16.19.07.984.0 ]--
r 201     public boolean validateCoord(Coord)
--[ 2019.11.02.16.19.08.187.0 ]--
r 201     public boolean validateCoord(Coord )
--[ 2019.11.02.16.19.08.385.0 ]--
r 201     public boolean validateCoord(Coord c)
--[ 2019.11.02.16.19.09.010.0 ]--
r 201     public boolean validateCoord(Coord c) 
--[ 2019.11.02.16.19.09.122.0 ]--
r 201     public boolean validateCoord(Coord c) {}
--[ 2019.11.02.16.19.09.272.0 ]--
+ 201     public boolean validateCoord(Coord c) {
r 202     }
--[ 2019.11.02.16.19.09.294.0 ]--
+ 202         
--[ 2019.11.02.16.19.20.431.0 ]--
r 202         c
--[ 2019.11.02.16.19.20.657.0 ]--
r 202         ci
--[ 2019.11.02.16.19.21.370.0 ]--
r 202         c
--[ 2019.11.02.16.19.21.509.0 ]--
r 202         
--[ 2019.11.02.16.19.22.728.0 ]--
r 202         i
--[ 2019.11.02.16.19.22.778.0 ]--
r 202         in
--[ 2019.11.02.16.19.22.856.0 ]--
r 202         int
--[ 2019.11.02.16.19.22.915.0 ]--
r 202         int 
--[ 2019.11.02.16.19.23.071.0 ]--
r 202         int c
--[ 2019.11.02.16.19.23.122.0 ]--
r 202         int ci
--[ 2019.11.02.16.19.23.210.0 ]--
r 202         int ci 
--[ 2019.11.02.16.19.23.333.0 ]--
r 202         int ci =
--[ 2019.11.02.16.19.23.407.0 ]--
r 202         int ci = 
--[ 2019.11.02.16.19.23.786.0 ]--
r 202         int ci = c
--[ 2019.11.02.16.19.23.885.0 ]--
r 202         int ci = c.
--[ 2019.11.02.16.19.24.145.0 ]--
r 202         int ci = c.g
--[ 2019.11.02.16.19.24.215.0 ]--
r 202         int ci = c.ge
--[ 2019.11.02.16.19.24.383.0 ]--
r 202         int ci = c.get
--[ 2019.11.02.16.19.24.577.0 ]--
r 202         int ci = c.getI
--[ 2019.11.02.16.19.24.821.0 ]--
r 202         int ci = c.getI()
--[ 2019.11.02.16.19.25.086.0 ]--
r 202         int ci = c.getI();
--[ 2019.11.02.16.19.25.271.0 ]--
+ 203         
--[ 2019.11.02.16.19.25.690.0 ]--
r 203         i
--[ 2019.11.02.16.19.25.781.0 ]--
r 203         in
--[ 2019.11.02.16.19.25.803.0 ]--
r 203         int
--[ 2019.11.02.16.19.25.898.0 ]--
r 203         int 
--[ 2019.11.02.16.19.26.335.0 ]--
r 203         int c
--[ 2019.11.02.16.19.26.385.0 ]--
r 203         int cj
--[ 2019.11.02.16.19.26.558.0 ]--
r 203         int cj 
--[ 2019.11.02.16.19.26.638.0 ]--
r 203         int cj =
--[ 2019.11.02.16.19.26.751.0 ]--
r 203         int cj = 
--[ 2019.11.02.16.19.27.014.0 ]--
r 203         int cj = c
--[ 2019.11.02.16.19.27.185.0 ]--
r 203         int cj = c.
--[ 2019.11.02.16.19.27.290.0 ]--
r 203         int cj = c.g
--[ 2019.11.02.16.19.27.369.0 ]--
r 203         int cj = c.ge
--[ 2019.11.02.16.19.27.543.0 ]--
r 203         int cj = c.get
--[ 2019.11.02.16.19.27.718.0 ]--
r 203         int cj = c.getJ
--[ 2019.11.02.16.19.28.018.0 ]--
r 203         int cj = c.getJ()
--[ 2019.11.02.16.19.28.319.0 ]--
r 203         int cj = c.getJ();
--[ 2019.11.02.16.19.28.503.0 ]--
+ 204         
--[ 2019.11.02.16.19.29.897.0 ]--
r 204         r
--[ 2019.11.02.16.19.29.996.0 ]--
r 204         re
--[ 2019.11.02.16.19.30.151.0 ]--
r 204         ret
--[ 2019.11.02.16.19.30.222.0 ]--
r 204         retu
--[ 2019.11.02.16.19.30.352.0 ]--
r 204         retur
--[ 2019.11.02.16.19.30.405.0 ]--
r 204         return
--[ 2019.11.02.16.19.30.515.0 ]--
r 204         return 
--[ 2019.11.02.16.19.31.632.0 ]--
r 204         return c
--[ 2019.11.02.16.19.31.738.0 ]--
r 204         return ci
--[ 2019.11.02.16.19.35.855.0 ]--
r 204         return ci 
--[ 2019.11.02.16.19.36.028.0 ]--
r 204         return ci >
--[ 2019.11.02.16.19.36.092.0 ]--
r 204         return ci > 
--[ 2019.11.02.16.19.36.342.0 ]--
r 204         return ci > 0
--[ 2019.11.02.16.19.37.566.0 ]--
r 204         return ci > 0 
--[ 2019.11.02.16.19.37.710.0 ]--
r 204         return ci > 0 &
--[ 2019.11.02.16.19.37.829.0 ]--
r 204         return ci > 0 &&
--[ 2019.11.02.16.19.37.962.0 ]--
r 204         return ci > 0 && 
--[ 2019.11.02.16.19.38.246.0 ]--
r 204         return ci > 0 &&
--[ 2019.11.02.16.19.38.426.0 ]--
r 204         return ci > 0 &
--[ 2019.11.02.16.19.39.495.0 ]--
r 204         return ci > 0 
--[ 2019.11.02.16.19.39.662.0 ]--
r 204         return ci > 0
--[ 2019.11.02.16.19.39.837.0 ]--
r 204         return ci > 
--[ 2019.11.02.16.19.40.078.0 ]--
r 204         return ci >
--[ 2019.11.02.16.19.40.559.0 ]--
r 204         return ci >=
--[ 2019.11.02.16.19.40.776.0 ]--
r 204         return ci >= 
--[ 2019.11.02.16.19.41.264.0 ]--
r 204         return ci >= -
--[ 2019.11.02.16.19.41.935.0 ]--
r 204         return ci >= - 
--[ 2019.11.02.16.19.42.094.0 ]--
r 204         return ci >= - &
--[ 2019.11.02.16.19.42.246.0 ]--
r 204         return ci >= - &&
--[ 2019.11.02.16.19.42.314.0 ]--
r 204         return ci >= - && 
--[ 2019.11.02.16.19.43.038.0 ]--
r 204         return ci >= - &&
--[ 2019.11.02.16.19.43.212.0 ]--
r 204         return ci >= - &
--[ 2019.11.02.16.19.43.361.0 ]--
r 204         return ci >= - 
--[ 2019.11.02.16.19.43.515.0 ]--
r 204         return ci >= -
--[ 2019.11.02.16.19.43.738.0 ]--
r 204         return ci >= 
--[ 2019.11.02.16.19.44.401.0 ]--
r 204         return ci >= 0
--[ 2019.11.02.16.19.44.778.0 ]--
r 204         return ci >= 0 
--[ 2019.11.02.16.19.45.006.0 ]--
r 204         return ci >= 0 &
--[ 2019.11.02.16.19.45.128.0 ]--
r 204         return ci >= 0 &&
--[ 2019.11.02.16.19.45.193.0 ]--
r 204         return ci >= 0 && 
--[ 2019.11.02.16.19.45.822.0 ]--
r 204         return ci >= 0 && c
--[ 2019.11.02.16.19.45.884.0 ]--
r 204         return ci >= 0 && ci
--[ 2019.11.02.16.19.46.250.0 ]--
r 204         return ci >= 0 && ci 
--[ 2019.11.02.16.19.46.462.0 ]--
r 204         return ci >= 0 && ci <
--[ 2019.11.02.16.19.46.546.0 ]--
r 204         return ci >= 0 && ci < 
--[ 2019.11.02.16.19.47.436.0 ]--
r 204         return ci >= 0 && ci < b
--[ 2019.11.02.16.19.47.485.0 ]--
r 204         return ci >= 0 && ci < bo
--[ 2019.11.02.16.19.47.688.0 ]--
r 204         return ci >= 0 && ci < boa
--[ 2019.11.02.16.19.47.763.0 ]--
r 204         return ci >= 0 && ci < boar
--[ 2019.11.02.16.19.47.912.0 ]--
r 204         return ci >= 0 && ci < board
--[ 2019.11.02.16.19.47.972.0 ]--
r 204         return ci >= 0 && ci < board.
--[ 2019.11.02.16.19.48.152.0 ]--
r 204         return ci >= 0 && ci < board.l
--[ 2019.11.02.16.19.48.226.0 ]--
r 204         return ci >= 0 && ci < board.le
--[ 2019.11.02.16.19.48.327.0 ]--
r 204         return ci >= 0 && ci < board.len
--[ 2019.11.02.16.19.48.457.0 ]--
r 204         return ci >= 0 && ci < board.leng
--[ 2019.11.02.16.19.48.652.0 ]--
r 204         return ci >= 0 && ci < board.lengt
--[ 2019.11.02.16.19.48.694.0 ]--
r 204         return ci >= 0 && ci < board.length
--[ 2019.11.02.16.19.52.055.0 ]--
r 204         return ci >= 0 && ci < board.length 
--[ 2019.11.02.16.19.52.262.0 ]--
r 204         return ci >= 0 && ci < board.length &
--[ 2019.11.02.16.19.52.387.0 ]--
r 204         return ci >= 0 && ci < board.length &&
--[ 2019.11.02.16.19.52.481.0 ]--
r 204         return ci >= 0 && ci < board.length && 
--[ 2019.11.02.16.19.52.718.0 ]--
r 204         return ci >= 0 && ci < board.length && c
--[ 2019.11.02.16.19.52.802.0 ]--
r 204         return ci >= 0 && ci < board.length && cj
--[ 2019.11.02.16.19.53.112.0 ]--
r 204         return ci >= 0 && ci < board.length && cj 
--[ 2019.11.02.16.19.53.292.0 ]--
r 204         return ci >= 0 && ci < board.length && cj >
--[ 2019.11.02.16.19.53.498.0 ]--
r 204         return ci >= 0 && ci < board.length && cj >=
--[ 2019.11.02.16.19.53.638.0 ]--
r 204         return ci >= 0 && ci < board.length && cj >= 
--[ 2019.11.02.16.19.53.755.0 ]--
r 204         return ci >= 0 && ci < board.length && cj >= 0
--[ 2019.11.02.16.19.54.690.0 ]--
r 204         return ci >= 0 && ci < board.length && cj >= 0 
--[ 2019.11.02.16.19.54.872.0 ]--
r 204         return ci >= 0 && ci < board.length && cj >= 0 &
--[ 2019.11.02.16.19.54.984.0 ]--
r 204         return ci >= 0 && ci < board.length && cj >= 0 &&
--[ 2019.11.02.16.19.55.058.0 ]--
r 204         return ci >= 0 && ci < board.length && cj >= 0 && 
--[ 2019.11.02.16.19.55.535.0 ]--
r 204         return ci >= 0 && ci < board.length && cj >= 0 && c
--[ 2019.11.02.16.19.55.619.0 ]--
r 204         return ci >= 0 && ci < board.length && cj >= 0 && cj
--[ 2019.11.02.16.19.56.505.0 ]--
r 204         return ci >= 0 && ci < board.length && cj >= 0 && cj 
--[ 2019.11.02.16.19.56.691.0 ]--
r 204         return ci >= 0 && ci < board.length && cj >= 0 && cj <
--[ 2019.11.02.16.19.56.747.0 ]--
r 204         return ci >= 0 && ci < board.length && cj >= 0 && cj < 
--[ 2019.11.02.16.19.56.939.0 ]--
r 204         return ci >= 0 && ci < board.length && cj >= 0 && cj < b
--[ 2019.11.02.16.19.57.000.0 ]--
r 204         return ci >= 0 && ci < board.length && cj >= 0 && cj < bo
--[ 2019.11.02.16.19.57.160.0 ]--
r 204         return ci >= 0 && ci < board.length && cj >= 0 && cj < boa
--[ 2019.11.02.16.19.57.208.0 ]--
r 204         return ci >= 0 && ci < board.length && cj >= 0 && cj < boar
--[ 2019.11.02.16.19.57.389.0 ]--
r 204         return ci >= 0 && ci < board.length && cj >= 0 && cj < board
--[ 2019.11.02.16.19.57.467.0 ]--
r 204         return ci >= 0 && ci < board.length && cj >= 0 && cj < board.
--[ 2019.11.02.16.19.57.650.0 ]--
r 204         return ci >= 0 && ci < board.length && cj >= 0 && cj < board.l
--[ 2019.11.02.16.19.57.714.0 ]--
r 204         return ci >= 0 && ci < board.length && cj >= 0 && cj < board.le
--[ 2019.11.02.16.19.57.866.0 ]--
r 204         return ci >= 0 && ci < board.length && cj >= 0 && cj < board.len
--[ 2019.11.02.16.19.57.927.0 ]--
r 204         return ci >= 0 && ci < board.length && cj >= 0 && cj < board.leng
--[ 2019.11.02.16.19.58.147.0 ]--
r 204         return ci >= 0 && ci < board.length && cj >= 0 && cj < board.lengt
--[ 2019.11.02.16.19.58.201.0 ]--
r 204         return ci >= 0 && ci < board.length && cj >= 0 && cj < board.length
--[ 2019.11.02.16.19.58.325.0 ]--
r 204         return ci >= 0 && ci < board.length && cj >= 0 && cj < board.length;
--[ 2019.11.02.16.20.04.369.0 ]--
r 177                 if (vboard[c.getI()][c.getJ()] < 0) {
--[ 2019.11.02.16.20.04.602.0 ]--
r 177                 if (valboard[c.getI()][c.getJ()] < 0) {
--[ 2019.11.02.16.20.04.637.0 ]--
r 177                 if (valiboard[c.getI()][c.getJ()] < 0) {
--[ 2019.11.02.16.20.04.907.0 ]--
r 177                 if (validboard[c.getI()][c.getJ()] < 0) {
--[ 2019.11.02.16.20.05.054.0 ]--
r 177                 if (validaboard[c.getI()][c.getJ()] < 0) {
--[ 2019.11.02.16.20.05.118.0 ]--
r 177                 if (validatboard[c.getI()][c.getJ()] < 0) {
--[ 2019.11.02.16.20.05.234.0 ]--
r 177                 if (validateboard[c.getI()][c.getJ()] < 0) {
--[ 2019.11.02.16.20.05.706.0 ]--
r 177                 if (validateCboard[c.getI()][c.getJ()] < 0) {
--[ 2019.11.02.16.20.05.946.0 ]--
r 177                 if (validateCoboard[c.getI()][c.getJ()] < 0) {
--[ 2019.11.02.16.20.06.065.0 ]--
r 177                 if (validateCooboard[c.getI()][c.getJ()] < 0) {
--[ 2019.11.02.16.20.06.202.0 ]--
r 177                 if (validateCoorboard[c.getI()][c.getJ()] < 0) {
--[ 2019.11.02.16.20.06.420.0 ]--
r 177                 if (validateCoordboard[c.getI()][c.getJ()] < 0) {
--[ 2019.11.02.16.20.06.694.0 ]--
r 177                 if (validateCoord(board[c.getI()][c.getJ()] < 0) {
--[ 2019.11.02.16.20.06.787.0 ]--
r 177                 if (validateCoord(cboard[c.getI()][c.getJ()] < 0) {
--[ 2019.11.02.16.20.07.046.0 ]--
r 177                 if (validateCoord(c)board[c.getI()][c.getJ()] < 0) {
--[ 2019.11.02.16.20.08.412.0 ]--
r 177                 if (validateCoord(c) board[c.getI()][c.getJ()] < 0) {
--[ 2019.11.02.16.20.08.607.0 ]--
r 177                 if (validateCoord(c) &board[c.getI()][c.getJ()] < 0) {
--[ 2019.11.02.16.20.08.741.0 ]--
r 177                 if (validateCoord(c) &&board[c.getI()][c.getJ()] < 0) {
--[ 2019.11.02.16.20.08.826.0 ]--
r 177                 if (validateCoord(c) && board[c.getI()][c.getJ()] < 0) {
--[ 2019.11.02.16.20.14.297.0 ]--
r 200 
--[ 2019.11.02.16.20.15.955.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.02.16.21.16.990.0 ]--
r 173             StdOut.println("current loc: " + currentLoc + " cost: " + c);
--[ 2019.11.02.16.21.17.154.0 ]--
r 173             StdOut.println("current loc: " + currentLoc + " cost: " + cu);
--[ 2019.11.02.16.21.17.236.0 ]--
r 173             StdOut.println("current loc: " + currentLoc + " cost: " + cur);
--[ 2019.11.02.16.21.17.415.0 ]--
r 173             StdOut.println("current loc: " + currentLoc + " cost: " + curr);
--[ 2019.11.02.16.21.17.513.0 ]--
r 173             StdOut.println("current loc: " + currentLoc + " cost: " + curre);
--[ 2019.11.02.16.21.17.651.0 ]--
r 173             StdOut.println("current loc: " + currentLoc + " cost: " + curren);
--[ 2019.11.02.16.21.17.695.0 ]--
r 173             StdOut.println("current loc: " + currentLoc + " cost: " + current);
--[ 2019.11.02.16.21.17.859.0 ]--
r 173             StdOut.println("current loc: " + currentLoc + " cost: " + currentN);
--[ 2019.11.02.16.21.17.991.0 ]--
r 173             StdOut.println("current loc: " + currentLoc + " cost: " + currentNo);
--[ 2019.11.02.16.21.18.065.0 ]--
r 173             StdOut.println("current loc: " + currentLoc + " cost: " + currentNod);
--[ 2019.11.02.16.21.18.266.0 ]--
r 173             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode);
--[ 2019.11.02.16.21.18.358.0 ]--
r 173             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.);
--[ 2019.11.02.16.21.18.572.0 ]--
r 173             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.g);
--[ 2019.11.02.16.21.18.628.0 ]--
r 173             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.ge);
--[ 2019.11.02.16.21.18.782.0 ]--
r 173             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.get);
--[ 2019.11.02.16.21.19.222.0 ]--
r 173             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getC);
--[ 2019.11.02.16.21.19.437.0 ]--
r 173             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCo);
--[ 2019.11.02.16.21.19.530.0 ]--
r 173             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCos);
--[ 2019.11.02.16.21.19.625.0 ]--
r 173             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCost);
--[ 2019.11.02.16.21.20.102.0 ]--
r 173             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCost());
--[ 2019.11.02.16.21.25.221.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.02.16.22.24.496.0 ]--
+ 170                 
--[ 2019.11.02.16.22.26.425.0 ]--
r 170                 i
--[ 2019.11.02.16.22.26.502.0 ]--
r 170                 if
--[ 2019.11.02.16.22.26.569.0 ]--
r 170                 if 
--[ 2019.11.02.16.22.27.415.0 ]--
r 170                 if p
--[ 2019.11.02.16.22.27.523.0 ]--
r 170                 if pq
--[ 2019.11.02.16.22.27.720.0 ]--
r 170                 if pq.
--[ 2019.11.02.16.22.30.250.0 ]--
r 170                 if pq.i
--[ 2019.11.02.16.22.30.327.0 ]--
r 170                 if pq.is
--[ 2019.11.02.16.22.30.655.0 ]--
r 170                 if pq.isE
--[ 2019.11.02.16.22.30.818.0 ]--
r 170                 if pq.isEm
--[ 2019.11.02.16.22.30.907.0 ]--
r 170                 if pq.isEmp
--[ 2019.11.02.16.22.30.974.0 ]--
r 170                 if pq.isEmpt
--[ 2019.11.02.16.22.31.135.0 ]--
r 170                 if pq.isEmpty
--[ 2019.11.02.16.22.31.533.0 ]--
r 170                 if pq.isEmpty()
--[ 2019.11.02.16.22.35.334.0 ]--
r 170                 if (pq.isEmpty()
--[ 2019.11.02.16.22.36.783.0 ]--
r 170                 if (pq.isEmpty())
--[ 2019.11.02.16.22.40.598.0 ]--
r 170                 if (!pq.isEmpty())
--[ 2019.11.02.16.22.42.475.0 ]--
r 170                 if (pq.isEmpty())
--[ 2019.11.02.16.22.43.457.0 ]--
r 170                 if (pq.isEmpty()) 
--[ 2019.11.02.16.22.43.638.0 ]--
r 170                 if (pq.isEmpty()) b
--[ 2019.11.02.16.22.43.925.0 ]--
r 170                 if (pq.isEmpty()) br
--[ 2019.11.02.16.22.43.990.0 ]--
r 170                 if (pq.isEmpty()) bre
--[ 2019.11.02.16.22.44.054.0 ]--
r 170                 if (pq.isEmpty()) brea
--[ 2019.11.02.16.22.44.077.0 ]--
r 170                 if (pq.isEmpty()) break
--[ 2019.11.02.16.22.44.212.0 ]--
r 170                 if (pq.isEmpty()) break;
--[ 2019.11.02.16.22.46.207.0 ]--
r 171                 ecurrentNode = pq.delMin();
--[ 2019.11.02.16.22.46.461.0 ]--
r 171                 elcurrentNode = pq.delMin();
--[ 2019.11.02.16.22.46.595.0 ]--
r 171                 elscurrentNode = pq.delMin();
--[ 2019.11.02.16.22.46.624.0 ]--
r 171                 elsecurrentNode = pq.delMin();
--[ 2019.11.02.16.22.46.725.0 ]--
r 171                 else currentNode = pq.delMin();
--[ 2019.11.02.16.22.51.267.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.02.16.23.33.434.0 ]--
r 170                 if (!pq.isEmpty()) break;
--[ 2019.11.02.16.23.33.704.0 ]--
r 170                 if (!apq.isEmpty()) break;
--[ 2019.11.02.16.23.33.892.0 ]--
r 170                 if (!atpq.isEmpty()) break;
--[ 2019.11.02.16.23.34.173.0 ]--
r 170                 if (!atSpq.isEmpty()) break;
--[ 2019.11.02.16.23.34.387.0 ]--
r 170                 if (!atStpq.isEmpty()) break;
--[ 2019.11.02.16.23.34.481.0 ]--
r 170                 if (!atStapq.isEmpty()) break;
--[ 2019.11.02.16.23.34.676.0 ]--
r 170                 if (!atStarpq.isEmpty()) break;
--[ 2019.11.02.16.23.34.766.0 ]--
r 170                 if (!atStartpq.isEmpty()) break;
--[ 2019.11.02.16.23.34.868.0 ]--
r 170                 if (!atStart pq.isEmpty()) break;
--[ 2019.11.02.16.23.35.779.0 ]--
r 170                 if (!atStart &pq.isEmpty()) break;
--[ 2019.11.02.16.23.35.865.0 ]--
r 170                 if (!atStart &&pq.isEmpty()) break;
--[ 2019.11.02.16.23.35.978.0 ]--
r 170                 if (!atStart && pq.isEmpty()) break;
--[ 2019.11.02.16.23.40.851.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.02.16.23.53.633.0 ]--
+ 186         
--[ 2019.11.02.16.23.54.352.0 ]--
r 186         S
--[ 2019.11.02.16.23.54.592.0 ]--
r 186         St
--[ 2019.11.02.16.23.54.794.0 ]--
r 186         Std
--[ 2019.11.02.16.23.55.020.0 ]--
r 186         StdO
--[ 2019.11.02.16.23.55.183.0 ]--
r 186         StdOu
--[ 2019.11.02.16.23.55.294.0 ]--
r 186         StdOut
--[ 2019.11.02.16.23.55.428.0 ]--
r 186         StdOut.
--[ 2019.11.02.16.23.56.016.0 ]--
r 186         StdOut.p
--[ 2019.11.02.16.23.56.069.0 ]--
r 186         StdOut.pr
--[ 2019.11.02.16.23.56.203.0 ]--
r 186         StdOut.pri
--[ 2019.11.02.16.23.56.349.0 ]--
r 186         StdOut.prin
--[ 2019.11.02.16.23.56.431.0 ]--
r 186         StdOut.print
--[ 2019.11.02.16.23.56.496.0 ]--
r 186         StdOut.printl
--[ 2019.11.02.16.23.56.571.0 ]--
r 186         StdOut.println
--[ 2019.11.02.16.23.56.787.0 ]--
r 186         StdOut.println()
--[ 2019.11.02.16.23.56.974.0 ]--
r 186         StdOut.println("")
--[ 2019.11.02.16.23.57.140.0 ]--
r 186         StdOut.println("b")
--[ 2019.11.02.16.23.57.398.0 ]--
r 186         StdOut.println("br")
--[ 2019.11.02.16.23.57.455.0 ]--
r 186         StdOut.println("bro")
--[ 2019.11.02.16.23.57.515.0 ]--
r 186         StdOut.println("brok")
--[ 2019.11.02.16.23.57.618.0 ]--
r 186         StdOut.println("broke")
--[ 2019.11.02.16.23.57.759.0 ]--
r 186         StdOut.println("brokeN")
--[ 2019.11.02.16.23.57.913.0 ]--
r 186         StdOut.println("brokeN'")
--[ 2019.11.02.16.23.58.094.0 ]--
r 186         StdOut.println("brokeN')")
--[ 2019.11.02.16.23.58.479.0 ]--
r 186         StdOut.println("brokeN'")
--[ 2019.11.02.16.23.58.630.0 ]--
r 186         StdOut.println("brokeN")
--[ 2019.11.02.16.23.58.789.0 ]--
r 186         StdOut.println("broke")
--[ 2019.11.02.16.23.59.287.0 ]--
r 186         StdOut.println("broken")
--[ 2019.11.02.16.23.59.965.0 ]--
r 186         StdOut.println("broken");
--[ 2019.11.02.16.24.04.350.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.02.16.28.04.296.0 ]--
+ 133     
--[ 2019.11.02.16.28.04.505.0 ]--
+ 133     
--[ 2019.11.02.16.28.04.945.0 ]--
r 134     p
--[ 2019.11.02.16.28.05.066.0 ]--
r 134     pr
--[ 2019.11.02.16.28.05.112.0 ]--
r 134     pri
--[ 2019.11.02.16.28.05.304.0 ]--
r 134     priv
--[ 2019.11.02.16.28.05.402.0 ]--
r 134     priva
--[ 2019.11.02.16.28.05.506.0 ]--
r 134     privat
--[ 2019.11.02.16.28.05.576.0 ]--
r 134     private
--[ 2019.11.02.16.28.05.691.0 ]--
r 134     private 
--[ 2019.11.02.16.28.05.848.0 ]--
r 134     private p
--[ 2019.11.02.16.28.06.028.0 ]--
r 134     private pi
--[ 2019.11.02.16.28.06.482.0 ]--
r 134     private p
--[ 2019.11.02.16.28.06.969.0 ]--
r 134     private pr
--[ 2019.11.02.16.28.07.160.0 ]--
r 134     private pri
--[ 2019.11.02.16.28.07.198.0 ]--
r 134     private prin
--[ 2019.11.02.16.28.07.274.0 ]--
r 134     private print
--[ 2019.11.02.16.28.07.573.0 ]--
r 134     private printO
--[ 2019.11.02.16.28.07.690.0 ]--
r 134     private printOr
--[ 2019.11.02.16.28.07.793.0 ]--
r 134     private printOri
--[ 2019.11.02.16.28.07.907.0 ]--
r 134     private printOrig
--[ 2019.11.02.16.28.08.166.0 ]--
r 134     private printOrigB
--[ 2019.11.02.16.28.08.281.0 ]--
r 134     private printOrigBo
--[ 2019.11.02.16.28.08.436.0 ]--
r 134     private printOrigBoa
--[ 2019.11.02.16.28.08.482.0 ]--
r 134     private printOrigBoar
--[ 2019.11.02.16.28.08.714.0 ]--
r 134     private printOrigBoard
--[ 2019.11.02.16.28.09.009.0 ]--
r 134     private printOrigBoard()
--[ 2019.11.02.16.28.09.344.0 ]--
r 134     private printOrigBoard() 
--[ 2019.11.02.16.28.09.467.0 ]--
r 134     private printOrigBoard() {}
--[ 2019.11.02.16.28.09.663.0 ]--
+ 134     private printOrigBoard() {
r 135     }
--[ 2019.11.02.16.28.09.686.0 ]--
+ 135         
--[ 2019.11.02.16.28.12.679.0 ]--
r 134     private vprintOrigBoard() {
--[ 2019.11.02.16.28.12.783.0 ]--
r 134     private voprintOrigBoard() {
--[ 2019.11.02.16.28.12.832.0 ]--
r 134     private voiprintOrigBoard() {
--[ 2019.11.02.16.28.12.925.0 ]--
r 134     private voidprintOrigBoard() {
--[ 2019.11.02.16.28.12.973.0 ]--
r 134     private void printOrigBoard() {
--[ 2019.11.02.16.28.16.442.0 ]--
r 135         f
--[ 2019.11.02.16.28.16.668.0 ]--
r 135         for
--[ 2019.11.02.16.28.16.750.0 ]--
r 135         for 
--[ 2019.11.02.16.28.16.973.0 ]--
r 135         for ()
--[ 2019.11.02.16.28.17.614.0 ]--
r 135         for (i)
--[ 2019.11.02.16.28.17.698.0 ]--
r 135         for (in)
--[ 2019.11.02.16.28.17.753.0 ]--
r 135         for (int)
--[ 2019.11.02.16.28.17.793.0 ]--
r 135         for (int )
--[ 2019.11.02.16.28.17.921.0 ]--
r 135         for (int j)
--[ 2019.11.02.16.28.18.026.0 ]--
r 135         for (int j )
--[ 2019.11.02.16.28.18.114.0 ]--
r 135         for (int j =)
--[ 2019.11.02.16.28.18.230.0 ]--
r 135         for (int j = )
--[ 2019.11.02.16.28.18.337.0 ]--
r 135         for (int j = 0)
--[ 2019.11.02.16.28.18.641.0 ]--
r 135         for (int j = 0;)
--[ 2019.11.02.16.28.18.746.0 ]--
r 135         for (int j = 0; )
--[ 2019.11.02.16.28.19.351.0 ]--
r 135         for (int j = 0; j)
--[ 2019.11.02.16.28.19.485.0 ]--
r 135         for (int j = 0; j )
--[ 2019.11.02.16.28.19.684.0 ]--
r 135         for (int j = 0; j <)
--[ 2019.11.02.16.28.19.730.0 ]--
r 135         for (int j = 0; j < )
--[ 2019.11.05.10.03.17.893.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.11.05.10.03.17.994.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/.cos265
/readme.html
/P04_Pathfinding.iml

--[ 2019.11.05.10.03.17.997.0 ]--
InitFile: /.cos265


--[ 2019.11.05.10.03.18.001.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.11.05.10.03.18.004.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.11.05.10.03.18.008.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private Terrain terrain;
    private int[][] board;
    private int[][] origCost;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)
        private Coord loc;
        private PFNode fromNode;
        private int cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            return getCost() - that.getCost();
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        public int getCost() {

            // use terrain.computeTravelCost() to get the cost of the current node

            //if (fromNode == null) return 0;
            //else return (int) terrain.computeTravelCost(fromNode.getLoc(), getLoc());

            //if (fromNode == null) return 0;
            //else return fromNode.getCost() + terrain.getHeight(loc);

            PFNode b = fromNode;
            if (b == null) return 0;
            else {
                int fromCost = board[b.getLoc().getI()][b.getLoc().getJ()];
                return fromCost + findHeightDiff(this, b) + 1;
            }
        }

        private int findHeightDiff(PFNode a, PFNode b) {
            int ha = board[a.getLoc().getI()][a.getLoc().getJ()];
            int hb = board[b.getLoc().getI()][b.getLoc().getJ()];
            return Math.abs(ha - hb);
        }

        // Returns the location of the PFNode
        public Coord getLoc() {
            return loc;
        }

        public float getCost(float heuristic) {
            return 0;
        }

        // returns if this PFNode is not marked invalid
        public boolean isValid() {
            return false;
        }

        // marks the PFNode as invalid
        public void invalidate() {

        }

        // returns if the PFNode is marked as used
        public boolean isUsed() {
            return true;
        }

        // marks the PFNode as used
        public void use() { }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        int N = this.terrain.getN();
        board = new int[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                board[j][i] = -1;
            }
        }
        origCost = new int[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                origCost[j][i] = this.terrain.getHeight(i, j);
            }
        }

    }

    public void setPathStart(Coord loc) {
        start = new Coord(loc.getI(), loc.getJ());
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        end = new Coord(loc.getI(), loc.getJ());
    }

    public Coord getPathEnd() {
        return end;
    }

    private void printOrigBoard() {
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board.length; j++) {
                StdOut.print(terrain.getHeight(j, i));
                StdOut.print(' ');
            }
            StdOut.println();
        }
    }

    public void setHeuristic(float v) {

    }

    public float getHeuristic() {
        return 0;
    }

    public void resetPath() {

    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        // Step 1: Look at all possible locations from starting point, create nodes for each
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        while (true) {
            StdOut.println("goodbye, sanity!");
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (!atStart && pq.isEmpty()) { StdOut.println("big oof"); break; }
                else currentNode = pq.delMin();
                currentLoc = currentNode.getLoc();
            }
            StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCost() + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
            if (currentLoc == getPathEnd()) break;
            Coord[] neighbors = findNeighbors(currentLoc);
            for (Coord c : neighbors) {
                if (validateCoord(c) && board[c.getI()][c.getJ()] < 0) {
                    StdOut.println("inserting " + c);
                    PFNode cNode = new PFNode(c, currentNode);
                    pq.insert(cNode);
                    board[c.getI()][c.getJ()] = cNode.getCost();
                }
            }
            atStart = false;
        }
        StdOut.println("broken");
        /*
        Coord[] neighbors = findNeighbors(start);
        PFNode startNode = new PFNode(start, null);
        for (Coord c : neighbors) {
            PFNode cNode = new PFNode(c, startNode);
            pq.insert(cNode);
            board[c.getI()][c.getJ()] = cNode.getCost();
        }
        for (PFNode n : pq) {
            StdOut.println("node: " + n.getLoc());
        }

         */
        printOrigBoard();

    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < board.length && cj >= 0 && cj < board.length;
    }

    public boolean foundPath() {

        return false;
    }

    public float getPathCost() {
        return 0;
    }

    public int getSearchSize() {
        return 0;
    }

    public Iterable<Coord> getPathSolution() {
        return null;
    }

    public boolean wasSearched(Coord loc) {
        return false;
    }
}

--[ 2019.11.05.10.03.18.012.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return null;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return true;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
    }

}

--[ 2019.11.05.10.03.18.015.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.11.05.10.03.18.019.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.11.05.10.03.18.022.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
    };

    private final static String emapFilename = emaps[12];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.11.05.10.03.18.025.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.05.10.10.23.215.0 ]--
:/src/Pathfinder.java
r 113                 board[][i] = -1;
--[ 2019.11.05.10.10.23.631.0 ]--
r 113                 board[i][i] = -1;
--[ 2019.11.05.10.10.25.314.0 ]--
r 113                 board[i][] = -1;
--[ 2019.11.05.10.10.25.776.0 ]--
r 113                 board[i][j] = -1;
--[ 2019.11.05.10.29.02.589.0 ]--
:/src/Terrain.java
+ 72         
--[ 2019.11.05.10.29.15.418.0 ]--
:/src/Pathfinder.java
r 119                 origCost[][i] = this.terrain.getHeight(i, j);
--[ 2019.11.05.10.29.15.642.0 ]--
r 119                 origCost[i][i] = this.terrain.getHeight(i, j);
--[ 2019.11.05.10.29.17.861.0 ]--
r 119                 origCost[i][] = this.terrain.getHeight(i, j);
--[ 2019.11.05.10.29.18.030.0 ]--
r 119                 origCost[i][j] = this.terrain.getHeight(i, j);
--[ 2019.11.05.10.29.31.144.0 ]--
r 144                 StdOut.print(terrain.getHeight(, i));
--[ 2019.11.05.10.29.31.380.0 ]--
r 144                 StdOut.print(terrain.getHeight(i, i));
--[ 2019.11.05.10.29.34.719.0 ]--
r 144                 StdOut.print(terrain.getHeight(, i));
--[ 2019.11.05.10.29.34.808.0 ]--
r 144                 StdOut.print(terrain.getHeight(j, i));
--[ 2019.11.05.10.29.37.145.0 ]--
:/src/Terrain.java
r 72 
--[ 2019.11.05.10.29.39.254.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.10.36.10.772.0 ]--
:/src/Pathfinder.java
+ 51 
--[ 2019.11.05.10.36.11.007.0 ]--
r 52             
--[ 2019.11.05.10.36.12.381.0 ]--
r 52             /
--[ 2019.11.05.10.36.12.734.0 ]--
r 52             /*
--[ 2019.11.05.10.36.15.173.0 ]--
+ 59             
+ 60              */
--[ 2019.11.05.10.36.15.446.0 ]--
r 59             *
--[ 2019.11.05.10.36.15.649.0 ]--
r 59             */
--[ 2019.11.05.10.36.16.662.0 ]--
r 59             *
--[ 2019.11.05.10.36.16.865.0 ]--
r 59             
--[ 2019.11.05.10.36.18.652.0 ]--
r 59            
--[ 2019.11.05.10.36.19.044.0 ]--
r 59           
--[ 2019.11.05.10.36.19.392.0 ]--
r 59          
--[ 2019.11.05.10.36.19.675.0 ]--
r 59         
--[ 2019.11.05.10.36.19.838.0 ]--
r 59        
--[ 2019.11.05.10.36.19.994.0 ]--
r 59       
--[ 2019.11.05.10.36.20.197.0 ]--
r 59      
--[ 2019.11.05.10.36.20.370.0 ]--
r 59     
--[ 2019.11.05.10.36.20.545.0 ]--
r 59    
--[ 2019.11.05.10.36.20.811.0 ]--
r 59   
--[ 2019.11.05.10.36.21.015.0 ]--
r 59  
--[ 2019.11.05.10.36.21.220.0 ]--
r 59 
--[ 2019.11.05.10.36.21.487.0 ]--
- 59
--[ 2019.11.05.10.36.24.506.0 ]--
+ 60              
--[ 2019.11.05.10.36.24.522.0 ]--
r 60             
--[ 2019.11.05.10.36.40.423.0 ]--
+ 60              
--[ 2019.11.05.10.36.40.678.0 ]--
r 60             re
--[ 2019.11.05.10.36.40.818.0 ]--
r 60             ret
--[ 2019.11.05.10.36.40.928.0 ]--
r 60             retu
--[ 2019.11.05.10.36.41.021.0 ]--
r 60             retur
--[ 2019.11.05.10.36.41.115.0 ]--
r 60             return
--[ 2019.11.05.10.36.41.177.0 ]--
r 60             return 
--[ 2019.11.05.10.36.41.287.0 ]--
r 60             return 0
--[ 2019.11.05.10.36.41.545.0 ]--
r 60             return 0;
--[ 2019.11.05.10.36.45.656.0 ]--
+ 76             
--[ 2019.11.05.10.36.47.347.0 ]--
r 76             b
--[ 2019.11.05.10.36.48.049.0 ]--
r 76             
--[ 2019.11.05.10.36.48.362.0 ]--
r 76             P
--[ 2019.11.05.10.36.48.473.0 ]--
r 76             PF
--[ 2019.11.05.10.36.48.614.0 ]--
r 76             PFN
--[ 2019.11.05.10.36.48.896.0 ]--
r 76             PFNo
--[ 2019.11.05.10.36.49.427.0 ]--
r 76             PFNod
--[ 2019.11.05.10.36.49.649.0 ]--
r 76             PFNode
--[ 2019.11.05.10.36.49.687.0 ]--
r 76             PFNode 
--[ 2019.11.05.10.36.49.890.0 ]--
r 76             PFNode b
--[ 2019.11.05.10.36.49.968.0 ]--
r 76             PFNode b 
--[ 2019.11.05.10.36.50.031.0 ]--
r 76             PFNode b =
--[ 2019.11.05.10.36.50.171.0 ]--
r 76             PFNode b = 
--[ 2019.11.05.10.36.50.376.0 ]--
r 76             PFNode b = f
--[ 2019.11.05.10.36.50.589.0 ]--
r 76             PFNode b = fr
--[ 2019.11.05.10.36.50.879.0 ]--
r 76             PFNode b = from
--[ 2019.11.05.10.36.50.911.0 ]--
r 76             PFNode b = fromN
--[ 2019.11.05.10.36.51.051.0 ]--
r 76             PFNode b = fromNo
--[ 2019.11.05.10.36.51.145.0 ]--
r 76             PFNode b = fromNod
--[ 2019.11.05.10.36.51.349.0 ]--
r 76             PFNode b = fromNode
--[ 2019.11.05.10.36.51.396.0 ]--
r 76             PFNode b = fromNode;
--[ 2019.11.05.10.36.51.641.0 ]--
+ 77             
--[ 2019.11.05.10.36.57.772.0 ]--
r 77             i
--[ 2019.11.05.10.36.57.866.0 ]--
r 77             if
--[ 2019.11.05.10.36.57.941.0 ]--
r 77             if 
--[ 2019.11.05.10.36.58.091.0 ]--
r 77             if ()
--[ 2019.11.05.10.36.58.271.0 ]--
r 77             if (b)
--[ 2019.11.05.10.36.58.427.0 ]--
r 77             if (b )
--[ 2019.11.05.10.36.58.521.0 ]--
r 77             if (b =)
--[ 2019.11.05.10.36.58.677.0 ]--
r 77             if (b ==)
--[ 2019.11.05.10.36.58.755.0 ]--
r 77             if (b == )
--[ 2019.11.05.10.36.58.880.0 ]--
r 77             if (b == 0)
--[ 2019.11.05.10.36.59.199.0 ]--
r 77             if (b == 0) 
--[ 2019.11.05.10.36.59.826.0 ]--
r 77             if (b == 0) r
--[ 2019.11.05.10.36.59.909.0 ]--
r 77             if (b == 0) re
--[ 2019.11.05.10.37.00.332.0 ]--
r 77             if (b == 0) r
--[ 2019.11.05.10.37.00.490.0 ]--
r 77             if (b == 0) 
--[ 2019.11.05.10.37.00.631.0 ]--
r 77             if (b == 0)
--[ 2019.11.05.10.37.00.871.0 ]--
r 77             if (b == 0
--[ 2019.11.05.10.37.00.965.0 ]--
r 77             if (b == 
--[ 2019.11.05.10.37.03.414.0 ]--
r 77             if (b == g
--[ 2019.11.05.10.37.03.476.0 ]--
r 77             if (b == ge
--[ 2019.11.05.10.37.03.648.0 ]--
r 77             if (b == get
--[ 2019.11.05.10.37.04.290.0 ]--
r 77             if (b == getS
--[ 2019.11.05.10.37.04.771.0 ]--
r 77             if (b == get
--[ 2019.11.05.10.37.05.053.0 ]--
r 77             if (b == getP
--[ 2019.11.05.10.37.05.191.0 ]--
r 77             if (b == getPa
--[ 2019.11.05.10.37.05.269.0 ]--
r 77             if (b == getPat
--[ 2019.11.05.10.37.05.362.0 ]--
r 77             if (b == getPath
--[ 2019.11.05.10.37.05.597.0 ]--
r 77             if (b == getPathS
--[ 2019.11.05.10.37.05.800.0 ]--
r 77             if (b == getPathSt
--[ 2019.11.05.10.37.05.894.0 ]--
r 77             if (b == getPathSta
--[ 2019.11.05.10.37.05.987.0 ]--
r 77             if (b == getPathStar
--[ 2019.11.05.10.37.06.175.0 ]--
r 77             if (b == getPathStart
--[ 2019.11.05.10.37.06.395.0 ]--
r 77             if (b == getPathStart()
--[ 2019.11.05.10.37.06.410.0 ]--
r 77             if (b == getPathStart())
--[ 2019.11.05.10.37.06.566.0 ]--
r 77             if (b == getPathStart() )
--[ 2019.11.05.10.37.07.381.0 ]--
r 77             if (b == getPathStart() f)
--[ 2019.11.05.10.37.07.960.0 ]--
r 77             if (b == getPathStart() )
--[ 2019.11.05.10.37.15.399.0 ]--
r 77             if (b == getPathStart())
--[ 2019.11.05.10.37.15.921.0 ]--
r 77             if (b == getPathStart)
--[ 2019.11.05.10.37.15.964.0 ]--
r 77             if (b == getPathStar)
--[ 2019.11.05.10.37.15.995.0 ]--
r 77             if (b == getPathSta)
--[ 2019.11.05.10.37.16.027.0 ]--
r 77             if (b == getPathSt)
--[ 2019.11.05.10.37.16.058.0 ]--
r 77             if (b == getPathS)
--[ 2019.11.05.10.37.16.105.0 ]--
r 77             if (b == getPath)
--[ 2019.11.05.10.37.16.120.0 ]--
r 77             if (b == getPat)
--[ 2019.11.05.10.37.16.152.0 ]--
r 77             if (b == getPa)
--[ 2019.11.05.10.37.16.183.0 ]--
r 77             if (b == getP)
--[ 2019.11.05.10.37.16.214.0 ]--
r 77             if (b == get)
--[ 2019.11.05.10.37.16.261.0 ]--
r 77             if (b == ge)
--[ 2019.11.05.10.37.16.292.0 ]--
r 77             if (b == g)
--[ 2019.11.05.10.37.16.324.0 ]--
r 77             if (b == )
--[ 2019.11.05.10.37.16.370.0 ]--
r 77             if (b ==)
--[ 2019.11.05.10.37.16.746.0 ]--
r 77             if (b =)
--[ 2019.11.05.10.37.16.956.0 ]--
r 77             if (b )
--[ 2019.11.05.10.37.17.305.0 ]--
r 77             if (b =)
--[ 2019.11.05.10.37.17.415.0 ]--
r 77             if (b ==)
--[ 2019.11.05.10.37.17.509.0 ]--
r 77             if (b == )
--[ 2019.11.05.10.37.17.822.0 ]--
r 77             if (b == n)
--[ 2019.11.05.10.37.18.075.0 ]--
r 77             if (b == nu)
--[ 2019.11.05.10.37.18.276.0 ]--
r 77             if (b == nul)
--[ 2019.11.05.10.37.18.433.0 ]--
r 77             if (b == null)
--[ 2019.11.05.10.37.18.762.0 ]--
r 77             if (b == null) 
--[ 2019.11.05.10.37.18.927.0 ]--
r 77             if (b == null) r
--[ 2019.11.05.10.37.19.020.0 ]--
r 77             if (b == null) re
--[ 2019.11.05.10.37.19.233.0 ]--
r 77             if (b == null) ret
--[ 2019.11.05.10.37.19.295.0 ]--
r 77             if (b == null) retu
--[ 2019.11.05.10.37.19.404.0 ]--
r 77             if (b == null) retur
--[ 2019.11.05.10.37.19.514.0 ]--
r 77             if (b == null) return
--[ 2019.11.05.10.37.19.545.0 ]--
r 77             if (b == null) return 
--[ 2019.11.05.10.37.19.686.0 ]--
r 77             if (b == null) return 0
--[ 2019.11.05.10.37.19.937.0 ]--
r 77             if (b == null) return 0;
--[ 2019.11.05.10.37.20.124.0 ]--
+ 78             
--[ 2019.11.05.10.37.20.640.0 ]--
r 78             e
--[ 2019.11.05.10.37.20.734.0 ]--
r 78             el
--[ 2019.11.05.10.37.20.843.0 ]--
r 78             els
--[ 2019.11.05.10.37.20.890.0 ]--
r 78             else
--[ 2019.11.05.10.37.20.984.0 ]--
r 78             else 
--[ 2019.11.05.10.37.21.282.0 ]--
r 78             else {
--[ 2019.11.05.10.37.21.445.0 ]--
+ 79 
+ 80 }
--[ 2019.11.05.10.37.21.460.0 ]--
r 80             }
--[ 2019.11.05.10.37.21.507.0 ]--
r 79                 
--[ 2019.11.05.10.37.32.805.0 ]--
r 79                 r
--[ 2019.11.05.10.37.33.064.0 ]--
r 79                 re
--[ 2019.11.05.10.37.33.104.0 ]--
r 79                 ret
--[ 2019.11.05.10.37.33.214.0 ]--
r 79                 retu
--[ 2019.11.05.10.37.33.292.0 ]--
r 79                 retur
--[ 2019.11.05.10.37.33.385.0 ]--
r 79                 return
--[ 2019.11.05.10.37.33.464.0 ]--
r 79                 return 
--[ 2019.11.05.10.37.33.635.0 ]--
r 79                 return b
--[ 2019.11.05.10.37.33.776.0 ]--
r 79                 return b.
--[ 2019.11.05.10.37.35.106.0 ]--
r 79                 return b.g
--[ 2019.11.05.10.37.35.170.0 ]--
r 79                 return b.ge
--[ 2019.11.05.10.37.35.326.0 ]--
r 79                 return b.get
--[ 2019.11.05.10.37.35.711.0 ]--
r 79                 return b.getC
--[ 2019.11.05.10.37.35.836.0 ]--
r 79                 return b.getCo
--[ 2019.11.05.10.37.36.478.0 ]--
r 79                 return b.getCos
--[ 2019.11.05.10.37.36.547.0 ]--
r 79                 return b.getCost
--[ 2019.11.05.10.37.36.931.0 ]--
r 79                 return b.getCost()
--[ 2019.11.05.10.37.37.370.0 ]--
r 79                 return b.getCost(
--[ 2019.11.05.10.37.37.777.0 ]--
r 79                 return b.getCost(h
--[ 2019.11.05.10.37.38.060.0 ]--
r 79                 return b.getCost(h)
--[ 2019.11.05.10.37.38.244.0 ]--
r 79                 return b.getCost(h) 
--[ 2019.11.05.10.37.38.730.0 ]--
r 79                 return b.getCost(h)
--[ 2019.11.05.10.37.38.935.0 ]--
r 79                 return b.getCost(h
--[ 2019.11.05.10.37.39.107.0 ]--
r 79                 return b.getCost(
--[ 2019.11.05.10.37.39.374.0 ]--
r 79                 return b.getCost(h
--[ 2019.11.05.10.37.39.502.0 ]--
r 79                 return b.getCost(he
--[ 2019.11.05.10.37.39.612.0 ]--
r 79                 return b.getCost(heu
--[ 2019.11.05.10.37.39.720.0 ]--
r 79                 return b.getCost(heur
--[ 2019.11.05.10.37.39.845.0 ]--
r 79                 return b.getCost(heuri
--[ 2019.11.05.10.37.39.971.0 ]--
r 79                 return b.getCost(heuris
--[ 2019.11.05.10.37.40.017.0 ]--
r 79                 return b.getCost(heurist
--[ 2019.11.05.10.37.40.110.0 ]--
r 79                 return b.getCost(heuristi
--[ 2019.11.05.10.37.40.251.0 ]--
r 79                 return b.getCost(heuristic
--[ 2019.11.05.10.37.40.423.0 ]--
r 79                 return b.getCost(heuristic)
--[ 2019.11.05.10.37.41.346.0 ]--
r 79                 return b.getCost(heuristic
--[ 2019.11.05.10.37.41.860.0 ]--
r 79                 return b.getCost(heuristi
--[ 2019.11.05.10.37.41.873.0 ]--
r 79                 return b.getCost(heurist
--[ 2019.11.05.10.37.41.904.0 ]--
r 79                 return b.getCost(heuris
--[ 2019.11.05.10.37.41.920.0 ]--
r 79                 return b.getCost(heuri
--[ 2019.11.05.10.37.41.967.0 ]--
r 79                 return b.getCost(heur
--[ 2019.11.05.10.37.41.982.0 ]--
r 79                 return b.getCost(heu
--[ 2019.11.05.10.37.42.029.0 ]--
r 79                 return b.getCost(he
--[ 2019.11.05.10.37.42.061.0 ]--
r 79                 return b.getCost(h
--[ 2019.11.05.10.37.42.092.0 ]--
r 79                 return b.getCost(
--[ 2019.11.05.10.37.42.123.0 ]--
r 79                 return b.getCost
--[ 2019.11.05.10.37.42.154.0 ]--
r 79                 return b.getCos
--[ 2019.11.05.10.37.42.192.0 ]--
r 79                 return b.getCo
--[ 2019.11.05.10.37.42.219.0 ]--
r 79                 return b.getC
--[ 2019.11.05.10.37.42.639.0 ]--
r 79                 return b.get
--[ 2019.11.05.10.37.42.843.0 ]--
r 79                 return b.ge
--[ 2019.11.05.10.37.43.246.0 ]--
r 79                 return b.
--[ 2019.11.05.10.37.43.607.0 ]--
r 79                 return b.g
--[ 2019.11.05.10.37.43.703.0 ]--
r 79                 return b.ge
--[ 2019.11.05.10.37.43.937.0 ]--
r 79                 return b.get
--[ 2019.11.05.10.37.44.376.0 ]--
r 79                 return b.ge
--[ 2019.11.05.10.37.44.844.0 ]--
r 79                 return b.g
--[ 2019.11.05.10.37.45.032.0 ]--
r 79                 return b.
--[ 2019.11.05.10.37.53.713.0 ]--
r 79                 return b
--[ 2019.11.05.10.37.53.969.0 ]--
r 79                 return 
--[ 2019.11.05.10.37.54.062.0 ]--
r 79                 return
--[ 2019.11.05.10.37.54.823.0 ]--
r 79                 return 
--[ 2019.11.05.10.37.55.886.0 ]--
r 79                 return b
--[ 2019.11.05.10.37.55.994.0 ]--
r 79                 return bo
--[ 2019.11.05.10.37.56.276.0 ]--
r 79                 return boa
--[ 2019.11.05.10.37.56.317.0 ]--
r 79                 return boar
--[ 2019.11.05.10.37.56.537.0 ]--
r 79                 return board
--[ 2019.11.05.10.37.56.615.0 ]--
r 79                 return board[]
--[ 2019.11.05.10.37.58.678.0 ]--
r 79                 return board[b]
--[ 2019.11.05.10.37.58.815.0 ]--
r 79                 return board[b.]
--[ 2019.11.05.10.37.59.973.0 ]--
r 79                 return board[b.getLoc]
--[ 2019.11.05.10.37.59.990.0 ]--
r 79                 return board[b.getLoc()]
--[ 2019.11.05.10.38.00.491.0 ]--
r 79                 return board[b.getLoc().]
--[ 2019.11.05.10.38.01.257.0 ]--
r 79                 return board[b.getLoc().getI]
--[ 2019.11.05.10.38.01.271.0 ]--
r 79                 return board[b.getLoc().getI()]
--[ 2019.11.05.10.38.02.292.0 ]--
r 79                 return board[b.getLoc().getI()][]
--[ 2019.11.05.10.38.02.878.0 ]--
r 79                 return board[b.getLoc().getI()][b]
--[ 2019.11.05.10.38.02.961.0 ]--
r 79                 return board[b.getLoc().getI()][b.]
--[ 2019.11.05.10.38.03.220.0 ]--
r 79                 return board[b.getLoc().getI()][b.g]
--[ 2019.11.05.10.38.03.300.0 ]--
r 79                 return board[b.getLoc().getI()][b.ge]
--[ 2019.11.05.10.38.03.488.0 ]--
r 79                 return board[b.getLoc().getI()][b.get]
--[ 2019.11.05.10.38.03.598.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc]
--[ 2019.11.05.10.38.03.612.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc()]
--[ 2019.11.05.10.38.04.160.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc()/.]
--[ 2019.11.05.10.38.04.579.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc()/]
--[ 2019.11.05.10.38.04.766.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc()]
--[ 2019.11.05.10.38.05.033.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().]
--[ 2019.11.05.10.38.05.362.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().g]
--[ 2019.11.05.10.38.05.446.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().ge]
--[ 2019.11.05.10.38.05.634.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().get]
--[ 2019.11.05.10.38.05.869.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ]
--[ 2019.11.05.10.38.06.188.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()]
--[ 2019.11.05.10.38.08.911.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] 
--[ 2019.11.05.10.38.09.138.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] +
--[ 2019.11.05.10.38.09.263.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + 
--[ 2019.11.05.10.38.09.624.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + t
--[ 2019.11.05.10.38.09.744.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + te
--[ 2019.11.05.10.38.09.900.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + ter
--[ 2019.11.05.10.38.10.072.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terr
--[ 2019.11.05.10.38.10.135.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terra
--[ 2019.11.05.10.38.10.212.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrai
--[ 2019.11.05.10.38.10.291.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain
--[ 2019.11.05.10.38.10.448.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.
--[ 2019.11.05.10.38.11.864.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.t
--[ 2019.11.05.10.38.12.069.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.tr
--[ 2019.11.05.10.38.12.131.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.tra
--[ 2019.11.05.10.38.12.292.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.trav
--[ 2019.11.05.10.38.12.398.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.trave
--[ 2019.11.05.10.38.12.583.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.travel
--[ 2019.11.05.10.38.15.179.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost
--[ 2019.11.05.10.38.15.384.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost()
--[ 2019.11.05.10.38.17.107.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b)
--[ 2019.11.05.10.38.17.200.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.)
--[ 2019.11.05.10.38.17.498.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.g)
--[ 2019.11.05.10.38.17.576.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.ge)
--[ 2019.11.05.10.38.18.132.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.get)
--[ 2019.11.05.10.38.18.466.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getL)
--[ 2019.11.05.10.38.18.622.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLo)
--[ 2019.11.05.10.38.18.716.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc)
--[ 2019.11.05.10.38.22.995.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc)_
--[ 2019.11.05.10.38.23.775.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc)
--[ 2019.11.05.10.38.23.962.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc
--[ 2019.11.05.10.38.24.930.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc()
--[ 2019.11.05.10.38.24.960.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc())
--[ 2019.11.05.10.38.25.560.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(),)
--[ 2019.11.05.10.38.25.782.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), )
--[ 2019.11.05.10.38.29.006.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), t)
--[ 2019.11.05.10.38.29.100.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), th)
--[ 2019.11.05.10.38.29.147.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), thi)
--[ 2019.11.05.10.38.29.288.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), this)
--[ 2019.11.05.10.38.29.397.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), this.)
--[ 2019.11.05.10.38.29.523.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), this.g)
--[ 2019.11.05.10.38.29.569.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), this.ge)
--[ 2019.11.05.10.38.29.741.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), this.get)
--[ 2019.11.05.10.38.29.992.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), this.getL)
--[ 2019.11.05.10.38.30.116.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), this.getLo)
--[ 2019.11.05.10.38.30.147.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), this.getLoc)
--[ 2019.11.05.10.38.30.524.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), this.getLoc())
--[ 2019.11.05.10.38.30.877.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), this.getLoc()
--[ 2019.11.05.10.38.31.369.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), this.getLoc)
--[ 2019.11.05.10.38.31.413.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), this.getLo)
--[ 2019.11.05.10.38.31.428.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), this.getL)
--[ 2019.11.05.10.38.31.491.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), this.get)
--[ 2019.11.05.10.38.31.506.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), this.ge)
--[ 2019.11.05.10.38.31.538.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), this.g)
--[ 2019.11.05.10.38.31.569.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), this.)
--[ 2019.11.05.10.38.31.600.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), this)
--[ 2019.11.05.10.38.31.632.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), thi)
--[ 2019.11.05.10.38.31.663.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), th)
--[ 2019.11.05.10.38.31.803.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), t)
--[ 2019.11.05.10.38.32.006.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), )
--[ 2019.11.05.10.38.32.467.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), l)
--[ 2019.11.05.10.38.32.647.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), lo)
--[ 2019.11.05.10.38.32.749.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), loc)
--[ 2019.11.05.10.38.33.593.0 ]--
r 79                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.05.10.38.39.226.0 ]--
r 81 
--[ 2019.11.05.10.38.39.404.0 ]--
- 81
--[ 2019.11.05.10.39.00.118.0 ]--
r 36             i
--[ 2019.11.05.10.39.00.315.0 ]--
r 36             if
--[ 2019.11.05.10.39.00.331.0 ]--
r 36             if 
--[ 2019.11.05.10.39.00.472.0 ]--
r 36             if ()
--[ 2019.11.05.10.39.00.755.0 ]--
r 36             if (t)
--[ 2019.11.05.10.39.00.936.0 ]--
r 36             if (th)
--[ 2019.11.05.10.39.00.984.0 ]--
r 36             if (thi)
--[ 2019.11.05.10.39.01.140.0 ]--
r 36             if (this)
--[ 2019.11.05.10.39.01.265.0 ]--
r 36             if (this.)
--[ 2019.11.05.10.39.01.405.0 ]--
r 36             if (this.g)
--[ 2019.11.05.10.39.01.516.0 ]--
r 36             if (this.ge)
--[ 2019.11.05.10.39.01.681.0 ]--
r 36             if (this.get)
--[ 2019.11.05.10.39.01.964.0 ]--
r 36             if (this.getC)
--[ 2019.11.05.10.39.02.167.0 ]--
r 36             if (this.getCo)
--[ 2019.11.05.10.39.02.316.0 ]--
r 36             if (this.getCos)
--[ 2019.11.05.10.39.02.452.0 ]--
r 36             if (this.getCost)
--[ 2019.11.05.10.39.02.898.0 ]--
r 36             if (this.getCost())
--[ 2019.11.05.10.39.03.308.0 ]--
r 36             if (this.getCost() )
--[ 2019.11.05.10.39.03.593.0 ]--
r 36             if (this.getCost() <)
--[ 2019.11.05.10.39.03.671.0 ]--
r 36             if (this.getCost() < )
--[ 2019.11.05.10.39.04.094.0 ]--
r 36             if (this.getCost() < t)
--[ 2019.11.05.10.39.04.160.0 ]--
r 36             if (this.getCost() < th)
--[ 2019.11.05.10.39.04.285.0 ]--
r 36             if (this.getCost() < tha)
--[ 2019.11.05.10.39.04.332.0 ]--
r 36             if (this.getCost() < that)
--[ 2019.11.05.10.39.04.410.0 ]--
r 36             if (this.getCost() < that.)
--[ 2019.11.05.10.39.04.613.0 ]--
r 36             if (this.getCost() < that.g)
--[ 2019.11.05.10.39.04.645.0 ]--
r 36             if (this.getCost() < that.ge)
--[ 2019.11.05.10.39.04.801.0 ]--
r 36             if (this.getCost() < that.get)
--[ 2019.11.05.10.39.05.052.0 ]--
r 36             if (this.getCost() < that.getC)
--[ 2019.11.05.10.39.05.192.0 ]--
r 36             if (this.getCost() < that.getCo)
--[ 2019.11.05.10.39.05.334.0 ]--
r 36             if (this.getCost() < that.getCos)
--[ 2019.11.05.10.39.05.490.0 ]--
r 36             if (this.getCost() < that.getCost)
--[ 2019.11.05.10.39.05.758.0 ]--
r 36             if (this.getCost() < that.getCost())
--[ 2019.11.05.10.39.06.702.0 ]--
r 36             if (this.getCost() < that.getCost()) 
--[ 2019.11.05.10.39.06.893.0 ]--
r 36             if (this.getCost() < that.getCost()) r
--[ 2019.11.05.10.39.07.002.0 ]--
r 36             if (this.getCost() < that.getCost()) re
--[ 2019.11.05.10.39.07.174.0 ]--
r 36             if (this.getCost() < that.getCost()) ret
--[ 2019.11.05.10.39.07.237.0 ]--
r 36             if (this.getCost() < that.getCost()) retu
--[ 2019.11.05.10.39.07.343.0 ]--
r 36             if (this.getCost() < that.getCost()) retur
--[ 2019.11.05.10.39.07.452.0 ]--
r 36             if (this.getCost() < that.getCost()) return
--[ 2019.11.05.10.39.07.530.0 ]--
r 36             if (this.getCost() < that.getCost()) return 
--[ 2019.11.05.10.39.07.671.0 ]--
r 36             if (this.getCost() < that.getCost()) return 1
--[ 2019.11.05.10.39.08.000.0 ]--
r 36             if (this.getCost() < that.getCost()) return 
--[ 2019.11.05.10.39.08.225.0 ]--
r 36             if (this.getCost() < that.getCost()) return -
--[ 2019.11.05.10.39.08.313.0 ]--
r 36             if (this.getCost() < that.getCost()) return -1
--[ 2019.11.05.10.39.08.518.0 ]--
r 36             if (this.getCost() < that.getCost()) return -1;
--[ 2019.11.05.10.39.08.716.0 ]--
+ 37             
--[ 2019.11.05.10.39.09.006.0 ]--
r 37             e
--[ 2019.11.05.10.39.09.162.0 ]--
r 37             el
--[ 2019.11.05.10.39.09.256.0 ]--
r 37             els
--[ 2019.11.05.10.39.09.334.0 ]--
r 37             else
--[ 2019.11.05.10.39.09.365.0 ]--
r 37             else 
--[ 2019.11.05.10.39.09.554.0 ]--
r 37             else i
--[ 2019.11.05.10.39.09.675.0 ]--
r 37             else if
--[ 2019.11.05.10.39.09.753.0 ]--
r 37             else if 
--[ 2019.11.05.10.39.09.878.0 ]--
r 37             else if ()
--[ 2019.11.05.10.39.10.098.0 ]--
r 37             else if (t)
--[ 2019.11.05.10.39.10.201.0 ]--
r 37             else if (th)
--[ 2019.11.05.10.39.10.452.0 ]--
r 37             else if (this)
--[ 2019.11.05.10.39.10.473.0 ]--
r 37             else if (this.)
--[ 2019.11.05.10.39.10.551.0 ]--
r 37             else if (this.g)
--[ 2019.11.05.10.39.10.613.0 ]--
r 37             else if (this.ge)
--[ 2019.11.05.10.39.10.770.0 ]--
r 37             else if (this.get)
--[ 2019.11.05.10.39.11.037.0 ]--
r 37             else if (this.getC)
--[ 2019.11.05.10.39.11.325.0 ]--
r 37             else if (this.getCo)
--[ 2019.11.05.10.39.11.466.0 ]--
r 37             else if (this.getCos)
--[ 2019.11.05.10.39.11.518.0 ]--
r 37             else if (this.getCost)
--[ 2019.11.05.10.39.12.097.0 ]--
r 37             else if (this.getCost())
--[ 2019.11.05.10.39.12.479.0 ]--
r 37             else if (this.getCost() )
--[ 2019.11.05.10.39.12.659.0 ]--
r 37             else if (this.getCost() >)
--[ 2019.11.05.10.39.12.786.0 ]--
r 37             else if (this.getCost() > )
--[ 2019.11.05.10.39.13.183.0 ]--
r 37             else if (this.getCost() > t)
--[ 2019.11.05.10.39.13.291.0 ]--
r 37             else if (this.getCost() > th)
--[ 2019.11.05.10.39.13.416.0 ]--
r 37             else if (this.getCost() > tha)
--[ 2019.11.05.10.39.13.448.0 ]--
r 37             else if (this.getCost() > that)
--[ 2019.11.05.10.39.13.557.0 ]--
r 37             else if (this.getCost() > that.)
--[ 2019.11.05.10.39.13.729.0 ]--
r 37             else if (this.getCost() > that.g)
--[ 2019.11.05.10.39.13.807.0 ]--
r 37             else if (this.getCost() > that.ge)
--[ 2019.11.05.10.39.13.948.0 ]--
r 37             else if (this.getCost() > that.get)
--[ 2019.11.05.10.39.14.199.0 ]--
r 37             else if (this.getCost() > that.getC)
--[ 2019.11.05.10.39.14.401.0 ]--
r 37             else if (this.getCost() > that.getCo)
--[ 2019.11.05.10.39.14.558.0 ]--
r 37             else if (this.getCost() > that.getCos)
--[ 2019.11.05.10.39.14.687.0 ]--
r 37             else if (this.getCost() > that.getCost)
--[ 2019.11.05.10.39.14.985.0 ]--
r 37             else if (this.getCost() > that.getCost())
--[ 2019.11.05.10.39.15.916.0 ]--
r 37             else if (this.getCost() > that.getCost()) 
--[ 2019.11.05.10.39.16.119.0 ]--
r 37             else if (this.getCost() > that.getCost()) r
--[ 2019.11.05.10.39.16.217.0 ]--
r 37             else if (this.getCost() > that.getCost()) re
--[ 2019.11.05.10.39.16.359.0 ]--
r 37             else if (this.getCost() > that.getCost()) ret
--[ 2019.11.05.10.39.16.453.0 ]--
r 37             else if (this.getCost() > that.getCost()) retu
--[ 2019.11.05.10.39.16.578.0 ]--
r 37             else if (this.getCost() > that.getCost()) retur
--[ 2019.11.05.10.39.16.673.0 ]--
r 37             else if (this.getCost() > that.getCost()) return
--[ 2019.11.05.10.39.16.783.0 ]--
r 37             else if (this.getCost() > that.getCost()) return 
--[ 2019.11.05.10.39.16.923.0 ]--
r 37             else if (this.getCost() > that.getCost()) return 1
--[ 2019.11.05.10.39.17.080.0 ]--
r 37             else if (this.getCost() > that.getCost()) return 1;
--[ 2019.11.05.10.39.17.284.0 ]--
+ 38             
--[ 2019.11.05.10.39.17.595.0 ]--
r 38             e
--[ 2019.11.05.10.39.17.689.0 ]--
r 38             el
--[ 2019.11.05.10.39.17.861.0 ]--
r 38             els
--[ 2019.11.05.10.39.17.923.0 ]--
r 38             else
--[ 2019.11.05.10.39.17.970.0 ]--
r 38             else 
--[ 2019.11.05.10.39.18.763.0 ]--
r 38             else r
--[ 2019.11.05.10.39.18.857.0 ]--
r 38             else re
--[ 2019.11.05.10.39.19.013.0 ]--
r 38             else ret
--[ 2019.11.05.10.39.19.060.0 ]--
r 38             else retu
--[ 2019.11.05.10.39.19.185.0 ]--
r 38             else retur
--[ 2019.11.05.10.39.19.248.0 ]--
r 38             else return
--[ 2019.11.05.10.39.19.342.0 ]--
r 38             else return 
--[ 2019.11.05.10.39.19.420.0 ]--
r 38             else return 0
--[ 2019.11.05.10.39.19.685.0 ]--
r 38             else return 0;
--[ 2019.11.05.10.39.25.928.0 ]--
r 36             if  (this.getCost() < that.getCost()) return -1;
--[ 2019.11.05.10.39.26.335.0 ]--
r 36             if      (this.getCost() < that.getCost()) return -1;
--[ 2019.11.05.10.40.05.477.0 ]--
+ 32             
--[ 2019.11.05.10.40.06.436.0 ]--
r 32             b
--[ 2019.11.05.10.40.06.558.0 ]--
r 32             bo
--[ 2019.11.05.10.40.06.730.0 ]--
r 32             boa
--[ 2019.11.05.10.40.06.778.0 ]--
r 32             boar
--[ 2019.11.05.10.40.06.959.0 ]--
r 32             board
--[ 2019.11.05.10.40.07.006.0 ]--
r 32             board[]
--[ 2019.11.05.10.40.07.288.0 ]--
r 32             board[l]
--[ 2019.11.05.10.40.07.457.0 ]--
r 32             board[lo]
--[ 2019.11.05.10.40.07.613.0 ]--
r 32             board[loc]
--[ 2019.11.05.10.40.07.800.0 ]--
r 32             board[loc.]
--[ 2019.11.05.10.40.07.967.0 ]--
r 32             board[loc.g]
--[ 2019.11.05.10.40.08.076.0 ]--
r 32             board[loc.ge]
--[ 2019.11.05.10.40.08.218.0 ]--
r 32             board[loc.get]
--[ 2019.11.05.10.40.08.404.0 ]--
r 32             board[loc.getI]
--[ 2019.11.05.10.40.08.703.0 ]--
r 32             board[loc.getI()]
--[ 2019.11.05.10.40.09.638.0 ]--
r 32             board[loc.getI()][]
--[ 2019.11.05.10.40.10.155.0 ]--
r 32             board[loc.getI()][l]
--[ 2019.11.05.10.40.10.328.0 ]--
r 32             board[loc.getI()][lo]
--[ 2019.11.05.10.40.10.407.0 ]--
r 32             board[loc.getI()][loc]
--[ 2019.11.05.10.40.10.564.0 ]--
r 32             board[loc.getI()][loc.]
--[ 2019.11.05.10.40.10.708.0 ]--
r 32             board[loc.getI()][loc.g]
--[ 2019.11.05.10.40.10.787.0 ]--
r 32             board[loc.getI()][loc.ge]
--[ 2019.11.05.10.40.10.989.0 ]--
r 32             board[loc.getI()][loc.get]
--[ 2019.11.05.10.40.11.160.0 ]--
r 32             board[loc.getI()][loc.getJ]
--[ 2019.11.05.10.40.11.527.0 ]--
r 32             board[loc.getI()][loc.getJ()]
--[ 2019.11.05.10.40.12.578.0 ]--
r 32             board[loc.getI()][loc.getJ()] 
--[ 2019.11.05.10.40.12.707.0 ]--
r 32             board[loc.getI()][loc.getJ()] =
--[ 2019.11.05.10.40.12.776.0 ]--
r 32             board[loc.getI()][loc.getJ()] = 
--[ 2019.11.05.10.40.31.625.0 ]--
r 32 
--[ 2019.11.05.10.40.31.875.0 ]--
- 32
--[ 2019.11.05.10.42.06.025.0 ]--
r 63 
--[ 2019.11.05.10.44.45.203.0 ]--
r 79             if (b == null) return 0.;
--[ 2019.11.05.10.44.45.474.0 ]--
r 79             if (b == null) return 0.0;
--[ 2019.11.05.10.44.51.324.0 ]--
r 79             if (b == null) return 0.;
--[ 2019.11.05.10.44.51.480.0 ]--
r 79             if (b == null) return 0;
--[ 2019.11.05.10.48.35.279.0 ]--
r 15     private f[][] board;
--[ 2019.11.05.10.48.35.375.0 ]--
r 15     private fl[][] board;
--[ 2019.11.05.10.48.35.515.0 ]--
r 15     private flo[][] board;
--[ 2019.11.05.10.48.35.659.0 ]--
r 15     private floa[][] board;
--[ 2019.11.05.10.48.35.691.0 ]--
r 15     private float[][] board;
--[ 2019.11.05.10.48.46.228.0 ]--
r 66         /private int findHeightDiff(PFNode a, PFNode b) {
--[ 2019.11.05.10.48.46.464.0 ]--
r 66         /*private int findHeightDiff(PFNode a, PFNode b) {
--[ 2019.11.05.10.48.48.405.0 ]--
+ 71         
+ 72          */
--[ 2019.11.05.10.48.54.499.0 ]--
r 122         board = new f[N][N];
--[ 2019.11.05.10.48.54.650.0 ]--
r 122         board = new fl[N][N];
--[ 2019.11.05.10.48.54.838.0 ]--
r 122         board = new flo[N][N];
--[ 2019.11.05.10.48.54.987.0 ]--
r 122         board = new floa[N][N];
--[ 2019.11.05.10.48.55.060.0 ]--
r 122         board = new float[N][N];
--[ 2019.11.05.10.49.12.493.0 ]--
+ 17     
--[ 2019.11.05.10.49.12.886.0 ]--
r 17     p
--[ 2019.11.05.10.49.13.039.0 ]--
r 17     pr
--[ 2019.11.05.10.49.13.072.0 ]--
r 17     pri
--[ 2019.11.05.10.49.13.217.0 ]--
r 17     priv
--[ 2019.11.05.10.49.13.352.0 ]--
r 17     priva
--[ 2019.11.05.10.49.13.472.0 ]--
r 17     privat
--[ 2019.11.05.10.49.13.569.0 ]--
r 17     private
--[ 2019.11.05.10.49.13.623.0 ]--
r 17     private 
--[ 2019.11.05.10.49.13.779.0 ]--
r 17     private f
--[ 2019.11.05.10.49.13.839.0 ]--
r 17     private fl
--[ 2019.11.05.10.49.14.021.0 ]--
r 17     private flo
--[ 2019.11.05.10.49.14.144.0 ]--
r 17     private floa
--[ 2019.11.05.10.49.14.224.0 ]--
r 17     private float
--[ 2019.11.05.10.49.14.309.0 ]--
r 17     private float 
--[ 2019.11.05.10.49.14.437.0 ]--
r 17     private float h
--[ 2019.11.05.10.49.15.057.0 ]--
r 17     private float h;
--[ 2019.11.05.10.49.25.884.0 ]--
+ 123         
--[ 2019.11.05.10.49.26.899.0 ]--
r 123         h
--[ 2019.11.05.10.49.27.062.0 ]--
r 123         h 
--[ 2019.11.05.10.49.27.163.0 ]--
r 123         h =
--[ 2019.11.05.10.49.27.286.0 ]--
r 123         h = 
--[ 2019.11.05.10.49.27.375.0 ]--
r 123         h = 0
--[ 2019.11.05.10.49.27.620.0 ]--
r 123         h = 0;
--[ 2019.11.05.10.49.38.251.0 ]--
+ 15     
--[ 2019.11.05.10.49.38.535.0 ]--
r 15     p
--[ 2019.11.05.10.49.38.643.0 ]--
r 15     pr
--[ 2019.11.05.10.49.38.711.0 ]--
r 15     pri
--[ 2019.11.05.10.49.38.914.0 ]--
r 15     priv
--[ 2019.11.05.10.49.38.992.0 ]--
r 15     priva
--[ 2019.11.05.10.49.39.118.0 ]--
r 15     privat
--[ 2019.11.05.10.49.39.223.0 ]--
r 15     private
--[ 2019.11.05.10.49.39.336.0 ]--
r 15     private 
--[ 2019.11.05.10.49.39.558.0 ]--
r 15     private
--[ 2019.11.05.10.49.40.069.0 ]--
r 15     privat
--[ 2019.11.05.10.49.40.104.0 ]--
r 15     priva
--[ 2019.11.05.10.49.40.124.0 ]--
r 15     priv
--[ 2019.11.05.10.49.40.162.0 ]--
r 15     pri
--[ 2019.11.05.10.49.40.189.0 ]--
r 15     pr
--[ 2019.11.05.10.49.40.221.0 ]--
r 15     p
--[ 2019.11.05.10.49.40.254.0 ]--
r 15     
--[ 2019.11.05.10.49.40.300.0 ]--
- 15
--[ 2019.11.05.10.49.40.321.0 ]--
r 14     private Terrain terrain
--[ 2019.11.05.10.49.41.641.0 ]--
r 14     private Terrain terrain;
--[ 2019.11.05.10.49.43.427.0 ]--
+ 18     
--[ 2019.11.05.10.49.44.074.0 ]--
r 18     p
--[ 2019.11.05.10.49.44.179.0 ]--
r 18     pr
--[ 2019.11.05.10.49.44.274.0 ]--
r 18     pri
--[ 2019.11.05.10.49.44.430.0 ]--
r 18     priv
--[ 2019.11.05.10.49.44.590.0 ]--
r 18     priva
--[ 2019.11.05.10.49.44.709.0 ]--
r 18     privat
--[ 2019.11.05.10.49.44.787.0 ]--
r 18     private
--[ 2019.11.05.10.49.44.869.0 ]--
r 18     private 
--[ 2019.11.05.10.49.44.982.0 ]--
r 18     private i
--[ 2019.11.05.10.49.45.062.0 ]--
r 18     private in
--[ 2019.11.05.10.49.45.147.0 ]--
r 18     private int
--[ 2019.11.05.10.49.45.217.0 ]--
r 18     private int 
--[ 2019.11.05.10.49.45.502.0 ]--
r 18     private int N
--[ 2019.11.05.10.49.45.684.0 ]--
r 18     private int N;
--[ 2019.11.05.10.49.49.827.0 ]--
r 123         intN = this.terrain.getN();
--[ 2019.11.05.10.49.50.080.0 ]--
r 123         inN = this.terrain.getN();
--[ 2019.11.05.10.49.50.167.0 ]--
r 123         iN = this.terrain.getN();
--[ 2019.11.05.10.49.50.350.0 ]--
r 123         N = this.terrain.getN();
--[ 2019.11.05.10.50.39.284.0 ]--
r 73 
--[ 2019.11.05.10.50.40.590.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.10.51.28.518.0 ]--
+ 85                 
--[ 2019.11.05.10.51.28.862.0 ]--
r 85                 S
--[ 2019.11.05.10.51.29.062.0 ]--
r 85                 St
--[ 2019.11.05.10.51.29.500.0 ]--
r 85                 Std
--[ 2019.11.05.10.51.29.528.0 ]--
r 85                 StdO
--[ 2019.11.05.10.51.29.663.0 ]--
r 85                 StdOu
--[ 2019.11.05.10.51.29.792.0 ]--
r 85                 StdOut
--[ 2019.11.05.10.51.29.936.0 ]--
r 85                 StdOut.
--[ 2019.11.05.10.51.30.178.0 ]--
r 85                 StdOut.p
--[ 2019.11.05.10.51.30.308.0 ]--
r 85                 StdOut.pr
--[ 2019.11.05.10.51.30.383.0 ]--
r 85                 StdOut.pri
--[ 2019.11.05.10.51.30.539.0 ]--
r 85                 StdOut.prin
--[ 2019.11.05.10.51.30.567.0 ]--
r 85                 StdOut.print
--[ 2019.11.05.10.51.30.780.0 ]--
r 85                 StdOut.printl
--[ 2019.11.05.10.51.30.933.0 ]--
r 85                 StdOut.println
--[ 2019.11.05.10.51.31.130.0 ]--
r 85                 StdOut.println()
--[ 2019.11.05.10.51.31.374.0 ]--
r 85                 StdOut.println("")
--[ 2019.11.05.10.51.31.573.0 ]--
r 85                 StdOut.println("g")
--[ 2019.11.05.10.51.31.669.0 ]--
r 85                 StdOut.println("ge")
--[ 2019.11.05.10.51.31.850.0 ]--
r 85                 StdOut.println("get")
--[ 2019.11.05.10.51.31.989.0 ]--
r 85                 StdOut.println("gett")
--[ 2019.11.05.10.51.32.061.0 ]--
r 85                 StdOut.println("getti")
--[ 2019.11.05.10.51.32.125.0 ]--
r 85                 StdOut.println("gettin")
--[ 2019.11.05.10.51.32.396.0 ]--
r 85                 StdOut.println("getting")
--[ 2019.11.05.10.51.32.485.0 ]--
r 85                 StdOut.println("getting ")
--[ 2019.11.05.10.51.32.714.0 ]--
r 85                 StdOut.println("getting c")
--[ 2019.11.05.10.51.32.799.0 ]--
r 85                 StdOut.println("getting co")
--[ 2019.11.05.10.51.32.925.0 ]--
r 85                 StdOut.println("getting cos")
--[ 2019.11.05.10.51.33.052.0 ]--
r 85                 StdOut.println("getting cost")
--[ 2019.11.05.10.51.33.256.0 ]--
r 85                 StdOut.println("getting cost:")
--[ 2019.11.05.10.51.33.333.0 ]--
r 85                 StdOut.println("getting cost: ")
--[ 2019.11.05.10.51.34.225.0 ]--
r 85                 StdOut.println("getting cost: " )
--[ 2019.11.05.10.51.34.389.0 ]--
r 85                 StdOut.println("getting cost: " +)
--[ 2019.11.05.10.51.34.504.0 ]--
r 85                 StdOut.println("getting cost: " + )
--[ 2019.11.05.10.51.38.745.0 ]--
r 85                 StdOut.println("getting cost: " + b)
--[ 2019.11.05.10.51.38.984.0 ]--
r 85                 StdOut.println("getting cost: " + bo)
--[ 2019.11.05.10.51.39.006.0 ]--
r 85                 StdOut.println("getting cost: " + boa)
--[ 2019.11.05.10.51.39.117.0 ]--
r 85                 StdOut.println("getting cost: " + boar)
--[ 2019.11.05.10.51.39.299.0 ]--
r 85                 StdOut.println("getting cost: " + board)
--[ 2019.11.05.10.51.39.390.0 ]--
r 85                 StdOut.println("getting cost: " + board[])
--[ 2019.11.05.10.51.39.866.0 ]--
r 85                 StdOut.println("getting cost: " + board[b])
--[ 2019.11.05.10.51.40.017.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.])
--[ 2019.11.05.10.51.40.407.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.g])
--[ 2019.11.05.10.51.40.462.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.ge])
--[ 2019.11.05.10.51.40.654.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.get])
--[ 2019.11.05.10.51.40.978.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getL])
--[ 2019.11.05.10.51.41.171.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLo])
--[ 2019.11.05.10.51.41.313.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc])
--[ 2019.11.05.10.51.41.688.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc()])
--[ 2019.11.05.10.51.43.427.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc()].)
--[ 2019.11.05.10.51.43.606.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc()].g)
--[ 2019.11.05.10.51.43.728.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc()].ge)
--[ 2019.11.05.10.51.43.865.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc()].get)
--[ 2019.11.05.10.51.44.121.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc()].getI)
--[ 2019.11.05.10.51.44.826.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc()].getI())
--[ 2019.11.05.10.51.45.485.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc()].getI()])
--[ 2019.11.05.10.51.51.623.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc()].getI())
--[ 2019.11.05.10.51.51.864.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc()].getI()
--[ 2019.11.05.10.51.51.997.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc()].getI)
--[ 2019.11.05.10.51.52.172.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc()].get)
--[ 2019.11.05.10.51.52.343.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc()].ge)
--[ 2019.11.05.10.51.52.531.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc()].g)
--[ 2019.11.05.10.51.52.679.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc()].)
--[ 2019.11.05.10.51.52.850.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc()])
--[ 2019.11.05.10.51.53.038.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc())
--[ 2019.11.05.10.51.53.802.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc().)
--[ 2019.11.05.10.51.53.898.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc().g)
--[ 2019.11.05.10.51.54.003.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc().ge)
--[ 2019.11.05.10.51.54.177.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc().get)
--[ 2019.11.05.10.51.54.346.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc().getI)
--[ 2019.11.05.10.51.54.750.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc().getI()
--[ 2019.11.05.10.51.55.330.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc().getI()]
--[ 2019.11.05.10.51.56.334.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc().getI()][]
--[ 2019.11.05.10.52.00.017.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc().getI()][b]
--[ 2019.11.05.10.52.00.104.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc().getI()][b.]
--[ 2019.11.05.10.52.00.385.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc().getI()][b.g]
--[ 2019.11.05.10.52.00.457.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc().getI()][b.ge]
--[ 2019.11.05.10.52.00.612.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc().getI()][b.get]
--[ 2019.11.05.10.52.00.816.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc().getI()][b.getL]
--[ 2019.11.05.10.52.00.993.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc().getI()][b.getLo]
--[ 2019.11.05.10.52.01.019.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc().getI()][b.getLoc]
--[ 2019.11.05.10.52.01.327.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc().getI()][b.getLoc()]
--[ 2019.11.05.10.52.01.693.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc().getI()][b.getLoc().]
--[ 2019.11.05.10.52.01.921.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc().getI()][b.getLoc().ge]
--[ 2019.11.05.10.52.02.020.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc().getI()][b.getLoc().get]
--[ 2019.11.05.10.52.02.291.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc().getI()][b.getLoc().getJ]
--[ 2019.11.05.10.52.02.599.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc().getI()][b.getLoc().getJ()]
--[ 2019.11.05.10.52.03.397.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc().getI()][b.getLoc().getJ()])
--[ 2019.11.05.10.52.03.983.0 ]--
r 85                 StdOut.println("getting cost: " + board[b.getLoc().getI()][b.getLoc().getJ()]);
--[ 2019.11.05.10.52.09.633.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.10.52.27.492.0 ]--
r 215                     board[c.getI()][c.getJ()] = cNode.getCost(h);
--[ 2019.11.05.10.52.50.406.0 ]--
r 207             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.10.52.54.556.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.10.53.10.675.0 ]--
+ 86                 
--[ 2019.11.05.10.53.10.941.0 ]--
r 86                 S
--[ 2019.11.05.10.53.11.132.0 ]--
r 86                 St
--[ 2019.11.05.10.53.11.398.0 ]--
r 86                 Std
--[ 2019.11.05.10.53.11.570.0 ]--
r 86                 StdO
--[ 2019.11.05.10.53.11.768.0 ]--
r 86                 StdOu
--[ 2019.11.05.10.53.11.944.0 ]--
r 86                 StdOut
--[ 2019.11.05.10.53.12.118.0 ]--
r 86                 StdOut.
--[ 2019.11.05.10.53.12.412.0 ]--
r 86                 StdOut.p
--[ 2019.11.05.10.53.12.479.0 ]--
r 86                 StdOut.pr
--[ 2019.11.05.10.53.12.618.0 ]--
r 86                 StdOut.pri
--[ 2019.11.05.10.53.12.709.0 ]--
r 86                 StdOut.prin
--[ 2019.11.05.10.53.12.881.0 ]--
r 86                 StdOut.print
--[ 2019.11.05.10.53.13.030.0 ]--
r 86                 StdOut.printl
--[ 2019.11.05.10.53.13.123.0 ]--
r 86                 StdOut.println
--[ 2019.11.05.10.53.13.382.0 ]--
r 86                 StdOut.println()
--[ 2019.11.05.10.53.13.657.0 ]--
r 86                 StdOut.println("")
--[ 2019.11.05.10.53.16.209.0 ]--
r 86                 StdOut.println("f")
--[ 2019.11.05.10.53.16.496.0 ]--
r 86                 StdOut.println("fr")
--[ 2019.11.05.10.53.16.580.0 ]--
r 86                 StdOut.println("fro")
--[ 2019.11.05.10.53.16.668.0 ]--
r 86                 StdOut.println("from")
--[ 2019.11.05.10.53.16.747.0 ]--
r 86                 StdOut.println("from ")
--[ 2019.11.05.10.53.16.868.0 ]--
r 86                 StdOut.println("from o")
--[ 2019.11.05.10.53.16.996.0 ]--
r 86                 StdOut.println("from ot")
--[ 2019.11.05.10.53.17.076.0 ]--
r 86                 StdOut.println("from oth")
--[ 2019.11.05.10.53.17.199.0 ]--
r 86                 StdOut.println("from othe")
--[ 2019.11.05.10.53.17.298.0 ]--
r 86                 StdOut.println("from other")
--[ 2019.11.05.10.53.17.487.0 ]--
r 86                 StdOut.println("from other:")
--[ 2019.11.05.10.53.17.610.0 ]--
r 86                 StdOut.println("from other: ")
--[ 2019.11.05.10.53.26.961.0 ]--
r 86                 StdOut.println("from other: )
--[ 2019.11.05.10.53.27.457.0 ]--
r 86                 StdOut.println("from other:)
--[ 2019.11.05.10.53.27.490.0 ]--
r 86                 StdOut.println("from other)
--[ 2019.11.05.10.53.27.528.0 ]--
r 86                 StdOut.println("from othe)
--[ 2019.11.05.10.53.27.555.0 ]--
r 86                 StdOut.println("from oth)
--[ 2019.11.05.10.53.27.588.0 ]--
r 86                 StdOut.println("from ot)
--[ 2019.11.05.10.53.27.621.0 ]--
r 86                 StdOut.println("from o)
--[ 2019.11.05.10.53.27.655.0 ]--
r 86                 StdOut.println("from )
--[ 2019.11.05.10.53.27.688.0 ]--
r 86                 StdOut.println("from)
--[ 2019.11.05.10.53.28.006.0 ]--
r 86                 StdOut.println("fro)
--[ 2019.11.05.10.53.28.193.0 ]--
r 86                 StdOut.println("fr)
--[ 2019.11.05.10.53.28.349.0 ]--
r 86                 StdOut.println("f)
--[ 2019.11.05.10.53.28.512.0 ]--
r 86                 StdOut.println(")
--[ 2019.11.05.10.53.28.700.0 ]--
r 86                 StdOut.println("c)
--[ 2019.11.05.10.53.28.820.0 ]--
r 86                 StdOut.println("co)
--[ 2019.11.05.10.53.29.012.0 ]--
r 86                 StdOut.println("cop)
--[ 2019.11.05.10.53.29.272.0 ]--
r 86                 StdOut.println("copu)
--[ 2019.11.05.10.53.29.412.0 ]--
r 86                 StdOut.println("coput)
--[ 2019.11.05.10.53.29.530.0 ]--
r 86                 StdOut.println("copute)
--[ 2019.11.05.10.53.29.725.0 ]--
r 86                 StdOut.println("coput)
--[ 2019.11.05.10.53.29.925.0 ]--
r 86                 StdOut.println("copu)
--[ 2019.11.05.10.53.30.053.0 ]--
r 86                 StdOut.println("cop)
--[ 2019.11.05.10.53.30.211.0 ]--
r 86                 StdOut.println("co)
--[ 2019.11.05.10.53.30.552.0 ]--
r 86                 StdOut.println("com)
--[ 2019.11.05.10.53.30.738.0 ]--
r 86                 StdOut.println("comp)
--[ 2019.11.05.10.53.30.864.0 ]--
r 86                 StdOut.println("compu)
--[ 2019.11.05.10.53.30.973.0 ]--
r 86                 StdOut.println("comput)
--[ 2019.11.05.10.53.31.106.0 ]--
r 86                 StdOut.println("compute)
--[ 2019.11.05.10.53.31.283.0 ]--
r 86                 StdOut.println("computed)
--[ 2019.11.05.10.53.31.433.0 ]--
r 86                 StdOut.println("computed )
--[ 2019.11.05.10.53.32.001.0 ]--
r 86                 StdOut.println("computed f)
--[ 2019.11.05.10.53.32.274.0 ]--
r 86                 StdOut.println("computed fr)
--[ 2019.11.05.10.53.32.357.0 ]--
r 86                 StdOut.println("computed fro)
--[ 2019.11.05.10.53.32.423.0 ]--
r 86                 StdOut.println("computed from)
--[ 2019.11.05.10.53.32.535.0 ]--
r 86                 StdOut.println("computed from )
--[ 2019.11.05.10.53.36.285.0 ]--
r 86                 StdOut.println("computed from b)
--[ 2019.11.05.10.53.36.632.0 ]--
r 86                 StdOut.println("computed from b:)
--[ 2019.11.05.10.53.36.788.0 ]--
r 86                 StdOut.println("computed from b: )
--[ 2019.11.05.10.53.36.956.0 ]--
r 86                 StdOut.println("computed from b: ")
--[ 2019.11.05.10.53.39.568.0 ]--
r 86                 StdOut.println("computed from b: " )
--[ 2019.11.05.10.53.39.811.0 ]--
r 86                 StdOut.println("computed from b: " +)
--[ 2019.11.05.10.53.39.900.0 ]--
r 86                 StdOut.println("computed from b: " + )
--[ 2019.11.05.10.53.40.440.0 ]--
r 86                 StdOut.println("computed from b: " + t)
--[ 2019.11.05.10.53.40.546.0 ]--
r 86                 StdOut.println("computed from b: " + te)
--[ 2019.11.05.10.53.40.752.0 ]--
r 86                 StdOut.println("computed from b: " + ter)
--[ 2019.11.05.10.53.40.922.0 ]--
r 86                 StdOut.println("computed from b: " + terr)
--[ 2019.11.05.10.53.40.965.0 ]--
r 86                 StdOut.println("computed from b: " + terra)
--[ 2019.11.05.10.53.41.039.0 ]--
r 86                 StdOut.println("computed from b: " + terrai)
--[ 2019.11.05.10.53.41.087.0 ]--
r 86                 StdOut.println("computed from b: " + terrain)
--[ 2019.11.05.10.53.41.300.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.)
--[ 2019.11.05.10.53.41.415.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.c)
--[ 2019.11.05.10.53.41.547.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.co)
--[ 2019.11.05.10.53.41.610.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.com)
--[ 2019.11.05.10.53.41.813.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.comp)
--[ 2019.11.05.10.53.41.918.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.compu)
--[ 2019.11.05.10.53.42.062.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.comput)
--[ 2019.11.05.10.53.42.123.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.compute)
--[ 2019.11.05.10.53.42.560.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.computeT)
--[ 2019.11.05.10.53.42.765.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.computeTr)
--[ 2019.11.05.10.53.42.809.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.computeTra)
--[ 2019.11.05.10.53.42.991.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.computeTrav)
--[ 2019.11.05.10.53.43.095.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.computeTrave)
--[ 2019.11.05.10.53.43.213.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.computeTravel)
--[ 2019.11.05.10.53.43.382.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.computeTravelC)
--[ 2019.11.05.10.53.43.515.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.computeTravelCo)
--[ 2019.11.05.10.53.43.618.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.computeTravelCos)
--[ 2019.11.05.10.53.43.716.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.computeTravelCost)
--[ 2019.11.05.10.53.43.941.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.computeTravelCost())
--[ 2019.11.05.10.53.44.986.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.computeTravelCost(b))
--[ 2019.11.05.10.53.45.087.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.computeTravelCost(b.))
--[ 2019.11.05.10.53.45.350.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.computeTravelCost(b.g))
--[ 2019.11.05.10.53.45.384.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.computeTravelCost(b.ge))
--[ 2019.11.05.10.53.45.525.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.computeTravelCost(b.get))
--[ 2019.11.05.10.53.45.714.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.computeTravelCost(b.getL))
--[ 2019.11.05.10.53.45.901.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.computeTravelCost(b.getLo))
--[ 2019.11.05.10.53.45.937.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.computeTravelCost(b.getLoc))
--[ 2019.11.05.10.53.46.518.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.computeTravelCost(b.getLoc()))
--[ 2019.11.05.10.53.47.137.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.computeTravelCost(b.getLoc(),))
--[ 2019.11.05.10.53.47.205.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.computeTravelCost(b.getLoc(), ))
--[ 2019.11.05.10.53.47.525.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.computeTravelCost(b.getLoc(), l))
--[ 2019.11.05.10.53.47.699.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.computeTravelCost(b.getLoc(), lo))
--[ 2019.11.05.10.53.47.792.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.computeTravelCost(b.getLoc(), loc))
--[ 2019.11.05.10.53.48.390.0 ]--
r 86                 StdOut.println("computed from b: " + terrain.computeTravelCost(b.getLoc(), loc));
--[ 2019.11.05.10.53.52.764.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.10.54.25.771.0 ]--
r 126         h = 0.;
--[ 2019.11.05.10.54.26.027.0 ]--
r 126         h = 0.0;
--[ 2019.11.05.10.54.26.267.0 ]--
r 126         h = 0.0f;
--[ 2019.11.05.10.57.56.057.0 ]--
+ 211             
--[ 2019.11.05.10.57.56.428.0 ]--
r 211             C
--[ 2019.11.05.10.57.56.645.0 ]--
r 211             Co
--[ 2019.11.05.10.57.56.726.0 ]--
r 211             Coo
--[ 2019.11.05.10.57.56.839.0 ]--
r 211             Coor
--[ 2019.11.05.10.57.57.060.0 ]--
r 211             Coord
--[ 2019.11.05.10.57.57.365.0 ]--
r 211             Coord[]
--[ 2019.11.05.10.57.57.842.0 ]--
r 211             Coord[] 
--[ 2019.11.05.10.57.58.049.0 ]--
r 211             Coord[] n
--[ 2019.11.05.10.57.58.106.0 ]--
r 211             Coord[] ne
--[ 2019.11.05.10.57.58.231.0 ]--
r 211             Coord[] nei
--[ 2019.11.05.10.57.58.330.0 ]--
r 211             Coord[] neig
--[ 2019.11.05.10.57.58.472.0 ]--
r 211             Coord[] neigh
--[ 2019.11.05.10.57.58.562.0 ]--
r 211             Coord[] neighb
--[ 2019.11.05.10.57.58.979.0 ]--
r 211             Coord[] neighbo
--[ 2019.11.05.10.57.59.118.0 ]--
r 211             Coord[] neighbor
--[ 2019.11.05.10.57.59.236.0 ]--
r 211             Coord[] neighbors
--[ 2019.11.05.10.57.59.300.0 ]--
r 211             Coord[] neighbors 
--[ 2019.11.05.10.57.59.461.0 ]--
r 211             Coord[] neighbors =
--[ 2019.11.05.10.57.59.522.0 ]--
r 211             Coord[] neighbors = 
--[ 2019.11.05.10.58.01.951.0 ]--
r 211             Coord[] neighbors = c
--[ 2019.11.05.10.58.02.128.0 ]--
r 211             Coord[] neighbors = cu
--[ 2019.11.05.10.58.02.266.0 ]--
r 211             Coord[] neighbors = cur
--[ 2019.11.05.10.58.02.440.0 ]--
r 211             Coord[] neighbors = curr
--[ 2019.11.05.10.58.02.501.0 ]--
r 211             Coord[] neighbors = curre
--[ 2019.11.05.10.58.02.628.0 ]--
r 211             Coord[] neighbors = curren
--[ 2019.11.05.10.58.02.686.0 ]--
r 211             Coord[] neighbors = current
--[ 2019.11.05.10.58.02.849.0 ]--
r 211             Coord[] neighbors = currentN
--[ 2019.11.05.10.58.03.017.0 ]--
r 211             Coord[] neighbors = currentNo
--[ 2019.11.05.10.58.03.111.0 ]--
r 211             Coord[] neighbors = currentNod
--[ 2019.11.05.10.58.03.331.0 ]--
r 211             Coord[] neighbors = currentNode
--[ 2019.11.05.10.58.03.353.0 ]--
r 211             Coord[] neighbors = currentNode 
--[ 2019.11.05.10.58.03.745.0 ]--
r 211             Coord[] neighbors = currentNode
--[ 2019.11.05.10.58.04.359.0 ]--
r 211             Coord[] neighbors = currentNode.
--[ 2019.11.05.10.58.19.977.0 ]--
r 211             Coord[] neighbors = currentNode.n
--[ 2019.11.05.10.58.20.224.0 ]--
r 211             Coord[] neighbors = currentNode.nei
--[ 2019.11.05.10.58.20.269.0 ]--
r 211             Coord[] neighbors = currentNode.neig
--[ 2019.11.05.10.58.20.353.0 ]--
r 211             Coord[] neighbors = currentNode.neigh
--[ 2019.11.05.10.58.20.478.0 ]--
r 211             Coord[] neighbors = currentNode.neighb
--[ 2019.11.05.10.58.20.585.0 ]--
r 211             Coord[] neighbors = currentNode.neighbo
--[ 2019.11.05.10.58.20.722.0 ]--
r 211             Coord[] neighbors = currentNode.neighbor
--[ 2019.11.05.10.58.20.892.0 ]--
r 211             Coord[] neighbors = currentNode.neighbors
--[ 2019.11.05.10.58.21.156.0 ]--
r 211             Coord[] neighbors = currentNode.neighbors()
--[ 2019.11.05.10.58.21.430.0 ]--
r 211             Coord[] neighbors = currentNode.neighbors();
--[ 2019.11.05.10.58.25.723.0 ]--
r 210 
--[ 2019.11.05.10.58.25.864.0 ]--
- 210
--[ 2019.11.05.10.58.30.782.0 ]--
r 210             P[] neighbors = currentNode.neighbors();
--[ 2019.11.05.10.58.31.015.0 ]--
r 210             PF[] neighbors = currentNode.neighbors();
--[ 2019.11.05.10.58.31.326.0 ]--
r 210             PFN[] neighbors = currentNode.neighbors();
--[ 2019.11.05.10.58.31.756.0 ]--
r 210             PFNo[] neighbors = currentNode.neighbors();
--[ 2019.11.05.10.58.31.896.0 ]--
r 210             PFNod[] neighbors = currentNode.neighbors();
--[ 2019.11.05.10.58.32.070.0 ]--
r 210             PFNode[] neighbors = currentNode.neighbors();
--[ 2019.11.05.10.58.52.431.0 ]--
r 211             for (P c : neighbors) {
--[ 2019.11.05.10.58.52.670.0 ]--
r 211             for (PF c : neighbors) {
--[ 2019.11.05.10.58.53.185.0 ]--
r 211             for (PFN c : neighbors) {
--[ 2019.11.05.10.58.53.502.0 ]--
r 211             for (PFNo c : neighbors) {
--[ 2019.11.05.10.58.53.588.0 ]--
r 211             for (PFNod c : neighbors) {
--[ 2019.11.05.10.58.53.776.0 ]--
r 211             for (PFNode c : neighbors) {
--[ 2019.11.05.10.58.56.014.0 ]--
r 211             for (PFNode c : c) {
--[ 2019.11.05.10.58.56.199.0 ]--
r 211             for (PFNode c : cu) {
--[ 2019.11.05.10.58.56.373.0 ]--
r 211             for (PFNode c : cur) {
--[ 2019.11.05.10.58.56.562.0 ]--
r 211             for (PFNode c : curr) {
--[ 2019.11.05.10.58.56.621.0 ]--
r 211             for (PFNode c : curre) {
--[ 2019.11.05.10.58.56.751.0 ]--
r 211             for (PFNode c : curren) {
--[ 2019.11.05.10.58.56.815.0 ]--
r 211             for (PFNode c : current) {
--[ 2019.11.05.10.58.56.993.0 ]--
r 211             for (PFNode c : currentN) {
--[ 2019.11.05.10.58.57.187.0 ]--
r 211             for (PFNode c : currentNo) {
--[ 2019.11.05.10.58.57.244.0 ]--
r 211             for (PFNode c : currentNod) {
--[ 2019.11.05.10.58.57.517.0 ]--
r 211             for (PFNode c : currentNode) {
--[ 2019.11.05.10.58.57.655.0 ]--
r 211             for (PFNode c : currentNode.) {
--[ 2019.11.05.10.58.57.930.0 ]--
r 211             for (PFNode c : currentNode.n) {
--[ 2019.11.05.10.58.58.026.0 ]--
r 211             for (PFNode c : currentNode.ne) {
--[ 2019.11.05.10.58.58.162.0 ]--
r 211             for (PFNode c : currentNode.nei) {
--[ 2019.11.05.10.58.58.228.0 ]--
r 211             for (PFNode c : currentNode.neig) {
--[ 2019.11.05.10.58.58.323.0 ]--
r 211             for (PFNode c : currentNode.neigh) {
--[ 2019.11.05.10.58.58.459.0 ]--
r 211             for (PFNode c : currentNode.neighb) {
--[ 2019.11.05.10.58.58.543.0 ]--
r 211             for (PFNode c : currentNode.neighbo) {
--[ 2019.11.05.10.58.58.665.0 ]--
r 211             for (PFNode c : currentNode.neighbor) {
--[ 2019.11.05.10.58.58.836.0 ]--
r 211             for (PFNode c : currentNode.neighbors) {
--[ 2019.11.05.10.58.59.089.0 ]--
r 211             for (PFNode c : currentNode.neighbors()) {
--[ 2019.11.05.10.59.03.432.0 ]--
r 210 
--[ 2019.11.05.10.59.03.682.0 ]--
- 210
--[ 2019.11.05.10.59.07.394.0 ]--
r 211                 if (validateCoord(c.) && board[c.getI()][c.getJ()] < 0) {
--[ 2019.11.05.10.59.08.045.0 ]--
r 211                 if (validateCoord(c.g) && board[c.getI()][c.getJ()] < 0) {
--[ 2019.11.05.10.59.08.152.0 ]--
r 211                 if (validateCoord(c.ge) && board[c.getI()][c.getJ()] < 0) {
--[ 2019.11.05.10.59.08.303.0 ]--
r 211                 if (validateCoord(c.get) && board[c.getI()][c.getJ()] < 0) {
--[ 2019.11.05.10.59.08.511.0 ]--
r 211                 if (validateCoord(c.getL) && board[c.getI()][c.getJ()] < 0) {
--[ 2019.11.05.10.59.08.685.0 ]--
r 211                 if (validateCoord(c.getLo) && board[c.getI()][c.getJ()] < 0) {
--[ 2019.11.05.10.59.08.750.0 ]--
r 211                 if (validateCoord(c.getLoc) && board[c.getI()][c.getJ()] < 0) {
--[ 2019.11.05.10.59.09.085.0 ]--
r 211                 if (validateCoord(c.getLoc()) && board[c.getI()][c.getJ()] < 0) {
--[ 2019.11.05.10.59.12.677.0 ]--
r 211                 if (validateCoord(c.getLoc()) && board[c.ggetI()][c.getJ()] < 0) {
--[ 2019.11.05.10.59.12.765.0 ]--
r 211                 if (validateCoord(c.getLoc()) && board[c.gegetI()][c.getJ()] < 0) {
--[ 2019.11.05.10.59.12.943.0 ]--
r 211                 if (validateCoord(c.getLoc()) && board[c.getgetI()][c.getJ()] < 0) {
--[ 2019.11.05.10.59.13.171.0 ]--
r 211                 if (validateCoord(c.getLoc()) && board[c.getLgetI()][c.getJ()] < 0) {
--[ 2019.11.05.10.59.13.337.0 ]--
r 211                 if (validateCoord(c.getLoc()) && board[c.getLogetI()][c.getJ()] < 0) {
--[ 2019.11.05.10.59.13.398.0 ]--
r 211                 if (validateCoord(c.getLoc()) && board[c.getLocgetI()][c.getJ()] < 0) {
--[ 2019.11.05.10.59.13.742.0 ]--
r 211                 if (validateCoord(c.getLoc()) && board[c.getLoc(getI()][c.getJ()] < 0) {
--[ 2019.11.05.10.59.14.001.0 ]--
r 211                 if (validateCoord(c.getLoc()) && board[c.getLoc()getI()][c.getJ()] < 0) {
--[ 2019.11.05.10.59.14.906.0 ]--
r 211                 if (validateCoord(c.getLoc()) && board[c.getLoc().getI()][c.getJ()] < 0) {
--[ 2019.11.05.10.59.22.048.0 ]--
r 211                 if (validateCoord(c.getLoc()) && board[c.getLoc().getI()][c.ggetJ()] < 0) {
--[ 2019.11.05.10.59.22.119.0 ]--
r 211                 if (validateCoord(c.getLoc()) && board[c.getLoc().getI()][c.gegetJ()] < 0) {
--[ 2019.11.05.10.59.22.314.0 ]--
r 211                 if (validateCoord(c.getLoc()) && board[c.getLoc().getI()][c.getgetJ()] < 0) {
--[ 2019.11.05.10.59.22.608.0 ]--
r 211                 if (validateCoord(c.getLoc()) && board[c.getLoc().getI()][c.getLgetJ()] < 0) {
--[ 2019.11.05.10.59.22.769.0 ]--
r 211                 if (validateCoord(c.getLoc()) && board[c.getLoc().getI()][c.getLogetJ()] < 0) {
--[ 2019.11.05.10.59.22.857.0 ]--
r 211                 if (validateCoord(c.getLoc()) && board[c.getLoc().getI()][c.getLocgetJ()] < 0) {
--[ 2019.11.05.10.59.23.139.0 ]--
r 211                 if (validateCoord(c.getLoc()) && board[c.getLoc().getI()][c.getLoc(getJ()] < 0) {
--[ 2019.11.05.10.59.23.194.0 ]--
r 211                 if (validateCoord(c.getLoc()) && board[c.getLoc().getI()][c.getLoc()getJ()] < 0) {
--[ 2019.11.05.10.59.23.467.0 ]--
r 211                 if (validateCoord(c.getLoc()) && board[c.getLoc().getI()][c.getLoc().getJ()] < 0) {
--[ 2019.11.05.10.59.31.994.0 ]--
r 213 
--[ 2019.11.05.10.59.32.237.0 ]--
- 213
--[ 2019.11.05.10.59.33.619.0 ]--
r 213                     pq.insert(c);
--[ 2019.11.05.10.59.37.059.0 ]--
r 212                     StdOut.println("inserting " + c.);
--[ 2019.11.05.10.59.37.215.0 ]--
r 212                     StdOut.println("inserting " + c.g);
--[ 2019.11.05.10.59.37.279.0 ]--
r 212                     StdOut.println("inserting " + c.ge);
--[ 2019.11.05.10.59.37.445.0 ]--
r 212                     StdOut.println("inserting " + c.get);
--[ 2019.11.05.10.59.37.808.0 ]--
r 212                     StdOut.println("inserting " + c.getC);
--[ 2019.11.05.10.59.38.751.0 ]--
r 212                     StdOut.println("inserting " + c.get);
--[ 2019.11.05.10.59.39.059.0 ]--
r 212                     StdOut.println("inserting " + c.getL);
--[ 2019.11.05.10.59.39.225.0 ]--
r 212                     StdOut.println("inserting " + c.getLo);
--[ 2019.11.05.10.59.39.295.0 ]--
r 212                     StdOut.println("inserting " + c.getLoc);
--[ 2019.11.05.10.59.39.581.0 ]--
r 212                     StdOut.println("inserting " + c.getLoc());
--[ 2019.11.05.10.59.42.968.0 ]--
r 214                     board[c.ggetI()][c.getJ()] = cNode.getCost(h);
--[ 2019.11.05.10.59.43.203.0 ]--
r 214                     board[c.gegetI()][c.getJ()] = cNode.getCost(h);
--[ 2019.11.05.10.59.43.222.0 ]--
r 214                     board[c.getgetI()][c.getJ()] = cNode.getCost(h);
--[ 2019.11.05.10.59.43.446.0 ]--
r 214                     board[c.getLgetI()][c.getJ()] = cNode.getCost(h);
--[ 2019.11.05.10.59.43.569.0 ]--
r 214                     board[c.getLogetI()][c.getJ()] = cNode.getCost(h);
--[ 2019.11.05.10.59.43.641.0 ]--
r 214                     board[c.getLocgetI()][c.getJ()] = cNode.getCost(h);
--[ 2019.11.05.10.59.44.180.0 ]--
r 214                     board[c.getLoc(getI()][c.getJ()] = cNode.getCost(h);
--[ 2019.11.05.10.59.44.241.0 ]--
r 214                     board[c.getLoc()getI()][c.getJ()] = cNode.getCost(h);
--[ 2019.11.05.10.59.44.518.0 ]--
r 214                     board[c.getLoc().getI()][c.getJ()] = cNode.getCost(h);
--[ 2019.11.05.10.59.46.811.0 ]--
r 214                     board[c.getLoc().getI()][c.ggetJ()] = cNode.getCost(h);
--[ 2019.11.05.10.59.46.917.0 ]--
r 214                     board[c.getLoc().getI()][c.gegetJ()] = cNode.getCost(h);
--[ 2019.11.05.10.59.47.072.0 ]--
r 214                     board[c.getLoc().getI()][c.getgetJ()] = cNode.getCost(h);
--[ 2019.11.05.10.59.47.322.0 ]--
r 214                     board[c.getLoc().getI()][c.getLgetJ()] = cNode.getCost(h);
--[ 2019.11.05.10.59.47.521.0 ]--
r 214                     board[c.getLoc().getI()][c.getLogetJ()] = cNode.getCost(h);
--[ 2019.11.05.10.59.47.570.0 ]--
r 214                     board[c.getLoc().getI()][c.getLocgetJ()] = cNode.getCost(h);
--[ 2019.11.05.10.59.47.860.0 ]--
r 214                     board[c.getLoc().getI()][c.getLoc(getJ()] = cNode.getCost(h);
--[ 2019.11.05.10.59.47.905.0 ]--
r 214                     board[c.getLoc().getI()][c.getLoc()getJ()] = cNode.getCost(h);
--[ 2019.11.05.10.59.48.179.0 ]--
r 214                     board[c.getLoc().getI()][c.getLoc().getJ()] = cNode.getCost(h);
--[ 2019.11.05.10.59.52.353.0 ]--
r 214                     board[c.getLoc().getI()][c.getLoc().getJ()] = c.getCost(h);
--[ 2019.11.05.11.00.30.761.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.11.03.48.734.0 ]--
r 214                     board[c.getLoc().getI()][c.getLoc().getJ()] = c.getCost(h);e
--[ 2019.11.05.11.03.50.816.0 ]--
r 214                     board[c.getLoc().getI()][c.getLoc().getJ()] = c.getCost(h);
--[ 2019.11.05.11.06.40.703.0 ]--
+ 202             
--[ 2019.11.05.11.06.40.889.0 ]--
r 202             S
--[ 2019.11.05.11.06.41.056.0 ]--
r 202             St
--[ 2019.11.05.11.06.41.232.0 ]--
r 202             Std
--[ 2019.11.05.11.06.41.389.0 ]--
r 202             StdO
--[ 2019.11.05.11.06.41.580.0 ]--
r 202             StdOu
--[ 2019.11.05.11.06.41.815.0 ]--
r 202             StdOut.
--[ 2019.11.05.11.06.42.015.0 ]--
r 202             StdOut.p
--[ 2019.11.05.11.06.42.129.0 ]--
r 202             StdOut.pr
--[ 2019.11.05.11.06.42.193.0 ]--
r 202             StdOut.pri
--[ 2019.11.05.11.06.42.421.0 ]--
r 202             StdOut.prin
--[ 2019.11.05.11.06.42.460.0 ]--
r 202             StdOut.print
--[ 2019.11.05.11.06.42.676.0 ]--
r 202             StdOut.printl
--[ 2019.11.05.11.06.42.792.0 ]--
r 202             StdOut.println
--[ 2019.11.05.11.06.42.979.0 ]--
r 202             StdOut.println()
--[ 2019.11.05.11.06.43.183.0 ]--
r 202             StdOut.println("")
--[ 2019.11.05.11.06.43.624.0 ]--
r 202             StdOut.println("l")
--[ 2019.11.05.11.06.43.784.0 ]--
r 202             StdOut.println("lo")
--[ 2019.11.05.11.06.43.905.0 ]--
r 202             StdOut.println("log")
--[ 2019.11.05.11.06.43.992.0 ]--
r 202             StdOut.println("logi")
--[ 2019.11.05.11.06.44.095.0 ]--
r 202             StdOut.println("logic")
--[ 2019.11.05.11.06.44.294.0 ]--
r 202             StdOut.println("logic:")
--[ 2019.11.05.11.06.44.435.0 ]--
r 202             StdOut.println("logic: ")
--[ 2019.11.05.11.06.44.877.0 ]--
r 202             StdOut.println("logic: " )
--[ 2019.11.05.11.06.45.040.0 ]--
r 202             StdOut.println("logic: " +)
--[ 2019.11.05.11.06.45.134.0 ]--
r 202             StdOut.println("logic: " + )
--[ 2019.11.05.11.06.45.345.0 ]--
r 202             StdOut.println("logic: " + f)
--[ 2019.11.05.11.06.45.474.0 ]--
r 202             StdOut.println("logic: " + fa)
--[ 2019.11.05.11.06.45.523.0 ]--
r 202             StdOut.println("logic: " + fal)
--[ 2019.11.05.11.06.45.649.0 ]--
r 202             StdOut.println("logic: " + fals)
--[ 2019.11.05.11.06.45.722.0 ]--
r 202             StdOut.println("logic: " + false)
--[ 2019.11.05.11.06.45.843.0 ]--
r 202             StdOut.println("logic: " + false )
--[ 2019.11.05.11.06.45.925.0 ]--
r 202             StdOut.println("logic: " + false a)
--[ 2019.11.05.11.06.46.392.0 ]--
r 202             StdOut.println("logic: " + false )
--[ 2019.11.05.11.06.47.458.0 ]--
r 202             StdOut.println("logic: " + false &)
--[ 2019.11.05.11.06.47.612.0 ]--
r 202             StdOut.println("logic: " + false &&)
--[ 2019.11.05.11.06.47.748.0 ]--
r 202             StdOut.println("logic: " + false && )
--[ 2019.11.05.11.06.47.943.0 ]--
r 202             StdOut.println("logic: " + false && f)
--[ 2019.11.05.11.06.48.093.0 ]--
r 202             StdOut.println("logic: " + false && fa)
--[ 2019.11.05.11.06.48.130.0 ]--
r 202             StdOut.println("logic: " + false && fal)
--[ 2019.11.05.11.06.48.258.0 ]--
r 202             StdOut.println("logic: " + false && fals)
--[ 2019.11.05.11.06.48.314.0 ]--
r 202             StdOut.println("logic: " + false && false)
--[ 2019.11.05.11.06.48.720.0 ]--
r 202             StdOut.println("logic: " + false && false);
--[ 2019.11.05.11.06.58.422.0 ]--
r 202             StdOut.printl("logic: " + false && false);
--[ 2019.11.05.11.06.58.644.0 ]--
r 202             StdOut.print("logic: " + false && false);
--[ 2019.11.05.11.07.01.387.0 ]--
r 202             StdOut.print("logic: " );
--[ 2019.11.05.11.07.01.925.0 ]--
r 202             StdOut.print("logic: ");
--[ 2019.11.05.11.07.03.135.0 ]--
+ 203             
--[ 2019.11.05.11.07.03.803.0 ]--
r 203             S
--[ 2019.11.05.11.07.03.999.0 ]--
r 203             St
--[ 2019.11.05.11.07.04.168.0 ]--
r 203             Std
--[ 2019.11.05.11.07.04.364.0 ]--
r 203             StdO
--[ 2019.11.05.11.07.04.611.0 ]--
r 203             StdOu
--[ 2019.11.05.11.07.04.692.0 ]--
r 203             StdOut
--[ 2019.11.05.11.07.04.843.0 ]--
r 203             StdOut.
--[ 2019.11.05.11.07.05.026.0 ]--
r 203             StdOut.p
--[ 2019.11.05.11.07.05.172.0 ]--
r 203             StdOut.pr
--[ 2019.11.05.11.07.05.213.0 ]--
r 203             StdOut.pri
--[ 2019.11.05.11.07.05.401.0 ]--
r 203             StdOut.prin
--[ 2019.11.05.11.07.05.585.0 ]--
r 203             StdOut.print
--[ 2019.11.05.11.07.05.614.0 ]--
r 203             StdOut.printl
--[ 2019.11.05.11.07.05.679.0 ]--
r 203             StdOut.println
--[ 2019.11.05.11.07.05.891.0 ]--
r 203             StdOut.println()
--[ 2019.11.05.11.07.06.351.0 ]--
r 203             StdOut.println(f)
--[ 2019.11.05.11.07.06.798.0 ]--
r 203             StdOut.println(fa)
--[ 2019.11.05.11.07.06.867.0 ]--
r 203             StdOut.println(fal)
--[ 2019.11.05.11.07.07.002.0 ]--
r 203             StdOut.println(fals)
--[ 2019.11.05.11.07.07.043.0 ]--
r 203             StdOut.println(false)
--[ 2019.11.05.11.07.07.245.0 ]--
r 203             StdOut.println(false )
--[ 2019.11.05.11.07.07.266.0 ]--
r 203             StdOut.println(false a)
--[ 2019.11.05.11.07.07.387.0 ]--
r 203             StdOut.println(false an)
--[ 2019.11.05.11.07.07.447.0 ]--
r 203             StdOut.println(false and)
--[ 2019.11.05.11.07.07.747.0 ]--
r 203             StdOut.println(false an)
--[ 2019.11.05.11.07.07.927.0 ]--
r 203             StdOut.println(false a)
--[ 2019.11.05.11.07.08.088.0 ]--
r 203             StdOut.println(false )
--[ 2019.11.05.11.07.08.845.0 ]--
r 203             StdOut.println(false &)
--[ 2019.11.05.11.07.09.090.0 ]--
r 203             StdOut.println(false &&)
--[ 2019.11.05.11.07.09.167.0 ]--
r 203             StdOut.println(false &&&)
--[ 2019.11.05.11.07.09.332.0 ]--
r 203             StdOut.println(false &&& )
--[ 2019.11.05.11.07.09.507.0 ]--
r 203             StdOut.println(false &&& f)
--[ 2019.11.05.11.07.09.653.0 ]--
r 203             StdOut.println(false &&& fa)
--[ 2019.11.05.11.07.09.815.0 ]--
r 203             StdOut.println(false &&& f)
--[ 2019.11.05.11.07.10.020.0 ]--
r 203             StdOut.println(false &&& )
--[ 2019.11.05.11.07.10.167.0 ]--
r 203             StdOut.println(false &&&)
--[ 2019.11.05.11.07.10.319.0 ]--
r 203             StdOut.println(false &&)
--[ 2019.11.05.11.07.10.660.0 ]--
r 203             StdOut.println(false && )
--[ 2019.11.05.11.07.10.837.0 ]--
r 203             StdOut.println(false && f)
--[ 2019.11.05.11.07.10.900.0 ]--
r 203             StdOut.println(false && fa)
--[ 2019.11.05.11.07.11.018.0 ]--
r 203             StdOut.println(false && fal)
--[ 2019.11.05.11.07.11.123.0 ]--
r 203             StdOut.println(false && fale)
--[ 2019.11.05.11.07.11.548.0 ]--
r 203             StdOut.println(false && fal)
--[ 2019.11.05.11.07.11.701.0 ]--
r 203             StdOut.println(false && fals)
--[ 2019.11.05.11.07.11.736.0 ]--
r 203             StdOut.println(false && false)
--[ 2019.11.05.11.07.12.208.0 ]--
r 203             StdOut.println(false && false);
--[ 2019.11.05.11.07.16.587.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.11.07.34.586.0 ]--
r 203             StdOut.println(false && false);e
--[ 2019.11.05.11.07.36.695.0 ]--
r 203             StdOut.println(false && false);
--[ 2019.11.05.11.09.01.427.0 ]--
+ 162                 
--[ 2019.11.05.11.09.01.700.0 ]--
r 162                 S
--[ 2019.11.05.11.09.01.876.0 ]--
r 162                 St
--[ 2019.11.05.11.09.02.092.0 ]--
r 162                 Std
--[ 2019.11.05.11.09.02.237.0 ]--
r 162                 StdO
--[ 2019.11.05.11.09.02.434.0 ]--
r 162                 StdOu
--[ 2019.11.05.11.09.02.691.0 ]--
r 162                 StdOut.
--[ 2019.11.05.11.09.02.955.0 ]--
r 162                 StdOut.p
--[ 2019.11.05.11.09.03.136.0 ]--
r 162                 StdOut.pr
--[ 2019.11.05.11.09.03.173.0 ]--
r 162                 StdOut.pri
--[ 2019.11.05.11.09.03.339.0 ]--
r 162                 StdOut.prin
--[ 2019.11.05.11.09.03.402.0 ]--
r 162                 StdOut.print
--[ 2019.11.05.11.09.03.618.0 ]--
r 162                 StdOut.print()
--[ 2019.11.05.11.09.03.755.0 ]--
r 162                 StdOut.print(b)
--[ 2019.11.05.11.09.03.893.0 ]--
r 162                 StdOut.print(bo)
--[ 2019.11.05.11.09.04.034.0 ]--
r 162                 StdOut.print(boa)
--[ 2019.11.05.11.09.04.063.0 ]--
r 162                 StdOut.print(boar)
--[ 2019.11.05.11.09.04.258.0 ]--
r 162                 StdOut.print(board)
--[ 2019.11.05.11.09.05.062.0 ]--
r 162                 StdOut.print(board[])
--[ 2019.11.05.11.09.05.387.0 ]--
r 162                 StdOut.print(board[i])
--[ 2019.11.05.11.09.07.304.0 ]--
r 162                 StdOut.print(board[i)
--[ 2019.11.05.11.09.07.491.0 ]--
r 162                 StdOut.print(board[)
--[ 2019.11.05.11.09.08.001.0 ]--
r 162                 StdOut.print(board[j)
--[ 2019.11.05.11.09.08.294.0 ]--
r 162                 StdOut.print(board[j])
--[ 2019.11.05.11.09.08.542.0 ]--
r 162                 StdOut.print(board[j][])
--[ 2019.11.05.11.09.08.843.0 ]--
r 162                 StdOut.print(board[j][i])
--[ 2019.11.05.11.09.10.580.0 ]--
r 162                 StdOut.print(board[j][i]);
--[ 2019.11.05.11.09.13.449.0 ]--
r 161                 /StdOut.print(terrain.getHeight(j, i));
--[ 2019.11.05.11.09.13.649.0 ]--
r 161                 //StdOut.print(terrain.getHeight(j, i));
--[ 2019.11.05.11.09.17.044.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.11.09.40.067.0 ]--
r 130                 board[i][j] = -1.;
--[ 2019.11.05.11.09.40.330.0 ]--
r 130                 board[i][j] = -1.0;
--[ 2019.11.05.11.09.41.410.0 ]--
r 130                 board[i][j] = -1.0f;
--[ 2019.11.05.11.10.41.639.0 ]--
+ 200         
--[ 2019.11.05.11.10.41.970.0 ]--
+ 200         board = new float[N][N];
+ 201         for (int i = 0; i < N; i++) {
+ 202             for (int j = 0; j < N; j++) {
+ 203                 board[i][j] = -1.0f;
+ 204             }
r 205         }
--[ 2019.11.05.11.10.46.754.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.11.11.18.149.0 ]--
r 178     
--[ 2019.11.05.11.11.18.374.0 ]--
r 178         
--[ 2019.11.05.11.11.18.941.0 ]--
+ 178         start = null;
+ 179         end = null;
+ 180         pq = new MinPQ<>();
+ 181         this.terrain = terrain;
+ 182         N = this.terrain.getN();
+ 183         h = 0.0f;
+ 184         board = new float[N][N];
+ 185         for (int i = 0; i < N; i++) {
+ 186             for (int j = 0; j < N; j++) {
+ 187                 board[i][j] = -1.0f;
+ 188             }
+ 189         }
+ 190         origCost = new int[N][N];
+ 191         for (int i = 0; i < N; i++) {
+ 192             for (int j = 0; j < N; j++) {
+ 193                 origCost[i][j] = this.terrain.getHeight(i, j);
+ 194             }
r 195         }
--[ 2019.11.05.11.11.24.305.0 ]--
r 181 
--[ 2019.11.05.11.11.24.472.0 ]--
- 181
--[ 2019.11.05.11.11.56.105.0 ]--
- 216
- 216
- 216
- 216
- 216
r 216         r
--[ 2019.11.05.11.11.56.351.0 ]--
r 216         res
--[ 2019.11.05.11.11.56.386.0 ]--
r 216         rese
--[ 2019.11.05.11.11.56.536.0 ]--
r 216         reset
--[ 2019.11.05.11.11.56.777.0 ]--
r 216         resetP
--[ 2019.11.05.11.11.56.943.0 ]--
r 216         resetPa
--[ 2019.11.05.11.11.57.022.0 ]--
r 216         resetPat
--[ 2019.11.05.11.11.57.142.0 ]--
r 216         resetPath
--[ 2019.11.05.11.11.57.489.0 ]--
r 216         resetPath()
--[ 2019.11.05.11.11.57.785.0 ]--
r 216         resetPath();
--[ 2019.11.05.11.12.59.325.0 ]--
r 216 
--[ 2019.11.05.11.12.59.552.0 ]--
- 216
--[ 2019.11.05.11.13.05.722.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.11.13.10.482.0 ]--
- 219
r 219 
--[ 2019.11.05.11.13.10.657.0 ]--
- 219
--[ 2019.11.05.11.13.16.044.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.11.17.30.430.0 ]--
+ 83             
--[ 2019.11.05.11.17.30.742.0 ]--
r 83             S
--[ 2019.11.05.11.17.30.848.0 ]--
r 83             ST
--[ 2019.11.05.11.17.31.075.0 ]--
r 83             STd
--[ 2019.11.05.11.17.31.288.0 ]--
r 83             STdO
--[ 2019.11.05.11.17.31.536.0 ]--
r 83             STd
--[ 2019.11.05.11.17.31.693.0 ]--
r 83             ST
--[ 2019.11.05.11.17.31.846.0 ]--
r 83             S
--[ 2019.11.05.11.17.31.989.0 ]--
r 83             St
--[ 2019.11.05.11.17.32.144.0 ]--
r 83             Std
--[ 2019.11.05.11.17.32.356.0 ]--
r 83             StdO
--[ 2019.11.05.11.17.32.521.0 ]--
r 83             StdOu
--[ 2019.11.05.11.17.32.616.0 ]--
r 83             StdOut
--[ 2019.11.05.11.17.32.776.0 ]--
r 83             StdOut.
--[ 2019.11.05.11.17.32.984.0 ]--
r 83             StdOut.p
--[ 2019.11.05.11.17.33.109.0 ]--
r 83             StdOut.pr
--[ 2019.11.05.11.17.33.153.0 ]--
r 83             StdOut.pri
--[ 2019.11.05.11.17.33.348.0 ]--
r 83             StdOut.prin
--[ 2019.11.05.11.17.33.465.0 ]--
r 83             StdOut.print
--[ 2019.11.05.11.17.33.565.0 ]--
r 83             StdOut.printl
--[ 2019.11.05.11.17.33.614.0 ]--
r 83             StdOut.println
--[ 2019.11.05.11.17.33.818.0 ]--
r 83             StdOut.println()
--[ 2019.11.05.11.17.34.034.0 ]--
r 83             StdOut.println("")
--[ 2019.11.05.11.17.34.306.0 ]--
r 83             StdOut.println("i")
--[ 2019.11.05.11.17.34.406.0 ]--
r 83             StdOut.println("is")
--[ 2019.11.05.11.17.34.487.0 ]--
r 83             StdOut.println("is ")
--[ 2019.11.05.11.17.34.671.0 ]--
r 83             StdOut.println("is b")
--[ 2019.11.05.11.17.34.813.0 ]--
r 83             StdOut.println("is b ")
--[ 2019.11.05.11.17.34.952.0 ]--
r 83             StdOut.println("is b n")
--[ 2019.11.05.11.17.35.210.0 ]--
r 83             StdOut.println("is b nu")
--[ 2019.11.05.11.17.35.383.0 ]--
r 83             StdOut.println("is b nul")
--[ 2019.11.05.11.17.35.520.0 ]--
r 83             StdOut.println("is b null")
--[ 2019.11.05.11.17.35.758.0 ]--
r 83             StdOut.println("is b null?")
--[ 2019.11.05.11.17.35.937.0 ]--
r 83             StdOut.println("is b null? ")
--[ 2019.11.05.11.17.36.808.0 ]--
r 83             StdOut.println("is b null? " )
--[ 2019.11.05.11.17.37.145.0 ]--
r 83             StdOut.println("is b null? " ) 
--[ 2019.11.05.11.17.37.821.0 ]--
r 83             StdOut.println("is b null? " )
--[ 2019.11.05.11.17.37.993.0 ]--
r 83             StdOut.println("is b null? " 
--[ 2019.11.05.11.17.38.757.0 ]--
r 83             StdOut.println("is b null? " +
--[ 2019.11.05.11.17.38.826.0 ]--
r 83             StdOut.println("is b null? " + 
--[ 2019.11.05.11.17.39.725.0 ]--
r 83             StdOut.println("is b null? " + b
--[ 2019.11.05.11.17.39.844.0 ]--
r 83             StdOut.println("is b null? " + b 
--[ 2019.11.05.11.17.39.999.0 ]--
r 83             StdOut.println("is b null? " + b =
--[ 2019.11.05.11.17.40.120.0 ]--
r 83             StdOut.println("is b null? " + b ==
--[ 2019.11.05.11.17.40.231.0 ]--
r 83             StdOut.println("is b null? " + b == 
--[ 2019.11.05.11.17.40.328.0 ]--
r 83             StdOut.println("is b null? " + b == n
--[ 2019.11.05.11.17.40.599.0 ]--
r 83             StdOut.println("is b null? " + b == nu
--[ 2019.11.05.11.17.40.861.0 ]--
r 83             StdOut.println("is b null? " + b == nul
--[ 2019.11.05.11.17.40.901.0 ]--
r 83             StdOut.println("is b null? " + b == null
--[ 2019.11.05.11.17.41.048.0 ]--
r 83             StdOut.println("is b null? " + b == null)
--[ 2019.11.05.11.17.41.327.0 ]--
r 83             StdOut.println("is b null? " + b == null);
--[ 2019.11.05.11.17.46.652.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.11.18.27.421.0 ]--
+ 83             StdOut.println("is b null? " 
r 84             + b == null);
--[ 2019.11.05.11.18.27.658.0 ]--
r 84                     + b == null);
--[ 2019.11.05.11.18.27.691.0 ]--
r 84                     S+ b == null);
--[ 2019.11.05.11.18.27.805.0 ]--
r 84                     St+ b == null);
--[ 2019.11.05.11.18.27.985.0 ]--
r 84                     Std+ b == null);
--[ 2019.11.05.11.18.28.151.0 ]--
r 84                     StdO+ b == null);
--[ 2019.11.05.11.18.28.439.0 ]--
r 84                     StdOu+ b == null);
--[ 2019.11.05.11.18.28.544.0 ]--
r 84                     StdOut+ b == null);
--[ 2019.11.05.11.18.28.945.0 ]--
r 84                     StdOut.+ b == null);
--[ 2019.11.05.11.18.29.205.0 ]--
r 84                     StdOut.p+ b == null);
--[ 2019.11.05.11.18.29.354.0 ]--
r 84                     StdOut.pr+ b == null);
--[ 2019.11.05.11.18.29.415.0 ]--
r 84                     StdOut.pri+ b == null);
--[ 2019.11.05.11.18.29.516.0 ]--
r 84                     StdOut.prin+ b == null);
--[ 2019.11.05.11.18.29.591.0 ]--
r 84                     StdOut.print+ b == null);
--[ 2019.11.05.11.18.29.836.0 ]--
r 84                     StdOut.print(+ b == null);
--[ 2019.11.05.11.18.32.765.0 ]--
r 84                     StdOut.printl(+ b == null);
--[ 2019.11.05.11.18.32.851.0 ]--
r 84                     StdOut.println(+ b == null);
--[ 2019.11.05.11.18.33.663.0 ]--
r 84                     StdOut.println( b == null);
--[ 2019.11.05.11.18.33.915.0 ]--
r 84                     StdOut.println(b == null);
--[ 2019.11.05.11.18.36.599.0 ]--
- 83
r 83             StdOut.println("is b null? "StdOut.println(b == null);
--[ 2019.11.05.11.18.37.805.0 ]--
+ 83             StdOut.println("is b null? "
r 84             StdOut.println(b == null);
--[ 2019.11.05.11.18.38.023.0 ]--
r 84                     StdOut.println(b == null);
--[ 2019.11.05.11.18.38.909.0 ]--
- 83
r 83             StdOut.println("is b null? "StdOut.println(b == null);
--[ 2019.11.05.11.18.39.747.0 ]--
r 83             StdOut.println("is b null? ")StdOut.println(b == null);
--[ 2019.11.05.11.18.40.011.0 ]--
r 83             StdOut.println("is b null? ");StdOut.println(b == null);
--[ 2019.11.05.11.18.40.276.0 ]--
+ 83             StdOut.println("is b null? ");
r 84             StdOut.println(b == null);
--[ 2019.11.05.11.18.43.504.0 ]--
r 83             StdOut.printl("is b null? ");
--[ 2019.11.05.11.18.43.676.0 ]--
r 83             StdOut.print("is b null? ");
--[ 2019.11.05.11.18.47.208.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.11.22.36.520.0 ]--
+ 229             
--[ 2019.11.05.11.22.37.891.0 ]--
r 229             b
--[ 2019.11.05.11.22.38.084.0 ]--
r 229             bo
--[ 2019.11.05.11.22.38.171.0 ]--
r 229             boa
--[ 2019.11.05.11.22.38.248.0 ]--
r 229             boar
--[ 2019.11.05.11.22.38.435.0 ]--
r 229             board
--[ 2019.11.05.11.22.38.569.0 ]--
r 229             board[]
--[ 2019.11.05.11.22.38.747.0 ]--
r 229             board[c]
--[ 2019.11.05.11.22.38.899.0 ]--
r 229             board[c.]
--[ 2019.11.05.11.22.39.053.0 ]--
r 229             board[c.g]
--[ 2019.11.05.11.22.39.150.0 ]--
r 229             board[c.ge]
--[ 2019.11.05.11.22.39.302.0 ]--
r 229             board[c.get]
--[ 2019.11.05.11.22.39.510.0 ]--
r 229             board[c.getL]
--[ 2019.11.05.11.22.39.675.0 ]--
r 229             board[c.getLo]
--[ 2019.11.05.11.22.39.737.0 ]--
r 229             board[c.getLoc]
--[ 2019.11.05.11.22.40.095.0 ]--
r 229             board[c.getLoc()]
--[ 2019.11.05.11.22.40.617.0 ]--
r 229             board[c.getLoc().]
--[ 2019.11.05.11.22.40.699.0 ]--
r 229             board[c.getLoc().g]
--[ 2019.11.05.11.22.40.780.0 ]--
r 229             board[c.getLoc().ge]
--[ 2019.11.05.11.22.40.941.0 ]--
r 229             board[c.getLoc().get]
--[ 2019.11.05.11.22.41.198.0 ]--
r 229             board[c.getLoc().getI]
--[ 2019.11.05.11.22.41.718.0 ]--
r 229             board[c.getLoc().getI()]
--[ 2019.11.05.11.22.45.064.0 ]--
r 229             board[cu.getLoc().getI()]
--[ 2019.11.05.11.22.45.173.0 ]--
r 229             board[cur.getLoc().getI()]
--[ 2019.11.05.11.22.45.360.0 ]--
r 229             board[curr.getLoc().getI()]
--[ 2019.11.05.11.22.45.435.0 ]--
r 229             board[curre.getLoc().getI()]
--[ 2019.11.05.11.22.45.567.0 ]--
r 229             board[curren.getLoc().getI()]
--[ 2019.11.05.11.22.45.609.0 ]--
r 229             board[current.getLoc().getI()]
--[ 2019.11.05.11.22.45.780.0 ]--
r 229             board[currentN.getLoc().getI()]
--[ 2019.11.05.11.22.45.918.0 ]--
r 229             board[currentNo.getLoc().getI()]
--[ 2019.11.05.11.22.45.985.0 ]--
r 229             board[currentNod.getLoc().getI()]
--[ 2019.11.05.11.22.46.214.0 ]--
r 229             board[currentNode.getLoc().getI()]
--[ 2019.11.05.11.22.48.622.0 ]--
r 229             board[currentNode.getLoc().getI()][]
--[ 2019.11.05.11.22.49.054.0 ]--
r 229             board[currentNode.getLoc().getI()][c]
--[ 2019.11.05.11.22.49.447.0 ]--
r 229             board[currentNode.getLoc().getI()][cu]
--[ 2019.11.05.11.22.49.562.0 ]--
r 229             board[currentNode.getLoc().getI()][cur]
--[ 2019.11.05.11.22.49.725.0 ]--
r 229             board[currentNode.getLoc().getI()][curr]
--[ 2019.11.05.11.22.49.792.0 ]--
r 229             board[currentNode.getLoc().getI()][curre]
--[ 2019.11.05.11.22.49.936.0 ]--
r 229             board[currentNode.getLoc().getI()][curren]
--[ 2019.11.05.11.22.49.985.0 ]--
r 229             board[currentNode.getLoc().getI()][current]
--[ 2019.11.05.11.22.50.236.0 ]--
r 229             board[currentNode.getLoc().getI()][currentN]
--[ 2019.11.05.11.22.50.400.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNo]
--[ 2019.11.05.11.22.50.448.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNod]
--[ 2019.11.05.11.22.50.677.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode]
--[ 2019.11.05.11.22.50.770.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.]
--[ 2019.11.05.11.22.50.860.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.g]
--[ 2019.11.05.11.22.50.951.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.ge]
--[ 2019.11.05.11.22.51.116.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.get]
--[ 2019.11.05.11.22.51.233.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getL]
--[ 2019.11.05.11.22.51.569.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLo]
--[ 2019.11.05.11.22.51.678.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc]
--[ 2019.11.05.11.22.51.921.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc()]
--[ 2019.11.05.11.22.52.286.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc().]
--[ 2019.11.05.11.22.52.402.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc().g]
--[ 2019.11.05.11.22.52.490.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc().ge]
--[ 2019.11.05.11.22.52.642.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc().get]
--[ 2019.11.05.11.22.52.821.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc().getJ]
--[ 2019.11.05.11.22.53.159.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()]
--[ 2019.11.05.11.22.54.865.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] 
--[ 2019.11.05.11.22.54.944.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] =
--[ 2019.11.05.11.22.55.072.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = 
--[ 2019.11.05.11.22.55.305.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = c
--[ 2019.11.05.11.22.55.386.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = cu
--[ 2019.11.05.11.22.55.594.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = cur
--[ 2019.11.05.11.22.55.791.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = curr
--[ 2019.11.05.11.22.55.832.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = curre
--[ 2019.11.05.11.22.56.018.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = curren
--[ 2019.11.05.11.22.56.050.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = current
--[ 2019.11.05.11.22.56.276.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = currentN
--[ 2019.11.05.11.22.56.425.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = currentNo
--[ 2019.11.05.11.22.56.513.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = currentNod
--[ 2019.11.05.11.22.56.731.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = currentNode
--[ 2019.11.05.11.22.56.855.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = currentNode.
--[ 2019.11.05.11.22.56.929.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = currentNode.g
--[ 2019.11.05.11.22.57.018.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = currentNode.ge
--[ 2019.11.05.11.22.57.165.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = currentNode.get
--[ 2019.11.05.11.22.57.365.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = currentNode.getC
--[ 2019.11.05.11.22.57.558.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = currentNode.getCo
--[ 2019.11.05.11.22.57.659.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = currentNode.getCos
--[ 2019.11.05.11.22.57.732.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = currentNode.getCost
--[ 2019.11.05.11.22.58.001.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = currentNode.getCost()
--[ 2019.11.05.11.22.58.218.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = currentNode.getCost(h)
--[ 2019.11.05.11.22.58.723.0 ]--
r 229             board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = currentNode.getCost(h);
--[ 2019.11.05.11.23.03.395.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.11.25.57.629.0 ]--
- 47
- 47
- 47
- 47
- 47
- 47
- 47
- 47
- 48
- 48
- 48
- 48
- 48
- 48
- 48
- 48
--[ 2019.11.05.11.26.01.506.0 ]--
- 52
- 52
- 52
- 52
- 52
- 53
--[ 2019.11.05.11.26.01.681.0 ]--
- 51
r 51         
--[ 2019.11.05.11.26.01.881.0 ]--
- 51
--[ 2019.11.05.11.26.15.939.0 ]--
- 45
- 45
- 45
- 45
- 46
--[ 2019.11.05.11.26.16.428.0 ]--
- 45
--[ 2019.11.05.11.26.31.789.0 ]--
r 29         private f cost;
--[ 2019.11.05.11.26.32.032.0 ]--
r 29         private fl cost;
--[ 2019.11.05.11.26.32.063.0 ]--
r 29         private flo cost;
--[ 2019.11.05.11.26.32.145.0 ]--
r 29         private floa cost;
--[ 2019.11.05.11.26.32.210.0 ]--
r 29         private float cost;
--[ 2019.11.05.11.26.43.726.0 ]--
+ 50         
--[ 2019.11.05.11.26.44.051.0 ]--
+ 50         
--[ 2019.11.05.11.26.44.384.0 ]--
r 51         p
--[ 2019.11.05.11.26.44.509.0 ]--
r 51         pr
--[ 2019.11.05.11.26.44.555.0 ]--
r 51         pri
--[ 2019.11.05.11.26.44.792.0 ]--
r 51         priv
--[ 2019.11.05.11.26.44.858.0 ]--
r 51         priva
--[ 2019.11.05.11.26.44.962.0 ]--
r 51         privat
--[ 2019.11.05.11.26.45.103.0 ]--
r 51         private
--[ 2019.11.05.11.26.45.157.0 ]--
r 51         private 
--[ 2019.11.05.11.26.45.348.0 ]--
r 51         private f
--[ 2019.11.05.11.26.45.465.0 ]--
r 51         private fl
--[ 2019.11.05.11.26.45.602.0 ]--
r 51         private flo
--[ 2019.11.05.11.26.45.709.0 ]--
r 51         private floa
--[ 2019.11.05.11.26.45.745.0 ]--
r 51         private float
--[ 2019.11.05.11.26.45.898.0 ]--
r 51         private float 
--[ 2019.11.05.11.26.45.971.0 ]--
r 51         private float c
--[ 2019.11.05.11.26.46.046.0 ]--
r 51         private float co
--[ 2019.11.05.11.26.46.087.0 ]--
r 51         private float com
--[ 2019.11.05.11.26.46.227.0 ]--
r 51         private float comp
--[ 2019.11.05.11.26.46.359.0 ]--
r 51         private float compu
--[ 2019.11.05.11.26.46.430.0 ]--
r 51         private float comput
--[ 2019.11.05.11.26.46.560.0 ]--
r 51         private float compute
--[ 2019.11.05.11.26.46.784.0 ]--
r 51         private float computeC
--[ 2019.11.05.11.26.46.962.0 ]--
r 51         private float computeCo
--[ 2019.11.05.11.26.47.100.0 ]--
r 51         private float computeCos
--[ 2019.11.05.11.26.47.159.0 ]--
r 51         private float computeCost
--[ 2019.11.05.11.26.47.404.0 ]--
r 51         private float computeCost()
--[ 2019.11.05.11.26.48.152.0 ]--
r 51         private float computeCost(f)
--[ 2019.11.05.11.26.48.220.0 ]--
r 51         private float computeCost(fl)
--[ 2019.11.05.11.26.48.399.0 ]--
r 51         private float computeCost(flo)
--[ 2019.11.05.11.26.48.465.0 ]--
r 51         private float computeCost(floa)
--[ 2019.11.05.11.26.48.523.0 ]--
r 51         private float computeCost(float)
--[ 2019.11.05.11.26.48.615.0 ]--
r 51         private float computeCost(float )
--[ 2019.11.05.11.26.48.744.0 ]--
r 51         private float computeCost(float h)
--[ 2019.11.05.11.26.48.886.0 ]--
r 51         private float computeCost(float he)
--[ 2019.11.05.11.26.48.951.0 ]--
r 51         private float computeCost(float heu)
--[ 2019.11.05.11.26.49.058.0 ]--
r 51         private float computeCost(float heur)
--[ 2019.11.05.11.26.49.192.0 ]--
r 51         private float computeCost(float heuri)
--[ 2019.11.05.11.26.49.279.0 ]--
r 51         private float computeCost(float heuris)
--[ 2019.11.05.11.26.49.335.0 ]--
r 51         private float computeCost(float heurist)
--[ 2019.11.05.11.26.49.407.0 ]--
r 51         private float computeCost(float heuristi)
--[ 2019.11.05.11.26.49.572.0 ]--
r 51         private float computeCost(float heuristic)
--[ 2019.11.05.11.26.49.967.0 ]--
r 51         private float computeCost(float heuristic);
--[ 2019.11.05.11.26.50.375.0 ]--
r 51         private float computeCost(float heuristic)
--[ 2019.11.05.11.26.50.579.0 ]--
r 51         private float computeCost(float heuristic) 
--[ 2019.11.05.11.26.50.808.0 ]--
r 51         private float computeCost(float heuristic) {}
--[ 2019.11.05.11.26.51.021.0 ]--
+ 51         private float computeCost(float heuristic) {
r 52         }
--[ 2019.11.05.11.26.51.093.0 ]--
+ 52             
--[ 2019.11.05.11.26.52.540.0 ]--
r 52             P
--[ 2019.11.05.11.26.52.663.0 ]--
r 52             PF
--[ 2019.11.05.11.26.53.288.0 ]--
r 52             PFN
--[ 2019.11.05.11.26.53.546.0 ]--
r 52             PFNo
--[ 2019.11.05.11.26.53.635.0 ]--
r 52             PFNod
--[ 2019.11.05.11.26.53.806.0 ]--
r 52             PFNode
--[ 2019.11.05.11.26.54.060.0 ]--
r 52             PFNode b
--[ 2019.11.05.11.26.54.149.0 ]--
r 52             PFNode b 
--[ 2019.11.05.11.26.54.266.0 ]--
r 52             PFNode b =
--[ 2019.11.05.11.26.54.332.0 ]--
r 52             PFNode b = 
--[ 2019.11.05.11.26.54.523.0 ]--
r 52             PFNode b = f
--[ 2019.11.05.11.26.54.754.0 ]--
r 52             PFNode b = fr
--[ 2019.11.05.11.26.54.846.0 ]--
r 52             PFNode b = fro
--[ 2019.11.05.11.26.54.888.0 ]--
r 52             PFNode b = from
--[ 2019.11.05.11.26.55.144.0 ]--
r 52             PFNode b = fromN
--[ 2019.11.05.11.26.55.252.0 ]--
r 52             PFNode b = fromNo
--[ 2019.11.05.11.26.55.390.0 ]--
r 52             PFNode b = fromNod
--[ 2019.11.05.11.26.55.545.0 ]--
r 52             PFNode b = fromNode
--[ 2019.11.05.11.26.55.607.0 ]--
r 52             PFNode b = fromNode;
--[ 2019.11.05.11.26.55.773.0 ]--
+ 53             
--[ 2019.11.05.11.26.56.607.0 ]--
- 53
--[ 2019.11.05.11.26.58.778.0 ]--
- 51
- 51
r 51 
--[ 2019.11.05.11.26.58.952.0 ]--
- 51
--[ 2019.11.05.11.26.59.346.0 ]--
- 50
--[ 2019.11.05.11.27.12.897.0 ]--
r 38             if      (this.getCost(h) < that.getCost()) return -1;
--[ 2019.11.05.11.27.17.075.0 ]--
r 38             if      (this.getCost(h) < that.getCost(h)) return -1;
--[ 2019.11.05.11.27.17.964.0 ]--
r 39             else if (this.getCost(h) > that.getCost()) return 1;
--[ 2019.11.05.11.27.18.806.0 ]--
r 39             else if (this.getCost(h) > that.getCost(h)) return 1;
--[ 2019.11.05.11.27.23.255.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.11.29.14.362.0 ]--
+ 197             
--[ 2019.11.05.11.29.14.739.0 ]--
r 198             SStdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.29.15.262.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.29.15.990.0 ]--
- 197
--[ 2019.11.05.11.29.16.959.0 ]--
+ 198             
--[ 2019.11.05.11.29.18.044.0 ]--
r 198             S
--[ 2019.11.05.11.29.18.228.0 ]--
r 198             St
--[ 2019.11.05.11.29.18.411.0 ]--
r 198             Std
--[ 2019.11.05.11.29.18.574.0 ]--
r 198             StdO
--[ 2019.11.05.11.29.18.768.0 ]--
r 198             StdOu
--[ 2019.11.05.11.29.18.941.0 ]--
r 198             StdOut
--[ 2019.11.05.11.29.19.030.0 ]--
r 198             StdOut.
--[ 2019.11.05.11.29.19.269.0 ]--
r 198             StdOut.p
--[ 2019.11.05.11.29.19.339.0 ]--
r 198             StdOut.pr
--[ 2019.11.05.11.29.19.379.0 ]--
r 198             StdOut.pri
--[ 2019.11.05.11.29.19.724.0 ]--
r 198             StdOut.prin
--[ 2019.11.05.11.29.19.869.0 ]--
r 198             StdOut.print
--[ 2019.11.05.11.29.19.955.0 ]--
r 198             StdOut.printl
--[ 2019.11.05.11.29.20.017.0 ]--
r 198             StdOut.println
--[ 2019.11.05.11.29.20.237.0 ]--
r 198             StdOut.println()
--[ 2019.11.05.11.29.20.465.0 ]--
r 198             StdOut.println("")
--[ 2019.11.05.11.29.20.725.0 ]--
r 198             StdOut.println("p")
--[ 2019.11.05.11.29.20.818.0 ]--
r 198             StdOut.println("pa")
--[ 2019.11.05.11.29.20.885.0 ]--
r 198             StdOut.println("pat")
--[ 2019.11.05.11.29.20.974.0 ]--
r 198             StdOut.println("path")
--[ 2019.11.05.11.29.21.063.0 ]--
r 198             StdOut.println("path ")
--[ 2019.11.05.11.29.21.147.0 ]--
r 198             StdOut.println("path e")
--[ 2019.11.05.11.29.21.262.0 ]--
r 198             StdOut.println("path en")
--[ 2019.11.05.11.29.21.330.0 ]--
r 198             StdOut.println("path end")
--[ 2019.11.05.11.29.21.682.0 ]--
r 198             StdOut.println("path end:")
--[ 2019.11.05.11.29.21.990.0 ]--
r 198             StdOut.println("path end: ")
--[ 2019.11.05.11.29.22.363.0 ]--
r 198             StdOut.println("path end: " )
--[ 2019.11.05.11.29.22.557.0 ]--
r 198             StdOut.println("path end: " +)
--[ 2019.11.05.11.29.22.674.0 ]--
r 198             StdOut.println("path end: " + )
--[ 2019.11.05.11.29.23.092.0 ]--
r 198             StdOut.println("path end: " + g)
--[ 2019.11.05.11.29.23.185.0 ]--
r 198             StdOut.println("path end: " + ge)
--[ 2019.11.05.11.29.23.327.0 ]--
r 198             StdOut.println("path end: " + get)
--[ 2019.11.05.11.29.23.529.0 ]--
r 198             StdOut.println("path end: " + getP)
--[ 2019.11.05.11.29.23.688.0 ]--
r 198             StdOut.println("path end: " + getPa)
--[ 2019.11.05.11.29.23.735.0 ]--
r 198             StdOut.println("path end: " + getPat)
--[ 2019.11.05.11.29.23.807.0 ]--
r 198             StdOut.println("path end: " + getPath)
--[ 2019.11.05.11.29.24.075.0 ]--
r 198             StdOut.println("path end: " + getPathE)
--[ 2019.11.05.11.29.24.329.0 ]--
r 198             StdOut.println("path end: " + getPathEn)
--[ 2019.11.05.11.29.24.405.0 ]--
r 198             StdOut.println("path end: " + getPathEnd)
--[ 2019.11.05.11.29.24.758.0 ]--
r 198             StdOut.println("path end: " + getPathEnd())
--[ 2019.11.05.11.29.25.359.0 ]--
r 198             StdOut.println("path end: " + getPathEnd());
--[ 2019.11.05.11.29.29.856.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.11.30.07.633.0 ]--
+ 199             
--[ 2019.11.05.11.30.07.875.0 ]--
r 199             S
--[ 2019.11.05.11.30.08.074.0 ]--
r 199             St
--[ 2019.11.05.11.30.08.260.0 ]--
r 199             Std
--[ 2019.11.05.11.30.08.429.0 ]--
r 199             StdO
--[ 2019.11.05.11.30.08.632.0 ]--
r 199             StdOu
--[ 2019.11.05.11.30.08.727.0 ]--
r 199             StdOut
--[ 2019.11.05.11.30.08.881.0 ]--
r 199             StdOut.
--[ 2019.11.05.11.30.09.111.0 ]--
r 199             StdOut.p
--[ 2019.11.05.11.30.09.253.0 ]--
r 199             StdOut.pr
--[ 2019.11.05.11.30.09.335.0 ]--
r 199             StdOut.pri
--[ 2019.11.05.11.30.09.444.0 ]--
r 199             StdOut.prin
--[ 2019.11.05.11.30.09.574.0 ]--
r 199             StdOut.print
--[ 2019.11.05.11.30.09.645.0 ]--
r 199             StdOut.printl
--[ 2019.11.05.11.30.09.719.0 ]--
r 199             StdOut.println
--[ 2019.11.05.11.30.09.933.0 ]--
r 199             StdOut.println()
--[ 2019.11.05.11.30.10.199.0 ]--
r 199             StdOut.println("")
--[ 2019.11.05.11.30.11.223.0 ]--
r 199             StdOut.println()
--[ 2019.11.05.11.30.11.992.0 ]--
r 199             StdOut.println(c)
--[ 2019.11.05.11.30.12.053.0 ]--
r 199             StdOut.println(cu)
--[ 2019.11.05.11.30.12.278.0 ]--
r 199             StdOut.println(cur)
--[ 2019.11.05.11.30.12.456.0 ]--
r 199             StdOut.println(curr)
--[ 2019.11.05.11.30.12.494.0 ]--
r 199             StdOut.println(curre)
--[ 2019.11.05.11.30.12.590.0 ]--
r 199             StdOut.println(curren)
--[ 2019.11.05.11.30.12.685.0 ]--
r 199             StdOut.println(current)
--[ 2019.11.05.11.30.12.871.0 ]--
r 199             StdOut.println(currentL)
--[ 2019.11.05.11.30.13.023.0 ]--
r 199             StdOut.println(currentLo)
--[ 2019.11.05.11.30.13.067.0 ]--
r 199             StdOut.println(currentLoc)
--[ 2019.11.05.11.30.13.146.0 ]--
r 199             StdOut.println(currentLoc )
--[ 2019.11.05.11.30.13.296.0 ]--
r 199             StdOut.println(currentLoc =)
--[ 2019.11.05.11.30.13.419.0 ]--
r 199             StdOut.println(currentLoc ==)
--[ 2019.11.05.11.30.13.500.0 ]--
r 199             StdOut.println(currentLoc == )
--[ 2019.11.05.11.30.13.707.0 ]--
r 199             StdOut.println(currentLoc == g)
--[ 2019.11.05.11.30.13.783.0 ]--
r 199             StdOut.println(currentLoc == ge)
--[ 2019.11.05.11.30.13.956.0 ]--
r 199             StdOut.println(currentLoc == get)
--[ 2019.11.05.11.30.14.110.0 ]--
r 199             StdOut.println(currentLoc == getP)
--[ 2019.11.05.11.30.14.255.0 ]--
r 199             StdOut.println(currentLoc == getPa)
--[ 2019.11.05.11.30.14.332.0 ]--
r 199             StdOut.println(currentLoc == getPat)
--[ 2019.11.05.11.30.14.435.0 ]--
r 199             StdOut.println(currentLoc == getPath)
--[ 2019.11.05.11.30.14.663.0 ]--
r 199             StdOut.println(currentLoc == getPathE)
--[ 2019.11.05.11.30.14.811.0 ]--
r 199             StdOut.println(currentLoc == getPathEn)
--[ 2019.11.05.11.30.14.879.0 ]--
r 199             StdOut.println(currentLoc == getPathEnd)
--[ 2019.11.05.11.30.15.157.0 ]--
r 199             StdOut.println(currentLoc == getPathEnd())
--[ 2019.11.05.11.30.15.954.0 ]--
r 199             StdOut.println(currentLoc == getPathEnd());
--[ 2019.11.05.11.30.20.550.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.11.30.35.831.0 ]--
r 199             StdOut.println(currentLoc. == getPathEnd());
--[ 2019.11.05.11.30.36.383.0 ]--
r 199             StdOut.println(currentLoc.g == getPathEnd());
--[ 2019.11.05.11.30.36.507.0 ]--
r 199             StdOut.println(currentLoc.ge == getPathEnd());
--[ 2019.11.05.11.30.36.671.0 ]--
r 199             StdOut.println(currentLoc.get == getPathEnd());
--[ 2019.11.05.11.30.36.880.0 ]--
r 199             StdOut.println(currentLoc.getI == getPathEnd());
--[ 2019.11.05.11.30.37.192.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd());
--[ 2019.11.05.11.30.39.745.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().);
--[ 2019.11.05.11.30.39.864.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().g);
--[ 2019.11.05.11.30.39.945.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().ge);
--[ 2019.11.05.11.30.40.125.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().get);
--[ 2019.11.05.11.30.40.391.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI);
--[ 2019.11.05.11.30.40.662.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI());
--[ 2019.11.05.11.30.42.504.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() );
--[ 2019.11.05.11.30.42.768.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() &);
--[ 2019.11.05.11.30.42.883.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() &&);
--[ 2019.11.05.11.30.43.024.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && );
--[ 2019.11.05.11.30.43.267.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && c);
--[ 2019.11.05.11.30.43.712.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && cu);
--[ 2019.11.05.11.30.43.829.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && cur);
--[ 2019.11.05.11.30.44.069.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && curr);
--[ 2019.11.05.11.30.44.337.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && curre);
--[ 2019.11.05.11.30.44.592.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && curren);
--[ 2019.11.05.11.30.44.637.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && current);
--[ 2019.11.05.11.30.44.891.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && currentL);
--[ 2019.11.05.11.30.45.038.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && currentLo);
--[ 2019.11.05.11.30.45.125.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && currentLoc);
--[ 2019.11.05.11.30.45.398.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && currentLoc.);
--[ 2019.11.05.11.30.45.522.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && currentLoc.g);
--[ 2019.11.05.11.30.45.587.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && currentLoc.ge);
--[ 2019.11.05.11.30.45.750.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && currentLoc.get);
--[ 2019.11.05.11.30.45.982.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ);
--[ 2019.11.05.11.30.46.384.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ());
--[ 2019.11.05.11.30.46.892.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() );
--[ 2019.11.05.11.30.47.025.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() =);
--[ 2019.11.05.11.30.47.167.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() ==);
--[ 2019.11.05.11.30.47.252.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == );
--[ 2019.11.05.11.30.47.740.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == g);
--[ 2019.11.05.11.30.47.833.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == ge);
--[ 2019.11.05.11.30.47.968.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == get);
--[ 2019.11.05.11.30.48.184.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == getP);
--[ 2019.11.05.11.30.48.348.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == getPa);
--[ 2019.11.05.11.30.48.399.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == getPat);
--[ 2019.11.05.11.30.48.529.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == getPath);
--[ 2019.11.05.11.30.48.755.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == getPathE);
--[ 2019.11.05.11.30.48.866.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == getPathEn);
--[ 2019.11.05.11.30.48.938.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == getPathEnd);
--[ 2019.11.05.11.30.49.065.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == getPathEnd.);
--[ 2019.11.05.11.30.49.151.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == getPathEnd.g);
--[ 2019.11.05.11.30.49.228.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == getPathEnd.ge);
--[ 2019.11.05.11.30.49.399.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == getPathEnd.get);
--[ 2019.11.05.11.30.49.563.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == getPathEnd.getJ);
--[ 2019.11.05.11.30.49.853.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == getPathEnd.getJ());
--[ 2019.11.05.11.30.53.283.0 ]--
r 199             StdOut.println(currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == getPathEnd().getJ());
--[ 2019.11.05.11.30.57.084.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.11.31.17.761.0 ]--
r 200             if (currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == getPathEnd().getJ()) break;
--[ 2019.11.05.11.31.23.250.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.11.31.42.242.0 ]--
+ 19     
--[ 2019.11.05.11.31.43.065.0 ]--
r 19     p
--[ 2019.11.05.11.31.43.168.0 ]--
r 19     pr
--[ 2019.11.05.11.31.43.316.0 ]--
r 19     pri
--[ 2019.11.05.11.31.43.574.0 ]--
r 19     priva
--[ 2019.11.05.11.31.43.686.0 ]--
r 19     privat
--[ 2019.11.05.11.31.43.797.0 ]--
r 19     private
--[ 2019.11.05.11.31.43.884.0 ]--
r 19     private 
--[ 2019.11.05.11.31.44.140.0 ]--
r 19     private P
--[ 2019.11.05.11.31.44.217.0 ]--
r 19     private PF
--[ 2019.11.05.11.31.44.320.0 ]--
r 19     private PFN
--[ 2019.11.05.11.31.44.744.0 ]--
r 19     private PFNo
--[ 2019.11.05.11.31.44.790.0 ]--
r 19     private PFNod
--[ 2019.11.05.11.31.45.016.0 ]--
r 19     private PFNode
--[ 2019.11.05.11.31.45.073.0 ]--
r 19     private PFNode 
--[ 2019.11.05.11.31.47.281.0 ]--
r 19     private PFNode e
--[ 2019.11.05.11.31.47.382.0 ]--
r 19     private PFNode en
--[ 2019.11.05.11.31.47.460.0 ]--
r 19     private PFNode end
--[ 2019.11.05.11.31.47.613.0 ]--
r 19     private PFNode endN
--[ 2019.11.05.11.31.47.792.0 ]--
r 19     private PFNode endNo
--[ 2019.11.05.11.31.47.843.0 ]--
r 19     private PFNode endNod
--[ 2019.11.05.11.31.48.042.0 ]--
r 19     private PFNode endNode
--[ 2019.11.05.11.31.48.102.0 ]--
r 19     private PFNode endNode;
--[ 2019.11.05.11.31.54.394.0 ]--
+ 20     
--[ 2019.11.05.11.31.54.943.0 ]--
r 20     p
--[ 2019.11.05.11.31.55.004.0 ]--
r 20     pr
--[ 2019.11.05.11.31.55.094.0 ]--
r 20     pri
--[ 2019.11.05.11.31.55.270.0 ]--
r 20     priv
--[ 2019.11.05.11.31.55.397.0 ]--
r 20     priva
--[ 2019.11.05.11.31.55.469.0 ]--
r 20     privat
--[ 2019.11.05.11.31.55.568.0 ]--
r 20     private
--[ 2019.11.05.11.31.55.628.0 ]--
r 20     private 
--[ 2019.11.05.11.31.55.793.0 ]--
r 20     private b
--[ 2019.11.05.11.31.55.868.0 ]--
r 20     private bo
--[ 2019.11.05.11.31.56.050.0 ]--
r 20     private boo
--[ 2019.11.05.11.31.56.249.0 ]--
r 20     private bool
--[ 2019.11.05.11.31.56.314.0 ]--
r 20     private boole
--[ 2019.11.05.11.31.56.385.0 ]--
r 20     private boolea
--[ 2019.11.05.11.31.56.481.0 ]--
r 20     private boolean
--[ 2019.11.05.11.31.56.508.0 ]--
r 20     private boolean 
--[ 2019.11.05.11.31.56.686.0 ]--
r 20     private boolean p
--[ 2019.11.05.11.31.56.845.0 ]--
r 20     private boolean pa
--[ 2019.11.05.11.31.56.916.0 ]--
r 20     private boolean pat
--[ 2019.11.05.11.31.56.982.0 ]--
r 20     private boolean path
--[ 2019.11.05.11.31.57.181.0 ]--
r 20     private boolean pathF
--[ 2019.11.05.11.31.57.308.0 ]--
r 20     private boolean pathFo
--[ 2019.11.05.11.31.57.350.0 ]--
r 20     private boolean pathFou
--[ 2019.11.05.11.31.57.550.0 ]--
r 20     private boolean pathFoun
--[ 2019.11.05.11.31.57.603.0 ]--
r 20     private boolean pathFound
--[ 2019.11.05.11.31.57.712.0 ]--
r 20     private boolean pathFound;
--[ 2019.11.05.11.32.16.170.0 ]--
+ 113         
--[ 2019.11.05.11.32.16.738.0 ]--
r 113         p
--[ 2019.11.05.11.32.16.852.0 ]--
r 113         pa
--[ 2019.11.05.11.32.16.938.0 ]--
r 113         pat
--[ 2019.11.05.11.32.16.979.0 ]--
r 113         path
--[ 2019.11.05.11.32.17.193.0 ]--
r 113         pathF
--[ 2019.11.05.11.32.17.315.0 ]--
r 113         pathFo
--[ 2019.11.05.11.32.17.369.0 ]--
r 113         pathFou
--[ 2019.11.05.11.32.17.591.0 ]--
r 113         pathFoun
--[ 2019.11.05.11.32.17.623.0 ]--
r 113         pathFound
--[ 2019.11.05.11.32.17.738.0 ]--
r 113         pathFound 
--[ 2019.11.05.11.32.17.893.0 ]--
r 113         pathFound -=
--[ 2019.11.05.11.32.18.236.0 ]--
r 113         pathFound -= 
--[ 2019.11.05.11.32.18.457.0 ]--
r 113         pathFound -=
--[ 2019.11.05.11.32.18.597.0 ]--
r 113         pathFound -
--[ 2019.11.05.11.32.18.778.0 ]--
r 113         pathFound 
--[ 2019.11.05.11.32.18.960.0 ]--
r 113         pathFound =
--[ 2019.11.05.11.32.19.089.0 ]--
r 113         pathFound = 
--[ 2019.11.05.11.32.19.212.0 ]--
r 113         pathFound = f
--[ 2019.11.05.11.32.19.303.0 ]--
r 113         pathFound = fa
--[ 2019.11.05.11.32.19.374.0 ]--
r 113         pathFound = fal
--[ 2019.11.05.11.32.19.510.0 ]--
r 113         pathFound = fals
--[ 2019.11.05.11.32.19.575.0 ]--
r 113         pathFound = false
--[ 2019.11.05.11.32.19.619.0 ]--
r 113         pathFound = false;
--[ 2019.11.05.11.32.32.629.0 ]--
- 203
--[ 2019.11.05.11.32.32.968.0 ]--
+ 203 
--[ 2019.11.05.11.32.37.211.0 ]--
- 203
--[ 2019.11.05.11.32.38.084.0 ]--
+ 203             if (currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == getPathEnd().getJ()) break;
--[ 2019.11.05.11.32.39.987.0 ]--
- 203
--[ 2019.11.05.11.32.41.788.0 ]--
+ 203             if (currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == getPathEnd().getJ()) break;
--[ 2019.11.05.11.32.43.004.0 ]--
r 203             if (currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == getPathEnd().getJ()) {break;
--[ 2019.11.05.11.32.43.827.0 ]--
+ 203             if (currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == getPathEnd().getJ()) {
+ 204 break;
r 205 }
--[ 2019.11.05.11.32.43.890.0 ]--
r 204                 break;
r 205             }
--[ 2019.11.05.11.32.47.287.0 ]--
+ 204                 
--[ 2019.11.05.11.32.49.774.0 ]--
r 204                 p
--[ 2019.11.05.11.32.49.900.0 ]--
r 204                 pa
--[ 2019.11.05.11.32.49.971.0 ]--
r 204                 pat
--[ 2019.11.05.11.32.50.059.0 ]--
r 204                 path
--[ 2019.11.05.11.32.50.243.0 ]--
r 204                 pathF
--[ 2019.11.05.11.32.50.395.0 ]--
r 204                 pathFo
--[ 2019.11.05.11.32.50.447.0 ]--
r 204                 pathFou
--[ 2019.11.05.11.32.50.674.0 ]--
r 204                 pathFoun
--[ 2019.11.05.11.32.50.764.0 ]--
r 204                 pathFound
--[ 2019.11.05.11.32.50.861.0 ]--
r 204                 pathFound 
--[ 2019.11.05.11.32.50.996.0 ]--
r 204                 pathFound =
--[ 2019.11.05.11.32.51.044.0 ]--
r 204                 pathFound = 
--[ 2019.11.05.11.32.51.435.0 ]--
r 204                 pathFound = f
--[ 2019.11.05.11.32.51.512.0 ]--
r 204                 pathFound = fa
--[ 2019.11.05.11.32.51.674.0 ]--
r 204                 pathFound = fal
--[ 2019.11.05.11.32.51.830.0 ]--
r 204                 pathFound = fals
--[ 2019.11.05.11.32.51.862.0 ]--
r 204                 pathFound = false
--[ 2019.11.05.11.32.51.908.0 ]--
r 204                 pathFound = false;
--[ 2019.11.05.11.32.52.163.0 ]--
+ 205                 
--[ 2019.11.05.11.32.52.754.0 ]--
r 205                 e
--[ 2019.11.05.11.32.52.928.0 ]--
r 205                 en
--[ 2019.11.05.11.32.53.174.0 ]--
r 205                 e
--[ 2019.11.05.11.32.53.449.0 ]--
r 205                 
--[ 2019.11.05.11.32.54.368.0 ]--
r 205                 e
--[ 2019.11.05.11.32.54.444.0 ]--
r 205                 en
--[ 2019.11.05.11.32.54.529.0 ]--
r 205                 end
--[ 2019.11.05.11.32.54.704.0 ]--
r 205                 endN
--[ 2019.11.05.11.32.54.922.0 ]--
r 205                 endNo
--[ 2019.11.05.11.32.55.028.0 ]--
r 205                 endNod
--[ 2019.11.05.11.32.55.239.0 ]--
r 205                 endNode
--[ 2019.11.05.11.32.55.285.0 ]--
r 205                 endNode 
--[ 2019.11.05.11.32.55.374.0 ]--
r 205                 endNode =
--[ 2019.11.05.11.32.55.487.0 ]--
r 205                 endNode = 
--[ 2019.11.05.11.32.55.986.0 ]--
r 205                 endNode = c
--[ 2019.11.05.11.32.56.098.0 ]--
r 205                 endNode = cu
--[ 2019.11.05.11.32.56.259.0 ]--
r 205                 endNode = cur
--[ 2019.11.05.11.32.56.446.0 ]--
r 205                 endNode = curr
--[ 2019.11.05.11.32.56.495.0 ]--
r 205                 endNode = curre
--[ 2019.11.05.11.32.56.599.0 ]--
r 205                 endNode = curren
--[ 2019.11.05.11.32.56.665.0 ]--
r 205                 endNode = current
--[ 2019.11.05.11.32.56.830.0 ]--
r 205                 endNode = currentn
--[ 2019.11.05.11.32.57.226.0 ]--
r 205                 endNode = current
--[ 2019.11.05.11.32.57.426.0 ]--
r 205                 endNode = currentN
--[ 2019.11.05.11.32.57.607.0 ]--
r 205                 endNode = currentNo
--[ 2019.11.05.11.32.57.654.0 ]--
r 205                 endNode = currentNod
--[ 2019.11.05.11.32.57.873.0 ]--
r 205                 endNode = currentNode
--[ 2019.11.05.11.32.57.927.0 ]--
r 205                 endNode = currentNode;
--[ 2019.11.05.11.33.03.520.0 ]--
r 202 
--[ 2019.11.05.11.33.03.761.0 ]--
- 202
--[ 2019.11.05.11.33.05.840.0 ]--
r 201 
--[ 2019.11.05.11.33.06.023.0 ]--
- 201
--[ 2019.11.05.11.33.09.757.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.11.33.16.690.0 ]--
- 242
--[ 2019.11.05.11.33.17.556.0 ]--
r 241     
--[ 2019.11.05.11.33.17.933.0 ]--
r 241         
--[ 2019.11.05.11.33.18.533.0 ]--
r 241         r
--[ 2019.11.05.11.33.18.623.0 ]--
r 241         re
--[ 2019.11.05.11.33.18.806.0 ]--
r 241         ret
--[ 2019.11.05.11.33.18.897.0 ]--
r 241         retu
--[ 2019.11.05.11.33.18.991.0 ]--
r 241         retur
--[ 2019.11.05.11.33.19.078.0 ]--
r 241         return
--[ 2019.11.05.11.33.19.165.0 ]--
r 241         return 
--[ 2019.11.05.11.33.19.317.0 ]--
r 241         return p
--[ 2019.11.05.11.33.19.492.0 ]--
r 241         return pa
--[ 2019.11.05.11.33.19.531.0 ]--
r 241         return pat
--[ 2019.11.05.11.33.19.595.0 ]--
r 241         return path
--[ 2019.11.05.11.33.19.834.0 ]--
r 241         return pathF
--[ 2019.11.05.11.33.19.931.0 ]--
r 241         return pathFo
--[ 2019.11.05.11.33.19.974.0 ]--
r 241         return pathFou
--[ 2019.11.05.11.33.20.214.0 ]--
r 241         return pathFoun
--[ 2019.11.05.11.33.20.244.0 ]--
r 241         return pathFound
--[ 2019.11.05.11.33.20.348.0 ]--
r 241         return pathFound;
--[ 2019.11.05.11.33.26.700.0 ]--
+ 253         
--[ 2019.11.05.11.33.28.346.0 ]--
r 253         S
--[ 2019.11.05.11.33.28.564.0 ]--
r 253         St
--[ 2019.11.05.11.33.28.742.0 ]--
r 253         Sta
--[ 2019.11.05.11.33.28.988.0 ]--
r 253         Stac
--[ 2019.11.05.11.33.29.171.0 ]--
r 253         Stack
--[ 2019.11.05.11.33.29.425.0 ]--
r 253         Stack<>
--[ 2019.11.05.11.33.29.769.0 ]--
r 253         Stack<C>
--[ 2019.11.05.11.33.29.925.0 ]--
r 253         Stack<Co>
--[ 2019.11.05.11.33.30.197.0 ]--
r 253         Stack<Coor>
--[ 2019.11.05.11.33.30.346.0 ]--
r 253         Stack<Coord>
--[ 2019.11.05.11.33.30.902.0 ]--
r 253         Stack<Coord> 
--[ 2019.11.05.11.33.31.057.0 ]--
r 253         Stack<Coord> s
--[ 2019.11.05.11.33.31.164.0 ]--
r 253         Stack<Coord> s 
--[ 2019.11.05.11.33.31.316.0 ]--
r 253         Stack<Coord> s =
--[ 2019.11.05.11.33.31.384.0 ]--
r 253         Stack<Coord> s = 
--[ 2019.11.05.11.33.32.032.0 ]--
r 253         Stack<Coord> s = n
--[ 2019.11.05.11.33.32.097.0 ]--
r 253         Stack<Coord> s = ne
--[ 2019.11.05.11.33.32.184.0 ]--
r 253         Stack<Coord> s = new
--[ 2019.11.05.11.33.32.269.0 ]--
r 253         Stack<Coord> s = new 
--[ 2019.11.05.11.33.32.534.0 ]--
r 253         Stack<Coord> s = new S
--[ 2019.11.05.11.33.32.757.0 ]--
r 253         Stack<Coord> s = new St
--[ 2019.11.05.11.33.32.806.0 ]--
r 253         Stack<Coord> s = new Sta
--[ 2019.11.05.11.33.32.982.0 ]--
r 253         Stack<Coord> s = new Stac
--[ 2019.11.05.11.33.33.125.0 ]--
r 253         Stack<Coord> s = new Stack
--[ 2019.11.05.11.33.36.039.0 ]--
r 253         Stack<Coord> s = new Stack()
--[ 2019.11.05.11.33.36.665.0 ]--
r 253         Stack<Coord> s = new Stack();
--[ 2019.11.05.11.33.39.976.0 ]--
r 253         Stack<Coord> s = new Stack<>();
--[ 2019.11.05.11.33.42.603.0 ]--
+ 254         
--[ 2019.11.05.11.33.47.129.0 ]--
r 254         P
--[ 2019.11.05.11.33.47.229.0 ]--
r 254         PF
--[ 2019.11.05.11.33.47.367.0 ]--
r 254         PFN
--[ 2019.11.05.11.33.47.899.0 ]--
r 254         PFNo
--[ 2019.11.05.11.33.47.979.0 ]--
r 254         PFNod
--[ 2019.11.05.11.33.48.191.0 ]--
r 254         PFNode
--[ 2019.11.05.11.33.48.248.0 ]--
r 254         PFNode 
--[ 2019.11.05.11.33.49.130.0 ]--
r 254         PFNode c
--[ 2019.11.05.11.33.49.223.0 ]--
r 254         PFNode c 
--[ 2019.11.05.11.33.49.385.0 ]--
r 254         PFNode c =
--[ 2019.11.05.11.33.49.436.0 ]--
r 254         PFNode c = 
--[ 2019.11.05.11.33.51.392.0 ]--
r 254         PFNode c = e
--[ 2019.11.05.11.33.51.590.0 ]--
r 254         PFNode c = end
--[ 2019.11.05.11.33.51.776.0 ]--
r 254         PFNode c = endN
--[ 2019.11.05.11.33.51.954.0 ]--
r 254         PFNode c = endNo
--[ 2019.11.05.11.33.52.018.0 ]--
r 254         PFNode c = endNod
--[ 2019.11.05.11.33.52.218.0 ]--
r 254         PFNode c = endNode
--[ 2019.11.05.11.33.52.260.0 ]--
r 254         PFNode c = endNode;
--[ 2019.11.05.11.33.52.474.0 ]--
+ 255         
--[ 2019.11.05.11.33.53.073.0 ]--
r 255         w
--[ 2019.11.05.11.33.53.193.0 ]--
r 255         wh
--[ 2019.11.05.11.33.53.270.0 ]--
r 255         whi
--[ 2019.11.05.11.33.53.467.0 ]--
r 255         whil
--[ 2019.11.05.11.33.53.528.0 ]--
r 255         while
--[ 2019.11.05.11.33.53.641.0 ]--
r 255         while 
--[ 2019.11.05.11.33.53.718.0 ]--
r 255         while ()
--[ 2019.11.05.11.33.54.764.0 ]--
r 255         while (t)
--[ 2019.11.05.11.33.55.018.0 ]--
r 255         while (tr)
--[ 2019.11.05.11.33.55.058.0 ]--
r 255         while (tru)
--[ 2019.11.05.11.33.55.139.0 ]--
r 255         while (true)
--[ 2019.11.05.11.33.55.993.0 ]--
r 255         while (true) 
--[ 2019.11.05.11.33.56.118.0 ]--
r 255         while (true) {
--[ 2019.11.05.11.33.56.283.0 ]--
+ 256 
+ 257 }
--[ 2019.11.05.11.33.56.311.0 ]--
r 257         }
--[ 2019.11.05.11.33.56.333.0 ]--
r 256             
--[ 2019.11.05.11.33.58.616.0 ]--
r 255         while (rue) {
--[ 2019.11.05.11.33.58.786.0 ]--
r 255         while (ue) {
--[ 2019.11.05.11.33.58.953.0 ]--
r 255         while (e) {
--[ 2019.11.05.11.33.59.121.0 ]--
r 255         while () {
--[ 2019.11.05.11.33.59.428.0 ]--
r 255         while (c) {
--[ 2019.11.05.11.33.59.594.0 ]--
r 255         while (c ) {
--[ 2019.11.05.11.33.59.904.0 ]--
r 255         while (c !) {
--[ 2019.11.05.11.34.00.198.0 ]--
r 255         while (c !=) {
--[ 2019.11.05.11.34.00.321.0 ]--
r 255         while (c != ) {
--[ 2019.11.05.11.34.00.581.0 ]--
r 255         while (c != n) {
--[ 2019.11.05.11.34.00.855.0 ]--
r 255         while (c != nu) {
--[ 2019.11.05.11.34.01.031.0 ]--
r 255         while (c != nul) {
--[ 2019.11.05.11.34.01.195.0 ]--
r 255         while (c != null) {
--[ 2019.11.05.11.34.03.624.0 ]--
r 256             s
--[ 2019.11.05.11.34.03.874.0 ]--
r 256             s.
--[ 2019.11.05.11.34.03.979.0 ]--
r 256             s.p
--[ 2019.11.05.11.34.04.041.0 ]--
r 256             s.pu
--[ 2019.11.05.11.34.04.197.0 ]--
r 256             s.pus
--[ 2019.11.05.11.34.04.257.0 ]--
r 256             s.push
--[ 2019.11.05.11.34.04.431.0 ]--
r 256             s.push()
--[ 2019.11.05.11.34.10.545.0 ]--
r 256             s.push(c)
--[ 2019.11.05.11.34.10.626.0 ]--
r 256             s.push(c.)
--[ 2019.11.05.11.34.11.183.0 ]--
r 256             s.push(c.g)
--[ 2019.11.05.11.34.11.235.0 ]--
r 256             s.push(c.ge)
--[ 2019.11.05.11.34.11.391.0 ]--
r 256             s.push(c.get)
--[ 2019.11.05.11.34.11.948.0 ]--
r 256             s.push(c.getL)
--[ 2019.11.05.11.34.12.103.0 ]--
r 256             s.push(c.getLo)
--[ 2019.11.05.11.34.12.153.0 ]--
r 256             s.push(c.getLoc)
--[ 2019.11.05.11.34.12.396.0 ]--
r 256             s.push(c.getLoc())
--[ 2019.11.05.11.34.12.926.0 ]--
r 256             s.push(c.getLoc());
--[ 2019.11.05.11.34.14.909.0 ]--
+ 257             
--[ 2019.11.05.11.34.16.604.0 ]--
r 257             c
--[ 2019.11.05.11.34.16.726.0 ]--
r 257             c 
--[ 2019.11.05.11.34.16.867.0 ]--
r 257             c =
--[ 2019.11.05.11.34.16.949.0 ]--
r 257             c = 
--[ 2019.11.05.11.34.17.439.0 ]--
r 257             c = c
--[ 2019.11.05.11.34.17.816.0 ]--
r 257             c = c.
--[ 2019.11.05.11.34.18.521.0 ]--
r 257             c = c.f
--[ 2019.11.05.11.34.18.732.0 ]--
r 257             c = c.fr
--[ 2019.11.05.11.34.18.794.0 ]--
r 257             c = c.fro
--[ 2019.11.05.11.34.18.856.0 ]--
r 257             c = c.from
--[ 2019.11.05.11.34.19.074.0 ]--
r 257             c = c.fromN
--[ 2019.11.05.11.34.19.232.0 ]--
r 257             c = c.fromNo
--[ 2019.11.05.11.34.19.317.0 ]--
r 257             c = c.fromNod
--[ 2019.11.05.11.34.19.532.0 ]--
r 257             c = c.fromNode
--[ 2019.11.05.11.34.19.571.0 ]--
r 257             c = c.fromNode;
--[ 2019.11.05.11.34.23.908.0 ]--
r 259         return s;
--[ 2019.11.05.11.34.29.002.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.11.36.59.726.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.11.37.19.758.0 ]--
- 55
r 55 
--[ 2019.11.05.11.37.20.002.0 ]--
- 55
--[ 2019.11.05.11.37.27.253.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.11.37.48.412.0 ]--
r 55             if (b == null) return 0.;
--[ 2019.11.05.11.37.48.703.0 ]--
r 55             if (b == null) return 0.0;
--[ 2019.11.05.11.37.48.831.0 ]--
r 55             if (b == null) return 0.0f;
--[ 2019.11.05.11.40.13.595.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.11.40.34.327.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.11.41.01.501.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.11.42.09.577.0 ]--
+ 52         
--[ 2019.11.05.11.42.09.781.0 ]--
+ 52         
--[ 2019.11.05.11.42.10.753.0 ]--
r 53         p
--[ 2019.11.05.11.42.10.828.0 ]--
r 53         pu
--[ 2019.11.05.11.42.10.938.0 ]--
r 53         pub
--[ 2019.11.05.11.42.11.059.0 ]--
r 53         publ
--[ 2019.11.05.11.42.11.146.0 ]--
r 53         publi
--[ 2019.11.05.11.42.11.266.0 ]--
r 53         public
--[ 2019.11.05.11.42.11.502.0 ]--
r 53         public 
--[ 2019.11.05.11.42.11.789.0 ]--
r 53         public f
--[ 2019.11.05.11.42.11.897.0 ]--
r 53         public fl
--[ 2019.11.05.11.42.12.033.0 ]--
r 53         public flo
--[ 2019.11.05.11.42.12.161.0 ]--
r 53         public floa
--[ 2019.11.05.11.42.12.189.0 ]--
r 53         public float
--[ 2019.11.05.11.42.12.360.0 ]--
r 53         public float 
--[ 2019.11.05.11.42.12.508.0 ]--
r 53         public float c
--[ 2019.11.05.11.42.12.606.0 ]--
r 53         public float co
--[ 2019.11.05.11.42.12.697.0 ]--
r 53         public float com
--[ 2019.11.05.11.42.12.822.0 ]--
r 53         public float comp
--[ 2019.11.05.11.42.12.990.0 ]--
r 53         public float compu
--[ 2019.11.05.11.42.13.035.0 ]--
r 53         public float comput
--[ 2019.11.05.11.42.13.141.0 ]--
r 53         public float compute
--[ 2019.11.05.11.42.13.415.0 ]--
r 53         public float computeC
--[ 2019.11.05.11.42.13.613.0 ]--
r 53         public float computeCo
--[ 2019.11.05.11.42.13.707.0 ]--
r 53         public float computeCos
--[ 2019.11.05.11.42.13.804.0 ]--
r 53         public float computeCost
--[ 2019.11.05.11.42.14.444.0 ]--
r 53         public float computeCos
--[ 2019.11.05.11.42.14.944.0 ]--
r 53         public float computeCo
--[ 2019.11.05.11.42.14.976.0 ]--
r 53         public float computeC
--[ 2019.11.05.11.42.15.009.0 ]--
r 53         public float compute
--[ 2019.11.05.11.42.15.042.0 ]--
r 53         public float comput
--[ 2019.11.05.11.42.15.075.0 ]--
r 53         public float compu
--[ 2019.11.05.11.42.15.109.0 ]--
r 53         public float comp
--[ 2019.11.05.11.42.15.141.0 ]--
r 53         public float com
--[ 2019.11.05.11.42.15.174.0 ]--
r 53         public float co
--[ 2019.11.05.11.42.15.207.0 ]--
r 53         public float c
--[ 2019.11.05.11.42.15.240.0 ]--
r 53         public float 
--[ 2019.11.05.11.42.15.283.0 ]--
r 53         public float
--[ 2019.11.05.11.42.15.305.0 ]--
r 53         public floa
--[ 2019.11.05.11.42.15.342.0 ]--
r 53         public flo
--[ 2019.11.05.11.42.15.371.0 ]--
r 53         public fl
--[ 2019.11.05.11.42.15.403.0 ]--
r 53         public f
--[ 2019.11.05.11.42.15.444.0 ]--
r 53         public 
--[ 2019.11.05.11.42.15.482.0 ]--
r 53         public
--[ 2019.11.05.11.42.15.509.0 ]--
r 53         publi
--[ 2019.11.05.11.42.15.558.0 ]--
r 53         publ
--[ 2019.11.05.11.42.15.578.0 ]--
r 53         pub
--[ 2019.11.05.11.42.15.603.0 ]--
r 53         pu
--[ 2019.11.05.11.42.15.771.0 ]--
r 53         p
--[ 2019.11.05.11.42.16.274.0 ]--
r 53         
--[ 2019.11.05.11.42.16.553.0 ]--
r 53         p
--[ 2019.11.05.11.42.16.640.0 ]--
r 53         pr
--[ 2019.11.05.11.42.16.759.0 ]--
r 53         pri
--[ 2019.11.05.11.42.16.854.0 ]--
r 53         priv
--[ 2019.11.05.11.42.16.991.0 ]--
r 53         priva
--[ 2019.11.05.11.42.17.099.0 ]--
r 53         privat
--[ 2019.11.05.11.42.17.190.0 ]--
r 53         private
--[ 2019.11.05.11.42.17.243.0 ]--
r 53         private 
--[ 2019.11.05.11.42.17.386.0 ]--
r 53         private f
--[ 2019.11.05.11.42.17.476.0 ]--
r 53         private fl
--[ 2019.11.05.11.42.17.630.0 ]--
r 53         private flo
--[ 2019.11.05.11.42.17.718.0 ]--
r 53         private floa
--[ 2019.11.05.11.42.17.789.0 ]--
r 53         private float
--[ 2019.11.05.11.42.17.916.0 ]--
r 53         private float 
--[ 2019.11.05.11.42.18.026.0 ]--
r 53         private float c
--[ 2019.11.05.11.42.18.080.0 ]--
r 53         private float co
--[ 2019.11.05.11.42.18.143.0 ]--
r 53         private float com
--[ 2019.11.05.11.42.18.290.0 ]--
r 53         private float comp
--[ 2019.11.05.11.42.18.395.0 ]--
r 53         private float compu
--[ 2019.11.05.11.42.18.483.0 ]--
r 53         private float comput
--[ 2019.11.05.11.42.18.582.0 ]--
r 53         private float compute
--[ 2019.11.05.11.42.18.795.0 ]--
r 53         private float computeC
--[ 2019.11.05.11.42.18.955.0 ]--
r 53         private float computeCo
--[ 2019.11.05.11.42.19.059.0 ]--
r 53         private float computeCos
--[ 2019.11.05.11.42.19.139.0 ]--
r 53         private float computeCost
--[ 2019.11.05.11.42.19.385.0 ]--
r 53         private float computeCost()
--[ 2019.11.05.11.42.20.384.0 ]--
r 53         private float computeCost(f)
--[ 2019.11.05.11.42.20.682.0 ]--
r 53         private float computeCost(flo)
--[ 2019.11.05.11.42.20.712.0 ]--
r 53         private float computeCost(floa)
--[ 2019.11.05.11.42.20.758.0 ]--
r 53         private float computeCost(float)
--[ 2019.11.05.11.42.20.862.0 ]--
r 53         private float computeCost(float )
--[ 2019.11.05.11.42.20.987.0 ]--
r 53         private float computeCost(float h)
--[ 2019.11.05.11.42.21.836.0 ]--
r 53         private float computeCost(float he)
--[ 2019.11.05.11.42.21.925.0 ]--
r 53         private float computeCost(float heu)
--[ 2019.11.05.11.42.22.048.0 ]--
r 53         private float computeCost(float heur)
--[ 2019.11.05.11.42.22.124.0 ]--
r 53         private float computeCost(float heuri)
--[ 2019.11.05.11.42.22.234.0 ]--
r 53         private float computeCost(float heuris)
--[ 2019.11.05.11.42.22.299.0 ]--
r 53         private float computeCost(float heurist)
--[ 2019.11.05.11.42.22.375.0 ]--
r 53         private float computeCost(float heuristi)
--[ 2019.11.05.11.42.22.499.0 ]--
r 53         private float computeCost(float heuristic)
--[ 2019.11.05.11.42.22.987.0 ]--
r 53         private float computeCost(float heuristic) 
--[ 2019.11.05.11.42.23.165.0 ]--
r 53         private float computeCost(float heuristic) {}
--[ 2019.11.05.11.42.23.327.0 ]--
+ 53         private float computeCost(float heuristic) {
r 54         }
--[ 2019.11.05.11.42.23.372.0 ]--
+ 54             
--[ 2019.11.05.11.42.24.992.0 ]--
r 54             P
--[ 2019.11.05.11.42.25.201.0 ]--
r 54             PF
--[ 2019.11.05.11.42.25.326.0 ]--
r 54             PFN
--[ 2019.11.05.11.42.25.629.0 ]--
r 54             PFNo
--[ 2019.11.05.11.42.25.695.0 ]--
r 54             PFNod
--[ 2019.11.05.11.42.25.925.0 ]--
r 54             PFNode
--[ 2019.11.05.11.42.25.983.0 ]--
r 54             PFNode 
--[ 2019.11.05.11.42.26.146.0 ]--
r 54             PFNode b
--[ 2019.11.05.11.42.26.299.0 ]--
r 54             PFNode b 
--[ 2019.11.05.11.42.26.429.0 ]--
r 54             PFNode b =
--[ 2019.11.05.11.42.26.532.0 ]--
r 54             PFNode b = 
--[ 2019.11.05.11.42.26.660.0 ]--
r 54             PFNode b = f
--[ 2019.11.05.11.42.26.846.0 ]--
r 54             PFNode b = fr
--[ 2019.11.05.11.42.26.908.0 ]--
r 54             PFNode b = fro
--[ 2019.11.05.11.42.26.957.0 ]--
r 54             PFNode b = from
--[ 2019.11.05.11.42.27.213.0 ]--
r 54             PFNode b = fro
--[ 2019.11.05.11.42.27.714.0 ]--
r 54             PFNode b = fr
--[ 2019.11.05.11.42.27.740.0 ]--
r 54             PFNode b = f
--[ 2019.11.05.11.42.27.774.0 ]--
r 54             PFNode b = 
--[ 2019.11.05.11.42.27.804.0 ]--
r 54             PFNode b =
--[ 2019.11.05.11.42.27.842.0 ]--
r 54             PFNode b 
--[ 2019.11.05.11.42.27.875.0 ]--
r 54             PFNode b
--[ 2019.11.05.11.42.27.909.0 ]--
r 54             PFNode 
--[ 2019.11.05.11.42.27.943.0 ]--
r 54             PFNode
--[ 2019.11.05.11.42.27.969.0 ]--
r 54             PFNod
--[ 2019.11.05.11.42.28.002.0 ]--
r 54             PFNo
--[ 2019.11.05.11.42.28.147.0 ]--
r 54             PFN
--[ 2019.11.05.11.42.28.338.0 ]--
r 54             PF
--[ 2019.11.05.11.42.28.499.0 ]--
r 54             P
--[ 2019.11.05.11.42.28.680.0 ]--
r 54             
--[ 2019.11.05.11.42.33.490.0 ]--
+ 54             PFNode b = fromNode;
+ 55             if (b == null) return 0.0f;
+ 56             else {
+ 57                 StdOut.println("getting cost: " + board[b.getLoc().getI()][b.getLoc().getJ()]);
+ 58                 StdOut.println("computed from b: " + terrain.computeTravelCost(b.getLoc(), loc));
+ 59                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), loc);
r 60             }
--[ 2019.11.05.11.42.37.717.0 ]--
r 53         private v computeCost(float heuristic) {
--[ 2019.11.05.11.42.37.854.0 ]--
r 53         private vo computeCost(float heuristic) {
--[ 2019.11.05.11.42.37.925.0 ]--
r 53         private voi computeCost(float heuristic) {
--[ 2019.11.05.11.42.38.038.0 ]--
r 53         private void computeCost(float heuristic) {
--[ 2019.11.05.11.42.40.616.0 ]--
r 55             if (b == null) return ;
--[ 2019.11.05.11.42.41.079.0 ]--
r 55             if (b == null) return;
--[ 2019.11.05.11.42.41.112.0 ]--
r 55             if (b == null) retur;
--[ 2019.11.05.11.42.41.153.0 ]--
r 55             if (b == null) retu;
--[ 2019.11.05.11.42.41.177.0 ]--
r 55             if (b == null) ret;
--[ 2019.11.05.11.42.41.284.0 ]--
r 55             if (b == null) re;
--[ 2019.11.05.11.42.41.461.0 ]--
r 55             if (b == null) r;
--[ 2019.11.05.11.42.41.980.0 ]--
r 55             if (b == null) ;
--[ 2019.11.05.11.42.42.649.0 ]--
r 55             if (b == null) t;
--[ 2019.11.05.11.42.42.717.0 ]--
r 55             if (b == null) th;
--[ 2019.11.05.11.42.42.765.0 ]--
r 55             if (b == null) thi;
--[ 2019.11.05.11.42.42.864.0 ]--
r 55             if (b == null) this;
--[ 2019.11.05.11.42.42.984.0 ]--
r 55             if (b == null) this.;
--[ 2019.11.05.11.42.43.098.0 ]--
r 55             if (b == null) this.c;
--[ 2019.11.05.11.42.43.200.0 ]--
r 55             if (b == null) this.co;
--[ 2019.11.05.11.42.43.319.0 ]--
r 55             if (b == null) this.cos;
--[ 2019.11.05.11.42.43.406.0 ]--
r 55             if (b == null) this.cost;
--[ 2019.11.05.11.42.43.471.0 ]--
r 55             if (b == null) this.cost ;
--[ 2019.11.05.11.42.43.586.0 ]--
r 55             if (b == null) this.cost =;
--[ 2019.11.05.11.42.43.857.0 ]--
r 55             if (b == null) this.cost = 0;
--[ 2019.11.05.11.42.44.061.0 ]--
r 55             if (b == null) this.cost = 0.;
--[ 2019.11.05.11.42.44.266.0 ]--
r 55             if (b == null) this.cost = 0.0;
--[ 2019.11.05.11.42.44.354.0 ]--
r 55             if (b == null) this.cost = 0.0f;
--[ 2019.11.05.11.42.47.273.0 ]--
r 59                 t board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.05.11.42.47.371.0 ]--
r 59                 th board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.05.11.42.47.430.0 ]--
r 59                 thi board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.05.11.42.47.514.0 ]--
r 59                 this board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.05.11.42.47.642.0 ]--
r 59                 this. board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.05.11.42.48.251.0 ]--
r 59                 this.c board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.05.11.42.48.288.0 ]--
r 59                 this.co board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.05.11.42.48.478.0 ]--
r 59                 this.cos board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.05.11.42.48.551.0 ]--
r 59                 this.cost board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.05.11.42.48.627.0 ]--
r 59                 this.cost  board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.05.11.42.48.701.0 ]--
r 59                 this.cost = board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.05.11.42.48.840.0 ]--
r 59                 this.cost =  board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.05.11.42.52.206.0 ]--
r 59                 this.cost = board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.05.11.42.57.737.0 ]--
- 64
- 64
- 64
- 64
- 64
- 64
r 64             r
--[ 2019.11.05.11.42.57.956.0 ]--
r 64             re
--[ 2019.11.05.11.42.57.975.0 ]--
r 64             ret
--[ 2019.11.05.11.42.58.043.0 ]--
r 64             retu
--[ 2019.11.05.11.42.58.182.0 ]--
r 64             retur
--[ 2019.11.05.11.42.58.245.0 ]--
r 64             return
--[ 2019.11.05.11.42.58.313.0 ]--
r 64             return 
--[ 2019.11.05.11.42.58.445.0 ]--
r 64             return t
--[ 2019.11.05.11.42.58.545.0 ]--
r 64             return th
--[ 2019.11.05.11.42.58.614.0 ]--
r 64             return thi
--[ 2019.11.05.11.42.58.668.0 ]--
r 64             return this
--[ 2019.11.05.11.42.58.930.0 ]--
r 64             return this.
--[ 2019.11.05.11.42.58.994.0 ]--
r 64             return this.c
--[ 2019.11.05.11.42.59.133.0 ]--
r 64             return this.co
--[ 2019.11.05.11.42.59.223.0 ]--
r 64             return this.cos
--[ 2019.11.05.11.42.59.310.0 ]--
r 64             return this.cost
--[ 2019.11.05.11.42.59.408.0 ]--
r 64             return this.cost;
--[ 2019.11.05.11.43.05.327.0 ]--
+ 36             
--[ 2019.11.05.11.43.05.855.0 ]--
r 36             c
--[ 2019.11.05.11.43.05.942.0 ]--
r 36             co
--[ 2019.11.05.11.43.06.005.0 ]--
r 36             com
--[ 2019.11.05.11.43.06.205.0 ]--
r 36             comp
--[ 2019.11.05.11.43.06.301.0 ]--
r 36             compu
--[ 2019.11.05.11.43.06.380.0 ]--
r 36             comput
--[ 2019.11.05.11.43.06.524.0 ]--
r 36             compute
--[ 2019.11.05.11.43.06.772.0 ]--
r 36             computeC
--[ 2019.11.05.11.43.07.026.0 ]--
r 36             computeCo
--[ 2019.11.05.11.43.07.170.0 ]--
r 36             computeCos
--[ 2019.11.05.11.43.07.247.0 ]--
r 36             computeCost
--[ 2019.11.05.11.43.07.484.0 ]--
r 36             computeCost()
--[ 2019.11.05.11.43.07.969.0 ]--
r 36             computeCost(h)
--[ 2019.11.05.11.43.08.399.0 ]--
r 36             computeCost(h);l
--[ 2019.11.05.11.43.09.328.0 ]--
r 36             computeCost(h);
--[ 2019.11.05.11.43.17.617.0 ]--
r 53 
--[ 2019.11.05.11.43.19.036.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.11.43.41.596.0 ]--
r 36             computeCost(h);l
r 53         
--[ 2019.11.05.11.43.41.853.0 ]--
r 36             
--[ 2019.11.05.11.43.42.128.0 ]--
- 36
--[ 2019.11.05.11.43.42.717.0 ]--
+ 64             PFNode b = fromNode;
+ 65             if (b == null) return 0.0f;
+ 66             else {
+ 67                 StdOut.println("getting cost: " + board[b.getLoc().getI()][b.getLoc().getJ()]);
+ 68                 StdOut.println("computed from b: " + terrain.computeTravelCost(b.getLoc(), loc));
+ 69                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), loc);
r 70             }
--[ 2019.11.05.11.43.43.669.0 ]--
r 59                 this.cost =  board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.05.11.43.44.057.0 ]--
r 59                 return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.05.11.43.45.742.0 ]--
r 55             if (b == null) ;
--[ 2019.11.05.11.43.46.274.0 ]--
r 55             if (b == null) return 0.0f;
--[ 2019.11.05.11.43.47.605.0 ]--
r 53         private float computeCost(float heuristic) {
--[ 2019.11.05.11.43.48.290.0 ]--
- 54
- 54
- 54
- 54
- 54
- 54
r 54             
--[ 2019.11.05.11.43.48.949.0 ]--
r 54             PFNode b = from
--[ 2019.11.05.11.43.49.274.0 ]--
r 54             
--[ 2019.11.05.11.43.49.594.0 ]--
- 53
- 53
r 53         private float computeCost(float heuristic) {}
--[ 2019.11.05.11.43.49.926.0 ]--
r 53         
--[ 2019.11.05.11.43.50.706.0 ]--
r 53         public float computeCost
--[ 2019.11.05.11.43.51.503.0 ]--
r 53         
--[ 2019.11.05.11.43.52.004.0 ]--
- 52
--[ 2019.11.05.11.43.52.721.0 ]--
- 52
--[ 2019.11.05.11.43.56.367.0 ]--
r 57                 /StdOut.println("getting cost: " + board[b.getLoc().getI()][b.getLoc().getJ()]);
--[ 2019.11.05.11.43.56.548.0 ]--
r 57                 //StdOut.println("getting cost: " + board[b.getLoc().getI()][b.getLoc().getJ()]);
--[ 2019.11.05.11.43.57.468.0 ]--
r 58                 /StdOut.println("computed from b: " + terrain.computeTravelCost(b.getLoc(), loc));
--[ 2019.11.05.11.43.57.613.0 ]--
r 58                 //StdOut.println("computed from b: " + terrain.computeTravelCost(b.getLoc(), loc));
--[ 2019.11.05.11.44.00.659.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.11.44.22.359.0 ]--
r 207                     StdOut.println("inserting " + c.getLoc() );
--[ 2019.11.05.11.44.22.630.0 ]--
r 207                     StdOut.println("inserting " + c.getLoc() +);
--[ 2019.11.05.11.44.22.697.0 ]--
r 207                     StdOut.println("inserting " + c.getLoc() + );
--[ 2019.11.05.11.44.23.859.0 ]--
r 207                     StdOut.println("inserting " + c.getLoc() + '');
--[ 2019.11.05.11.44.24.085.0 ]--
r 207                     StdOut.println("inserting " + c.getLoc() + ' ');
--[ 2019.11.05.11.44.24.526.0 ]--
r 207                     StdOut.println("inserting " + c.getLoc() + ' ' );
--[ 2019.11.05.11.44.24.703.0 ]--
r 207                     StdOut.println("inserting " + c.getLoc() + ' ' +);
--[ 2019.11.05.11.44.24.785.0 ]--
r 207                     StdOut.println("inserting " + c.getLoc() + ' ' + );
--[ 2019.11.05.11.44.25.163.0 ]--
r 207                     StdOut.println("inserting " + c.getLoc() + ' ' + c);
--[ 2019.11.05.11.44.25.264.0 ]--
r 207                     StdOut.println("inserting " + c.getLoc() + ' ' + c.);
--[ 2019.11.05.11.44.25.813.0 ]--
r 207                     StdOut.println("inserting " + c.getLoc() + ' ' + c.g);
--[ 2019.11.05.11.44.25.901.0 ]--
r 207                     StdOut.println("inserting " + c.getLoc() + ' ' + c.ge);
--[ 2019.11.05.11.44.26.081.0 ]--
r 207                     StdOut.println("inserting " + c.getLoc() + ' ' + c.get);
--[ 2019.11.05.11.44.26.365.0 ]--
r 207                     StdOut.println("inserting " + c.getLoc() + ' ' + c.getC);
--[ 2019.11.05.11.44.26.621.0 ]--
r 207                     StdOut.println("inserting " + c.getLoc() + ' ' + c.getCo);
--[ 2019.11.05.11.44.26.803.0 ]--
r 207                     StdOut.println("inserting " + c.getLoc() + ' ' + c.getCos);
--[ 2019.11.05.11.44.26.834.0 ]--
r 207                     StdOut.println("inserting " + c.getLoc() + ' ' + c.getCost);
--[ 2019.11.05.11.44.27.078.0 ]--
r 207                     StdOut.println("inserting " + c.getLoc() + ' ' + c.getCost());
--[ 2019.11.05.11.44.27.292.0 ]--
r 207                     StdOut.println("inserting " + c.getLoc() + ' ' + c.getCost(h));
--[ 2019.11.05.11.44.32.272.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.11.45.17.127.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + """ cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.17.246.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "f"" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.17.437.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "fr"" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.17.524.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "fro"" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.17.589.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from"" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.17.797.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from:"" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.18.004.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: "" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.18.526.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.18.773.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.20.640.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + c" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.20.755.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + cu" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.21.066.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + cur" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.21.322.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + curr" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.21.450.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + curre" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.21.587.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + curren" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.21.657.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + current" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.21.833.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + currentN" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.22.009.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + currentNo" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.22.098.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + currentNod" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.22.440.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + currentNod.e" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.23.019.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + currentNod." cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.23.197.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + currentNod" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.23.384.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + currentNode" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.23.531.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + currentNode." cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.28.338.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + currentNode.f" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.28.580.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + currentNode.fr" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.28.832.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + currentNode.from" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.29.181.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + currentNode.fromN" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.29.362.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + currentNode.fromNo" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.29.442.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + currentNode.fromNod" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.29.644.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + currentNode.fromNode" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.29.741.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + currentNode.fromNode." cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.29.897.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + currentNode.fromNode.g" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.29.940.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + currentNode.fromNode.ge" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.30.153.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + currentNode.fromNode.get" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.30.335.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + currentNode.fromNode.getL" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.30.536.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + currentNode.fromNode.getLo" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.30.602.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + currentNode.fromNode.getLoc" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.30.877.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + currentNode.fromNode.getLoc(" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.30.955.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + currentNode.fromNode.getLoc()" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.31.452.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + currentNode.fromNode.getLoc() " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.35.058.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + currentNode.fromNode.getLoc() +" cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.35.100.0 ]--
r 198             StdOut.println("current loc: " + currentLoc + "from: " + currentNode.fromNode.getLoc() + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.37.872.0 ]--
+ 198             
--[ 2019.11.05.11.45.38.171.0 ]--
r 198             i
--[ 2019.11.05.11.45.38.286.0 ]--
r 198             if
--[ 2019.11.05.11.45.38.366.0 ]--
r 198             if 
--[ 2019.11.05.11.45.38.604.0 ]--
r 198             if ()
--[ 2019.11.05.11.45.40.970.0 ]--
r 198             if (c)
--[ 2019.11.05.11.45.41.077.0 ]--
r 198             if (cu)
--[ 2019.11.05.11.45.41.290.0 ]--
r 198             if (cur)
--[ 2019.11.05.11.45.41.467.0 ]--
r 198             if (curr)
--[ 2019.11.05.11.45.41.524.0 ]--
r 198             if (curre)
--[ 2019.11.05.11.45.41.704.0 ]--
r 198             if (curren)
--[ 2019.11.05.11.45.41.808.0 ]--
r 198             if (current)
--[ 2019.11.05.11.45.41.984.0 ]--
r 198             if (currentN)
--[ 2019.11.05.11.45.42.189.0 ]--
r 198             if (currentNo)
--[ 2019.11.05.11.45.42.334.0 ]--
r 198             if (currentNod)
--[ 2019.11.05.11.45.42.525.0 ]--
r 198             if (currentNode)
--[ 2019.11.05.11.45.42.625.0 ]--
r 198             if (currentNode.)
--[ 2019.11.05.11.45.42.782.0 ]--
r 198             if (currentNode.f)
--[ 2019.11.05.11.45.43.038.0 ]--
r 198             if (currentNode.fr)
--[ 2019.11.05.11.45.43.094.0 ]--
r 198             if (currentNode.fro)
--[ 2019.11.05.11.45.43.173.0 ]--
r 198             if (currentNode.from)
--[ 2019.11.05.11.45.43.381.0 ]--
r 198             if (currentNode.fromN)
--[ 2019.11.05.11.45.43.856.0 ]--
r 198             if (currentNode.fromNo)
--[ 2019.11.05.11.45.44.000.0 ]--
r 198             if (currentNode.fromNod)
--[ 2019.11.05.11.45.44.203.0 ]--
r 198             if (currentNode.fromNode)
--[ 2019.11.05.11.45.44.279.0 ]--
r 198             if (currentNode.fromNode )
--[ 2019.11.05.11.45.44.558.0 ]--
r 198             if (currentNode.fromNode !)
--[ 2019.11.05.11.45.44.790.0 ]--
r 198             if (currentNode.fromNode !=)
--[ 2019.11.05.11.45.44.873.0 ]--
r 198             if (currentNode.fromNode != )
--[ 2019.11.05.11.45.45.015.0 ]--
r 198             if (currentNode.fromNode != n)
--[ 2019.11.05.11.45.45.252.0 ]--
r 198             if (currentNode.fromNode != nu)
--[ 2019.11.05.11.45.45.443.0 ]--
r 198             if (currentNode.fromNode != nul)
--[ 2019.11.05.11.45.45.587.0 ]--
r 198             if (currentNode.fromNode != null)
--[ 2019.11.05.11.45.46.690.0 ]--
r 198             if (currentNode.fromNode != null) 
--[ 2019.11.05.11.45.47.144.0 ]--
r 198             if (currentNode.fromNode != null) {
--[ 2019.11.05.11.45.50.024.0 ]--
+ 200            
--[ 2019.11.05.11.45.51.652.0 ]--
r 200            }
--[ 2019.11.05.11.45.51.720.0 ]--
r 199                 StdOut.println("current loc: " + currentLoc + "from: " + currentNode.fromNode.getLoc() + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.45.51.733.0 ]--
r 200             }
--[ 2019.11.05.11.45.53.339.0 ]--
r 200             } 
--[ 2019.11.05.11.45.53.639.0 ]--
r 200             } e
--[ 2019.11.05.11.45.53.843.0 ]--
r 200             } el
--[ 2019.11.05.11.45.53.924.0 ]--
r 200             } els
--[ 2019.11.05.11.45.53.987.0 ]--
r 200             } else
--[ 2019.11.05.11.45.54.067.0 ]--
r 200             } else 
--[ 2019.11.05.11.45.55.201.0 ]--
r 200             } else {
--[ 2019.11.05.11.45.55.430.0 ]--
+ 201 
+ 202 }
--[ 2019.11.05.11.45.55.495.0 ]--
r 202             }
--[ 2019.11.05.11.45.55.517.0 ]--
r 201                 
--[ 2019.11.05.11.46.10.572.0 ]--
r 201                 StdOut.println("current loc: " + currentLoc + "from: " + currentNode.fromNode.getLoc() + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.46.15.606.0 ]--
r 201                 StdOut.println("current loc: " + currentLoc + "from: " + + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.46.15.795.0 ]--
r 201                 StdOut.println("current loc: " + currentLoc + "from: " ++ " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.46.16.255.0 ]--
r 201                 StdOut.println("current loc: " + currentLoc + "from: " + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.46.17.977.0 ]--
r 201                 StdOut.println("current loc: " + currentLoc + "from: "+ " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.46.18.451.0 ]--
r 201                 StdOut.println("current loc: " + currentLoc + "from: + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.46.18.486.0 ]--
r 201                 StdOut.println("current loc: " + currentLoc + "from:+ " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.46.18.518.0 ]--
r 201                 StdOut.println("current loc: " + currentLoc + "from+ " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.46.18.550.0 ]--
r 201                 StdOut.println("current loc: " + currentLoc + "fro+ " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.46.18.583.0 ]--
r 201                 StdOut.println("current loc: " + currentLoc + "fr+ " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.46.18.616.0 ]--
r 201                 StdOut.println("current loc: " + currentLoc + "f+ " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.46.18.649.0 ]--
r 201                 StdOut.println("current loc: " + currentLoc + "+ " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.46.18.685.0 ]--
r 201                 StdOut.println("current loc: " + currentLoc + + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.46.18.723.0 ]--
r 201                 StdOut.println("current loc: " + currentLoc ++ " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.46.19.191.0 ]--
r 201                 StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.46.24.693.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.11.46.29.232.0 ]--
r 199                 StdOut.println("current loc: " + currentLoc + " from: " + currentNode.fromNode.getLoc() + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.11.46.32.911.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.11.52.16.439.0 ]--
r 204                 pathFound = t;
--[ 2019.11.05.11.52.16.681.0 ]--
r 204                 pathFound = tr;
--[ 2019.11.05.11.52.16.729.0 ]--
r 204                 pathFound = tru;
--[ 2019.11.05.11.52.16.826.0 ]--
r 204                 pathFound = true;
--[ 2019.11.05.11.52.21.036.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.11.53.38.018.0 ]--
- 151
r 151 
--[ 2019.11.05.11.53.38.322.0 ]--
- 151
--[ 2019.11.05.11.53.42.342.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.11.58.24.376.0 ]--
DisposeComponent
--[ 2019.11.05.13.08.28.421.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.11.05.13.08.28.596.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/.cos265
/readme.html
/P04_Pathfinding.iml

--[ 2019.11.05.13.08.28.601.0 ]--
InitFile: /.cos265


--[ 2019.11.05.13.08.28.605.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.11.05.13.08.28.609.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.11.05.13.08.28.613.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private Terrain terrain;
    private float[][] board;
    private int[][] origCost;
    private float h;
    private int N;
    private PFNode endNode;
    private boolean pathFound;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        public Coord getLoc() {
            return loc;
        }

        public float getCost(float heuristic) {
            PFNode b = fromNode;
            if (b == null) return 0.0f;
            else {
                //StdOut.println("getting cost: " + board[b.getLoc().getI()][b.getLoc().getJ()]);
                //StdOut.println("computed from b: " + terrain.computeTravelCost(b.getLoc(), loc));
                return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), loc);
            }
        }

        // returns if this PFNode is not marked invalid
        public boolean isValid() {
            return false;
        }

        // marks the PFNode as invalid
        public void invalidate() {

        }

        // returns if the PFNode is marked as used
        public boolean isUsed() {
            return true;
        }

        // marks the PFNode as used
        public void use() { }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        board = new float[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                board[i][j] = -1.0f;
            }
        }
        origCost = new int[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                origCost[i][j] = this.terrain.getHeight(i, j);
            }
        }
        pathFound = false;

    }

    public void setPathStart(Coord loc) {
        start = new Coord(loc.getI(), loc.getJ());
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        end = new Coord(loc.getI(), loc.getJ());
    }

    public Coord getPathEnd() {
        return end;
    }

    private void printOrigBoard() {
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board.length; j++) {
                //StdOut.print(terrain.getHeight(j, i));
                StdOut.print(board[j][i]);
                StdOut.print(' ');
            }
            StdOut.println();
        }
    }

    public void setHeuristic(float v) {

    }

    public float getHeuristic() {
        return 0;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        h = 0.0f;
        board = new float[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                board[i][j] = -1.0f;
            }
        }
        origCost = new int[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                origCost[i][j] = this.terrain.getHeight(i, j);
            }
        }
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        // Step 1: Look at all possible locations from starting point, create nodes for each
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        while (true) {
            StdOut.println("goodbye, sanity!");
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (!atStart && pq.isEmpty()) { StdOut.println("big oof"); break; }
                else currentNode = pq.delMin();
                currentLoc = currentNode.getLoc();
            }
            if (currentNode.fromNode != null) {
                StdOut.println("current loc: " + currentLoc + " from: " + currentNode.fromNode.getLoc() + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
            } else {
                StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
            }
            if (currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == getPathEnd().getJ()) {
                pathFound = true;
                endNode = currentNode;
                break;
            }
            board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = currentNode.getCost(h);
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc()) && board[c.getLoc().getI()][c.getLoc().getJ()] < 0) {
                    StdOut.println("inserting " + c.getLoc() + ' ' + c.getCost(h));
                    pq.insert(c);
                    board[c.getLoc().getI()][c.getLoc().getJ()] = c.getCost(h);
                }
            }
            atStart = false;
        }
        StdOut.println("broken");
        /*
        Coord[] neighbors = findNeighbors(start);
        PFNode startNode = new PFNode(start, null);
        for (Coord c : neighbors) {
            PFNode cNode = new PFNode(c, startNode);
            pq.insert(cNode);
            board[c.getI()][c.getJ()] = cNode.getCost();
        }
        for (PFNode n : pq) {
            StdOut.println("node: " + n.getLoc());
        }

         */
        printOrigBoard();

    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < board.length && cj >= 0 && cj < board.length;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        return 0;
    }

    public int getSearchSize() {
        return 0;
    }

    public Iterable<Coord> getPathSolution() {
        Stack<Coord> s = new Stack<>();
        PFNode c = endNode;
        while (c != null) {
            s.push(c.getLoc());
            c = c.fromNode;
        }
        return s;
    }

    public boolean wasSearched(Coord loc) {
        return false;
    }
}

--[ 2019.11.05.13.08.28.618.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return null;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return true;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
    }

}

--[ 2019.11.05.13.08.28.628.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.11.05.13.08.28.632.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.11.05.13.08.28.640.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
    };

    private final static String emapFilename = emaps[12];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.11.05.13.08.28.645.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.05.13.09.36.089.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.13.11.35.487.0 ]--
:/src/Pathfinder.java
r 211                     /board[c.getLoc().getI()][c.getLoc().getJ()] = c.getCost(h);
--[ 2019.11.05.13.11.35.535.0 ]--
r 211                     //board[c.getLoc().getI()][c.getLoc().getJ()] = c.getCost(h);
--[ 2019.11.05.13.11.40.998.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.13.15.35.583.0 ]--
- 217
- 217
- 217
- 217
- 217
- 217
- 217
- 217
- 217
- 217
- 217
- 218
--[ 2019.11.05.13.15.35.963.0 ]--
- 217
--[ 2019.11.05.13.32.16.537.0 ]--
+ 125         
--[ 2019.11.05.13.32.17.059.0 ]--
r 125         e
--[ 2019.11.05.13.32.17.236.0 ]--
r 125         en
--[ 2019.11.05.13.32.17.275.0 ]--
r 125         end
--[ 2019.11.05.13.32.17.414.0 ]--
r 125         end 
--[ 2019.11.05.13.32.17.492.0 ]--
r 125         end =- 
--[ 2019.11.05.13.32.17.762.0 ]--
r 125         end =-
--[ 2019.11.05.13.32.17.927.0 ]--
r 125         end =
--[ 2019.11.05.13.32.18.275.0 ]--
r 125         end = 
--[ 2019.11.05.13.32.18.484.0 ]--
r 125         end = l
--[ 2019.11.05.13.32.18.628.0 ]--
r 125         end = lo
--[ 2019.11.05.13.32.18.701.0 ]--
r 125         end = loc
--[ 2019.11.05.13.32.18.834.0 ]--
r 125         end = loc;
--[ 2019.11.05.13.32.21.062.0 ]--
+ 117         
--[ 2019.11.05.13.32.21.431.0 ]--
r 117         s
--[ 2019.11.05.13.32.21.527.0 ]--
r 117         st
--[ 2019.11.05.13.32.21.776.0 ]--
r 117         star
--[ 2019.11.05.13.32.21.944.0 ]--
r 117         start
--[ 2019.11.05.13.32.22.114.0 ]--
r 117         start 
--[ 2019.11.05.13.32.22.307.0 ]--
r 117         start =
--[ 2019.11.05.13.32.22.394.0 ]--
r 117         start = 
--[ 2019.11.05.13.32.22.562.0 ]--
r 117         start = l
--[ 2019.11.05.13.32.22.754.0 ]--
r 117         start = lo
--[ 2019.11.05.13.32.22.826.0 ]--
r 117         start = loc
--[ 2019.11.05.13.32.22.906.0 ]--
r 117         start = loc;
--[ 2019.11.05.13.32.27.919.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.13.32.58.916.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 47     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2019.11.05.13.33.02.742.0 ]--
r 47     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.05.13.33.03.318.0 ]--
r 47     private final static String emapFilename = emaps[0];        // change index to load a different elevation map
--[ 2019.11.05.13.33.06.690.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.13.42.08.294.0 ]--
r 47     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.05.13.42.09.177.0 ]--
r 47     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2019.11.05.13.42.09.265.0 ]--
r 47     private final static String emapFilename = emaps[12];        // change index to load a different elevation map
--[ 2019.11.05.13.42.15.443.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.13.43.11.474.0 ]--
:/src/Pathfinder.java
r 213                     /board[c.getLoc().getI()][c.getLoc().getJ()] = c.getCost(h);
--[ 2019.11.05.13.43.11.636.0 ]--
r 213                     board[c.getLoc().getI()][c.getLoc().getJ()] = c.getCost(h);
--[ 2019.11.05.13.44.00.055.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.13.57.27.591.0 ]--
+ 217             
--[ 2019.11.05.13.57.28.960.0 ]--
r 217             p
--[ 2019.11.05.13.57.29.093.0 ]--
r 217             pr
--[ 2019.11.05.13.57.29.165.0 ]--
r 217             pri
--[ 2019.11.05.13.57.29.286.0 ]--
r 217             prin
--[ 2019.11.05.13.57.29.362.0 ]--
r 217             print
--[ 2019.11.05.13.57.30.243.0 ]--
r 217             prin
--[ 2019.11.05.13.57.30.418.0 ]--
r 217             pri
--[ 2019.11.05.13.57.30.569.0 ]--
r 217             pr
--[ 2019.11.05.13.57.30.738.0 ]--
r 217             p
--[ 2019.11.05.13.57.31.195.0 ]--
r 217             
--[ 2019.11.05.13.57.40.815.0 ]--
r 217             p
--[ 2019.11.05.13.57.41.046.0 ]--
r 217             pri
--[ 2019.11.05.13.57.41.134.0 ]--
r 217             prin
--[ 2019.11.05.13.57.41.198.0 ]--
r 217             print
--[ 2019.11.05.13.57.41.430.0 ]--
r 217             printO
--[ 2019.11.05.13.57.41.582.0 ]--
r 217             printOr
--[ 2019.11.05.13.57.41.690.0 ]--
r 217             printOri
--[ 2019.11.05.13.57.41.814.0 ]--
r 217             printOrig
--[ 2019.11.05.13.57.42.033.0 ]--
r 217             printOrigB
--[ 2019.11.05.13.57.42.064.0 ]--
r 217             printOrigB 
--[ 2019.11.05.13.57.42.186.0 ]--
r 217             printOrigB o
--[ 2019.11.05.13.57.42.327.0 ]--
r 217             printOrigB oa
--[ 2019.11.05.13.57.42.366.0 ]--
r 217             printOrigB oar
--[ 2019.11.05.13.57.42.727.0 ]--
r 217             printOrigB oa
--[ 2019.11.05.13.57.42.893.0 ]--
r 217             printOrigB o
--[ 2019.11.05.13.57.43.047.0 ]--
r 217             printOrigB 
--[ 2019.11.05.13.57.43.183.0 ]--
r 217             printOrigB
--[ 2019.11.05.13.57.43.451.0 ]--
r 217             printOrigBo
--[ 2019.11.05.13.57.43.538.0 ]--
r 217             printOrigBoa
--[ 2019.11.05.13.57.43.596.0 ]--
r 217             printOrigBoar
--[ 2019.11.05.13.57.43.804.0 ]--
r 217             printOrigBoard
--[ 2019.11.05.13.57.43.980.0 ]--
r 217             printOrigBoard()
--[ 2019.11.05.13.57.44.337.0 ]--
r 217             printOrigBoard();
--[ 2019.11.05.13.57.50.561.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.15.07.26.824.0 ]--
DisposeComponent
--[ 2019.11.05.22.30.07.094.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.11.05.22.30.07.381.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/.cos265
/readme.html
/P04_Pathfinding.iml

--[ 2019.11.05.22.30.07.390.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.05.22.30.07.401.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.11.05.22.30.07.413.0 ]--
InitFile: /.cos265


--[ 2019.11.05.22.30.07.424.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.11.05.22.30.07.436.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.11.05.22.30.07.448.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
    };

    private final static String emapFilename = emaps[12];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.11.05.22.30.07.457.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.11.05.22.30.07.476.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return null;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return true;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
    }

}

--[ 2019.11.05.22.30.07.557.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private Terrain terrain;
    private float[][] board;
    private int[][] origCost;
    private float h;
    private int N;
    private PFNode endNode;
    private boolean pathFound;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        public Coord getLoc() {
            return loc;
        }

        public float getCost(float heuristic) {
            PFNode b = fromNode;
            if (b == null) return 0.0f;
            else {
                //StdOut.println("getting cost: " + board[b.getLoc().getI()][b.getLoc().getJ()]);
                //StdOut.println("computed from b: " + terrain.computeTravelCost(b.getLoc(), loc));
                return board[b.getLoc().getI()][b.getLoc().getJ()] + terrain.computeTravelCost(b.getLoc(), loc);
            }
        }

        // returns if this PFNode is not marked invalid
        public boolean isValid() {
            return false;
        }

        // marks the PFNode as invalid
        public void invalidate() {

        }

        // returns if the PFNode is marked as used
        public boolean isUsed() {
            return true;
        }

        // marks the PFNode as used
        public void use() { }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        board = new float[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                board[i][j] = -1.0f;
            }
        }
        origCost = new int[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                origCost[i][j] = this.terrain.getHeight(i, j);
            }
        }
        pathFound = false;

    }

    public void setPathStart(Coord loc) {
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    private void printOrigBoard() {
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board.length; j++) {
                //StdOut.print(terrain.getHeight(j, i));
                StdOut.print(board[j][i]);
                StdOut.print(' ');
            }
            StdOut.println();
        }
    }

    public void setHeuristic(float v) {

    }

    public float getHeuristic() {
        return 0;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        h = 0.0f;
        board = new float[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                board[i][j] = -1.0f;
            }
        }
        origCost = new int[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                origCost[i][j] = this.terrain.getHeight(i, j);
            }
        }
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        // Step 1: Look at all possible locations from starting point, create nodes for each
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        while (true) {
            StdOut.println("goodbye, sanity!");
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (!atStart && pq.isEmpty()) { StdOut.println("big oof"); break; }
                else currentNode = pq.delMin();
                currentLoc = currentNode.getLoc();
            }
            if (currentNode.fromNode != null) {
                StdOut.println("current loc: " + currentLoc + " from: " + currentNode.fromNode.getLoc() + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
            } else {
                StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
            }
            if (currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == getPathEnd().getJ()) {
                pathFound = true;
                endNode = currentNode;
                break;
            }
            board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = currentNode.getCost(h);
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc()) && board[c.getLoc().getI()][c.getLoc().getJ()] < 0) {
                    StdOut.println("inserting " + c.getLoc() + ' ' + c.getCost(h));
                    pq.insert(c);
                    board[c.getLoc().getI()][c.getLoc().getJ()] = c.getCost(h);
                }
            }
            atStart = false;
            printOrigBoard();
        }
        StdOut.println("broken");
        printOrigBoard();

    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < board.length && cj >= 0 && cj < board.length;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        return 0;
    }

    public int getSearchSize() {
        return 0;
    }

    public Iterable<Coord> getPathSolution() {
        Stack<Coord> s = new Stack<>();
        PFNode c = endNode;
        while (c != null) {
            s.push(c.getLoc());
            c = c.fromNode;
        }
        return s;
    }

    public boolean wasSearched(Coord loc) {
        return false;
    }
}

--[ 2019.11.05.22.46.39.512.0 ]--
:/src/Pathfinder.java
r 192             if (atStart) {currentNode = new PFNode(currentLoc, null);
--[ 2019.11.05.22.46.40.129.0 ]--
+ 192             if (atStart) {
+ 193 currentNode = new PFNode(currentLoc, null);
r 194 }
--[ 2019.11.05.22.46.40.369.0 ]--
r 193                 currentNode = new PFNode(currentLoc, null);
r 194             }
--[ 2019.11.05.22.46.44.287.0 ]--
+ 194                 
--[ 2019.11.05.22.46.44.538.0 ]--
r 194                 b
--[ 2019.11.05.22.46.44.725.0 ]--
r 194                 bo
--[ 2019.11.05.22.46.44.774.0 ]--
r 194                 boa
--[ 2019.11.05.22.46.44.843.0 ]--
r 194                 boar
--[ 2019.11.05.22.46.45.071.0 ]--
r 194                 board
--[ 2019.11.05.22.46.45.161.0 ]--
r 194                 board[]
--[ 2019.11.05.22.46.47.785.0 ]--
r 194                 board[c]
--[ 2019.11.05.22.46.47.942.0 ]--
r 194                 board[cu]
--[ 2019.11.05.22.46.48.108.0 ]--
r 194                 board[cur]
--[ 2019.11.05.22.46.48.251.0 ]--
r 194                 board[curr]
--[ 2019.11.05.22.46.48.345.0 ]--
r 194                 board[curre]
--[ 2019.11.05.22.46.48.534.0 ]--
r 194                 board[curren]
--[ 2019.11.05.22.46.48.589.0 ]--
r 194                 board[current]
--[ 2019.11.05.22.46.48.920.0 ]--
r 194                 board[currentN]
--[ 2019.11.05.22.46.49.061.0 ]--
r 194                 board[currentNo]
--[ 2019.11.05.22.46.49.142.0 ]--
r 194                 board[currentNod]
--[ 2019.11.05.22.46.49.318.0 ]--
r 194                 board[currentNode]
--[ 2019.11.05.22.46.49.389.0 ]--
r 194                 board[currentNode.]
--[ 2019.11.05.22.46.49.875.0 ]--
r 194                 board[currentNode.g]
--[ 2019.11.05.22.46.50.273.0 ]--
r 194                 board[currentNode.get]
--[ 2019.11.05.22.46.55.698.0 ]--
r 194                 board[currentNode.getL]
--[ 2019.11.05.22.46.55.859.0 ]--
r 194                 board[currentNode.getLo]
--[ 2019.11.05.22.46.55.928.0 ]--
r 194                 board[currentNode.getLoc]
--[ 2019.11.05.22.46.56.614.0 ]--
r 194                 board[currentNode.getLoc()]
--[ 2019.11.05.22.46.56.919.0 ]--
r 194                 board[currentNode.getLoc().]
--[ 2019.11.05.22.46.57.056.0 ]--
r 194                 board[currentNode.getLoc().g]
--[ 2019.11.05.22.46.57.128.0 ]--
r 194                 board[currentNode.getLoc().ge]
--[ 2019.11.05.22.46.57.240.0 ]--
r 194                 board[currentNode.getLoc().get]
--[ 2019.11.05.22.46.57.482.0 ]--
r 194                 board[currentNode.getLoc().getI]
--[ 2019.11.05.22.46.57.726.0 ]--
r 194                 board[currentNode.getLoc().getI()]
--[ 2019.11.05.22.46.58.205.0 ]--
r 194                 board[currentNode.getLoc().getI()]]
--[ 2019.11.05.22.46.58.678.0 ]--
r 194                 board[currentNode.getLoc().getI()]
--[ 2019.11.05.22.46.58.903.0 ]--
r 194                 board[currentNode.getLoc().getI()][]
--[ 2019.11.05.22.46.59.668.0 ]--
r 194                 board[currentNode.getLoc().getI()][c]
--[ 2019.11.05.22.46.59.772.0 ]--
r 194                 board[currentNode.getLoc().getI()][cu]
--[ 2019.11.05.22.46.59.951.0 ]--
r 194                 board[currentNode.getLoc().getI()][cur]
--[ 2019.11.05.22.47.00.122.0 ]--
r 194                 board[currentNode.getLoc().getI()][curr]
--[ 2019.11.05.22.47.00.172.0 ]--
r 194                 board[currentNode.getLoc().getI()][curre]
--[ 2019.11.05.22.47.00.272.0 ]--
r 194                 board[currentNode.getLoc().getI()][curren]
--[ 2019.11.05.22.47.00.345.0 ]--
r 194                 board[currentNode.getLoc().getI()][current]
--[ 2019.11.05.22.47.00.520.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentN]
--[ 2019.11.05.22.47.00.771.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentNo]
--[ 2019.11.05.22.47.00.877.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentNod]
--[ 2019.11.05.22.47.01.062.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentNode]
--[ 2019.11.05.22.47.01.174.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentNode.]
--[ 2019.11.05.22.47.01.295.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentNode.g]
--[ 2019.11.05.22.47.01.350.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentNode.ge]
--[ 2019.11.05.22.47.01.484.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentNode.get]
--[ 2019.11.05.22.47.01.715.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentNode.getL]
--[ 2019.11.05.22.47.01.855.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentNode.getLo]
--[ 2019.11.05.22.47.01.904.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentNode.getLoc]
--[ 2019.11.05.22.47.02.242.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentNode.getLoc()]
--[ 2019.11.05.22.47.02.716.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentNode.getLoc().]
--[ 2019.11.05.22.47.02.922.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentNode.getLoc().g]
--[ 2019.11.05.22.47.03.010.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentNode.getLoc().ge]
--[ 2019.11.05.22.47.03.160.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentNode.getLoc().get]
--[ 2019.11.05.22.47.03.356.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentNode.getLoc().getJ]
--[ 2019.11.05.22.47.03.711.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()]
--[ 2019.11.05.22.47.05.086.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] 
--[ 2019.11.05.22.47.05.404.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = 
--[ 2019.11.05.22.47.05.772.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = i
--[ 2019.11.05.22.47.05.895.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = i;
--[ 2019.11.05.22.47.06.364.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = i
--[ 2019.11.05.22.47.06.521.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = 
--[ 2019.11.05.22.47.07.418.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = a
--[ 2019.11.05.22.47.07.463.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = a;
--[ 2019.11.05.22.47.08.489.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = a
--[ 2019.11.05.22.47.08.685.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = 
--[ 2019.11.05.22.47.16.319.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = 0
--[ 2019.11.05.22.47.16.758.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = 0.
--[ 2019.11.05.22.47.16.885.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = 0.0
--[ 2019.11.05.22.47.17.056.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = 0.0f
--[ 2019.11.05.22.47.17.137.0 ]--
r 194                 board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = 0.0f;
--[ 2019.11.05.22.47.22.041.0 ]--
r 211 
--[ 2019.11.05.22.47.22.220.0 ]--
- 211
--[ 2019.11.05.22.47.29.620.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.22.49.28.467.0 ]--
+ 59                 
--[ 2019.11.05.22.49.29.370.0 ]--
- 59
--[ 2019.11.05.22.49.32.070.0 ]--
r 57                 /StdOut.println("getting cost: " + board[b.getLoc().getI()][b.getLoc().getJ()]);
--[ 2019.11.05.22.49.32.261.0 ]--
r 57                 StdOut.println("getting cost: " + board[b.getLoc().getI()][b.getLoc().getJ()]);
--[ 2019.11.05.22.49.37.486.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.22.51.48.369.0 ]--
r 55             if (fromNode == null) return 0.0f;
--[ 2019.11.05.22.51.49.721.0 ]--
r 55             if (b == null) return 0.0f;
--[ 2019.11.05.22.51.50.683.0 ]--
r 57                 //StdOut.println("getting cost: " + board[b.getLoc().getI()][b.getLoc().getJ()]);
--[ 2019.11.05.22.51.53.867.0 ]--
r 57                 StdOut.println("getting cost: " + board[b.getLoc().getI()][b.getLoc().getJ()]);
--[ 2019.11.05.22.52.22.746.0 ]--
r 58                 /StdOut.println("computed from b: " + terrain.computeTravelCost(b.getLoc(), loc));
--[ 2019.11.05.22.52.23.066.0 ]--
r 58                 StdOut.println("computed from b: " + terrain.computeTravelCost(b.getLoc(), loc));
--[ 2019.11.05.22.52.25.695.0 ]--
+ 59                 
--[ 2019.11.05.22.52.27.288.0 ]--
- 59
--[ 2019.11.05.22.52.29.826.0 ]--
+ 57                 
--[ 2019.11.05.22.52.30.074.0 ]--
r 57                 f
--[ 2019.11.05.22.52.30.143.0 ]--
r 57                 fl
--[ 2019.11.05.22.52.30.302.0 ]--
r 57                 flo
--[ 2019.11.05.22.52.30.378.0 ]--
r 57                 floa
--[ 2019.11.05.22.52.30.458.0 ]--
r 57                 float
--[ 2019.11.05.22.52.30.541.0 ]--
r 57                 float 
--[ 2019.11.05.22.52.31.004.0 ]--
r 57                 float a
--[ 2019.11.05.22.52.31.084.0 ]--
r 57                 float a 
--[ 2019.11.05.22.52.31.233.0 ]--
r 57                 float a =
--[ 2019.11.05.22.52.31.324.0 ]--
r 57                 float a = 
--[ 2019.11.05.22.52.31.837.0 ]--
r 57                 float a = b
--[ 2019.11.05.22.52.31.922.0 ]--
r 57                 float a = bo
--[ 2019.11.05.22.52.32.037.0 ]--
r 57                 float a = boa
--[ 2019.11.05.22.52.32.114.0 ]--
r 57                 float a = boar
--[ 2019.11.05.22.52.32.294.0 ]--
r 57                 float a = board
--[ 2019.11.05.22.52.32.413.0 ]--
r 57                 float a = board[]
--[ 2019.11.05.22.52.32.563.0 ]--
r 57                 float a = board[b]
--[ 2019.11.05.22.52.32.679.0 ]--
r 57                 float a = board[b.]
--[ 2019.11.05.22.52.32.844.0 ]--
r 57                 float a = board[b.g]
--[ 2019.11.05.22.52.33.227.0 ]--
r 57                 float a = board[b.get]
--[ 2019.11.05.22.52.33.270.0 ]--
r 57                 float a = board[b.getL]
--[ 2019.11.05.22.52.33.415.0 ]--
r 57                 float a = board[b.getLo]
--[ 2019.11.05.22.52.33.483.0 ]--
r 57                 float a = board[b.getLoc]
--[ 2019.11.05.22.52.33.846.0 ]--
r 57                 float a = board[b.getLoc()]
--[ 2019.11.05.22.52.34.447.0 ]--
r 57                 float a = board[b.getLoc().]
--[ 2019.11.05.22.52.34.584.0 ]--
r 57                 float a = board[b.getLoc().g]
--[ 2019.11.05.22.52.34.675.0 ]--
r 57                 float a = board[b.getLoc().ge]
--[ 2019.11.05.22.52.34.818.0 ]--
r 57                 float a = board[b.getLoc().get]
--[ 2019.11.05.22.52.35.023.0 ]--
r 57                 float a = board[b.getLoc().getI]
--[ 2019.11.05.22.52.35.287.0 ]--
r 57                 float a = board[b.getLoc().getI()]
--[ 2019.11.05.22.52.35.879.0 ]--
r 57                 float a = board[b.getLoc().getI()][]
--[ 2019.11.05.22.52.36.056.0 ]--
r 57                 float a = board[b.getLoc().getI()][b]
--[ 2019.11.05.22.52.36.167.0 ]--
r 57                 float a = board[b.getLoc().getI()][bo]
--[ 2019.11.05.22.52.36.270.0 ]--
r 57                 float a = board[b.getLoc().getI()][boa]
--[ 2019.11.05.22.52.36.342.0 ]--
r 57                 float a = board[b.getLoc().getI()][boar]
--[ 2019.11.05.22.52.36.515.0 ]--
r 57                 float a = board[b.getLoc().getI()][board]
--[ 2019.11.05.22.52.36.592.0 ]--
r 57                 float a = board[b.getLoc().getI()][board.]
--[ 2019.11.05.22.52.36.719.0 ]--
r 57                 float a = board[b.getLoc().getI()][board.g]
--[ 2019.11.05.22.52.36.803.0 ]--
r 57                 float a = board[b.getLoc().getI()][board.ge]
--[ 2019.11.05.22.52.36.944.0 ]--
r 57                 float a = board[b.getLoc().getI()][board.get]
--[ 2019.11.05.22.52.37.125.0 ]--
r 57                 float a = board[b.getLoc().getI()][board.getL]
--[ 2019.11.05.22.52.37.282.0 ]--
r 57                 float a = board[b.getLoc().getI()][board.getLo]
--[ 2019.11.05.22.52.37.350.0 ]--
r 57                 float a = board[b.getLoc().getI()][board.getLoc]
--[ 2019.11.05.22.52.37.648.0 ]--
r 57                 float a = board[b.getLoc().getI()][board.getLoc()]
--[ 2019.11.05.22.52.37.994.0 ]--
r 57                 float a = board[b.getLoc().getI()][board.getLoc().]
--[ 2019.11.05.22.52.38.071.0 ]--
r 57                 float a = board[b.getLoc().getI()][board.getLoc().g]
--[ 2019.11.05.22.52.38.141.0 ]--
r 57                 float a = board[b.getLoc().getI()][board.getLoc().ge]
--[ 2019.11.05.22.52.38.306.0 ]--
r 57                 float a = board[b.getLoc().getI()][board.getLoc().get]
--[ 2019.11.05.22.52.38.503.0 ]--
r 57                 float a = board[b.getLoc().getI()][board.getLoc().getNJ]
--[ 2019.11.05.22.52.38.904.0 ]--
r 57                 float a = board[b.getLoc().getI()][board.getLoc().getN]
--[ 2019.11.05.22.52.39.063.0 ]--
r 57                 float a = board[b.getLoc().getI()][board.getLoc().get]
--[ 2019.11.05.22.52.39.253.0 ]--
r 57                 float a = board[b.getLoc().getI()][board.getLoc().getJ]
--[ 2019.11.05.22.52.39.582.0 ]--
r 57                 float a = board[b.getLoc().getI()][board.getLoc().getJ()]
--[ 2019.11.05.22.52.40.611.0 ]--
r 57                 float a = board[b.getLoc().getI()][board.getLoc().getJ()];
--[ 2019.11.05.22.52.44.237.0 ]--
r 57                 float a = board[b.getLoc().getI()][b.getLoc().getJ()];
--[ 2019.11.05.22.52.46.803.0 ]--
r 57                 float a = board[b.getLoc().getI()][b.getLoc().getJ()];\
--[ 2019.11.05.22.52.46.870.0 ]--
+ 58                 
--[ 2019.11.05.22.52.47.828.0 ]--
- 58
--[ 2019.11.05.22.52.48.214.0 ]--
r 57                 float a = board[b.getLoc().getI()][b.getLoc().getJ()];
--[ 2019.11.05.22.52.48.470.0 ]--
+ 58                 
--[ 2019.11.05.22.52.48.805.0 ]--
r 58                 f
--[ 2019.11.05.22.52.48.884.0 ]--
r 58                 fl
--[ 2019.11.05.22.52.49.047.0 ]--
r 58                 flo
--[ 2019.11.05.22.52.49.139.0 ]--
r 58                 floa
--[ 2019.11.05.22.52.49.194.0 ]--
r 58                 float
--[ 2019.11.05.22.52.49.304.0 ]--
r 58                 float 
--[ 2019.11.05.22.52.49.453.0 ]--
r 58                 float b
--[ 2019.11.05.22.52.49.568.0 ]--
r 58                 float b 
--[ 2019.11.05.22.52.49.602.0 ]--
r 58                 float b =
--[ 2019.11.05.22.52.49.752.0 ]--
r 58                 float b = 
--[ 2019.11.05.22.52.51.372.0 ]--
r 58                 float b = t
--[ 2019.11.05.22.52.51.469.0 ]--
r 58                 float b = te
--[ 2019.11.05.22.52.51.617.0 ]--
r 58                 float b = ter
--[ 2019.11.05.22.52.51.776.0 ]--
r 58                 float b = terr
--[ 2019.11.05.22.52.51.853.0 ]--
r 58                 float b = terra
--[ 2019.11.05.22.52.51.901.0 ]--
r 58                 float b = terrai
--[ 2019.11.05.22.52.52.009.0 ]--
r 58                 float b = terrain
--[ 2019.11.05.22.52.52.194.0 ]--
r 58                 float b = terrain.
--[ 2019.11.05.22.52.52.321.0 ]--
r 58                 float b = terrain.c
--[ 2019.11.05.22.52.52.453.0 ]--
r 58                 float b = terrain.co
--[ 2019.11.05.22.52.52.546.0 ]--
r 58                 float b = terrain.com
--[ 2019.11.05.22.52.52.687.0 ]--
r 58                 float b = terrain.comp
--[ 2019.11.05.22.52.52.818.0 ]--
r 58                 float b = terrain.compu
--[ 2019.11.05.22.52.52.859.0 ]--
r 58                 float b = terrain.comput
--[ 2019.11.05.22.52.52.975.0 ]--
r 58                 float b = terrain.compute
--[ 2019.11.05.22.52.53.305.0 ]--
r 58                 float b = terrain.computeT
--[ 2019.11.05.22.52.53.513.0 ]--
r 58                 float b = terrain.computeTr
--[ 2019.11.05.22.52.53.565.0 ]--
r 58                 float b = terrain.computeTra
--[ 2019.11.05.22.52.53.739.0 ]--
r 58                 float b = terrain.computeTrav
--[ 2019.11.05.22.52.53.841.0 ]--
r 58                 float b = terrain.computeTrave
--[ 2019.11.05.22.52.53.920.0 ]--
r 58                 float b = terrain.computeTravel
--[ 2019.11.05.22.52.54.082.0 ]--
r 58                 float b = terrain.computeTravelC
--[ 2019.11.05.22.52.54.224.0 ]--
r 58                 float b = terrain.computeTravelCo
--[ 2019.11.05.22.52.54.329.0 ]--
r 58                 float b = terrain.computeTravelCos
--[ 2019.11.05.22.52.54.696.0 ]--
r 58                 float b = terrain.computeTravelCost()
--[ 2019.11.05.22.52.55.852.0 ]--
r 58                 float b = terrain.computeTravelCost(b)
--[ 2019.11.05.22.52.55.979.0 ]--
r 58                 float b = terrain.computeTravelCost(b.)
--[ 2019.11.05.22.52.56.125.0 ]--
r 58                 float b = terrain.computeTravelCost(b.g)
--[ 2019.11.05.22.52.56.227.0 ]--
r 58                 float b = terrain.computeTravelCost(b.ge)
--[ 2019.11.05.22.52.56.350.0 ]--
r 58                 float b = terrain.computeTravelCost(b.get)
--[ 2019.11.05.22.52.56.504.0 ]--
r 58                 float b = terrain.computeTravelCost(b.getL)
--[ 2019.11.05.22.52.56.661.0 ]--
r 58                 float b = terrain.computeTravelCost(b.getLo)
--[ 2019.11.05.22.52.56.729.0 ]--
r 58                 float b = terrain.computeTravelCost(b.getLoc)
--[ 2019.11.05.22.52.57.208.0 ]--
r 58                 float b = terrain.computeTravelCost(b.getLoc*)
--[ 2019.11.05.22.52.57.273.0 ]--
r 58                 float b = terrain.computeTravelCost(b.getLoc*())
--[ 2019.11.05.22.52.57.575.0 ]--
r 58                 float b = terrain.computeTravelCost(b.getLoc*(,))
--[ 2019.11.05.22.52.57.628.0 ]--
r 58                 float b = terrain.computeTravelCost(b.getLoc*(, ))
--[ 2019.11.05.22.52.57.777.0 ]--
r 58                 float b = terrain.computeTravelCost(b.getLoc*(, l))
--[ 2019.11.05.22.52.58.212.0 ]--
r 58                 float b = terrain.computeTravelCost(b.getLoc*(, ))
--[ 2019.11.05.22.52.58.707.0 ]--
r 58                 float b = terrain.computeTravelCost(b.getLoc*(,))
--[ 2019.11.05.22.52.58.741.0 ]--
r 58                 float b = terrain.computeTravelCost(b.getLoc*())
--[ 2019.11.05.22.52.58.778.0 ]--
r 58                 float b = terrain.computeTravelCost(b.getLoc*)
--[ 2019.11.05.22.52.58.812.0 ]--
r 58                 float b = terrain.computeTravelCost(b.getLoc)
--[ 2019.11.05.22.52.58.848.0 ]--
r 58                 float b = terrain.computeTravelCost(b.getLo)
--[ 2019.11.05.22.52.59.245.0 ]--
r 58                 float b = terrain.computeTravelCost(b.getL)
--[ 2019.11.05.22.53.00.473.0 ]--
r 58                 float b = terrain.computeTravelCost(b.getLo)
--[ 2019.11.05.22.53.00.558.0 ]--
r 58                 float b = terrain.computeTravelCost(b.getLoc)
--[ 2019.11.05.22.53.00.819.0 ]--
r 58                 float b = terrain.computeTravelCost(b.getLoc())
--[ 2019.11.05.22.53.01.199.0 ]--
r 58                 float b = terrain.computeTravelCost(b.getLoc(),)
--[ 2019.11.05.22.53.01.258.0 ]--
r 58                 float b = terrain.computeTravelCost(b.getLoc(), )
--[ 2019.11.05.22.53.01.407.0 ]--
r 58                 float b = terrain.computeTravelCost(b.getLoc(), l)
--[ 2019.11.05.22.53.01.575.0 ]--
r 58                 float b = terrain.computeTravelCost(b.getLoc(), lo)
--[ 2019.11.05.22.53.01.641.0 ]--
r 58                 float b = terrain.computeTravelCost(b.getLoc(), loc)
--[ 2019.11.05.22.53.02.042.0 ]--
r 58                 float b = terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.05.22.53.10.472.0 ]--
r 58                 float  = terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.05.22.53.10.863.0 ]--
r 58                 float ab = terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.05.22.53.14.382.0 ]--
r 59                 /StdOut.println("getting cost: " + board[b.getLoc().getI()][b.getLoc().getJ()]);
--[ 2019.11.05.22.53.14.534.0 ]--
r 59                 //StdOut.println("getting cost: " + board[b.getLoc().getI()][b.getLoc().getJ()]);
--[ 2019.11.05.22.53.15.413.0 ]--
r 59                 /StdOut.println("getting cost: " + board[b.getLoc().getI()][b.getLoc().getJ()]);
--[ 2019.11.05.22.53.15.584.0 ]--
r 59                 StdOut.println("getting cost: " + board[b.getLoc().getI()][b.getLoc().getJ()]);
--[ 2019.11.05.22.53.19.584.0 ]--
r 59                 StdOut.println("getting cost: " + a);
--[ 2019.11.05.22.53.23.434.0 ]--
r 60                 StdOut.println("computed from b: " + b);
--[ 2019.11.05.22.53.30.228.0 ]--
r 61                 return a + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.05.22.53.34.593.0 ]--
r 61                 return a + b;
--[ 2019.11.05.22.53.40.060.0 ]--
UpdateTree (AD): 0 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class

--[ 2019.11.05.22.53.40.071.0 ]--
CompilationStatus (AEW): 0 1 0
[Ljava.lang.String;@288b94bb
--[ 2019.11.05.22.53.44.173.0 ]--
r 61                 return a + ab;
--[ 2019.11.05.22.53.44.192.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.05.22.53.44.224.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.05.22.53.47.549.0 ]--
UpdateTree (AD): 2 0
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.05.22.53.47.565.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.22.54.00.077.0 ]--
r 60                 StdOut.println("computed from b: " + ab);
--[ 2019.11.05.22.54.03.842.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.22.54.53.681.0 ]--
+ 61                 
--[ 2019.11.05.22.54.54.218.0 ]--
r 61                 St
--[ 2019.11.05.22.54.54.275.0 ]--
r 61                 Std
--[ 2019.11.05.22.54.54.452.0 ]--
r 61                 StdO
--[ 2019.11.05.22.54.54.645.0 ]--
r 61                 StdOu
--[ 2019.11.05.22.54.54.728.0 ]--
r 61                 StdOut
--[ 2019.11.05.22.54.54.862.0 ]--
r 61                 StdOut.
--[ 2019.11.05.22.54.55.107.0 ]--
r 61                 StdOut.p
--[ 2019.11.05.22.54.55.214.0 ]--
r 61                 StdOut.pr
--[ 2019.11.05.22.54.55.305.0 ]--
r 61                 StdOut.pri
--[ 2019.11.05.22.54.55.440.0 ]--
r 61                 StdOut.prin
--[ 2019.11.05.22.54.55.649.0 ]--
r 61                 StdOut.printl
--[ 2019.11.05.22.54.55.724.0 ]--
r 61                 StdOut.println
--[ 2019.11.05.22.54.55.883.0 ]--
r 61                 StdOut.println()
--[ 2019.11.05.22.54.56.089.0 ]--
r 61                 StdOut.println("")
--[ 2019.11.05.22.54.56.338.0 ]--
r 61                 StdOut.println("a")
--[ 2019.11.05.22.54.56.433.0 ]--
r 61                 StdOut.println("ad")
--[ 2019.11.05.22.54.56.606.0 ]--
r 61                 StdOut.println("add")
--[ 2019.11.05.22.54.56.718.0 ]--
r 61                 StdOut.println("addi")
--[ 2019.11.05.22.54.56.795.0 ]--
r 61                 StdOut.println("addit")
--[ 2019.11.05.22.54.56.845.0 ]--
r 61                 StdOut.println("additi")
--[ 2019.11.05.22.54.56.931.0 ]--
r 61                 StdOut.println("additio")
--[ 2019.11.05.22.54.57.009.0 ]--
r 61                 StdOut.println("addition")
--[ 2019.11.05.22.54.57.212.0 ]--
r 61                 StdOut.println("addition:")
--[ 2019.11.05.22.54.57.324.0 ]--
r 61                 StdOut.println("addition: ")
--[ 2019.11.05.22.54.57.662.0 ]--
r 61                 StdOut.println("addition: " )
--[ 2019.11.05.22.54.57.861.0 ]--
r 61                 StdOut.println("addition: " +)
--[ 2019.11.05.22.54.57.958.0 ]--
r 61                 StdOut.println("addition: " + )
--[ 2019.11.05.22.54.59.412.0 ]--
r 61                 StdOut.println("addition: " + ())
--[ 2019.11.05.22.54.59.660.0 ]--
r 61                 StdOut.println("addition: " + (a))
--[ 2019.11.05.22.54.59.842.0 ]--
r 61                 StdOut.println("addition: " + (a ))
--[ 2019.11.05.22.55.00.036.0 ]--
r 61                 StdOut.println("addition: " + (a +))
--[ 2019.11.05.22.55.00.103.0 ]--
r 61                 StdOut.println("addition: " + (a + ))
--[ 2019.11.05.22.55.00.305.0 ]--
r 61                 StdOut.println("addition: " + (a + a))
--[ 2019.11.05.22.55.00.906.0 ]--
r 61                 StdOut.println("addition: " + (a + ab))
--[ 2019.11.05.22.55.01.650.0 ]--
r 61                 StdOut.println("addition: " + (a + ab));
--[ 2019.11.05.22.55.04.022.0 ]--
r 61                 StdOut.printl("addition: " + (a + ab));
--[ 2019.11.05.22.55.04.365.0 ]--
r 61                 StdOut.print("addition: " + (a + ab));
--[ 2019.11.05.22.55.06.240.0 ]--
+ 62                 
--[ 2019.11.05.22.55.06.501.0 ]--
r 62                 S
--[ 2019.11.05.22.55.06.657.0 ]--
r 62                 St
--[ 2019.11.05.22.55.06.869.0 ]--
r 62                 Std
--[ 2019.11.05.22.55.07.020.0 ]--
r 62                 StdO
--[ 2019.11.05.22.55.07.186.0 ]--
r 62                 StdOu
--[ 2019.11.05.22.55.07.317.0 ]--
r 62                 StdOut
--[ 2019.11.05.22.55.07.417.0 ]--
r 62                 StdOut.
--[ 2019.11.05.22.55.07.663.0 ]--
r 62                 StdOut.p
--[ 2019.11.05.22.55.07.757.0 ]--
r 62                 StdOut.pr
--[ 2019.11.05.22.55.08.009.0 ]--
r 62                 StdOut.prin
--[ 2019.11.05.22.55.08.072.0 ]--
r 62                 StdOut.print
--[ 2019.11.05.22.55.08.163.0 ]--
r 62                 StdOut.printl
--[ 2019.11.05.22.55.08.229.0 ]--
r 62                 StdOut.println
--[ 2019.11.05.22.55.08.435.0 ]--
r 62                 StdOut.println()
--[ 2019.11.05.22.55.08.757.0 ]--
r 62                 StdOut.println(a)
--[ 2019.11.05.22.55.09.176.0 ]--
r 62                 StdOut.println(a+)
--[ 2019.11.05.22.55.09.435.0 ]--
r 62                 StdOut.println(a+a)
--[ 2019.11.05.22.55.09.646.0 ]--
r 62                 StdOut.println(a+ab)
--[ 2019.11.05.22.55.09.996.0 ]--
r 62                 StdOut.println(a+ab);
--[ 2019.11.05.22.55.11.951.0 ]--
r 61                 StdOut.print("addition: " + (a + ab);
--[ 2019.11.05.22.55.12.141.0 ]--
r 61                 StdOut.print("addition: " + (a + a);
--[ 2019.11.05.22.55.12.340.0 ]--
r 61                 StdOut.print("addition: " + (a + );
--[ 2019.11.05.22.55.12.546.0 ]--
r 61                 StdOut.print("addition: " + (a +);
--[ 2019.11.05.22.55.12.738.0 ]--
r 61                 StdOut.print("addition: " + (a );
--[ 2019.11.05.22.55.12.992.0 ]--
r 61                 StdOut.print("addition: " + (a);
--[ 2019.11.05.22.55.13.234.0 ]--
r 61                 StdOut.print("addition: " + ();
--[ 2019.11.05.22.55.13.474.0 ]--
r 61                 StdOut.print("addition: " + );
--[ 2019.11.05.22.55.13.734.0 ]--
r 61                 StdOut.print("addition: " +);
--[ 2019.11.05.22.55.13.961.0 ]--
r 61                 StdOut.print("addition: " );
--[ 2019.11.05.22.55.14.481.0 ]--
r 61                 StdOut.print("addition: ");
--[ 2019.11.05.22.55.19.421.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.22.56.22.588.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.22.59.27.493.0 ]--
+ 219                     
--[ 2019.11.05.22.59.28.183.0 ]--
r 219                     S
--[ 2019.11.05.22.59.28.332.0 ]--
r 219                     St
--[ 2019.11.05.22.59.28.538.0 ]--
r 219                     Std
--[ 2019.11.05.22.59.28.709.0 ]--
r 219                     StdO
--[ 2019.11.05.22.59.28.903.0 ]--
r 219                     StdOu
--[ 2019.11.05.22.59.28.987.0 ]--
r 219                     StdOut
--[ 2019.11.05.22.59.29.114.0 ]--
r 219                     StdOut.
--[ 2019.11.05.22.59.29.364.0 ]--
r 219                     StdOut.p
--[ 2019.11.05.22.59.29.440.0 ]--
r 219                     StdOut.pr
--[ 2019.11.05.22.59.29.562.0 ]--
r 219                     StdOut.pri
--[ 2019.11.05.22.59.29.686.0 ]--
r 219                     StdOut.prin
--[ 2019.11.05.22.59.29.769.0 ]--
r 219                     StdOut.print
--[ 2019.11.05.22.59.29.862.0 ]--
r 219                     StdOut.printl
--[ 2019.11.05.22.59.29.924.0 ]--
r 219                     StdOut.println
--[ 2019.11.05.22.59.30.136.0 ]--
r 219                     StdOut.println()
--[ 2019.11.05.22.59.30.366.0 ]--
r 219                     StdOut.println("")
--[ 2019.11.05.22.59.30.848.0 ]--
r 219                     StdOut.println("A")
--[ 2019.11.05.22.59.30.932.0 ]--
r 219                     StdOut.println("AH")
--[ 2019.11.05.22.59.31.063.0 ]--
r 219                     StdOut.println("AHH")
--[ 2019.11.05.22.59.31.233.0 ]--
r 219                     StdOut.println("AHHH")
--[ 2019.11.05.22.59.31.383.0 ]--
r 219                     StdOut.println("AHHHH")
--[ 2019.11.05.22.59.31.557.0 ]--
r 219                     StdOut.println("AHHHHH")
--[ 2019.11.05.22.59.31.696.0 ]--
r 219                     StdOut.println("AHHHHHH")
--[ 2019.11.05.22.59.31.845.0 ]--
r 219                     StdOut.println("AHHHHHHH")
--[ 2019.11.05.22.59.32.019.0 ]--
r 219                     StdOut.println("AHHHHHHHH")
--[ 2019.11.05.22.59.32.161.0 ]--
r 219                     StdOut.println("AHHHHHHHHH")
--[ 2019.11.05.22.59.33.122.0 ]--
r 219                     StdOut.println("AHHHHHHHHH" )
--[ 2019.11.05.22.59.33.699.0 ]--
r 219                     StdOut.println("AHHHHHHHHH" +)
--[ 2019.11.05.22.59.33.807.0 ]--
r 219                     StdOut.println("AHHHHHHHHH" + )
--[ 2019.11.05.22.59.34.035.0 ]--
r 219                     StdOut.println("AHHHHHHHHH" +)
--[ 2019.11.05.22.59.34.199.0 ]--
r 219                     StdOut.println("AHHHHHHHHH" )
--[ 2019.11.05.22.59.34.380.0 ]--
r 219                     StdOut.println("AHHHHHHHHH")
--[ 2019.11.05.22.59.34.509.0 ]--
r 219                     StdOut.println("AHHHHHHHHH)
--[ 2019.11.05.22.59.35.264.0 ]--
r 219                     StdOut.println("AHHHHHHHHH )
--[ 2019.11.05.22.59.35.690.0 ]--
r 219                     StdOut.println("AHHHHHHHHH 0)
--[ 2019.11.05.22.59.36.350.0 ]--
r 219                     StdOut.println("AHHHHHHHHH )
--[ 2019.11.05.22.59.36.589.0 ]--
r 219                     StdOut.println("AHHHHHHHHH -)
--[ 2019.11.05.22.59.37.088.0 ]--
r 219                     StdOut.println("AHHHHHHHHH --)
--[ 2019.11.05.22.59.37.121.0 ]--
r 219                     StdOut.println("AHHHHHHHHH ---)
--[ 2019.11.05.22.59.37.154.0 ]--
r 219                     StdOut.println("AHHHHHHHHH ----)
--[ 2019.11.05.22.59.37.188.0 ]--
r 219                     StdOut.println("AHHHHHHHHH -----)
--[ 2019.11.05.22.59.37.220.0 ]--
r 219                     StdOut.println("AHHHHHHHHH ------)
--[ 2019.11.05.22.59.37.252.0 ]--
r 219                     StdOut.println("AHHHHHHHHH -------)
--[ 2019.11.05.22.59.37.295.0 ]--
r 219                     StdOut.println("AHHHHHHHHH --------)
--[ 2019.11.05.22.59.37.326.0 ]--
r 219                     StdOut.println("AHHHHHHHHH ---------)
--[ 2019.11.05.22.59.37.357.0 ]--
r 219                     StdOut.println("AHHHHHHHHH ----------)
--[ 2019.11.05.22.59.37.387.0 ]--
r 219                     StdOut.println("AHHHHHHHHH -----------)
--[ 2019.11.05.22.59.37.432.0 ]--
r 219                     StdOut.println("AHHHHHHHHH ------------)
--[ 2019.11.05.22.59.37.465.0 ]--
r 219                     StdOut.println("AHHHHHHHHH -------------)
--[ 2019.11.05.22.59.37.496.0 ]--
r 219                     StdOut.println("AHHHHHHHHH --------------)
--[ 2019.11.05.22.59.37.572.0 ]--
r 219                     StdOut.println("AHHHHHHHHH ---------------)
--[ 2019.11.05.22.59.37.875.0 ]--
r 219                     StdOut.println("AHHHHHHHHH ----------------)
--[ 2019.11.05.22.59.37.923.0 ]--
r 219                     StdOut.println("AHHHHHHHHH --------------------------)
--[ 2019.11.05.22.59.37.954.0 ]--
r 219                     StdOut.println("AHHHHHHHHH ---------------------------)
--[ 2019.11.05.22.59.37.985.0 ]--
r 219                     StdOut.println("AHHHHHHHHH ----------------------------)
--[ 2019.11.05.22.59.38.016.0 ]--
r 219                     StdOut.println("AHHHHHHHHH -----------------------------)
--[ 2019.11.05.22.59.38.046.0 ]--
r 219                     StdOut.println("AHHHHHHHHH ------------------------------)
--[ 2019.11.05.22.59.38.076.0 ]--
r 219                     StdOut.println("AHHHHHHHHH -------------------------------)
--[ 2019.11.05.22.59.38.103.0 ]--
r 219                     StdOut.println("AHHHHHHHHH --------------------------------)
--[ 2019.11.05.22.59.38.139.0 ]--
r 219                     StdOut.println("AHHHHHHHHH ---------------------------------)
--[ 2019.11.05.22.59.38.170.0 ]--
r 219                     StdOut.println("AHHHHHHHHH ----------------------------------)
--[ 2019.11.05.22.59.38.203.0 ]--
r 219                     StdOut.println("AHHHHHHHHH -----------------------------------)
--[ 2019.11.05.22.59.38.234.0 ]--
r 219                     StdOut.println("AHHHHHHHHH ------------------------------------)
--[ 2019.11.05.22.59.38.264.0 ]--
r 219                     StdOut.println("AHHHHHHHHH -------------------------------------)
--[ 2019.11.05.22.59.38.300.0 ]--
r 219                     StdOut.println("AHHHHHHHHH --------------------------------------)
--[ 2019.11.05.22.59.38.608.0 ]--
r 219                     StdOut.println("AHHHHHHHHH --------------------------------------")
--[ 2019.11.05.22.59.42.290.0 ]--
r 219                     StdOut.println("AHHHHHHHHH --------------------------------------");
--[ 2019.11.05.22.59.46.879.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.23.02.44.508.0 ]--
r 198                 board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = .0f;
--[ 2019.11.05.23.02.46.410.0 ]--
r 198                 board[currentNode.getLoc().getI()][currentNode.getLoc().getJ()] = 1.0f;
--[ 2019.11.05.23.03.03.286.0 ]--
+ 198                 
--[ 2019.11.05.23.03.03.729.0 ]--
r 198                 I
--[ 2019.11.05.23.03.03.818.0 ]--
r 198                 IN
--[ 2019.11.05.23.03.03.855.0 ]--
r 198                 INT
--[ 2019.11.05.23.03.03.961.0 ]--
r 198                 INT 
--[ 2019.11.05.23.03.04.117.0 ]--
r 198                 INT I
--[ 2019.11.05.23.03.04.190.0 ]--
r 198                 INT I 
--[ 2019.11.05.23.03.04.331.0 ]--
r 198                 INT I =
--[ 2019.11.05.23.03.04.559.0 ]--
r 198                 INT I 
--[ 2019.11.05.23.03.04.736.0 ]--
r 198                 INT I
--[ 2019.11.05.23.03.04.894.0 ]--
r 198                 INT 
--[ 2019.11.05.23.03.05.037.0 ]--
r 198                 INT
--[ 2019.11.05.23.03.05.225.0 ]--
r 198                 IN
--[ 2019.11.05.23.03.05.367.0 ]--
r 198                 I
--[ 2019.11.05.23.03.05.764.0 ]--
r 198                 
--[ 2019.11.05.23.03.06.119.0 ]--
r 198                 i
--[ 2019.11.05.23.03.06.207.0 ]--
r 198                 in
--[ 2019.11.05.23.03.06.249.0 ]--
r 198                 int
--[ 2019.11.05.23.03.06.329.0 ]--
r 198                 int 
--[ 2019.11.05.23.03.06.412.0 ]--
r 198                 int i
--[ 2019.11.05.23.03.06.527.0 ]--
r 198                 int i 
--[ 2019.11.05.23.03.06.644.0 ]--
r 198                 int i =
--[ 2019.11.05.23.03.06.838.0 ]--
r 198                 int i = 
--[ 2019.11.05.23.03.07.328.0 ]--
r 198                 int i = c
--[ 2019.11.05.23.03.07.462.0 ]--
r 198                 int i = cu
--[ 2019.11.05.23.03.07.611.0 ]--
r 198                 int i = cur
--[ 2019.11.05.23.03.07.768.0 ]--
r 198                 int i = curr
--[ 2019.11.05.23.03.07.843.0 ]--
r 198                 int i = curre
--[ 2019.11.05.23.03.07.952.0 ]--
r 198                 int i = curren
--[ 2019.11.05.23.03.08.009.0 ]--
r 198                 int i = current
--[ 2019.11.05.23.03.08.193.0 ]--
r 198                 int i = currentN
--[ 2019.11.05.23.03.08.378.0 ]--
r 198                 int i = currentNo
--[ 2019.11.05.23.03.08.481.0 ]--
r 198                 int i = currentNod
--[ 2019.11.05.23.03.08.684.0 ]--
r 198                 int i = currentNode
--[ 2019.11.05.23.03.08.778.0 ]--
r 198                 int i = currentNode.
--[ 2019.11.05.23.03.10.240.0 ]--
r 198                 int i = currentNode.g
--[ 2019.11.05.23.03.10.365.0 ]--
r 198                 int i = currentNode.ge
--[ 2019.11.05.23.03.10.582.0 ]--
r 198                 int i = currentNode.get
--[ 2019.11.05.23.03.14.683.0 ]--
r 198                 int i = currentNode.getL
--[ 2019.11.05.23.03.15.016.0 ]--
r 198                 int i = currentNode.getLoc
--[ 2019.11.05.23.03.15.208.0 ]--
r 198                 int i = currentNode.getLoc()
--[ 2019.11.05.23.03.15.505.0 ]--
r 198                 int i = currentNode.getLoc().
--[ 2019.11.05.23.03.15.680.0 ]--
r 198                 int i = currentNode.getLoc().g
--[ 2019.11.05.23.03.15.745.0 ]--
r 198                 int i = currentNode.getLoc().ge
--[ 2019.11.05.23.03.15.854.0 ]--
r 198                 int i = currentNode.getLoc().get
--[ 2019.11.05.23.03.16.073.0 ]--
r 198                 int i = currentNode.getLoc().getI
--[ 2019.11.05.23.03.16.359.0 ]--
r 198                 int i = currentNode.getLoc().getI()
--[ 2019.11.05.23.03.16.651.0 ]--
r 198                 int i = currentNode.getLoc().getI();
--[ 2019.11.05.23.03.16.921.0 ]--
+ 199                 
--[ 2019.11.05.23.03.17.641.0 ]--
r 199                 i
--[ 2019.11.05.23.03.17.780.0 ]--
r 199                 in
--[ 2019.11.05.23.03.17.844.0 ]--
r 199                 int
--[ 2019.11.05.23.03.17.927.0 ]--
r 199                 int 
--[ 2019.11.05.23.03.18.044.0 ]--
r 199                 int j
--[ 2019.11.05.23.03.18.149.0 ]--
r 199                 int j 
--[ 2019.11.05.23.03.18.257.0 ]--
r 199                 int j =
--[ 2019.11.05.23.03.18.301.0 ]--
r 199                 int j =-
--[ 2019.11.05.23.03.18.341.0 ]--
r 199                 int j =- 
--[ 2019.11.05.23.03.18.655.0 ]--
r 199                 int j =-
--[ 2019.11.05.23.03.18.814.0 ]--
r 199                 int j =
--[ 2019.11.05.23.03.18.952.0 ]--
r 199                 int j = 
--[ 2019.11.05.23.03.19.143.0 ]--
r 199                 int j = c
--[ 2019.11.05.23.03.19.267.0 ]--
r 199                 int j = cu
--[ 2019.11.05.23.03.19.394.0 ]--
r 199                 int j = cur
--[ 2019.11.05.23.03.19.574.0 ]--
r 199                 int j = curr
--[ 2019.11.05.23.03.19.664.0 ]--
r 199                 int j = curre
--[ 2019.11.05.23.03.19.805.0 ]--
r 199                 int j = curren
--[ 2019.11.05.23.03.19.844.0 ]--
r 199                 int j = current
--[ 2019.11.05.23.03.20.038.0 ]--
r 199                 int j = currentN
--[ 2019.11.05.23.03.20.175.0 ]--
r 199                 int j = currentNo
--[ 2019.11.05.23.03.20.251.0 ]--
r 199                 int j = currentNod
--[ 2019.11.05.23.03.20.440.0 ]--
r 199                 int j = currentNode
--[ 2019.11.05.23.03.20.514.0 ]--
r 199                 int j = currentNode.
--[ 2019.11.05.23.03.20.650.0 ]--
r 199                 int j = currentNode.g
--[ 2019.11.05.23.03.20.721.0 ]--
r 199                 int j = currentNode.ge
--[ 2019.11.05.23.03.20.856.0 ]--
r 199                 int j = currentNode.get
--[ 2019.11.05.23.03.21.006.0 ]--
r 199                 int j = currentNode.getL
--[ 2019.11.05.23.03.21.153.0 ]--
r 199                 int j = currentNode.getLo
--[ 2019.11.05.23.03.21.240.0 ]--
r 199                 int j = currentNode.getLoc
--[ 2019.11.05.23.03.21.382.0 ]--
r 199                 int j = currentNode.getLoc.
--[ 2019.11.05.23.03.21.514.0 ]--
r 199                 int j = currentNode.getLoc.g
--[ 2019.11.05.23.03.21.587.0 ]--
r 199                 int j = currentNode.getLoc.ge
--[ 2019.11.05.23.03.21.731.0 ]--
r 199                 int j = currentNode.getLoc.get
--[ 2019.11.05.23.03.21.931.0 ]--
r 199                 int j = currentNode.getLoc.getJ
--[ 2019.11.05.23.03.22.273.0 ]--
r 199                 int j = currentNode.getLoc.getJ()
--[ 2019.11.05.23.03.22.568.0 ]--
r 199                 int j = currentNode.getLoc.getJ();
--[ 2019.11.05.23.03.25.601.0 ]--
r 199                 int j = currentNode.getLoc().getJ();
--[ 2019.11.05.23.03.30.254.0 ]--
r 200                 board[i][currentNode.getLoc().getJ()] = 1.0f;
--[ 2019.11.05.23.03.33.942.0 ]--
r 200                 board[i][j] = 1.0f;
--[ 2019.11.05.23.03.36.484.0 ]--
r 200                 board[i][j] = t;
--[ 2019.11.05.23.03.36.844.0 ]--
r 200                 board[i][j] = ter;
--[ 2019.11.05.23.03.36.915.0 ]--
r 200                 board[i][j] = terr;
--[ 2019.11.05.23.03.36.996.0 ]--
r 200                 board[i][j] = terra;
--[ 2019.11.05.23.03.37.061.0 ]--
r 200                 board[i][j] = terrai;
--[ 2019.11.05.23.03.37.122.0 ]--
r 200                 board[i][j] = terrain;
--[ 2019.11.05.23.03.37.297.0 ]--
r 200                 board[i][j] = terrain.;
--[ 2019.11.05.23.03.37.416.0 ]--
r 200                 board[i][j] = terrain.g;
--[ 2019.11.05.23.03.37.483.0 ]--
r 200                 board[i][j] = terrain.ge;
--[ 2019.11.05.23.03.37.618.0 ]--
r 200                 board[i][j] = terrain.get;
--[ 2019.11.05.23.03.37.881.0 ]--
r 200                 board[i][j] = terrain.getH;
--[ 2019.11.05.23.03.37.997.0 ]--
r 200                 board[i][j] = terrain.getHe;
--[ 2019.11.05.23.03.38.103.0 ]--
r 200                 board[i][j] = terrain.getHei;
--[ 2019.11.05.23.03.38.184.0 ]--
r 200                 board[i][j] = terrain.getHeig;
--[ 2019.11.05.23.03.38.276.0 ]--
r 200                 board[i][j] = terrain.getHeigh;
--[ 2019.11.05.23.03.38.392.0 ]--
r 200                 board[i][j] = terrain.getHeight;
--[ 2019.11.05.23.03.38.560.0 ]--
r 200                 board[i][j] = terrain.getHeight();
--[ 2019.11.05.23.03.38.817.0 ]--
r 200                 board[i][j] = terrain.getHeight(i);
--[ 2019.11.05.23.03.39.016.0 ]--
r 200                 board[i][j] = terrain.getHeight(i,);
--[ 2019.11.05.23.03.39.103.0 ]--
r 200                 board[i][j] = terrain.getHeight(i, );
--[ 2019.11.05.23.03.39.266.0 ]--
r 200                 board[i][j] = terrain.getHeight(i, j);
--[ 2019.11.05.23.03.53.353.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.23.05.52.184.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 47     private final static String emapFilename = emaps[0];        // change index to load a different elevation map
--[ 2019.11.05.23.05.55.788.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.23.06.29.307.0 ]--
:/src/Pathfinder.java
r 59                 /StdOut.println("getting cost: " + a);
--[ 2019.11.05.23.06.29.787.0 ]--
r 59                 //StdOut.println("getting cost: " + a);
--[ 2019.11.05.23.06.30.707.0 ]--
r 60                 /StdOut.println("computed from b: " + ab);
--[ 2019.11.05.23.06.30.936.0 ]--
r 60                 //StdOut.println("computed from b: " + ab);
--[ 2019.11.05.23.06.31.601.0 ]--
r 61                 /StdOut.print("addition: ");
--[ 2019.11.05.23.06.31.819.0 ]--
r 61                 //StdOut.print("addition: ");
--[ 2019.11.05.23.06.32.345.0 ]--
r 62                 /StdOut.println(a+ab);
--[ 2019.11.05.23.06.32.573.0 ]--
r 62                 //StdOut.println(a+ab);
--[ 2019.11.05.23.06.37.078.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.23.06.48.086.0 ]--
r 221                     /StdOut.println("AHHHHHHHHH --------------------------------------");
--[ 2019.11.05.23.06.48.361.0 ]--
r 221                     //StdOut.println("AHHHHHHHHH --------------------------------------");
--[ 2019.11.05.23.06.49.081.0 ]--
r 219                    / StdOut.println("inserting " + c.getLoc() + ' ' + c.getCost(h));
--[ 2019.11.05.23.06.49.346.0 ]--
r 219                    // StdOut.println("inserting " + c.getLoc() + ' ' + c.getCost(h));
--[ 2019.11.05.23.06.50.850.0 ]--
r 219                    / StdOut.println("inserting " + c.getLoc() + ' ' + c.getCost(h));
--[ 2019.11.05.23.06.51.023.0 ]--
r 219                     StdOut.println("inserting " + c.getLoc() + ' ' + c.getCost(h));
--[ 2019.11.05.23.06.51.784.0 ]--
r 219                     /StdOut.println("inserting " + c.getLoc() + ' ' + c.getCost(h));
--[ 2019.11.05.23.06.51.975.0 ]--
r 219                     //StdOut.println("inserting " + c.getLoc() + ' ' + c.getCost(h));
--[ 2019.11.05.23.06.56.418.0 ]--
r 208                 /StdOut.println("current loc: " + currentLoc + " from: " + currentNode.fromNode.getLoc() + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.23.06.56.668.0 ]--
r 208                 //StdOut.println("current loc: " + currentLoc + " from: " + currentNode.fromNode.getLoc() + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.23.06.57.689.0 ]--
r 210                 /StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.23.06.57.923.0 ]--
r 210                 //StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.23.07.02.524.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.23.07.11.266.0 ]--
r 226             /printOrigBoard();
--[ 2019.11.05.23.07.11.473.0 ]--
r 226             //printOrigBoard();
--[ 2019.11.05.23.07.15.758.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.23.08.15.064.0 ]--
+ 230         
--[ 2019.11.05.23.08.16.566.0 ]--
r 230         S
--[ 2019.11.05.23.08.16.777.0 ]--
r 230         St
--[ 2019.11.05.23.08.16.969.0 ]--
r 230         Std
--[ 2019.11.05.23.08.17.131.0 ]--
r 230         StdO
--[ 2019.11.05.23.08.17.322.0 ]--
r 230         StdOu
--[ 2019.11.05.23.08.17.427.0 ]--
r 230         StdOut
--[ 2019.11.05.23.08.17.541.0 ]--
r 230         StdOut.
--[ 2019.11.05.23.08.17.808.0 ]--
r 230         StdOut.p
--[ 2019.11.05.23.08.17.933.0 ]--
r 230         StdOut.pr
--[ 2019.11.05.23.08.18.032.0 ]--
r 230         StdOut.pri
--[ 2019.11.05.23.08.18.141.0 ]--
r 230         StdOut.prin
--[ 2019.11.05.23.08.18.235.0 ]--
r 230         StdOut.print
--[ 2019.11.05.23.08.18.400.0 ]--
r 230         StdOut.printn
--[ 2019.11.05.23.08.18.788.0 ]--
r 230         StdOut.print
--[ 2019.11.05.23.08.19.045.0 ]--
r 230         StdOut.printl
--[ 2019.11.05.23.08.19.183.0 ]--
r 230         StdOut.println
--[ 2019.11.05.23.08.19.467.0 ]--
r 230         StdOut.println9
--[ 2019.11.05.23.08.20.109.0 ]--
r 230         StdOut.println
--[ 2019.11.05.23.08.20.615.0 ]--
r 230         StdOut.println()
--[ 2019.11.05.23.08.21.090.0 ]--
r 230         StdOut.println("")
--[ 2019.11.05.23.08.21.553.0 ]--
r 230         StdOut.println("E")
--[ 2019.11.05.23.08.21.633.0 ]--
r 230         StdOut.println("EL")
--[ 2019.11.05.23.08.21.741.0 ]--
r 230         StdOut.println("ELE")
--[ 2019.11.05.23.08.21.952.0 ]--
r 230         StdOut.println("ELEV")
--[ 2019.11.05.23.08.22.075.0 ]--
r 230         StdOut.println("ELEVA")
--[ 2019.11.05.23.08.22.204.0 ]--
r 230         StdOut.println("ELEVAT")
--[ 2019.11.05.23.08.22.300.0 ]--
r 230         StdOut.println("ELEVATI")
--[ 2019.11.05.23.08.22.357.0 ]--
r 230         StdOut.println("ELEVATIO")
--[ 2019.11.05.23.08.22.435.0 ]--
r 230         StdOut.println("ELEVATION")
--[ 2019.11.05.23.08.22.586.0 ]--
r 230         StdOut.println("ELEVATION ")
--[ 2019.11.05.23.08.22.770.0 ]--
r 230         StdOut.println("ELEVATION T")
--[ 2019.11.05.23.08.22.864.0 ]--
r 230         StdOut.println("ELEVATION TE")
--[ 2019.11.05.23.08.22.990.0 ]--
r 230         StdOut.println("ELEVATION TES")
--[ 2019.11.05.23.08.23.037.0 ]--
r 230         StdOut.println("ELEVATION TEST")
--[ 2019.11.05.23.08.23.193.0 ]--
r 230         StdOut.println("ELEVATION TESTI")
--[ 2019.11.05.23.08.23.241.0 ]--
r 230         StdOut.println("ELEVATION TESTIN")
--[ 2019.11.05.23.08.23.291.0 ]--
r 230         StdOut.println("ELEVATION TESTING")
--[ 2019.11.05.23.08.24.105.0 ]--
r 230         StdOut.println("ELEVATION TESTING");
--[ 2019.11.05.23.08.24.725.0 ]--
+ 231         
--[ 2019.11.05.23.08.30.169.0 ]--
r 231         a
--[ 2019.11.05.23.08.31.008.0 ]--
r 231         
--[ 2019.11.05.23.08.31.646.0 ]--
r 231         P
--[ 2019.11.05.23.08.31.738.0 ]--
r 231         PF
--[ 2019.11.05.23.08.31.887.0 ]--
r 231         PFN
--[ 2019.11.05.23.08.32.206.0 ]--
r 231         PFNo
--[ 2019.11.05.23.08.32.308.0 ]--
r 231         PFNod
--[ 2019.11.05.23.08.32.502.0 ]--
r 231         PFNode
--[ 2019.11.05.23.08.32.588.0 ]--
r 231         PFNode 
--[ 2019.11.05.23.08.32.688.0 ]--
r 231         PFNode a
--[ 2019.11.05.23.08.32.841.0 ]--
r 231         PFNode a 
--[ 2019.11.05.23.08.32.933.0 ]--
r 231         PFNode a =
--[ 2019.11.05.23.08.33.035.0 ]--
r 231         PFNode a = 
--[ 2019.11.05.23.08.34.038.0 ]--
r 231         PFNode a = f
--[ 2019.11.05.23.08.34.444.0 ]--
r 231         PFNode a = 
--[ 2019.11.05.23.08.35.730.0 ]--
r 231         PFNode a = f
--[ 2019.11.05.23.08.35.990.0 ]--
r 231         PFNode a = fr
--[ 2019.11.05.23.08.36.109.0 ]--
r 231         PFNode a = fro
--[ 2019.11.05.23.08.36.213.0 ]--
r 231         PFNode a = from
--[ 2019.11.05.23.08.36.462.0 ]--
r 231         PFNode a = fro
--[ 2019.11.05.23.08.36.629.0 ]--
r 231         PFNode a = fr
--[ 2019.11.05.23.08.36.803.0 ]--
r 231         PFNode a = f
--[ 2019.11.05.23.08.37.037.0 ]--
r 231         PFNode a = 
--[ 2019.11.05.23.08.37.347.0 ]--
r 231         PFNode a = n
--[ 2019.11.05.23.08.37.447.0 ]--
r 231         PFNode a = ne
--[ 2019.11.05.23.08.37.546.0 ]--
r 231         PFNode a = new
--[ 2019.11.05.23.08.37.588.0 ]--
r 231         PFNode a = new 
--[ 2019.11.05.23.08.37.830.0 ]--
r 231         PFNode a = new P
--[ 2019.11.05.23.08.37.995.0 ]--
r 231         PFNode a = new PF
--[ 2019.11.05.23.08.38.133.0 ]--
r 231         PFNode a = new PFN
--[ 2019.11.05.23.08.38.439.0 ]--
r 231         PFNode a = new PFNo
--[ 2019.11.05.23.08.38.551.0 ]--
r 231         PFNode a = new PFNod
--[ 2019.11.05.23.08.38.749.0 ]--
r 231         PFNode a = new PFNode
--[ 2019.11.05.23.08.38.947.0 ]--
r 231         PFNode a = new PFNode()
--[ 2019.11.05.23.08.39.786.0 ]--
r 231         PFNode a = new PFNode(n)
--[ 2019.11.05.23.08.40.200.0 ]--
r 231         PFNode a = new PFNode()
--[ 2019.11.05.23.08.42.906.0 ]--
r 231         PFNode a = new PFNode(a)
--[ 2019.11.05.23.08.43.246.0 ]--
r 231         PFNode a = new PFNode(ac)
--[ 2019.11.05.23.08.43.325.0 ]--
r 231         PFNode a = new PFNode(ac )
--[ 2019.11.05.23.08.43.468.0 ]--
r 231         PFNode a = new PFNode(ac =)
--[ 2019.11.05.23.08.43.575.0 ]--
r 231         PFNode a = new PFNode(ac = )
--[ 2019.11.05.23.08.43.787.0 ]--
r 231         PFNode a = new PFNode(ac = n)
--[ 2019.11.05.23.08.43.904.0 ]--
r 231         PFNode a = new PFNode(ac = ne)
--[ 2019.11.05.23.08.44.003.0 ]--
r 231         PFNode a = new PFNode(ac = new)
--[ 2019.11.05.23.08.44.064.0 ]--
r 231         PFNode a = new PFNode(ac = new )
--[ 2019.11.05.23.08.44.372.0 ]--
r 231         PFNode a = new PFNode(ac = new C)
--[ 2019.11.05.23.08.44.542.0 ]--
r 231         PFNode a = new PFNode(ac = new Co)
--[ 2019.11.05.23.08.44.721.0 ]--
r 231         PFNode a = new PFNode(ac = new Coo)
--[ 2019.11.05.23.08.44.833.0 ]--
r 231         PFNode a = new PFNode(ac = new Coor)
--[ 2019.11.05.23.08.45.001.0 ]--
r 231         PFNode a = new PFNode(ac = new Coord)
--[ 2019.11.05.23.08.45.115.0 ]--
r 231         PFNode a = new PFNode(ac = new Coor)
--[ 2019.11.05.23.08.45.756.0 ]--
r 231         PFNode a = new PFNode(ac = new Co)
--[ 2019.11.05.23.08.45.790.0 ]--
r 231         PFNode a = new PFNode(ac = new C)
--[ 2019.11.05.23.08.45.826.0 ]--
r 231         PFNode a = new PFNode(ac = new )
--[ 2019.11.05.23.08.45.865.0 ]--
r 231         PFNode a = new PFNode(ac = new)
--[ 2019.11.05.23.08.45.893.0 ]--
r 231         PFNode a = new PFNode(ac = ne)
--[ 2019.11.05.23.08.46.002.0 ]--
r 231         PFNode a = new PFNode(ac = n)
--[ 2019.11.05.23.08.46.206.0 ]--
r 231         PFNode a = new PFNode(ac = )
--[ 2019.11.05.23.08.46.382.0 ]--
r 231         PFNode a = new PFNode(ac =)
--[ 2019.11.05.23.08.46.544.0 ]--
r 231         PFNode a = new PFNode(ac )
--[ 2019.11.05.23.08.46.708.0 ]--
r 231         PFNode a = new PFNode(ac)
--[ 2019.11.05.23.08.46.945.0 ]--
r 231         PFNode a = new PFNode(a)
--[ 2019.11.05.23.08.47.142.0 ]--
r 231         PFNode a = new PFNode()
--[ 2019.11.05.23.08.47.905.0 ]--
r 231         PFNode a = new PFNode(C)
--[ 2019.11.05.23.08.48.173.0 ]--
r 231         PFNode a = new PFNode(Co)
--[ 2019.11.05.23.08.48.328.0 ]--
r 231         PFNode a = new PFNode(Coo)
--[ 2019.11.05.23.08.48.481.0 ]--
r 231         PFNode a = new PFNode(Coor)
--[ 2019.11.05.23.08.48.741.0 ]--
r 231         PFNode a = new PFNode(Coord)
--[ 2019.11.05.23.08.48.797.0 ]--
r 231         PFNode a = new PFNode(Coord )
--[ 2019.11.05.23.08.49.055.0 ]--
r 231         PFNode a = new PFNode(Coord a)
--[ 2019.11.05.23.08.49.100.0 ]--
r 231         PFNode a = new PFNode(Coord ac)
--[ 2019.11.05.23.08.49.128.0 ]--
r 231         PFNode a = new PFNode(Coord ac )
--[ 2019.11.05.23.08.49.277.0 ]--
r 231         PFNode a = new PFNode(Coord ac =)
--[ 2019.11.05.23.08.49.320.0 ]--
r 231         PFNode a = new PFNode(Coord ac = )
--[ 2019.11.05.23.08.49.511.0 ]--
r 231         PFNode a = new PFNode(Coord ac = n)
--[ 2019.11.05.23.08.49.608.0 ]--
r 231         PFNode a = new PFNode(Coord ac = ne)
--[ 2019.11.05.23.08.49.649.0 ]--
r 231         PFNode a = new PFNode(Coord ac = new)
--[ 2019.11.05.23.08.49.717.0 ]--
r 231         PFNode a = new PFNode(Coord ac = new )
--[ 2019.11.05.23.08.50.028.0 ]--
r 231         PFNode a = new PFNode(Coord ac = new C)
--[ 2019.11.05.23.08.50.199.0 ]--
r 231         PFNode a = new PFNode(Coord ac = new Co)
--[ 2019.11.05.23.08.50.339.0 ]--
r 231         PFNode a = new PFNode(Coord ac = new Coo)
--[ 2019.11.05.23.08.50.437.0 ]--
r 231         PFNode a = new PFNode(Coord ac = new Coor)
--[ 2019.11.05.23.08.50.602.0 ]--
r 231         PFNode a = new PFNode(Coord ac = new Coord)
--[ 2019.11.05.23.08.50.747.0 ]--
r 231         PFNode a = new PFNode(Coord ac = new Coord())
--[ 2019.11.05.23.08.56.258.0 ]--
r 231         PFNode a = new PFNode(Coord ac = new Coord(1))
--[ 2019.11.05.23.08.56.557.0 ]--
r 231         PFNode a = new PFNode(Coord ac = new Coord(1, ))
--[ 2019.11.05.23.08.56.626.0 ]--
r 231         PFNode a = new PFNode(Coord ac = new Coord(1, 0))
--[ 2019.11.05.23.08.57.851.0 ]--
r 231         PFNode a = new PFNode(Coord ac = new Coord(1, 0),)
--[ 2019.11.05.23.08.57.941.0 ]--
r 231         PFNode a = new PFNode(Coord ac = new Coord(1, 0), )
--[ 2019.11.05.23.09.02.933.0 ]--
r 231         PFNode a = new PFNode(new Coord(1, 0), )
--[ 2019.11.05.23.09.12.235.0 ]--
r 231         PFNode a = new PFNode(new Coord(1, 0), n)
--[ 2019.11.05.23.09.12.535.0 ]--
r 231         PFNode a = new PFNode(new Coord(1, 0), nu)
--[ 2019.11.05.23.09.12.617.0 ]--
r 231         PFNode a = new PFNode(new Coord(1, 0), nul)
--[ 2019.11.05.23.09.12.792.0 ]--
r 231         PFNode a = new PFNode(new Coord(1, 0), null)
--[ 2019.11.05.23.09.13.651.0 ]--
r 231         PFNode a = new PFNode(new Coord(1, 0), null);
--[ 2019.11.05.23.09.13.915.0 ]--
+ 232         
--[ 2019.11.05.23.09.14.591.0 ]--
r 232         P
--[ 2019.11.05.23.09.14.732.0 ]--
r 232         PF
--[ 2019.11.05.23.09.14.905.0 ]--
r 232         PFN
--[ 2019.11.05.23.09.15.198.0 ]--
r 232         PFNo
--[ 2019.11.05.23.09.15.277.0 ]--
r 232         PFNod
--[ 2019.11.05.23.09.15.493.0 ]--
r 232         PFNode
--[ 2019.11.05.23.09.15.569.0 ]--
r 232         PFNode 
--[ 2019.11.05.23.09.15.727.0 ]--
r 232         PFNode b
--[ 2019.11.05.23.09.15.871.0 ]--
r 232         PFNode b 
--[ 2019.11.05.23.09.15.927.0 ]--
r 232         PFNode b =
--[ 2019.11.05.23.09.16.087.0 ]--
r 232         PFNode b = 
--[ 2019.11.05.23.09.16.203.0 ]--
r 232         PFNode b = n
--[ 2019.11.05.23.09.16.314.0 ]--
r 232         PFNode b = ne
--[ 2019.11.05.23.09.16.407.0 ]--
r 232         PFNode b = new
--[ 2019.11.05.23.09.16.461.0 ]--
r 232         PFNode b = new 
--[ 2019.11.05.23.09.16.680.0 ]--
r 232         PFNode b = new P
--[ 2019.11.05.23.09.16.829.0 ]--
r 232         PFNode b = new PF
--[ 2019.11.05.23.09.16.970.0 ]--
r 232         PFNode b = new PFN
--[ 2019.11.05.23.09.17.277.0 ]--
r 232         PFNode b = new PFNo
--[ 2019.11.05.23.09.17.358.0 ]--
r 232         PFNode b = new PFNod
--[ 2019.11.05.23.09.17.557.0 ]--
r 232         PFNode b = new PFNode
--[ 2019.11.05.23.09.17.834.0 ]--
r 232         PFNode b = new PFNode()
--[ 2019.11.05.23.09.18.639.0 ]--
r 232         PFNode b = new PFNode(n)
--[ 2019.11.05.23.09.18.770.0 ]--
r 232         PFNode b = new PFNode(ne)
--[ 2019.11.05.23.09.18.830.0 ]--
r 232         PFNode b = new PFNode(new)
--[ 2019.11.05.23.09.18.986.0 ]--
r 232         PFNode b = new PFNode(new )
--[ 2019.11.05.23.09.19.222.0 ]--
r 232         PFNode b = new PFNode(new C)
--[ 2019.11.05.23.09.19.352.0 ]--
r 232         PFNode b = new PFNode(new Co)
--[ 2019.11.05.23.09.19.567.0 ]--
r 232         PFNode b = new PFNode(new Coo)
--[ 2019.11.05.23.09.19.669.0 ]--
r 232         PFNode b = new PFNode(new Coor)
--[ 2019.11.05.23.09.19.859.0 ]--
r 232         PFNode b = new PFNode(new Coord)
--[ 2019.11.05.23.09.20.052.0 ]--
r 232         PFNode b = new PFNode(new Coord())
--[ 2019.11.05.23.09.20.569.0 ]--
r 232         PFNode b = new PFNode(new Coord(0))
--[ 2019.11.05.23.09.20.866.0 ]--
r 232         PFNode b = new PFNode(new Coord(0,))
--[ 2019.11.05.23.09.21.050.0 ]--
r 232         PFNode b = new PFNode(new Coord(0, ))
--[ 2019.11.05.23.09.21.120.0 ]--
r 232         PFNode b = new PFNode(new Coord(0, 0))
--[ 2019.11.05.23.09.21.955.0 ]--
r 232         PFNode b = new PFNode(new Coord(0, 0),)
--[ 2019.11.05.23.09.22.037.0 ]--
r 232         PFNode b = new PFNode(new Coord(0, 0), )
--[ 2019.11.05.23.09.22.504.0 ]--
r 232         PFNode b = new PFNode(new Coord(0, 0), a)
--[ 2019.11.05.23.09.23.078.0 ]--
r 232         PFNode b = new PFNode(new Coord(0, 0), a);
--[ 2019.11.05.23.09.25.629.0 ]--
+ 233         
--[ 2019.11.05.23.09.33.356.0 ]--
r 233         S
--[ 2019.11.05.23.09.33.685.0 ]--
r 233         St
--[ 2019.11.05.23.09.33.752.0 ]--
r 233         Std
--[ 2019.11.05.23.09.33.904.0 ]--
r 233         StdO
--[ 2019.11.05.23.09.34.081.0 ]--
r 233         StdOu
--[ 2019.11.05.23.09.34.173.0 ]--
r 233         StdOut
--[ 2019.11.05.23.09.34.294.0 ]--
r 233         StdOut.
--[ 2019.11.05.23.09.34.533.0 ]--
r 233         StdOut.p
--[ 2019.11.05.23.09.34.623.0 ]--
r 233         StdOut.pr
--[ 2019.11.05.23.09.34.721.0 ]--
r 233         StdOut.pri
--[ 2019.11.05.23.09.34.854.0 ]--
r 233         StdOut.prin
--[ 2019.11.05.23.09.34.902.0 ]--
r 233         StdOut.print
--[ 2019.11.05.23.09.35.277.0 ]--
r 233         StdOut.printl
--[ 2019.11.05.23.09.35.388.0 ]--
r 233         StdOut.println
--[ 2019.11.05.23.09.35.640.0 ]--
r 233         StdOut.println()
--[ 2019.11.05.23.09.36.140.0 ]--
r 233         StdOut.println(t)
--[ 2019.11.05.23.09.36.256.0 ]--
r 233         StdOut.println(te)
--[ 2019.11.05.23.09.36.398.0 ]--
r 233         StdOut.println(ter)
--[ 2019.11.05.23.09.36.559.0 ]--
r 233         StdOut.println(terr)
--[ 2019.11.05.23.09.36.620.0 ]--
r 233         StdOut.println(terra)
--[ 2019.11.05.23.09.36.681.0 ]--
r 233         StdOut.println(terrai)
--[ 2019.11.05.23.09.36.743.0 ]--
r 233         StdOut.println(terrain)
--[ 2019.11.05.23.09.36.960.0 ]--
r 233         StdOut.println(terrain.)
--[ 2019.11.05.23.09.37.079.0 ]--
r 233         StdOut.println(terrain.c)
--[ 2019.11.05.23.09.37.198.0 ]--
r 233         StdOut.println(terrain.co)
--[ 2019.11.05.23.09.37.294.0 ]--
r 233         StdOut.println(terrain.com)
--[ 2019.11.05.23.09.37.435.0 ]--
r 233         StdOut.println(terrain.comp)
--[ 2019.11.05.23.09.37.574.0 ]--
r 233         StdOut.println(terrain.compu)
--[ 2019.11.05.23.09.37.718.0 ]--
r 233         StdOut.println(terrain.comput)
--[ 2019.11.05.23.09.37.864.0 ]--
r 233         StdOut.println(terrain.compute)
--[ 2019.11.05.23.09.39.182.0 ]--
r 233         StdOut.println(terrain.computeT)
--[ 2019.11.05.23.09.39.445.0 ]--
r 233         StdOut.println(terrain.computeTr)
--[ 2019.11.05.23.09.39.524.0 ]--
r 233         StdOut.println(terrain.computeTra)
--[ 2019.11.05.23.09.39.701.0 ]--
r 233         StdOut.println(terrain.computeTrav)
--[ 2019.11.05.23.09.39.801.0 ]--
r 233         StdOut.println(terrain.computeTrave)
--[ 2019.11.05.23.09.39.921.0 ]--
r 233         StdOut.println(terrain.computeTravel)
--[ 2019.11.05.23.09.40.132.0 ]--
r 233         StdOut.println(terrain.computeTravelC)
--[ 2019.11.05.23.09.40.422.0 ]--
r 233         StdOut.println(terrain.computeTravelCo)
--[ 2019.11.05.23.09.40.553.0 ]--
r 233         StdOut.println(terrain.computeTravelCos)
--[ 2019.11.05.23.09.40.643.0 ]--
r 233         StdOut.println(terrain.computeTravelCost)
--[ 2019.11.05.23.09.40.949.0 ]--
r 233         StdOut.println(terrain.computeTravelCost())
--[ 2019.11.05.23.09.42.170.0 ]--
r 233         StdOut.println(terrain.computeTravelCost(a))
--[ 2019.11.05.23.09.42.301.0 ]--
r 233         StdOut.println(terrain.computeTravelCost(a,))
--[ 2019.11.05.23.09.42.378.0 ]--
r 233         StdOut.println(terrain.computeTravelCost(a, ))
--[ 2019.11.05.23.09.42.573.0 ]--
r 233         StdOut.println(terrain.computeTravelCost(a, b))
--[ 2019.11.05.23.09.43.443.0 ]--
r 233         StdOut.println(terrain.computeTravelCost(a, b));
--[ 2019.11.05.23.09.43.727.0 ]--
+ 234         
--[ 2019.11.05.23.09.44.364.0 ]--
r 234         s
--[ 2019.11.05.23.09.44.702.0 ]--
r 234         
--[ 2019.11.05.23.09.44.928.0 ]--
r 234         S
--[ 2019.11.05.23.09.45.146.0 ]--
r 234         St
--[ 2019.11.05.23.09.45.321.0 ]--
r 234         Std
--[ 2019.11.05.23.09.45.456.0 ]--
r 234         StdO
--[ 2019.11.05.23.09.45.652.0 ]--
r 234         StdOu
--[ 2019.11.05.23.09.45.776.0 ]--
r 234         StdOut
--[ 2019.11.05.23.09.45.887.0 ]--
r 234         StdOut.
--[ 2019.11.05.23.09.46.219.0 ]--
r 234         StdOut.p
--[ 2019.11.05.23.09.46.262.0 ]--
r 234         StdOut.pr
--[ 2019.11.05.23.09.46.322.0 ]--
r 234         StdOut.pri
--[ 2019.11.05.23.09.46.437.0 ]--
r 234         StdOut.prin
--[ 2019.11.05.23.09.46.576.0 ]--
r 234         StdOut.print
--[ 2019.11.05.23.09.46.672.0 ]--
r 234         StdOut.printl
--[ 2019.11.05.23.09.46.712.0 ]--
r 234         StdOut.println
--[ 2019.11.05.23.09.46.940.0 ]--
r 234         StdOut.println()
--[ 2019.11.05.23.09.47.560.0 ]--
r 234         StdOut.println(t)
--[ 2019.11.05.23.09.47.665.0 ]--
r 234         StdOut.println(te)
--[ 2019.11.05.23.09.47.802.0 ]--
r 234         StdOut.println(ter)
--[ 2019.11.05.23.09.47.951.0 ]--
r 234         StdOut.println(terr)
--[ 2019.11.05.23.09.48.040.0 ]--
r 234         StdOut.println(terra)
--[ 2019.11.05.23.09.48.073.0 ]--
r 234         StdOut.println(terrai)
--[ 2019.11.05.23.09.48.158.0 ]--
r 234         StdOut.println(terrain)
--[ 2019.11.05.23.09.48.364.0 ]--
r 234         StdOut.println(terrain.)
--[ 2019.11.05.23.09.48.474.0 ]--
r 234         StdOut.println(terrain.c)
--[ 2019.11.05.23.09.48.642.0 ]--
r 234         StdOut.println(terrain.co)
--[ 2019.11.05.23.09.48.761.0 ]--
r 234         StdOut.println(terrain.com)
--[ 2019.11.05.23.09.48.887.0 ]--
r 234         StdOut.println(terrain.comp)
--[ 2019.11.05.23.09.49.025.0 ]--
r 234         StdOut.println(terrain.compu)
--[ 2019.11.05.23.09.49.171.0 ]--
r 234         StdOut.println(terrain.comput)
--[ 2019.11.05.23.09.49.266.0 ]--
r 234         StdOut.println(terrain.compute)
--[ 2019.11.05.23.09.49.573.0 ]--
r 234         StdOut.println(terrain.computeT)
--[ 2019.11.05.23.09.49.777.0 ]--
r 234         StdOut.println(terrain.computeTr)
--[ 2019.11.05.23.09.49.835.0 ]--
r 234         StdOut.println(terrain.computeTra)
--[ 2019.11.05.23.09.49.984.0 ]--
r 234         StdOut.println(terrain.computeTrav)
--[ 2019.11.05.23.09.50.058.0 ]--
r 234         StdOut.println(terrain.computeTrave)
--[ 2019.11.05.23.09.50.149.0 ]--
r 234         StdOut.println(terrain.computeTravel)
--[ 2019.11.05.23.09.50.343.0 ]--
r 234         StdOut.println(terrain.computeTravelC)
--[ 2019.11.05.23.09.50.501.0 ]--
r 234         StdOut.println(terrain.computeTravelCo)
--[ 2019.11.05.23.09.50.609.0 ]--
r 234         StdOut.println(terrain.computeTravelCos)
--[ 2019.11.05.23.09.50.705.0 ]--
r 234         StdOut.println(terrain.computeTravelCost)
--[ 2019.11.05.23.09.50.929.0 ]--
r 234         StdOut.println(terrain.computeTravelCost())
--[ 2019.11.05.23.09.51.123.0 ]--
r 234         StdOut.println(terrain.computeTravelCost(b))
--[ 2019.11.05.23.09.51.240.0 ]--
r 234         StdOut.println(terrain.computeTravelCost(b,))
--[ 2019.11.05.23.09.51.300.0 ]--
r 234         StdOut.println(terrain.computeTravelCost(b, ))
--[ 2019.11.05.23.09.51.466.0 ]--
r 234         StdOut.println(terrain.computeTravelCost(b, a))
--[ 2019.11.05.23.09.52.294.0 ]--
r 234         StdOut.println(terrain.computeTravelCost(b, a));
--[ 2019.11.05.23.09.59.672.0 ]--
r 233         StdOut.println(terrain.computeTravelCost(a., b));
--[ 2019.11.05.23.10.00.067.0 ]--
r 233         StdOut.println(terrain.computeTravelCost(a.get, b));
--[ 2019.11.05.23.10.00.148.0 ]--
r 233         StdOut.println(terrain.computeTravelCost(a.getL, b));
--[ 2019.11.05.23.10.00.310.0 ]--
r 233         StdOut.println(terrain.computeTravelCost(a.getLo, b));
--[ 2019.11.05.23.10.00.408.0 ]--
r 233         StdOut.println(terrain.computeTravelCost(a.getLoc, b));
--[ 2019.11.05.23.10.00.768.0 ]--
r 233         StdOut.println(terrain.computeTravelCost(a.getLoc(), b));
--[ 2019.11.05.23.10.04.953.0 ]--
r 233         StdOut.println(terrain.computeTravelCost(a.getLoc(), b.));
--[ 2019.11.05.23.10.05.025.0 ]--
r 233         StdOut.println(terrain.computeTravelCost(a.getLoc(), b.g));
--[ 2019.11.05.23.10.05.125.0 ]--
r 233         StdOut.println(terrain.computeTravelCost(a.getLoc(), b.ge));
--[ 2019.11.05.23.10.05.263.0 ]--
r 233         StdOut.println(terrain.computeTravelCost(a.getLoc(), b.get));
--[ 2019.11.05.23.10.05.399.0 ]--
r 233         StdOut.println(terrain.computeTravelCost(a.getLoc(), b.getL));
--[ 2019.11.05.23.10.05.564.0 ]--
r 233         StdOut.println(terrain.computeTravelCost(a.getLoc(), b.getLo));
--[ 2019.11.05.23.10.05.811.0 ]--
r 233         StdOut.println(terrain.computeTravelCost(a.getLoc(), b.getLoc));
--[ 2019.11.05.23.10.06.165.0 ]--
r 233         StdOut.println(terrain.computeTravelCost(a.getLoc(), b.getLoc()));
--[ 2019.11.05.23.10.08.943.0 ]--
r 234         StdOut.println(terrain.computeTravelCost(b., a));
--[ 2019.11.05.23.10.09.005.0 ]--
r 234         StdOut.println(terrain.computeTravelCost(b.g, a));
--[ 2019.11.05.23.10.09.110.0 ]--
r 234         StdOut.println(terrain.computeTravelCost(b.ge, a));
--[ 2019.11.05.23.10.09.253.0 ]--
r 234         StdOut.println(terrain.computeTravelCost(b.get, a));
--[ 2019.11.05.23.10.09.405.0 ]--
r 234         StdOut.println(terrain.computeTravelCost(b.getL, a));
--[ 2019.11.05.23.10.09.571.0 ]--
r 234         StdOut.println(terrain.computeTravelCost(b.getLo, a));
--[ 2019.11.05.23.10.09.877.0 ]--
r 234         StdOut.println(terrain.computeTravelCost(b.getLoc, a));
--[ 2019.11.05.23.10.10.065.0 ]--
r 234         StdOut.println(terrain.computeTravelCost(b.getLoc(), a));
--[ 2019.11.05.23.10.11.668.0 ]--
r 234         StdOut.println(terrain.computeTravelCost(b.getLoc(), a.));
--[ 2019.11.05.23.10.12.080.0 ]--
r 234         StdOut.println(terrain.computeTravelCost(b.getLoc(), a.g));
--[ 2019.11.05.23.10.12.185.0 ]--
r 234         StdOut.println(terrain.computeTravelCost(b.getLoc(), a.ge));
--[ 2019.11.05.23.10.12.329.0 ]--
r 234         StdOut.println(terrain.computeTravelCost(b.getLoc(), a.get));
--[ 2019.11.05.23.10.12.539.0 ]--
r 234         StdOut.println(terrain.computeTravelCost(b.getLoc(), a.getL));
--[ 2019.11.05.23.10.12.709.0 ]--
r 234         StdOut.println(terrain.computeTravelCost(b.getLoc(), a.getLo));
--[ 2019.11.05.23.10.12.810.0 ]--
r 234         StdOut.println(terrain.computeTravelCost(b.getLoc(), a.getLoc));
--[ 2019.11.05.23.10.13.224.0 ]--
r 234         StdOut.println(terrain.computeTravelCost(b.getLoc(), a.getLoc()));
--[ 2019.11.05.23.10.18.597.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.23.11.20.661.0 ]--
UpdateTree (AD): 2 0
+ /src/elevationTests
+ /heightmaps/elevationTests

--[ 2019.11.05.23.11.20.678.0 ]--
InitFile: /src/elevationTests


--[ 2019.11.05.23.11.27.998.0 ]--
UpdateTree (AD): 0 1
- /heightmaps/elevationTests

--[ 2019.11.05.23.11.32.406.0 ]--
UpdateTree (AD): 0 1
- /src/elevationTests

--[ 2019.11.05.23.11.42.456.0 ]--
UpdateTree (AD): 1 0
+ /heightmaps/elevationTests

--[ 2019.11.05.23.12.12.115.0 ]--
UpdateTree (AD): 0 1
- /heightmaps/elevationTests

--[ 2019.11.05.23.12.24.574.0 ]--
UpdateTree (AD): 1 0
+ /heightmaps/elevationTests.emap

--[ 2019.11.05.23.12.40.006.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.23.12.48.206.0 ]--
:/src/InteractivePathfinderVisualizer.java
+ 45             
--[ 2019.11.05.23.12.48.224.0 ]--
UpdateTree (AD): 1 0
+ /out/production/P04_Pathfinding/elevationTests.emap

--[ 2019.11.05.23.12.48.454.0 ]--
r 45             ""
--[ 2019.11.05.23.12.49.876.0 ]--
r 45             "e"
--[ 2019.11.05.23.12.49.968.0 ]--
r 45             "el"
--[ 2019.11.05.23.12.50.057.0 ]--
r 45             "ele"
--[ 2019.11.05.23.12.50.265.0 ]--
r 45             "elev"
--[ 2019.11.05.23.12.50.353.0 ]--
r 45             "eleva"
--[ 2019.11.05.23.12.50.523.0 ]--
r 45             "elevat"
--[ 2019.11.05.23.12.50.663.0 ]--
r 45             "elevati"
--[ 2019.11.05.23.12.50.725.0 ]--
r 45             "elevatio"
--[ 2019.11.05.23.12.50.789.0 ]--
r 45             "elevation"
--[ 2019.11.05.23.12.51.014.0 ]--
r 45             "elevationT"
--[ 2019.11.05.23.12.51.163.0 ]--
r 45             "elevationTe"
--[ 2019.11.05.23.12.51.348.0 ]--
r 45             "elevationTet"
--[ 2019.11.05.23.12.51.744.0 ]--
r 45             "elevationTe"
--[ 2019.11.05.23.12.51.896.0 ]--
r 45             "elevationTes"
--[ 2019.11.05.23.12.51.961.0 ]--
r 45             "elevationTest"
--[ 2019.11.05.23.12.52.086.0 ]--
r 45             "elevationTests"
--[ 2019.11.05.23.12.52.217.0 ]--
r 45             "elevationTests."
--[ 2019.11.05.23.12.52.315.0 ]--
r 45             "elevationTests.e"
--[ 2019.11.05.23.12.52.450.0 ]--
r 45             "elevationTests.em"
--[ 2019.11.05.23.12.52.552.0 ]--
r 45             "elevationTests.ema"
--[ 2019.11.05.23.12.52.632.0 ]--
r 45             "elevationTests.emap"
--[ 2019.11.05.23.12.53.261.0 ]--
r 45             "elevationTests.emap",
--[ 2019.11.05.23.12.53.992.0 ]--
r 45             "elevationTests.emap", 
--[ 2019.11.05.23.12.54.248.0 ]--
r 45             "elevationTests.emap", /
--[ 2019.11.05.23.12.54.277.0 ]--
r 45             "elevationTests.emap", //
--[ 2019.11.05.23.12.54.616.0 ]--
r 45             "elevationTests.emap", /
--[ 2019.11.05.23.12.54.782.0 ]--
r 45             "elevationTests.emap", 
--[ 2019.11.05.23.12.54.968.0 ]--
r 45             "elevationTests.emap",  
--[ 2019.11.05.23.12.55.379.0 ]--
r 45             "elevationTests.emap",  /
--[ 2019.11.05.23.12.55.502.0 ]--
r 45             "elevationTests.emap",  //
--[ 2019.11.05.23.12.55.564.0 ]--
r 45             "elevationTests.emap",  // 
--[ 2019.11.05.23.12.55.976.0 ]--
r 45             "elevationTests.emap",  // 1
--[ 2019.11.05.23.12.56.023.0 ]--
r 45             "elevationTests.emap",  // 13
--[ 2019.11.05.23.12.56.197.0 ]--
r 45             "elevationTests.emap",  // 13 
--[ 2019.11.05.23.12.56.433.0 ]--
r 45             "elevationTests.emap",  // 13 (
--[ 2019.11.05.23.12.57.319.0 ]--
r 45             "elevationTests.emap",  // 13 
--[ 2019.11.05.23.12.57.418.0 ]--
r 45             "elevationTests.emap",  // 13  
--[ 2019.11.05.23.12.57.943.0 ]--
r 45             "elevationTests.emap",  // 13  (
--[ 2019.11.05.23.12.58.236.0 ]--
r 45             "elevationTests.emap",  // 13  (f
--[ 2019.11.05.23.12.58.311.0 ]--
r 45             "elevationTests.emap",  // 13  (fo
--[ 2019.11.05.23.12.58.435.0 ]--
r 45             "elevationTests.emap",  // 13  (for
--[ 2019.11.05.23.12.58.534.0 ]--
r 45             "elevationTests.emap",  // 13  (for 
--[ 2019.11.05.23.12.58.650.0 ]--
r 45             "elevationTests.emap",  // 13  (for m
--[ 2019.11.05.23.12.58.718.0 ]--
r 45             "elevationTests.emap",  // 13  (for me
--[ 2019.11.05.23.12.58.817.0 ]--
r 45             "elevationTests.emap",  // 13  (for me 
--[ 2019.11.05.23.12.58.989.0 ]--
r 45             "elevationTests.emap",  // 13  (for me t
--[ 2019.11.05.23.12.59.071.0 ]--
r 45             "elevationTests.emap",  // 13  (for me to
--[ 2019.11.05.23.12.59.206.0 ]--
r 45             "elevationTests.emap",  // 13  (for me to 
--[ 2019.11.05.23.12.59.368.0 ]--
r 45             "elevationTests.emap",  // 13  (for me to c
--[ 2019.11.05.23.12.59.446.0 ]--
r 45             "elevationTests.emap",  // 13  (for me to co
--[ 2019.11.05.23.12.59.534.0 ]--
r 45             "elevationTests.emap",  // 13  (for me to com
--[ 2019.11.05.23.12.59.653.0 ]--
r 45             "elevationTests.emap",  // 13  (for me to comp
--[ 2019.11.05.23.12.59.759.0 ]--
r 45             "elevationTests.emap",  // 13  (for me to compr
--[ 2019.11.05.23.12.59.836.0 ]--
r 45             "elevationTests.emap",  // 13  (for me to compre
--[ 2019.11.05.23.12.59.944.0 ]--
r 45             "elevationTests.emap",  // 13  (for me to compreh
--[ 2019.11.05.23.13.00.040.0 ]--
r 45             "elevationTests.emap",  // 13  (for me to comprehe
--[ 2019.11.05.23.13.00.143.0 ]--
r 45             "elevationTests.emap",  // 13  (for me to comprehen
--[ 2019.11.05.23.13.00.237.0 ]--
r 45             "elevationTests.emap",  // 13  (for me to comprehend
--[ 2019.11.05.23.13.00.328.0 ]--
r 45             "elevationTests.emap",  // 13  (for me to comprehend 
--[ 2019.11.05.23.13.00.437.0 ]--
r 45             "elevationTests.emap",  // 13  (for me to comprehend e
--[ 2019.11.05.23.13.00.527.0 ]--
r 45             "elevationTests.emap",  // 13  (for me to comprehend el
--[ 2019.11.05.23.13.00.639.0 ]--
r 45             "elevationTests.emap",  // 13  (for me to comprehend ele
--[ 2019.11.05.23.13.00.865.0 ]--
r 45             "elevationTests.emap",  // 13  (for me to comprehend elev
--[ 2019.11.05.23.13.00.938.0 ]--
r 45             "elevationTests.emap",  // 13  (for me to comprehend eleva
--[ 2019.11.05.23.13.01.076.0 ]--
r 45             "elevationTests.emap",  // 13  (for me to comprehend elevat
--[ 2019.11.05.23.13.01.160.0 ]--
r 45             "elevationTests.emap",  // 13  (for me to comprehend elevati
--[ 2019.11.05.23.13.01.226.0 ]--
r 45             "elevationTests.emap",  // 13  (for me to comprehend elevatio
--[ 2019.11.05.23.13.01.322.0 ]--
r 45             "elevationTests.emap",  // 13  (for me to comprehend elevation
--[ 2019.11.05.23.13.01.353.0 ]--
r 45             "elevationTests.emap",  // 13  (for me to comprehend elevation 
--[ 2019.11.05.23.13.01.513.0 ]--
r 45             "elevationTests.emap",  // 13  (for me to comprehend elevation s
--[ 2019.11.05.23.13.01.585.0 ]--
r 45             "elevationTests.emap",  // 13  (for me to comprehend elevation st
--[ 2019.11.05.23.13.01.688.0 ]--
r 45             "elevationTests.emap",  // 13  (for me to comprehend elevation stu
--[ 2019.11.05.23.13.01.816.0 ]--
r 45             "elevationTests.emap",  // 13  (for me to comprehend elevation stut
--[ 2019.11.05.23.13.02.187.0 ]--
r 45             "elevationTests.emap",  // 13  (for me to comprehend elevation stu
--[ 2019.11.05.23.13.02.896.0 ]--
r 45             "elevationTests.emap",  // 13  (for me to comprehend elevation stuf
--[ 2019.11.05.23.13.03.056.0 ]--
r 45             "elevationTests.emap",  // 13  (for me to comprehend elevation stuff
--[ 2019.11.05.23.13.03.262.0 ]--
r 45             "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
--[ 2019.11.05.23.13.06.364.0 ]--
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.05.23.13.06.836.0 ]--
r 48     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2019.11.05.23.13.06.980.0 ]--
r 48     private final static String emapFilename = emaps[13];        // change index to load a different elevation map
--[ 2019.11.05.23.13.11.872.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.23.14.19.931.0 ]--
:/src/Terrain.java
+ 71         
--[ 2019.11.05.23.14.20.313.0 ]--
r 71         S
--[ 2019.11.05.23.14.20.372.0 ]--
r 71         St
--[ 2019.11.05.23.14.20.608.0 ]--
r 71         Std
--[ 2019.11.05.23.14.20.718.0 ]--
r 71         StdO
--[ 2019.11.05.23.14.20.896.0 ]--
r 71         StdOu
--[ 2019.11.05.23.14.21.025.0 ]--
r 71         StdOut
--[ 2019.11.05.23.14.21.098.0 ]--
r 71         StdOut.
--[ 2019.11.05.23.14.21.323.0 ]--
r 71         StdOut.p
--[ 2019.11.05.23.14.21.434.0 ]--
r 71         StdOut.pr
--[ 2019.11.05.23.14.21.530.0 ]--
r 71         StdOut.pri
--[ 2019.11.05.23.14.21.640.0 ]--
r 71         StdOut.prin
--[ 2019.11.05.23.14.21.684.0 ]--
r 71         StdOut.print
--[ 2019.11.05.23.14.21.816.0 ]--
r 71         StdOut.printl
--[ 2019.11.05.23.14.21.881.0 ]--
r 71         StdOut.println
--[ 2019.11.05.23.14.22.132.0 ]--
r 71         StdOut.println()
--[ 2019.11.05.23.14.22.399.0 ]--
r 71         StdOut.println("")
--[ 2019.11.05.23.14.23.245.0 ]--
r 71         StdOut.println("h")
--[ 2019.11.05.23.14.23.294.0 ]--
r 71         StdOut.println("ho")
--[ 2019.11.05.23.14.23.674.0 ]--
r 71         StdOut.println("ho:")
--[ 2019.11.05.23.14.24.017.0 ]--
r 71         StdOut.println("ho")
--[ 2019.11.05.23.14.24.169.0 ]--
r 71         StdOut.println("h")
--[ 2019.11.05.23.14.24.369.0 ]--
r 71         StdOut.println("h0")
--[ 2019.11.05.23.14.24.580.0 ]--
r 71         StdOut.println("h0:")
--[ 2019.11.05.23.14.24.903.0 ]--
r 71         StdOut.println("h0: ")
--[ 2019.11.05.23.14.25.268.0 ]--
r 71         StdOut.println("h0: " )
--[ 2019.11.05.23.14.25.482.0 ]--
r 71         StdOut.println("h0: " +)
--[ 2019.11.05.23.14.25.598.0 ]--
r 71         StdOut.println("h0: " + )
--[ 2019.11.05.23.14.25.783.0 ]--
r 71         StdOut.println("h0: " + h)
--[ 2019.11.05.23.14.26.105.0 ]--
r 71         StdOut.println("h0: " + h0)
--[ 2019.11.05.23.14.27.275.0 ]--
r 71         StdOut.println("h0: " + h0 )
--[ 2019.11.05.23.14.27.463.0 ]--
r 71         StdOut.println("h0: " + h0 +)
--[ 2019.11.05.23.14.27.626.0 ]--
r 71         StdOut.println("h0: " + h0 + )
--[ 2019.11.05.23.14.27.977.0 ]--
r 71         StdOut.println("h0: " + h0 + "")
--[ 2019.11.05.23.14.28.158.0 ]--
r 71         StdOut.println("h0: " + h0 + " ")
--[ 2019.11.05.23.14.28.629.0 ]--
r 71         StdOut.println("h0: " + h0 + " h")
--[ 2019.11.05.23.14.28.790.0 ]--
r 71         StdOut.println("h0: " + h0 + " h1")
--[ 2019.11.05.23.14.29.146.0 ]--
r 71         StdOut.println("h0: " + h0 + " h1:")
--[ 2019.11.05.23.14.29.256.0 ]--
r 71         StdOut.println("h0: " + h0 + " h1: ")
--[ 2019.11.05.23.14.29.685.0 ]--
r 71         StdOut.println("h0: " + h0 + " h1: " )
--[ 2019.11.05.23.14.29.894.0 ]--
r 71         StdOut.println("h0: " + h0 + " h1: " +)
--[ 2019.11.05.23.14.29.994.0 ]--
r 71         StdOut.println("h0: " + h0 + " h1: " + )
--[ 2019.11.05.23.14.30.347.0 ]--
r 71         StdOut.println("h0: " + h0 + " h1: " + h1)
--[ 2019.11.05.23.14.30.822.0 ]--
r 71         StdOut.println("h0: " + h0 + " h1: " + h1);
--[ 2019.11.05.23.14.35.930.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.23.14.51.886.0 ]--
+ 72         
--[ 2019.11.05.23.14.53.284.0 ]--
- 72
--[ 2019.11.05.23.14.53.386.0 ]--
r 71         StdOut.println("h0: " + h0 + " h1: " + h1)
--[ 2019.11.05.23.14.54.343.0 ]--
r 71         StdOut.println("h0: " + h0 + " h1: " + h1);
--[ 2019.11.05.23.14.56.880.0 ]--
+ 73         
--[ 2019.11.05.23.14.57.194.0 ]--
r 73         S
--[ 2019.11.05.23.14.57.374.0 ]--
r 73         St
--[ 2019.11.05.23.14.57.583.0 ]--
r 73         Std
--[ 2019.11.05.23.14.57.737.0 ]--
r 73         StdO
--[ 2019.11.05.23.14.57.946.0 ]--
r 73         StdOu
--[ 2019.11.05.23.14.58.037.0 ]--
r 73         StdOut
--[ 2019.11.05.23.14.58.147.0 ]--
r 73         StdOut.
--[ 2019.11.05.23.14.58.384.0 ]--
r 73         StdOut.p
--[ 2019.11.05.23.14.58.500.0 ]--
r 73         StdOut.pr
--[ 2019.11.05.23.14.58.563.0 ]--
r 73         StdOut.pri
--[ 2019.11.05.23.14.58.722.0 ]--
r 73         StdOut.prin
--[ 2019.11.05.23.14.58.859.0 ]--
r 73         StdOut.print
--[ 2019.11.05.23.14.58.935.0 ]--
r 73         StdOut.printl
--[ 2019.11.05.23.14.59.001.0 ]--
r 73         StdOut.println
--[ 2019.11.05.23.14.59.219.0 ]--
r 73         StdOut.println()
--[ 2019.11.05.23.14.59.849.0 ]--
r 73         StdOut.println(c)
--[ 2019.11.05.23.14.59.933.0 ]--
r 73         StdOut.println(cl)
--[ 2019.11.05.23.15.00.047.0 ]--
r 73         StdOut.println(cli)
--[ 2019.11.05.23.15.00.127.0 ]--
r 73         StdOut.println(clim)
--[ 2019.11.05.23.15.00.239.0 ]--
r 73         StdOut.println(climb)
--[ 2019.11.05.23.15.00.646.0 ]--
r 73         StdOut.println(climb);
--[ 2019.11.05.23.15.05.927.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.23.15.19.153.0 ]--
r 73         StdOut.println("climb);
--[ 2019.11.05.23.15.19.409.0 ]--
r 73         StdOut.println("cclimb);
--[ 2019.11.05.23.15.19.502.0 ]--
r 73         StdOut.println("clclimb);
--[ 2019.11.05.23.15.19.646.0 ]--
r 73         StdOut.println("cliclimb);
--[ 2019.11.05.23.15.19.727.0 ]--
r 73         StdOut.println("climclimb);
--[ 2019.11.05.23.15.19.820.0 ]--
r 73         StdOut.println("climbclimb);
--[ 2019.11.05.23.15.20.019.0 ]--
r 73         StdOut.println("climb:climb);
--[ 2019.11.05.23.15.20.593.0 ]--
r 73         StdOut.println("climb: climb);
--[ 2019.11.05.23.15.20.805.0 ]--
r 73         StdOut.println("climb: "climb);
--[ 2019.11.05.23.15.20.983.0 ]--
r 73         StdOut.println("climb: " climb);
--[ 2019.11.05.23.15.21.210.0 ]--
r 73         StdOut.println("climb: " +climb);
--[ 2019.11.05.23.15.21.390.0 ]--
r 73         StdOut.println("climb: " + climb);
--[ 2019.11.05.23.15.26.000.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.23.16.47.253.0 ]--
:/src/Pathfinder.java
r 231         PFNode a = new PFNode(new Coord(1, ), null);
--[ 2019.11.05.23.16.47.715.0 ]--
r 231         PFNode a = new PFNode(new Coord(1, 1), null);
--[ 2019.11.05.23.16.50.261.0 ]--
r 232         PFNode b = new PFNode(new Coord(0, ), a);
--[ 2019.11.05.23.16.50.876.0 ]--
r 232         PFNode b = new PFNode(new Coord(0, 1), a);
--[ 2019.11.05.23.16.56.962.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.23.17.17.609.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 48     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2019.11.05.23.17.18.284.0 ]--
r 48     private final static String emapFilename = emaps[12];        // change index to load a different elevation map
--[ 2019.11.05.23.17.24.459.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.23.24.22.562.0 ]--
:/src/Pathfinder.java
r 208                 /StdOut.println("current loc: " + currentLoc + " from: " + currentNode.fromNode.getLoc() + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.23.24.22.704.0 ]--
r 208                 StdOut.println("current loc: " + currentLoc + " from: " + currentNode.fromNode.getLoc() + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.23.24.24.096.0 ]--
r 210                 /StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.23.24.24.237.0 ]--
r 210                 StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.05.23.24.28.698.0 ]--
:/src/Terrain.java
r 73 
--[ 2019.11.05.23.24.28.888.0 ]--
- 73
--[ 2019.11.05.23.24.30.078.0 ]--
r 71 
--[ 2019.11.05.23.24.30.237.0 ]--
- 71
--[ 2019.11.05.23.24.33.491.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.23.25.38.619.0 ]--
:/src/Pathfinder.java
r 218                 if (validateCoord(c.getLoc()) && (board[c.getLoc().getI()][c.getLoc().getJ()] < 0) {
--[ 2019.11.05.23.25.41.481.0 ]--
r 218                 if (validateCoord(c.getLoc()) && (board[c.getLoc().getI()][c.getLoc().getJ()] < 0)) {
--[ 2019.11.05.23.25.42.681.0 ]--
r 218                 if (validateCoord(c.getLoc()) && (board[c.getLoc().getI()][c.getLoc().getJ()] < 0) ) {
--[ 2019.11.05.23.25.42.931.0 ]--
r 218                 if (validateCoord(c.getLoc()) && (board[c.getLoc().getI()][c.getLoc().getJ()] < 0) |) {
--[ 2019.11.05.23.25.43.076.0 ]--
r 218                 if (validateCoord(c.getLoc()) && (board[c.getLoc().getI()][c.getLoc().getJ()] < 0) ||) {
--[ 2019.11.05.23.25.43.238.0 ]--
r 218                 if (validateCoord(c.getLoc()) && (board[c.getLoc().getI()][c.getLoc().getJ()] < 0) || ) {
--[ 2019.11.05.23.25.54.663.0 ]--
r 218                 if (validateCoord(c.getLoc()) && (board[c.getLoc().getI()][c.getLoc().getJ()] < 0) || c) {
--[ 2019.11.05.23.25.55.208.0 ]--
r 218                 if (validateCoord(c.getLoc()) && (board[c.getLoc().getI()][c.getLoc().getJ()] < 0) || c.) {
--[ 2019.11.05.23.25.55.382.0 ]--
r 218                 if (validateCoord(c.getLoc()) && (board[c.getLoc().getI()][c.getLoc().getJ()] < 0) || c.g) {
--[ 2019.11.05.23.25.55.475.0 ]--
r 218                 if (validateCoord(c.getLoc()) && (board[c.getLoc().getI()][c.getLoc().getJ()] < 0) || c.ge) {
--[ 2019.11.05.23.25.55.622.0 ]--
r 218                 if (validateCoord(c.getLoc()) && (board[c.getLoc().getI()][c.getLoc().getJ()] < 0) || c.get) {
--[ 2019.11.05.23.25.55.887.0 ]--
r 218                 if (validateCoord(c.getLoc()) && (board[c.getLoc().getI()][c.getLoc().getJ()] < 0) || c.getC) {
--[ 2019.11.05.23.25.56.036.0 ]--
r 218                 if (validateCoord(c.getLoc()) && (board[c.getLoc().getI()][c.getLoc().getJ()] < 0) || c.getCo) {
--[ 2019.11.05.23.25.56.240.0 ]--
r 218                 if (validateCoord(c.getLoc()) && (board[c.getLoc().getI()][c.getLoc().getJ()] < 0) || c.getCos) {
--[ 2019.11.05.23.25.56.330.0 ]--
r 218                 if (validateCoord(c.getLoc()) && (board[c.getLoc().getI()][c.getLoc().getJ()] < 0) || c.getCost) {
--[ 2019.11.05.23.25.56.614.0 ]--
r 218                 if (validateCoord(c.getLoc()) && (board[c.getLoc().getI()][c.getLoc().getJ()] < 0) || c.getCost()) {
--[ 2019.11.05.23.25.56.842.0 ]--
r 218                 if (validateCoord(c.getLoc()) && (board[c.getLoc().getI()][c.getLoc().getJ()] < 0) || c.getCost(h)) {
--[ 2019.11.05.23.25.57.720.0 ]--
r 218                 if (validateCoord(c.getLoc()) && (board[c.getLoc().getI()][c.getLoc().getJ()] < 0) || c.getCost(h) ) {
--[ 2019.11.05.23.25.57.909.0 ]--
r 218                 if (validateCoord(c.getLoc()) && (board[c.getLoc().getI()][c.getLoc().getJ()] < 0) || c.getCost(h) <) {
--[ 2019.11.05.23.25.57.973.0 ]--
r 218                 if (validateCoord(c.getLoc()) && (board[c.getLoc().getI()][c.getLoc().getJ()] < 0) || c.getCost(h) < ) {
--[ 2019.11.05.23.25.59.473.0 ]--
r 218                 if (validateCoord(c.getLoc()) && (board[c.getLoc().getI()][c.getLoc().getJ()] < 0) || c.getCost(h) < b) {
--[ 2019.11.05.23.25.59.590.0 ]--
r 218                 if (validateCoord(c.getLoc()) && (board[c.getLoc().getI()][c.getLoc().getJ()] < 0) || c.getCost(h) < bo) {
--[ 2019.11.05.23.26.00.350.0 ]--
r 218                 if (validateCoord(c.getLoc()) && (board[c.getLoc().getI()][c.getLoc().getJ()] < 0) || c.getCost(h) < b) {
--[ 2019.11.05.23.26.00.489.0 ]--
r 218                 if (validateCoord(c.getLoc()) && (board[c.getLoc().getI()][c.getLoc().getJ()] < 0) || c.getCost(h) < ) {
--[ 2019.11.05.23.26.04.721.0 ]--
r 218                 if (validateCoord(c.getLoc()) && (board[c.getLoc().getI()][c.getLoc().getJ()] < 0) || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()]) {
--[ 2019.11.05.23.26.09.132.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.23.26.26.476.0 ]--
+ 219                     
--[ 2019.11.05.23.26.28.910.0 ]--
r 219                     i
--[ 2019.11.05.23.26.29.190.0 ]--
r 219                     if 
--[ 2019.11.05.23.26.29.230.0 ]--
r 219                     if ()
--[ 2019.11.05.23.26.35.549.0 ]--
r 219                     if ()board[c.getLoc().getI()][c.getLoc().getJ()] < 0) || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()]
--[ 2019.11.05.23.26.36.605.0 ]--
r 219                     if ()
--[ 2019.11.05.23.26.37.819.0 ]--
r 219                     if (board[c.getLoc().getI()][c.getLoc().getJ()] < 0) || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()])
--[ 2019.11.05.23.26.42.529.0 ]--
r 218                 if (validateCoord(c.getLoc())) {
--[ 2019.11.05.23.26.45.171.0 ]--
r 219                     if (board[c.getLoc().getI()][c.getLoc().getJ()] < 0) || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()]) 
--[ 2019.11.05.23.26.45.358.0 ]--
r 219                     if (board[c.getLoc().getI()][c.getLoc().getJ()] < 0) || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()]) {
--[ 2019.11.05.23.26.47.377.0 ]--
+ 224                     
--[ 2019.11.05.23.26.49.224.0 ]--
r 224                     }
--[ 2019.11.05.23.26.49.361.0 ]--
+ 219                     if (board[c.getLoc().getI()][c.getLoc().getJ()] < 0) || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()])
r 220                     {
--[ 2019.11.05.23.26.49.385.0 ]--
r 221                         //StdOut.println("inserting " + c.getLoc() + ' ' + c.getCost(h));
--[ 2019.11.05.23.26.49.408.0 ]--
r 222                         pq.insert(c);
--[ 2019.11.05.23.26.49.432.0 ]--
r 223                         //StdOut.println("AHHHHHHHHH --------------------------------------");
--[ 2019.11.05.23.26.49.460.0 ]--
r 224                         board[c.getLoc().getI()][c.getLoc().getJ()] = c.getCost(h);
--[ 2019.11.05.23.26.54.033.0 ]--
- 219
r 219                     if (board[c.getLoc().getI()][c.getLoc().getJ()] < 0) || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()]){
--[ 2019.11.05.23.26.55.616.0 ]--
r 219                     if (board[c.getLoc().getI()][c.getLoc().getJ()] < 0) || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()]) {
--[ 2019.11.05.23.27.02.847.0 ]--
r 219                     if (board[c.getLoc().getI()][c.getLoc().getJ()] < 0 || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()]) {
--[ 2019.11.05.23.27.09.059.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.23.29.41.374.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.23.31.55.630.0 ]--
r 269         r
--[ 2019.11.05.23.31.55.739.0 ]--
r 269         re
--[ 2019.11.05.23.31.55.914.0 ]--
r 269         ret
--[ 2019.11.05.23.31.55.989.0 ]--
r 269         retu
--[ 2019.11.05.23.31.56.119.0 ]--
r 269         retur
--[ 2019.11.05.23.31.56.188.0 ]--
r 269         return
--[ 2019.11.05.23.31.56.423.0 ]--
r 269         return 
--[ 2019.11.05.23.31.58.866.0 ]--
r 269         return b
--[ 2019.11.05.23.31.58.968.0 ]--
r 269         return bo
--[ 2019.11.05.23.31.59.070.0 ]--
r 269         return boa
--[ 2019.11.05.23.31.59.151.0 ]--
r 269         return boar
--[ 2019.11.05.23.31.59.340.0 ]--
r 269         return board
--[ 2019.11.05.23.31.59.414.0 ]--
r 269         return board[]
--[ 2019.11.05.23.31.59.660.0 ]--
r 269         return board[l]
--[ 2019.11.05.23.31.59.844.0 ]--
r 269         return board[lo]
--[ 2019.11.05.23.31.59.925.0 ]--
r 269         return board[loc]
--[ 2019.11.05.23.32.00.058.0 ]--
r 269         return board[loc.]
--[ 2019.11.05.23.32.00.189.0 ]--
r 269         return board[loc.g]
--[ 2019.11.05.23.32.00.252.0 ]--
r 269         return board[loc.ge]
--[ 2019.11.05.23.32.00.406.0 ]--
r 269         return board[loc.get]
--[ 2019.11.05.23.32.00.619.0 ]--
r 269         return board[loc.getI]
--[ 2019.11.05.23.32.00.936.0 ]--
r 269         return board[loc.getI()]
--[ 2019.11.05.23.32.01.779.0 ]--
r 269         return board[loc.getI()][]
--[ 2019.11.05.23.32.02.055.0 ]--
r 269         return board[loc.getI()][l]
--[ 2019.11.05.23.32.02.256.0 ]--
r 269         return board[loc.getI()][lo]
--[ 2019.11.05.23.32.02.346.0 ]--
r 269         return board[loc.getI()][loc]
--[ 2019.11.05.23.32.02.458.0 ]--
r 269         return board[loc.getI()][loc.]
--[ 2019.11.05.23.32.02.679.0 ]--
r 269         return board[loc.getI()][loc.g]
--[ 2019.11.05.23.32.02.783.0 ]--
r 269         return board[loc.getI()][loc.ge]
--[ 2019.11.05.23.32.02.921.0 ]--
r 269         return board[loc.getI()][loc.get]
--[ 2019.11.05.23.32.03.130.0 ]--
r 269         return board[loc.getI()][loc.getJ]
--[ 2019.11.05.23.32.03.484.0 ]--
r 269         return board[loc.getI()][loc.getJ()]
--[ 2019.11.05.23.32.04.610.0 ]--
r 269         return board[loc.getI()][loc.getJ()] 
--[ 2019.11.05.23.32.10.754.0 ]--
r 269         return board[loc.getI()][loc.getJ()] <
--[ 2019.11.05.23.32.10.869.0 ]--
r 269         return board[loc.getI()][loc.getJ()] < 
--[ 2019.11.05.23.32.11.028.0 ]--
r 269         return board[loc.getI()][loc.getJ()] < 0
--[ 2019.11.05.23.32.11.679.0 ]--
r 269         return board[loc.getI()][loc.getJ()] < 0;
--[ 2019.11.05.23.32.17.628.0 ]--
r 269         return !board[loc.getI()][loc.getJ()] < 0;
--[ 2019.11.05.23.32.21.150.0 ]--
r 269         return board[loc.getI()][loc.getJ()] < 0;
--[ 2019.11.05.23.32.23.744.0 ]--
r 269         return board[loc.getI()][loc.getJ()]  0;
--[ 2019.11.05.23.32.28.426.0 ]--
r 269         return board[loc.getI()][loc.getJ()] > 0;
--[ 2019.11.05.23.32.29.384.0 ]--
r 269         return board[loc.getI()][loc.getJ()] >= 0;
--[ 2019.11.05.23.32.36.458.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.23.32.54.413.0 ]--
r 215                 /break;
--[ 2019.11.05.23.32.54.598.0 ]--
r 215                 //break;
--[ 2019.11.05.23.32.55.146.0 ]--
r 214                 /endNode = currentNode;
--[ 2019.11.05.23.32.55.372.0 ]--
r 214                 //endNode = currentNode;
--[ 2019.11.05.23.32.55.804.0 ]--
r 213                 /pathFound = true;
--[ 2019.11.05.23.32.55.981.0 ]--
r 213                 //pathFound = true;
--[ 2019.11.05.23.33.00.555.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.23.33.05.223.0 ]--
r 215                 /break;
--[ 2019.11.05.23.33.05.473.0 ]--
r 215                 break;
--[ 2019.11.05.23.33.06.031.0 ]--
r 214                 /endNode = currentNode;
--[ 2019.11.05.23.33.06.220.0 ]--
r 214                 endNode = currentNode;
--[ 2019.11.05.23.33.06.616.0 ]--
r 213                 /pathFound = true;
--[ 2019.11.05.23.33.06.785.0 ]--
r 213                 pathFound = true;
--[ 2019.11.05.23.33.11.439.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.23.33.31.526.0 ]--
r 220                         /StdOut.println("inserting " + c.getLoc() + ' ' + c.getCost(h));
--[ 2019.11.05.23.33.31.665.0 ]--
r 220                         StdOut.println("inserting " + c.getLoc() + ' ' + c.getCost(h));
--[ 2019.11.05.23.33.37.118.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.05.23.39.01.621.0 ]--
- 103
- 103
- 103
- 103
- 103
- 103
- 103
- 103
- 103
- 103
- 103
r 103         ]
--[ 2019.11.05.23.39.02.694.0 ]--
r 103         
--[ 2019.11.05.23.39.02.991.0 ]--
- 103
--[ 2019.11.05.23.39.09.129.0 ]--
+ 179         
--[ 2019.11.05.23.39.11.008.0 ]--
+ 179         board = new float[N][N];
+ 180         for (int i = 0; i < N; i++) {
+ 181             for (int j = 0; j < N; j++) {
+ 182                 board[i][j] = -1.0f;
+ 183             }
+ 184         }
+ 185         origCost = new int[N][N];
+ 186         for (int i = 0; i < N; i++) {
+ 187             for (int j = 0; j < N; j++) {
+ 188                 origCost[i][j] = this.terrain.getHeight(i, j);
+ 189             }
r 190         }
--[ 2019.11.05.23.41.13.508.0 ]--
+ 251         
--[ 2019.11.05.23.41.14.199.0 ]--
r 251         P
--[ 2019.11.05.23.41.14.306.0 ]--
r 251         PF
--[ 2019.11.05.23.41.14.456.0 ]--
r 251         PFN
--[ 2019.11.05.23.41.14.710.0 ]--
r 251         PFNo
--[ 2019.11.05.23.41.14.805.0 ]--
r 251         PFNod
--[ 2019.11.05.23.41.15.012.0 ]--
r 251         PFNode
--[ 2019.11.05.23.41.15.115.0 ]--
r 251         PFNode 
--[ 2019.11.05.23.41.15.240.0 ]--
r 251         PFNode c
--[ 2019.11.05.23.41.15.382.0 ]--
r 251         PFNode c 
--[ 2019.11.05.23.41.15.640.0 ]--
r 251         PFNode c =
--[ 2019.11.05.23.41.15.768.0 ]--
r 251         PFNode c = 
--[ 2019.11.05.23.41.16.040.0 ]--
r 251         PFNode c = e
--[ 2019.11.05.23.41.16.175.0 ]--
r 251         PFNode c = en
--[ 2019.11.05.23.41.16.258.0 ]--
r 251         PFNode c = end
--[ 2019.11.05.23.41.16.362.0 ]--
r 251         PFNode c = endn
--[ 2019.11.05.23.41.16.485.0 ]--
r 251         PFNode c = endno
--[ 2019.11.05.23.41.16.802.0 ]--
r 251         PFNode c = endn
--[ 2019.11.05.23.41.16.973.0 ]--
r 251         PFNode c = end
--[ 2019.11.05.23.41.17.208.0 ]--
r 251         PFNode c = endN
--[ 2019.11.05.23.41.17.350.0 ]--
r 251         PFNode c = endNo
--[ 2019.11.05.23.41.17.450.0 ]--
r 251         PFNode c = endNod
--[ 2019.11.05.23.41.17.624.0 ]--
r 251         PFNode c = endNode
--[ 2019.11.05.23.41.17.700.0 ]--
r 251         PFNode c = endNode;
--[ 2019.11.05.23.41.17.880.0 ]--
+ 252         
--[ 2019.11.05.23.41.18.265.0 ]--
r 252         r
--[ 2019.11.05.23.41.18.355.0 ]--
r 252         re
--[ 2019.11.05.23.41.18.523.0 ]--
r 252         ret
--[ 2019.11.05.23.41.18.603.0 ]--
r 252         retu
--[ 2019.11.05.23.41.18.716.0 ]--
r 252         retur
--[ 2019.11.05.23.41.18.795.0 ]--
r 252         return
--[ 2019.11.05.23.41.18.856.0 ]--
r 252         return 
--[ 2019.11.05.23.41.18.993.0 ]--
r 252         return c
--[ 2019.11.05.23.41.19.087.0 ]--
r 252         return c.
--[ 2019.11.05.23.41.19.667.0 ]--
r 252         return c.p
--[ 2019.11.05.23.41.19.800.0 ]--
r 252         return c.pa
--[ 2019.11.05.23.41.19.870.0 ]--
r 252         return c.pat
--[ 2019.11.05.23.41.19.945.0 ]--
r 252         return c.path
--[ 2019.11.05.23.41.20.348.0 ]--
r 252         return c.pat
--[ 2019.11.05.23.41.20.523.0 ]--
r 252         return c.pa
--[ 2019.11.05.23.41.20.683.0 ]--
r 252         return c.p
--[ 2019.11.05.23.41.20.858.0 ]--
r 252         return c.
--[ 2019.11.05.23.41.21.046.0 ]--
r 252         return c.g
--[ 2019.11.05.23.41.21.146.0 ]--
r 252         return c.ge
--[ 2019.11.05.23.41.21.284.0 ]--
r 252         return c.get
--[ 2019.11.05.23.41.21.504.0 ]--
r 252         return c.ge
--[ 2019.11.05.23.41.22.269.0 ]--
r 252         return c.get
--[ 2019.11.05.23.41.22.591.0 ]--
r 252         return c.getC
--[ 2019.11.05.23.41.22.714.0 ]--
r 252         return c.getCo
--[ 2019.11.05.23.41.22.924.0 ]--
r 252         return c.getCos
--[ 2019.11.05.23.41.23.126.0 ]--
r 252         return c.getCost
--[ 2019.11.05.23.41.25.231.0 ]--
r 252         return c.getCost()
--[ 2019.11.05.23.41.25.649.0 ]--
r 252         return c.getCost(h)
--[ 2019.11.05.23.41.26.046.0 ]--
r 252         return c.getCost(h);
--[ 2019.11.05.23.41.27.189.0 ]--
+ 252         
--[ 2019.11.05.23.41.27.701.0 ]--
- 252
--[ 2019.11.05.23.41.29.846.0 ]--
r 252         ireturn c.getCost(h);
--[ 2019.11.05.23.41.29.956.0 ]--
r 252         ifreturn c.getCost(h);
--[ 2019.11.05.23.41.30.045.0 ]--
r 252         if return c.getCost(h);
--[ 2019.11.05.23.41.30.204.0 ]--
r 252         if (return c.getCost(h);
--[ 2019.11.05.23.41.30.392.0 ]--
r 252         if (creturn c.getCost(h);
--[ 2019.11.05.23.41.30.765.0 ]--
r 252         if (c return c.getCost(h);
--[ 2019.11.05.23.41.31.059.0 ]--
r 252         if (c !return c.getCost(h);
--[ 2019.11.05.23.41.31.312.0 ]--
r 252         if (c !-return c.getCost(h);
--[ 2019.11.05.23.41.31.342.0 ]--
r 252         if (c !-=return c.getCost(h);
--[ 2019.11.05.23.41.31.382.0 ]--
r 252         if (c !-= return c.getCost(h);
--[ 2019.11.05.23.41.31.874.0 ]--
r 252         if (c !-=return c.getCost(h);
--[ 2019.11.05.23.41.32.039.0 ]--
r 252         if (c !-return c.getCost(h);
--[ 2019.11.05.23.41.32.210.0 ]--
r 252         if (c !return c.getCost(h);
--[ 2019.11.05.23.41.32.570.0 ]--
r 252         if (c !=return c.getCost(h);
--[ 2019.11.05.23.41.32.675.0 ]--
r 252         if (c != return c.getCost(h);
--[ 2019.11.05.23.41.32.793.0 ]--
r 252         if (c != nreturn c.getCost(h);
--[ 2019.11.05.23.41.33.027.0 ]--
r 252         if (c != nureturn c.getCost(h);
--[ 2019.11.05.23.41.33.212.0 ]--
r 252         if (c != nulreturn c.getCost(h);
--[ 2019.11.05.23.41.33.372.0 ]--
r 252         if (c != nullreturn c.getCost(h);
--[ 2019.11.05.23.41.33.624.0 ]--
r 252         if (c != null)return c.getCost(h);
--[ 2019.11.05.23.41.34.058.0 ]--
r 252         if (c != null) return c.getCost(h);
--[ 2019.11.05.23.41.37.251.0 ]--
r 253         ereturn 0;
--[ 2019.11.05.23.41.37.632.0 ]--
r 253         else return 0;
--[ 2019.11.05.23.41.42.912.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.06.00.04.45.414.0 ]--
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 1
- 2
- 2
- 2
- 2
--[ 2019.11.06.00.05.10.048.0 ]--
+ 1 import java.lang.IndexOutOfBoundsException;
+ 2 import java.lang.IllegalArgumentException;
+ 3 
+ 4 /**
+ 5  * Pathfinder uses A* search to find a near optimal path
+ 6  * between to locations with given terrain.
+ 7  */
+ 8 
+ 9 public class Pathfinder {
+ 10 
+ 11     private Coord start;
+ 12     private Coord end;
+ 13     private MinPQ<PFNode> pq;
+ 14     private Terrain terrain;
+ 15     private float[][] board;
+ 16     private int[][] origCost;
+ 17     private float h;
+ 18     private int N;
+ 19     private PFNode endNode;
+ 20     private boolean pathFound;
+ 21 
+ 22     /**
+ 23      * PFNode will be the key for MinPQ (used in computePath())
+ 24      */
+ 25 
+ 26     private class PFNode implements Comparable<PFNode> {
+ 27         // loc: the location of the PFNode
+ 28         // fromNode: how did we get here? (linked list back to start)
+ 29         private Coord loc;
+ 30         private PFNode fromNode;
+ 31         private float cost;
+ 32 
+ 33         public PFNode(Coord loc, PFNode fromNode) {
+ 34             this.loc = loc;
+ 35             this.fromNode = fromNode;
+ 36         }
+ 37 
+ 38         // compares this with that, used to find minimum cost PFNode
+ 39         public int compareTo(PFNode that) {
+ 40             if      (this.getCost(h) < that.getCost(h)) return -1;
+ 41             else if (this.getCost(h) > that.getCost(h)) return 1;
+ 42             else return 0;
+ 43         }
+ 44 
+ 45         // returns the cost to travel from starting point to this
+ 46         // via the fromNode chain
+ 47 
+ 48         // Returns the location of the PFNode
+ 49         public Coord getLoc() {
+ 50             return loc;
+ 51         }
+ 52 
+ 53         public float getCost(float heuristic) {
+ 54             PFNode b = fromNode;
+ 55             if (b == null) return 0.0f;
+ 56             else {
+ 57                 float a = board[b.getLoc().getI()][b.getLoc().getJ()];
+ 58                 float ab = terrain.computeTravelCost(b.getLoc(), loc);
+ 59                 //StdOut.println("getting cost: " + a);
+ 60                 //StdOut.println("computed from b: " + ab);
+ 61                 //StdOut.print("addition: ");
+ 62                 //StdOut.println(a+ab);
+ 63                 return a + ab;
+ 64             }
+ 65         }
+ 66 
+ 67         // returns if this PFNode is not marked invalid
+ 68         public boolean isValid() {
+ 69             return false;
+ 70         }
+ 71 
+ 72         // marks the PFNode as invalid
+ 73         public void invalidate() {
+ 74 
+ 75         }
+ 76 
+ 77         // returns if the PFNode is marked as used
+ 78         public boolean isUsed() {
+ 79             return true;
+ 80         }
+ 81 
+ 82         // marks the PFNode as used
+ 83         public void use() { }
+ 84 
+ 85         // returns an Iterable of PFNodes that surround this
+ 86         public Iterable<PFNode> neighbors() {
+ 87             Coord[] coords = findNeighbors(loc);
+ 88             Stack<PFNode> s = new Stack<>();
+ 89             for (Coord c : coords) {
+ 90                 s.push(new PFNode(c, this));
+ 91             }
+ 92             return s;
+ 93         }
+ 94     }
+ 95 
+ 96     public Pathfinder(Terrain terrain) {
+ 97         start = null;
+ 98         end = null;
+ 99         pq = new MinPQ<>();
+ 100         this.terrain = terrain;
+ 101         N = this.terrain.getN();
+ 102         h = 0.0f;
+ 103         pathFound = false;
+ 104 
+ 105     }
+ 106 
+ 107     public void setPathStart(Coord loc) {
+ 108         start = new Coord(loc.getI(), loc.getJ());
+ 109         start = loc;
+ 110     }
+ 111 
+ 112     public Coord getPathStart() {
+ 113         return start;
+ 114     }
+ 115 
+ 116     public void setPathEnd(Coord loc) {
+ 117         end = new Coord(loc.getI(), loc.getJ());
+ 118         end = loc;
+ 119     }
+ 120 
+ 121     public Coord getPathEnd() {
+ 122         return end;
+ 123     }
+ 124 
+ 125     private void printOrigBoard() {
+ 126         for (int i = 0; i < board.length; i++) {
+ 127             for (int j = 0; j < board.length; j++) {
+ 128                 //StdOut.print(terrain.getHeight(j, i));
+ 129                 StdOut.print(board[j][i]);
+ 130                 StdOut.print(' ');
+ 131             }
+ 132             StdOut.println();
+ 133         }
+ 134     }
+ 135 
+ 136     public void setHeuristic(float v) {
+ 137 
+ 138     }
+ 139 
+ 140     public float getHeuristic() {
+ 141         return 0;
+ 142     }
+ 143 
+ 144     public void resetPath() {
+ 145         pq = new MinPQ<>();
+ 146         N = this.terrain.getN();
+ 147         h = 0.0f;
+ 148         board = new float[N][N];
+ 149         for (int i = 0; i < N; i++) {
+ 150             for (int j = 0; j < N; j++) {
+ 151                 board[i][j] = -1.0f;
+ 152             }
+ 153         }
+ 154         origCost = new int[N][N];
+ 155         for (int i = 0; i < N; i++) {
+ 156             for (int j = 0; j < N; j++) {
+ 157                 origCost[i][j] = this.terrain.getHeight(i, j);
+ 158             }
+ 159         }
+ 160     }
+ 161 
+ 162     // Helper function to find neighbors given a coord
+ 163     private Coord[] findNeighbors(Coord s) {
+ 164         Coord a = new Coord(s.getI(), s.getJ()-1);
+ 165         Coord b = new Coord(s.getI()+1, s.getJ());
+ 166         Coord c = new Coord(s.getI(), s.getJ()+1);
+ 167         Coord d = new Coord(s.getI()-1, s.getJ());
+ 168         // a is 1 up, b is 1 right, c is 1 down, d is 1 left
+ 169         Coord[] e = new Coord[4];
+ 170         e[0] = a;
+ 171         e[1] = b;
+ 172         e[2] = c;
+ 173         e[3] = d;
+ 174         return e;
+ 175     }
+ 176 
+ 177     public void computePath() {
+ 178         // Step 1: Look at all possible locations from starting point, create nodes for each
+ 179         board = new float[N][N];
+ 180         for (int i = 0; i < N; i++) {
+ 181             for (int j = 0; j < N; j++) {
+ 182                 board[i][j] = -1.0f;
+ 183             }
+ 184         }
+ 185         origCost = new int[N][N];
+ 186         for (int i = 0; i < N; i++) {
+ 187             for (int j = 0; j < N; j++) {
+ 188                 origCost[i][j] = this.terrain.getHeight(i, j);
+ 189             }
+ 190         }
+ 191         Coord currentLoc = getPathStart();
+ 192         boolean atStart = true;
+ 193         while (true) {
+ 194             StdOut.println("goodbye, sanity!");
+ 195             PFNode currentNode;
+ 196             if (atStart) {
+ 197                 currentNode = new PFNode(currentLoc, null);
+ 198                 int i = currentNode.getLoc().getI();
+ 199                 int j = currentNode.getLoc().getJ();
+ 200                 board[i][j] = terrain.getHeight(i, j);
+ 201             }
+ 202             else {
+ 203                 if (!atStart && pq.isEmpty()) { StdOut.println("big oof"); break; }
+ 204                 else currentNode = pq.delMin();
+ 205                 currentLoc = currentNode.getLoc();
+ 206             }
+ 207             if (currentNode.fromNode != null) {
+ 208                 StdOut.println("current loc: " + currentLoc + " from: " + currentNode.fromNode.getLoc() + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
+ 209             } else {
+ 210                 StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
+ 211             }
+ 212             if (currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == getPathEnd().getJ()) {
+ 213                 pathFound = true;
+ 214                 endNode = currentNode;
+ 215                 break;
+ 216             }
+ 217             for (PFNode c : currentNode.neighbors()) {
+ 218                 if (validateCoord(c.getLoc())) {
+ 219                     if (board[c.getLoc().getI()][c.getLoc().getJ()] < 0 || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()]) {
+ 220                         StdOut.println("inserting " + c.getLoc() + ' ' + c.getCost(h));
+ 221                         pq.insert(c);
+ 222                         //StdOut.println("AHHHHHHHHH --------------------------------------");
+ 223                         board[c.getLoc().getI()][c.getLoc().getJ()] = c.getCost(h);
+ 224                     }
+ 225                 }
+ 226             }
+ 227             atStart = false;
+ 228             //printOrigBoard();
+ 229         }
+ 230         StdOut.println("broken");
+ 231         printOrigBoard();
+ 232         StdOut.println("ELEVATION TESTING");
+ 233         PFNode a = new PFNode(new Coord(1, 1), null);
+ 234         PFNode b = new PFNode(new Coord(0, 1), a);
+ 235         StdOut.println(terrain.computeTravelCost(a.getLoc(), b.getLoc()));
+ 236         StdOut.println(terrain.computeTravelCost(b.getLoc(), a.getLoc()));
+ 237 
+ 238     }
+ 239 
+ 240     public boolean validateCoord(Coord c) {
+ 241         int ci = c.getI();
+ 242         int cj = c.getJ();
+ 243         return ci >= 0 && ci < board.length && cj >= 0 && cj < board.length;
+ 244     }
+ 245 
+ 246     public boolean foundPath() {
+ 247         return pathFound;
+ 248     }
+ 249 
+ 250     public float getPathCost() {
+ 251         PFNode c = endNode;
+ 252         if (c != null) return c.getCost(h);
+ 253         else return 0;
+ 254     }
+ 255 
+ 256     public int getSearchSize() {
+ 257         return 0;
+ 258     }
+ 259 
+ 260     public Iterable<Coord> getPathSolution() {
+ 261         Stack<Coord> s = new Stack<>();
+ 262         PFNode c = endNode;
+ 263         while (c != null) {
+ 264             s.push(c.getLoc());
+ 265             c = c.fromNode;
+ 266         }
+ 267         return s;
+ 268     }
+ 270     public boolean wasSearched(Coord loc) {
+ 271         return board[loc.getI()][loc.getJ()] >= 0;
+ 272     }
+ 273 }
--[ 2019.11.06.00.09.44.881.0 ]--
DisposeComponent
--[ 2019.11.06.12.01.22.333.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.11.06.12.01.22.661.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml

--[ 2019.11.06.12.01.22.682.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.06.12.01.22.696.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.11.06.12.01.22.713.0 ]--
InitFile: /.cos265


--[ 2019.11.06.12.01.22.729.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.11.06.12.01.22.749.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.11.06.12.01.22.767.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[12];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.11.06.12.01.23.098.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.11.06.12.01.23.118.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return null;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return true;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
    }

}

--[ 2019.11.06.12.01.23.137.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private Terrain terrain;
    private float[][] board;
    private int[][] origCost;
    private float h;
    private int N;
    private PFNode endNode;
    private boolean pathFound;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        public Coord getLoc() {
            return loc;
        }

        public float getCost(float heuristic) {
            PFNode b = fromNode;
            if (b == null) return 0.0f;
            else {
                float a = board[b.getLoc().getI()][b.getLoc().getJ()];
                float ab = terrain.computeTravelCost(b.getLoc(), loc);
                //StdOut.println("getting cost: " + a);
                //StdOut.println("computed from b: " + ab);
                //StdOut.print("addition: ");
                //StdOut.println(a+ab);
                return a + ab;
            }
        }

        // returns if this PFNode is not marked invalid
        public boolean isValid() {
            return false;
        }

        // marks the PFNode as invalid
        public void invalidate() {

        }

        // returns if the PFNode is marked as used
        public boolean isUsed() {
            return true;
        }

        // marks the PFNode as used
        public void use() { }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        pathFound = false;

    }

    public void setPathStart(Coord loc) {
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    private void printOrigBoard() {
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board.length; j++) {
                //StdOut.print(terrain.getHeight(j, i));
                StdOut.print(board[j][i]);
                StdOut.print(' ');
            }
            StdOut.println();
        }
    }

    public void setHeuristic(float v) {

    }

    public float getHeuristic() {
        return 0;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        h = 0.0f;
        board = new float[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                board[i][j] = -1.0f;
            }
        }
        origCost = new int[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                origCost[i][j] = this.terrain.getHeight(i, j);
            }
        }
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        // Step 1: Look at all possible locations from starting point, create nodes for each
        board = new float[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                board[i][j] = -1.0f;
            }
        }
        origCost = new int[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                origCost[i][j] = this.terrain.getHeight(i, j);
            }
        }
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        while (true) {
            StdOut.println("goodbye, sanity!");
            PFNode currentNode;
            if (atStart) {
                currentNode = new PFNode(currentLoc, null);
                int i = currentNode.getLoc().getI();
                int j = currentNode.getLoc().getJ();
                board[i][j] = terrain.getHeight(i, j);
            }
            else {
                if (!atStart && pq.isEmpty()) { StdOut.println("big oof"); break; }
                else currentNode = pq.delMin();
                currentLoc = currentNode.getLoc();
            }
            if (currentNode.fromNode != null) {
                StdOut.println("current loc: " + currentLoc + " from: " + currentNode.fromNode.getLoc() + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
            } else {
                StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
            }
            if (currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == getPathEnd().getJ()) {
                pathFound = true;
                endNode = currentNode;
                break;
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] < 0 || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()]) {
                        StdOut.println("inserting " + c.getLoc() + ' ' + c.getCost(h));
                        pq.insert(c);
                        //StdOut.println("AHHHHHHHHH --------------------------------------");
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c.getCost(h);
                    }
                }
            }
            atStart = false;
            //printOrigBoard();
        }
        StdOut.println("broken");
        printOrigBoard();
        StdOut.println("ELEVATION TESTING");
        PFNode a = new PFNode(new Coord(1, 1), null);
        PFNode b = new PFNode(new Coord(0, 1), a);
        StdOut.println(terrain.computeTravelCost(a.getLoc(), b.getLoc()));
        StdOut.println(terrain.computeTravelCost(b.getLoc(), a.getLoc()));

    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < board.length && cj >= 0 && cj < board.length;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(h);
        else return 0;
    }

    public int getSearchSize() {
        return 0;
    }

    public Iterable<Coord> getPathSolution() {
        Stack<Coord> s = new Stack<>();
        PFNode c = endNode;
        while (c != null) {
            s.push(c.getLoc());
            c = c.fromNode;
        }
        return s;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] >= 0;
    }
}

--[ 2019.11.06.12.01.37.652.0 ]--
DisposeComponent
--[ 2019.11.06.13.08.21.671.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.11.06.13.08.22.349.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml

--[ 2019.11.06.13.08.22.385.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.06.13.08.22.408.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.11.06.13.08.22.426.0 ]--
InitFile: /.cos265


--[ 2019.11.06.13.08.22.453.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.11.06.13.08.22.493.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.11.06.13.08.22.581.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[12];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.11.06.13.08.22.605.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.11.06.13.08.22.662.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return null;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return true;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
    }

}

--[ 2019.11.06.13.08.22.764.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private Terrain terrain;
    private float[][] board;
    private int[][] origCost;
    private float h;
    private int N;
    private PFNode endNode;
    private boolean pathFound;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        public Coord getLoc() {
            return loc;
        }

        public float getCost(float heuristic) {
            PFNode b = fromNode;
            if (b == null) return 0.0f;
            else {
                float a = board[b.getLoc().getI()][b.getLoc().getJ()];
                float ab = terrain.computeTravelCost(b.getLoc(), loc);
                //StdOut.println("getting cost: " + a);
                //StdOut.println("computed from b: " + ab);
                //StdOut.print("addition: ");
                //StdOut.println(a+ab);
                return a + ab;
            }
        }

        // returns if this PFNode is not marked invalid
        public boolean isValid() {
            return false;
        }

        // marks the PFNode as invalid
        public void invalidate() {

        }

        // returns if the PFNode is marked as used
        public boolean isUsed() {
            return true;
        }

        // marks the PFNode as used
        public void use() { }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        pathFound = false;

    }

    public void setPathStart(Coord loc) {
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    private void printOrigBoard() {
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board.length; j++) {
                //StdOut.print(terrain.getHeight(j, i));
                StdOut.print(board[j][i]);
                StdOut.print(' ');
            }
            StdOut.println();
        }
    }

    public void setHeuristic(float v) {

    }

    public float getHeuristic() {
        return 0;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        h = 0.0f;
        board = new float[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                board[i][j] = -1.0f;
            }
        }
        origCost = new int[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                origCost[i][j] = this.terrain.getHeight(i, j);
            }
        }
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        // Step 1: Look at all possible locations from starting point, create nodes for each
        board = new float[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                board[i][j] = -1.0f;
            }
        }
        origCost = new int[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                origCost[i][j] = this.terrain.getHeight(i, j);
            }
        }
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        while (true) {
            StdOut.println("goodbye, sanity!");
            PFNode currentNode;
            if (atStart) {
                currentNode = new PFNode(currentLoc, null);
                int i = currentNode.getLoc().getI();
                int j = currentNode.getLoc().getJ();
                board[i][j] = terrain.getHeight(i, j);
            }
            else {
                if (!atStart && pq.isEmpty()) { StdOut.println("big oof"); break; }
                else currentNode = pq.delMin();
                currentLoc = currentNode.getLoc();
            }
            if (currentNode.fromNode != null) {
                StdOut.println("current loc: " + currentLoc + " from: " + currentNode.fromNode.getLoc() + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
            } else {
                StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
            }
            if (currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == getPathEnd().getJ()) {
                pathFound = true;
                endNode = currentNode;
                break;
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] < 0 || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()]) {
                        StdOut.println("inserting " + c.getLoc() + ' ' + c.getCost(h));
                        pq.insert(c);
                        //StdOut.println("AHHHHHHHHH --------------------------------------");
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c.getCost(h);
                    }
                }
            }
            atStart = false;
            //printOrigBoard();
        }
        StdOut.println("broken");
        printOrigBoard();
        StdOut.println("ELEVATION TESTING");
        PFNode a = new PFNode(new Coord(1, 1), null);
        PFNode b = new PFNode(new Coord(0, 1), a);
        StdOut.println(terrain.computeTravelCost(a.getLoc(), b.getLoc()));
        StdOut.println(terrain.computeTravelCost(b.getLoc(), a.getLoc()));

    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < board.length && cj >= 0 && cj < board.length;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(h);
        else return 0;
    }

    public int getSearchSize() {
        return 0;
    }

    public Iterable<Coord> getPathSolution() {
        Stack<Coord> s = new Stack<>();
        PFNode c = endNode;
        while (c != null) {
            s.push(c.getLoc());
            c = c.fromNode;
        }
        return s;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] >= 0;
    }
}

--[ 2019.11.06.13.09.50.802.0 ]--
:/src/Pathfinder.java
+ 52         
+ 53         
--[ 2019.11.06.13.09.52.186.0 ]--
r 53         privat
--[ 2019.11.06.13.09.52.352.0 ]--
r 53         private 
--[ 2019.11.06.13.09.52.751.0 ]--
r 53         private c
--[ 2019.11.06.13.09.52.868.0 ]--
r 53         private co
--[ 2019.11.06.13.09.52.968.0 ]--
r 53         private com
--[ 2019.11.06.13.09.53.234.0 ]--
r 53         private compu
--[ 2019.11.06.13.09.53.315.0 ]--
r 53         private comput
--[ 2019.11.06.13.09.53.566.0 ]--
r 53         private compute
--[ 2019.11.06.13.09.53.674.0 ]--
r 53         private computeC
--[ 2019.11.06.13.09.53.903.0 ]--
r 53         private computeCo
--[ 2019.11.06.13.09.54.151.0 ]--
r 53         private computeCos
--[ 2019.11.06.13.09.54.246.0 ]--
r 53         private computeCost
--[ 2019.11.06.13.09.54.926.0 ]--
r 53         private computeCost()
--[ 2019.11.06.13.09.55.290.0 ]--
r 53         private computeCost() 
--[ 2019.11.06.13.09.55.536.0 ]--
r 53         private computeCost() {}
--[ 2019.11.06.13.09.55.698.0 ]--
+ 53         private computeCost() {
r 54         }
--[ 2019.11.06.13.09.55.771.0 ]--
+ 54             
--[ 2019.11.06.13.10.00.781.0 ]--
r 53         private vcomputeCost() {
--[ 2019.11.06.13.10.00.890.0 ]--
r 53         private vocomputeCost() {
--[ 2019.11.06.13.10.02.479.0 ]--
r 53         private voidcomputeCost() {
--[ 2019.11.06.13.10.02.573.0 ]--
r 53         private void computeCost() {
--[ 2019.11.06.13.10.05.466.0 ]--
r 53         private void computeCost(h) {
--[ 2019.11.06.13.10.05.560.0 ]--
r 53         private void computeCost(he) {
--[ 2019.11.06.13.10.05.663.0 ]--
r 53         private void computeCost(heu) {
--[ 2019.11.06.13.10.05.781.0 ]--
r 53         private void computeCost(heur) {
--[ 2019.11.06.13.10.05.852.0 ]--
r 53         private void computeCost(heuri) {
--[ 2019.11.06.13.10.05.966.0 ]--
r 53         private void computeCost(heuris) {
--[ 2019.11.06.13.10.06.079.0 ]--
r 53         private void computeCost(heurist) {
--[ 2019.11.06.13.10.06.166.0 ]--
r 53         private void computeCost(heuristi) {
--[ 2019.11.06.13.10.06.318.0 ]--
r 53         private void computeCost(heuristic) {
--[ 2019.11.06.13.10.08.830.0 ]--
r 53         private void computeCost(fheuristic) {
--[ 2019.11.06.13.10.08.970.0 ]--
r 53         private void computeCost(flheuristic) {
--[ 2019.11.06.13.10.09.177.0 ]--
r 53         private void computeCost(floheuristic) {
--[ 2019.11.06.13.10.09.245.0 ]--
r 53         private void computeCost(floaheuristic) {
--[ 2019.11.06.13.10.09.374.0 ]--
r 53         private void computeCost(floatheuristic) {
--[ 2019.11.06.13.10.09.431.0 ]--
r 53         private void computeCost(float heuristic) {
--[ 2019.11.06.13.11.33.558.0 ]--
r 54             P
--[ 2019.11.06.13.11.34.941.0 ]--
r 54             PFNode b
--[ 2019.11.06.13.11.35.027.0 ]--
r 54             PFNode b 
--[ 2019.11.06.13.11.35.153.0 ]--
r 54             PFNode b = 
--[ 2019.11.06.13.11.35.848.0 ]--
r 54             PFNode b = f
--[ 2019.11.06.13.11.36.029.0 ]--
r 54             PFNode b = fr
--[ 2019.11.06.13.11.36.159.0 ]--
r 54             PFNode b = fro
--[ 2019.11.06.13.11.36.235.0 ]--
r 54             PFNode b = from
--[ 2019.11.06.13.11.36.395.0 ]--
r 54             PFNode b = fromN
--[ 2019.11.06.13.11.36.552.0 ]--
r 54             PFNode b = fromNo
--[ 2019.11.06.13.11.36.675.0 ]--
r 54             PFNode b = fromNod
--[ 2019.11.06.13.11.36.854.0 ]--
r 54             PFNode b = fromNode
--[ 2019.11.06.13.11.36.946.0 ]--
r 54             PFNode b = fromNode;
--[ 2019.11.06.13.11.37.117.0 ]--
+ 55             
--[ 2019.11.06.13.11.37.798.0 ]--
r 55             i
--[ 2019.11.06.13.11.37.903.0 ]--
r 55             if
--[ 2019.11.06.13.11.37.960.0 ]--
r 55             if 
--[ 2019.11.06.13.11.38.102.0 ]--
r 55             if ()
--[ 2019.11.06.13.11.38.313.0 ]--
r 55             if (b)
--[ 2019.11.06.13.11.38.478.0 ]--
r 55             if (b )
--[ 2019.11.06.13.11.38.601.0 ]--
r 55             if (b =)
--[ 2019.11.06.13.11.38.763.0 ]--
r 55             if (b ==)
--[ 2019.11.06.13.11.38.836.0 ]--
r 55             if (b == )
--[ 2019.11.06.13.11.38.957.0 ]--
r 55             if (b == n)
--[ 2019.11.06.13.11.39.174.0 ]--
r 55             if (b == nu)
--[ 2019.11.06.13.11.39.406.0 ]--
r 55             if (b == nul)
--[ 2019.11.06.13.11.39.537.0 ]--
r 55             if (b == null)
--[ 2019.11.06.13.11.39.873.0 ]--
r 55             if (b == null) 
--[ 2019.11.06.13.11.41.558.0 ]--
r 55             if (b == null) t
--[ 2019.11.06.13.11.41.691.0 ]--
r 55             if (b == null) th
--[ 2019.11.06.13.11.41.785.0 ]--
r 55             if (b == null) thi
--[ 2019.11.06.13.11.41.899.0 ]--
r 55             if (b == null) this
--[ 2019.11.06.13.11.42.006.0 ]--
r 55             if (b == null) this.
--[ 2019.11.06.13.11.42.216.0 ]--
r 55             if (b == null) this.c
--[ 2019.11.06.13.11.42.292.0 ]--
r 55             if (b == null) this.co
--[ 2019.11.06.13.11.42.407.0 ]--
r 55             if (b == null) this.cos
--[ 2019.11.06.13.11.42.558.0 ]--
r 55             if (b == null) this.cost
--[ 2019.11.06.13.11.42.748.0 ]--
r 55             if (b == null) this.cost 
--[ 2019.11.06.13.11.42.829.0 ]--
r 55             if (b == null) this.cost =
--[ 2019.11.06.13.11.42.942.0 ]--
r 55             if (b == null) this.cost = 
--[ 2019.11.06.13.11.43.144.0 ]--
r 55             if (b == null) this.cost = 0
--[ 2019.11.06.13.11.43.435.0 ]--
r 55             if (b == null) this.cost = 0.
--[ 2019.11.06.13.11.43.649.0 ]--
r 55             if (b == null) this.cost = 0.0
--[ 2019.11.06.13.11.43.878.0 ]--
r 55             if (b == null) this.cost = 0.0;
--[ 2019.11.06.13.11.46.611.0 ]--
r 55             if (b == null) this.cost = 0.0f;
--[ 2019.11.06.13.11.49.479.0 ]--
+ 56             
--[ 2019.11.06.13.11.49.864.0 ]--
r 56             e
--[ 2019.11.06.13.11.50.270.0 ]--
r 56             else
--[ 2019.11.06.13.11.51.059.0 ]--
r 56             else 
--[ 2019.11.06.13.11.51.206.0 ]--
+ 56             else {
+ 57 
r 58 }
--[ 2019.11.06.13.11.51.358.0 ]--
r 58             }
--[ 2019.11.06.13.11.51.465.0 ]--
r 57                 
--[ 2019.11.06.13.11.53.642.0 ]--
r 57                 r
--[ 2019.11.06.13.11.53.810.0 ]--
r 57                 re
--[ 2019.11.06.13.11.53.968.0 ]--
r 57                 ret
--[ 2019.11.06.13.11.54.302.0 ]--
r 57                 return
--[ 2019.11.06.13.11.54.729.0 ]--
r 57                 return 
--[ 2019.11.06.13.11.58.136.0 ]--
r 57                 return b.getCost()
--[ 2019.11.06.13.11.58.263.0 ]--
r 57                 return b.getCost(h)
--[ 2019.11.06.13.12.01.436.0 ]--
r 57                 return b.getCost(h) 
--[ 2019.11.06.13.12.01.618.0 ]--
r 57                 return b.getCost(h) +
--[ 2019.11.06.13.12.01.728.0 ]--
r 57                 return b.getCost(h) + 
--[ 2019.11.06.13.12.01.945.0 ]--
r 57                 return b.getCost(h) + t
--[ 2019.11.06.13.12.02.015.0 ]--
r 57                 return b.getCost(h) + te
--[ 2019.11.06.13.12.02.183.0 ]--
r 57                 return b.getCost(h) + ter
--[ 2019.11.06.13.12.02.335.0 ]--
r 57                 return b.getCost(h) + terr
--[ 2019.11.06.13.12.02.440.0 ]--
r 57                 return b.getCost(h) + terra
--[ 2019.11.06.13.12.02.519.0 ]--
r 57                 return b.getCost(h) + terrai
--[ 2019.11.06.13.12.02.629.0 ]--
r 57                 return b.getCost(h) + terrain
--[ 2019.11.06.13.12.02.859.0 ]--
r 57                 return b.getCost(h) + terrainc
--[ 2019.11.06.13.12.03.399.0 ]--
r 57                 return b.getCost(h) + terrain
--[ 2019.11.06.13.12.03.731.0 ]--
r 57                 return b.getCost(h) + terrain.
--[ 2019.11.06.13.12.03.892.0 ]--
r 57                 return b.getCost(h) + terrain.c
--[ 2019.11.06.13.12.04.037.0 ]--
r 57                 return b.getCost(h) + terrain.co
--[ 2019.11.06.13.12.04.269.0 ]--
r 57                 return b.getCost(h) + terrain.com
--[ 2019.11.06.13.12.04.415.0 ]--
r 57                 return b.getCost(h) + terrain.comp
--[ 2019.11.06.13.12.04.469.0 ]--
r 57                 return b.getCost(h) + terrain.compu
--[ 2019.11.06.13.12.04.581.0 ]--
r 57                 return b.getCost(h) + terrain.comput
--[ 2019.11.06.13.12.04.684.0 ]--
r 57                 return b.getCost(h) + terrain.compute
--[ 2019.11.06.13.12.04.975.0 ]--
r 57                 return b.getCost(h) + terrain.computeT
--[ 2019.11.06.13.12.05.172.0 ]--
r 57                 return b.getCost(h) + terrain.computeTr
--[ 2019.11.06.13.12.05.251.0 ]--
r 57                 return b.getCost(h) + terrain.computeTra
--[ 2019.11.06.13.12.05.411.0 ]--
r 57                 return b.getCost(h) + terrain.computeTrav
--[ 2019.11.06.13.12.05.519.0 ]--
r 57                 return b.getCost(h) + terrain.computeTrave
--[ 2019.11.06.13.12.05.633.0 ]--
r 57                 return b.getCost(h) + terrain.computeTravel
--[ 2019.11.06.13.12.05.866.0 ]--
r 57                 return b.getCost(h) + terrain.computeTravelC
--[ 2019.11.06.13.12.05.995.0 ]--
r 57                 return b.getCost(h) + terrain.computeTravelCo
--[ 2019.11.06.13.12.06.095.0 ]--
r 57                 return b.getCost(h) + terrain.computeTravelCos
--[ 2019.11.06.13.12.06.228.0 ]--
r 57                 return b.getCost(h) + terrain.computeTravelCost
--[ 2019.11.06.13.12.06.563.0 ]--
r 57                 return b.getCost(h) + terrain.computeTravelCost()
--[ 2019.11.06.13.12.07.174.0 ]--
r 57                 return b.getCost(h) + terrain.computeTravelCost(b)
--[ 2019.11.06.13.12.09.899.0 ]--
r 57                 return b.getCost(h) + terrain.computeTravelCost(b.getLoc(),)
--[ 2019.11.06.13.12.10.083.0 ]--
r 57                 return b.getCost(h) + terrain.computeTravelCost(b.getLoc(), )
--[ 2019.11.06.13.12.10.185.0 ]--
r 57                 return b.getCost(h) + terrain.computeTravelCost(b.getLoc(), l)
--[ 2019.11.06.13.12.10.340.0 ]--
r 57                 return b.getCost(h) + terrain.computeTravelCost(b.getLoc(), lo)
--[ 2019.11.06.13.12.10.502.0 ]--
r 57                 return b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc)
--[ 2019.11.06.13.12.10.862.0 ]--
r 57                 return b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.06.13.12.15.642.0 ]--
r 57                 c b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.06.13.12.16.298.0 ]--
r 57                 cost  b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.06.13.12.16.376.0 ]--
r 57                 cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.06.13.12.16.490.0 ]--
r 57                 cost =  b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.06.13.12.18.261.0 ]--
r 57                 cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.06.13.12.21.645.0 ]--
r 57                 tcost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.06.13.12.22.088.0 ]--
r 57                 this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.06.13.13.00.149.0 ]--
+ 36             
--[ 2019.11.06.13.13.01.394.0 ]--
r 36             compute
--[ 2019.11.06.13.13.01.560.0 ]--
r 36             computeC
--[ 2019.11.06.13.13.01.736.0 ]--
r 36             computeCo
--[ 2019.11.06.13.13.01.947.0 ]--
r 36             computeCos
--[ 2019.11.06.13.13.02.083.0 ]--
r 36             computeCost
--[ 2019.11.06.13.13.02.393.0 ]--
r 36             computeCost()
--[ 2019.11.06.13.13.02.564.0 ]--
r 36             computeCost(h)
--[ 2019.11.06.13.13.03.095.0 ]--
r 36             computeCost(h);
--[ 2019.11.06.13.13.19.192.0 ]--
+ 61         
--[ 2019.11.06.13.13.23.096.0 ]--
+ 62         /*
--[ 2019.11.06.13.13.25.276.0 ]--
+ 77         
+ 78          */
--[ 2019.11.06.13.13.27.847.0 ]--
+ 79          
--[ 2019.11.06.13.13.29.155.0 ]--
+ 79         
r 80         
--[ 2019.11.06.13.13.29.766.0 ]--
r 80         p
--[ 2019.11.06.13.13.29.860.0 ]--
r 80         pu
--[ 2019.11.06.13.13.29.970.0 ]--
r 80         pub
--[ 2019.11.06.13.13.30.107.0 ]--
r 80         publ
--[ 2019.11.06.13.13.30.171.0 ]--
r 80         publi
--[ 2019.11.06.13.13.30.253.0 ]--
r 80         public
--[ 2019.11.06.13.13.30.393.0 ]--
r 80         public 
--[ 2019.11.06.13.13.30.553.0 ]--
r 80         public f
--[ 2019.11.06.13.13.30.691.0 ]--
r 80         public fl
--[ 2019.11.06.13.13.30.759.0 ]--
r 80         public flo
--[ 2019.11.06.13.13.30.831.0 ]--
r 80         public floa
--[ 2019.11.06.13.13.30.937.0 ]--
r 80         public float
--[ 2019.11.06.13.13.31.056.0 ]--
r 80         public float 
--[ 2019.11.06.13.13.31.218.0 ]--
r 80         public float g
--[ 2019.11.06.13.13.31.429.0 ]--
r 80         public float ge
--[ 2019.11.06.13.13.33.769.0 ]--
r 80         public float getCost(heuristi)
--[ 2019.11.06.13.13.34.589.0 ]--
r 80         public float getCost(heuristic)
--[ 2019.11.06.13.13.36.381.0 ]--
r 80         public float getCost(fheuristic)
--[ 2019.11.06.13.13.36.498.0 ]--
r 80         public float getCost(flheuristic)
--[ 2019.11.06.13.13.36.656.0 ]--
r 80         public float getCost(floheuristic)
--[ 2019.11.06.13.13.36.782.0 ]--
r 80         public float getCost(floaheuristic)
--[ 2019.11.06.13.13.36.868.0 ]--
r 80         public float getCost(floatheuristic)
--[ 2019.11.06.13.13.36.970.0 ]--
r 80         public float getCost(float heuristic)
--[ 2019.11.06.13.13.39.031.0 ]--
r 80         public float getCost(float heuristic) 
--[ 2019.11.06.13.13.39.827.0 ]--
r 80         public float getCost(float heuristic) {}
--[ 2019.11.06.13.13.40.241.0 ]--
+ 80         public float getCost(float heuristic) {
r 81         }
--[ 2019.11.06.13.13.40.347.0 ]--
+ 81             
--[ 2019.11.06.13.13.42.248.0 ]--
r 81             r
--[ 2019.11.06.13.13.43.932.0 ]--
r 81             return cost
--[ 2019.11.06.13.13.43.984.0 ]--
r 81             return cost;
--[ 2019.11.06.13.14.23.712.0 ]--
+ 55             
--[ 2019.11.06.13.14.31.154.0 ]--
r 55             if (validateCoord)
--[ 2019.11.06.13.14.33.681.0 ]--
r 55             if (validateCoord())
--[ 2019.11.06.13.14.34.816.0 ]--
r 55             if (validateCoord(t))
--[ 2019.11.06.13.14.37.259.0 ]--
r 55             if (validateCoord(thi))
--[ 2019.11.06.13.14.38.535.0 ]--
r 55             if (validateCoord(this))
--[ 2019.11.06.13.14.38.750.0 ]--
r 55             if (validateCoord(this.))
--[ 2019.11.06.13.14.38.943.0 ]--
r 55             if (validateCoord(this.l))
--[ 2019.11.06.13.14.39.611.0 ]--
r 55             if (validateCoord(this.loc))
--[ 2019.11.06.13.14.42.387.0 ]--
r 55             if (validateCoord(this.loc)) 
--[ 2019.11.06.13.14.43.454.0 ]--
r 55             if (validateCoord(this.loc)) {
--[ 2019.11.06.13.14.45.867.0 ]--
+ 61             
--[ 2019.11.06.13.14.46.283.0 ]--
r 61             }
--[ 2019.11.06.13.14.46.341.0 ]--
r 56                 PFNode b = fromNode;
--[ 2019.11.06.13.14.46.405.0 ]--
r 57                 if (b == null) this.cost = 0.0f;
--[ 2019.11.06.13.14.46.469.0 ]--
r 58                 else {
--[ 2019.11.06.13.14.46.525.0 ]--
r 59                     this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.06.13.14.47.162.0 ]--
r 60                 }
--[ 2019.11.06.13.15.06.908.0 ]--
- 58
r 58                 else { this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.06.13.15.09.685.0 ]--
r 58                 else {this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.06.13.15.10.109.0 ]--
r 58                 else this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.06.13.15.11.170.0 ]--
r 59                 
--[ 2019.11.06.13.15.11.486.0 ]--
- 59
--[ 2019.11.06.13.15.21.449.0 ]--
r 58                 else    this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.06.13.15.22.874.0 ]--
r 58                 else        this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.06.13.15.23.325.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.06.13.15.25.474.0 ]--
r 57                 if (b == null)  this.cost = 0.0f;
--[ 2019.11.06.13.17.40.572.0 ]--
r 220                 if ( pq.isEmpty()) { StdOut.println("big oof"); break; }
--[ 2019.11.06.13.17.43.450.0 ]--
r 220                 if (pq.isEmpty()) { StdOut.println("big oof"); break; }
--[ 2019.11.06.13.17.56.293.0 ]--
r 53 
r 61 
r 77 
r 79 
--[ 2019.11.06.13.18.26.605.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.06.13.34.48.889.0 ]--
DisposeComponent
--[ 2019.11.06.19.09.47.164.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.11.06.19.09.47.320.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/.cos265
/readme.html
/P04_Pathfinding.iml

--[ 2019.11.06.19.09.47.320.1 ]--
InitFile: /.cos265


--[ 2019.11.06.19.09.47.336.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.11.06.19.09.47.336.1 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.11.06.19.09.47.336.2 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private Terrain terrain;
    private float[][] board;
    private int[][] origCost;
    private float h;
    private int N;
    private PFNode endNode;
    private boolean pathFound;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        public Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null)  this.cost = 0.0f;
                else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc);
            }
        }

        /*

        public float getCost(float heuristic) {
            PFNode b = fromNode;
            if (b == null) return 0.0f;
            else {
                float a = board[b.getLoc().getI()][b.getLoc().getJ()];
                float ab = terrain.computeTravelCost(b.getLoc(), loc);
                //StdOut.println("getting cost: " + a);
                //StdOut.println("computed from b: " + ab);
                //StdOut.print("addition: ");
                //StdOut.println(a+ab);
                return a + ab;
            }
        }

         */

        public float getCost(float heuristic) {
            return cost;
        }

        // returns if this PFNode is not marked invalid
        public boolean isValid() {
            return false;
        }

        // marks the PFNode as invalid
        public void invalidate() {

        }

        // returns if the PFNode is marked as used
        public boolean isUsed() {
            return true;
        }

        // marks the PFNode as used
        public void use() { }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        pathFound = false;

    }

    public void setPathStart(Coord loc) {
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    private void printOrigBoard() {
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board.length; j++) {
                //StdOut.print(terrain.getHeight(j, i));
                StdOut.print(board[j][i]);
                StdOut.print(' ');
            }
            StdOut.println();
        }
    }

    public void setHeuristic(float v) {

    }

    public float getHeuristic() {
        return 0;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        h = 0.0f;
        board = new float[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                board[i][j] = -1.0f;
            }
        }
        origCost = new int[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                origCost[i][j] = this.terrain.getHeight(i, j);
            }
        }
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        // Step 1: Look at all possible locations from starting point, create nodes for each
        board = new float[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                board[i][j] = -1.0f;
            }
        }
        origCost = new int[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                origCost[i][j] = this.terrain.getHeight(i, j);
            }
        }
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        while (true) {
            StdOut.println("goodbye, sanity!");
            PFNode currentNode;
            if (atStart) {
                currentNode = new PFNode(currentLoc, null);
                int i = currentNode.getLoc().getI();
                int j = currentNode.getLoc().getJ();
                board[i][j] = terrain.getHeight(i, j);
            }
            else {
                if (pq.isEmpty()) { StdOut.println("big oof"); break; }
                else currentNode = pq.delMin();
                currentLoc = currentNode.getLoc();
            }
            if (currentNode.fromNode != null) {
                StdOut.println("current loc: " + currentLoc + " from: " + currentNode.fromNode.getLoc() + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
            } else {
                StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
            }
            if (currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == getPathEnd().getJ()) {
                pathFound = true;
                endNode = currentNode;
                break;
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] < 0 || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()]) {
                        StdOut.println("inserting " + c.getLoc() + ' ' + c.getCost(h));
                        pq.insert(c);
                        //StdOut.println("AHHHHHHHHH --------------------------------------");
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c.getCost(h);
                    }
                }
            }
            atStart = false;
            //printOrigBoard();
        }
        StdOut.println("broken");
        printOrigBoard();
        StdOut.println("ELEVATION TESTING");
        PFNode a = new PFNode(new Coord(1, 1), null);
        PFNode b = new PFNode(new Coord(0, 1), a);
        StdOut.println(terrain.computeTravelCost(a.getLoc(), b.getLoc()));
        StdOut.println(terrain.computeTravelCost(b.getLoc(), a.getLoc()));

    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < board.length && cj >= 0 && cj < board.length;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(h);
        else return 0;
    }

    public int getSearchSize() {
        return 0;
    }

    public Iterable<Coord> getPathSolution() {
        Stack<Coord> s = new Stack<>();
        PFNode c = endNode;
        while (c != null) {
            s.push(c.getLoc());
            c = c.fromNode;
        }
        return s;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] >= 0;
    }
}

--[ 2019.11.06.19.09.47.336.3 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return null;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return true;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
    }

}

--[ 2019.11.06.19.09.47.352.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.11.06.19.09.47.352.1 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.11.06.19.09.47.352.2 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[12];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.11.06.19.09.47.367.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.06.19.09.51.372.0 ]--
UpdateTree (AD): 2 0
+ /out/production/P04_Pathfinding/elevationTests.emap
+ /heightmaps/elevationTests.emap

--[ 2019.11.06.19.14.03.215.0 ]--
:/src/Pathfinder.java
r 154     
--[ 2019.11.06.19.14.03.466.0 ]--
r 154         
--[ 2019.11.06.19.14.04.624.0 ]--
r 154         t
--[ 2019.11.06.19.14.04.671.0 ]--
r 154         th
--[ 2019.11.06.19.14.04.782.0 ]--
r 154         thi
--[ 2019.11.06.19.14.04.829.0 ]--
r 154         this
--[ 2019.11.06.19.14.04.956.0 ]--
r 154         this.
--[ 2019.11.06.19.14.05.145.0 ]--
r 154         this.h
--[ 2019.11.06.19.14.05.335.0 ]--
r 154         this.h 
--[ 2019.11.06.19.14.05.366.0 ]--
r 154         this.h =
--[ 2019.11.06.19.14.05.461.0 ]--
r 154         this.h = 
--[ 2019.11.06.19.14.05.603.0 ]--
r 154         this.h = v
--[ 2019.11.06.19.14.05.714.0 ]--
r 154         this.h = v;
--[ 2019.11.06.19.14.09.422.0 ]--
r 158         return ;
--[ 2019.11.06.19.14.09.863.0 ]--
r 158         return t;
--[ 2019.11.06.19.14.09.974.0 ]--
r 158         return th;
--[ 2019.11.06.19.14.10.026.0 ]--
r 158         return thi;
--[ 2019.11.06.19.14.10.184.0 ]--
r 158         return this;
--[ 2019.11.06.19.14.10.264.0 ]--
r 158         return this.;
--[ 2019.11.06.19.14.10.423.0 ]--
r 158         return this.h;
--[ 2019.11.06.19.17.42.506.0 ]--
- 61
- 61
- 62
- 62
- 62
- 62
- 62
- 62
- 62
- 62
- 62
- 62
- 62
- 62
- 62
- 63
--[ 2019.11.06.19.17.42.966.0 ]--
- 61
r 61         
--[ 2019.11.06.19.17.43.284.0 ]--
- 61
--[ 2019.11.06.19.19.50.541.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.11.06.19.19.50.722.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml

--[ 2019.11.06.19.19.50.737.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.06.19.19.50.752.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.11.06.19.19.50.768.0 ]--
InitFile: /.cos265


--[ 2019.11.06.19.19.50.783.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.11.06.19.19.50.806.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.11.06.19.19.50.821.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[12];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.11.06.19.19.50.841.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.11.06.19.19.50.855.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return null;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return true;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
    }

}

--[ 2019.11.06.19.19.50.869.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private Terrain terrain;
    private float[][] board;
    private int[][] origCost;
    private float h;
    private int N;
    private PFNode endNode;
    private boolean pathFound;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        public Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null)  this.cost = 0.0f;
                else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc);
            }
        }

        public float getCost(float heuristic) {
            return cost;
        }

        // returns if this PFNode is not marked invalid
        public boolean isValid() {
            return false;
        }

        // marks the PFNode as invalid
        public void invalidate() {

        }

        // returns if the PFNode is marked as used
        public boolean isUsed() {
            return true;
        }

        // marks the PFNode as used
        public void use() { }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        pathFound = false;

    }

    public void setPathStart(Coord loc) {
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    private void printOrigBoard() {
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board.length; j++) {
                //StdOut.print(terrain.getHeight(j, i));
                StdOut.print(board[j][i]);
                StdOut.print(' ');
            }
            StdOut.println();
        }
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        h = 0.0f;
        board = new float[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                board[i][j] = -1.0f;
            }
        }
        origCost = new int[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                origCost[i][j] = this.terrain.getHeight(i, j);
            }
        }
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        // Step 1: Look at all possible locations from starting point, create nodes for each
        board = new float[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                board[i][j] = -1.0f;
            }
        }
        origCost = new int[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                origCost[i][j] = this.terrain.getHeight(i, j);
            }
        }
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        while (true) {
            StdOut.println("goodbye, sanity!");
            PFNode currentNode;
            if (atStart) {
                currentNode = new PFNode(currentLoc, null);
                int i = currentNode.getLoc().getI();
                int j = currentNode.getLoc().getJ();
                board[i][j] = terrain.getHeight(i, j);
            }
            else {
                if (pq.isEmpty()) { StdOut.println("big oof"); break; }
                else currentNode = pq.delMin();
                currentLoc = currentNode.getLoc();
            }
            if (currentNode.fromNode != null) {
                StdOut.println("current loc: " + currentLoc + " from: " + currentNode.fromNode.getLoc() + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
            } else {
                StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
            }
            if (currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == getPathEnd().getJ()) {
                pathFound = true;
                endNode = currentNode;
                break;
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] < 0 || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()]) {
                        StdOut.println("inserting " + c.getLoc() + ' ' + c.getCost(h));
                        pq.insert(c);
                        //StdOut.println("AHHHHHHHHH --------------------------------------");
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c.getCost(h);
                    }
                }
            }
            atStart = false;
            //printOrigBoard();
        }
        StdOut.println("broken");
        printOrigBoard();
        StdOut.println("ELEVATION TESTING");
        PFNode a = new PFNode(new Coord(1, 1), null);
        PFNode b = new PFNode(new Coord(0, 1), a);
        StdOut.println(terrain.computeTravelCost(a.getLoc(), b.getLoc()));
        StdOut.println(terrain.computeTravelCost(b.getLoc(), a.getLoc()));

    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < board.length && cj >= 0 && cj < board.length;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(h);
        else return 0;
    }

    public int getSearchSize() {
        return 0;
    }

    public Iterable<Coord> getPathSolution() {
        Stack<Coord> s = new Stack<>();
        PFNode c = endNode;
        while (c != null) {
            s.push(c.getLoc());
            c = c.fromNode;
        }
        return s;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] >= 0;
    }
}

--[ 2019.11.06.19.20.24.076.0 ]--
DisposeComponent
--[ 2019.11.06.19.36.36.547.0 ]--
- 148
- 148
- 148
- 148
r 148 
--[ 2019.11.06.19.36.36.896.0 ]--
- 148
--[ 2019.11.06.19.36.42.989.0 ]--
- 173
- 173
- 173
- 173
- 173
- 173
- 173
- 173
- 173
- 173
- 173
r 173 
--[ 2019.11.06.19.36.43.326.0 ]--
- 173
--[ 2019.11.06.19.36.44.746.0 ]--
+ 173 
--[ 2019.11.06.19.36.46.083.0 ]--
+ 173         board = new float[N][N];
+ 174         for (int i = 0; i < N; i++) {
+ 175             for (int j = 0; j < N; j++) {
+ 176                 board[i][j] = -1.0f;
+ 177             }
+ 178         }
+ 179         origCost = new int[N][N];
+ 180         for (int i = 0; i < N; i++) {
+ 181             for (int j = 0; j < N; j++) {
+ 182                 origCost[i][j] = this.terrain.getHeight(i, j);
+ 183             }
r 184         }
--[ 2019.11.06.19.36.48.815.0 ]--
- 173
- 173
- 173
- 173
- 173
r 173 
--[ 2019.11.06.19.36.49.116.0 ]--
- 173
--[ 2019.11.06.19.37.21.471.0 ]--
- 148
- 148
- 148
- 148
- 148
r 148 
--[ 2019.11.06.19.37.21.726.0 ]--
- 148
--[ 2019.11.06.19.37.33.669.0 ]--
r 201                     if (board[c.getLoc().getI()][c.getLoc().getJ()] <  || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()]) {
--[ 2019.11.06.19.37.33.926.0 ]--
r 201                     if (board[c.getLoc().getI()][c.getLoc().getJ()] < || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()]) {
--[ 2019.11.06.19.37.33.988.0 ]--
r 201                     if (board[c.getLoc().getI()][c.getLoc().getJ()]  || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()]) {
--[ 2019.11.06.19.37.34.906.0 ]--
r 201                     if (board[c.getLoc().getI()][c.getLoc().getJ()] = || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()]) {
--[ 2019.11.06.19.37.34.968.0 ]--
r 201                     if (board[c.getLoc().getI()][c.getLoc().getJ()] == || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()]) {
--[ 2019.11.06.19.37.35.738.0 ]--
r 201                     if (board[c.getLoc().getI()][c.getLoc().getJ()] ==  || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()]) {
--[ 2019.11.06.19.37.35.818.0 ]--
r 201                     if (board[c.getLoc().getI()][c.getLoc().getJ()] == n || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()]) {
--[ 2019.11.06.19.37.36.053.0 ]--
r 201                     if (board[c.getLoc().getI()][c.getLoc().getJ()] == nu || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()]) {
--[ 2019.11.06.19.37.36.198.0 ]--
r 201                     if (board[c.getLoc().getI()][c.getLoc().getJ()] == nul || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()]) {
--[ 2019.11.06.19.37.36.339.0 ]--
r 201                     if (board[c.getLoc().getI()][c.getLoc().getJ()] == null || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()]) {
--[ 2019.11.06.19.39.25.391.0 ]--
r 15     private P[][] board;
--[ 2019.11.06.19.39.25.639.0 ]--
r 15     private PFN[][] board;
--[ 2019.11.06.19.39.25.826.0 ]--
r 15     private PFNo[][] board;
--[ 2019.11.06.19.39.25.905.0 ]--
r 15     private PFNod[][] board;
--[ 2019.11.06.19.39.26.124.0 ]--
r 15     private PFNode[][] board;
--[ 2019.11.06.19.39.33.381.0 ]--
r 147         board = new P[N][N];
--[ 2019.11.06.19.39.33.494.0 ]--
r 147         board = new PF[N][N];
--[ 2019.11.06.19.39.33.605.0 ]--
r 147         board = new PFN[N][N];
--[ 2019.11.06.19.39.33.895.0 ]--
r 147         board = new PFNo[N][N];
--[ 2019.11.06.19.39.33.977.0 ]--
r 147         board = new PFNod[N][N];
--[ 2019.11.06.19.39.34.192.0 ]--
r 147         board = new PFNode[N][N];
--[ 2019.11.06.19.39.50.323.0 ]--
r 182 
--[ 2019.11.06.19.39.51.420.0 ]--
- 182
--[ 2019.11.06.19.39.52.352.0 ]--
+ 182 
--[ 2019.11.06.19.39.52.764.0 ]--
r 182                 board[i][j] = terrain.getHeight(i, j);
--[ 2019.11.06.19.40.05.619.0 ]--
r 182 
--[ 2019.11.06.19.40.05.950.0 ]--
- 182
--[ 2019.11.06.19.40.24.838.0 ]--
r 200                     if (board[c.getLoc().getI()][c.getLoc().getJ()] == null || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].) {
--[ 2019.11.06.19.40.25.155.0 ]--
r 200                     if (board[c.getLoc().getI()][c.getLoc().getJ()] == null || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].g) {
--[ 2019.11.06.19.40.25.233.0 ]--
r 200                     if (board[c.getLoc().getI()][c.getLoc().getJ()] == null || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].ge) {
--[ 2019.11.06.19.40.25.389.0 ]--
r 200                     if (board[c.getLoc().getI()][c.getLoc().getJ()] == null || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].get) {
--[ 2019.11.06.19.40.25.656.0 ]--
r 200                     if (board[c.getLoc().getI()][c.getLoc().getJ()] == null || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getC) {
--[ 2019.11.06.19.40.25.859.0 ]--
r 200                     if (board[c.getLoc().getI()][c.getLoc().getJ()] == null || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCo) {
--[ 2019.11.06.19.40.26.026.0 ]--
r 200                     if (board[c.getLoc().getI()][c.getLoc().getJ()] == null || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCos) {
--[ 2019.11.06.19.40.26.151.0 ]--
r 200                     if (board[c.getLoc().getI()][c.getLoc().getJ()] == null || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost) {
--[ 2019.11.06.19.40.26.496.0 ]--
r 200                     if (board[c.getLoc().getI()][c.getLoc().getJ()] == null || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost()) {
--[ 2019.11.06.19.40.27.083.0 ]--
r 200                     if (board[c.getLoc().getI()][c.getLoc().getJ()] == null || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost() {
--[ 2019.11.06.19.40.27.740.0 ]--
r 200                     if (board[c.getLoc().getI()][c.getLoc().getJ()] == null || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h) {
--[ 2019.11.06.19.40.27.956.0 ]--
r 200                     if (board[c.getLoc().getI()][c.getLoc().getJ()] == null || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
--[ 2019.11.06.19.40.38.349.0 ]--
r 204                         board[c.getLoc().getI()][c.getLoc().getJ()] = c;
--[ 2019.11.06.19.40.49.043.0 ]--
r 252         return board[loc.getI()][loc.getJ()] >= ;
--[ 2019.11.06.19.40.49.289.0 ]--
r 252         return board[loc.getI()][loc.getJ()] >=;
--[ 2019.11.06.19.40.49.336.0 ]--
r 252         return board[loc.getI()][loc.getJ()] >;
--[ 2019.11.06.19.40.49.540.0 ]--
r 252         return board[loc.getI()][loc.getJ()] ;
--[ 2019.11.06.19.40.50.047.0 ]--
r 252         return board[loc.getI()][loc.getJ()] !;
--[ 2019.11.06.19.40.50.498.0 ]--
r 252         return board[loc.getI()][loc.getJ()] !=;
--[ 2019.11.06.19.40.50.605.0 ]--
r 252         return board[loc.getI()][loc.getJ()] != ;
--[ 2019.11.06.19.40.50.777.0 ]--
r 252         return board[loc.getI()][loc.getJ()] != n;
--[ 2019.11.06.19.40.50.998.0 ]--
r 252         return board[loc.getI()][loc.getJ()] != nu;
--[ 2019.11.06.19.40.51.187.0 ]--
r 252         return board[loc.getI()][loc.getJ()] != nul;
--[ 2019.11.06.19.40.51.344.0 ]--
r 252         return board[loc.getI()][loc.getJ()] != null;
--[ 2019.11.06.19.40.54.855.0 ]--
r 200                     if (board[c.getLoc().getI()][c.getLoc().getJ()] = null || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
--[ 2019.11.06.19.40.55.394.0 ]--
r 200                     if (board[c.getLoc().getI()][c.getLoc().getJ()] != null || c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
--[ 2019.11.06.19.41.02.350.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.06.19.41.51.393.0 ]--
r 224         return ci >= 0 && ci < b && cj >= 0 && cj < board.length;
--[ 2019.11.06.19.41.51.649.0 ]--
r 224         return ci >= 0 && ci <  && cj >= 0 && cj < board.length;
--[ 2019.11.06.19.41.52.135.0 ]--
r 224         return ci >= 0 && ci < N && cj >= 0 && cj < board.length;
--[ 2019.11.06.19.41.56.587.0 ]--
r 224         return ci >= 0 && ci < N && cj >= 0 && cj < N;
--[ 2019.11.06.19.42.03.698.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.06.19.43.51.455.0 ]--
r 200                     if (board[c.getLoc().getI()][c.getLoc().getJ()] != null | c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
--[ 2019.11.06.19.43.51.734.0 ]--
r 200                     if (board[c.getLoc().getI()][c.getLoc().getJ()] != null  c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
--[ 2019.11.06.19.43.51.797.0 ]--
r 200                     if (board[c.getLoc().getI()][c.getLoc().getJ()] != null c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
--[ 2019.11.06.19.43.52.720.0 ]--
r 200                     if (board[c.getLoc().getI()][c.getLoc().getJ()] != null  c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
--[ 2019.11.06.19.43.52.869.0 ]--
r 200                     if (board[c.getLoc().getI()][c.getLoc().getJ()] != null { c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
--[ 2019.11.06.19.43.53.134.0 ]--
+ 200                     if (board[c.getLoc().getI()][c.getLoc().getJ()] != null {
+ 201  c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)
r 202 }) {
--[ 2019.11.06.19.43.53.212.0 ]--
r 201                         c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)
r 202                     }) {
--[ 2019.11.06.19.43.54.128.0 ]--
r 201                         ifc.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)
--[ 2019.11.06.19.43.54.221.0 ]--
r 201                         if c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)
--[ 2019.11.06.19.43.54.362.0 ]--
r 201                         if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)
--[ 2019.11.06.19.43.56.214.0 ]--
r 201                         if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h))
--[ 2019.11.06.19.43.56.535.0 ]--
r 201                         if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) 
--[ 2019.11.06.19.43.56.785.0 ]--
r 201                         if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
--[ 2019.11.06.19.44.02.438.0 ]--
r 202                     } {
--[ 2019.11.06.19.44.02.656.0 ]--
r 202                      {
--[ 2019.11.06.19.44.03.386.0 ]--
- 201
r 201                         if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) { {
--[ 2019.11.06.19.44.04.734.0 ]--
r 201                         if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) { 
--[ 2019.11.06.19.44.05.017.0 ]--
r 201                         if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
--[ 2019.11.06.19.44.07.188.0 ]--
+ 206                         
--[ 2019.11.06.19.44.07.531.0 ]--
r 206                         }
--[ 2019.11.06.19.44.07.650.0 ]--
r 202                             StdOut.println("inserting " + c.getLoc() + ' ' + c.getCost(h));
--[ 2019.11.06.19.44.07.666.0 ]--
r 203                             pq.insert(c);
--[ 2019.11.06.19.44.07.681.0 ]--
r 204                             //StdOut.println("AHHHHHHHHH --------------------------------------");
--[ 2019.11.06.19.44.07.697.0 ]--
r 205                             board[c.getLoc().getI()][c.getLoc().getJ()] = c;
--[ 2019.11.06.19.44.11.168.0 ]--
r 200                     if (board[c.getLoc().getI()][c.getLoc().getJ()] != null) {
--[ 2019.11.06.19.45.22.228.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.06.19.46.10.977.0 ]--
+ 103         
--[ 2019.11.06.19.46.12.379.0 ]--
r 103         b
--[ 2019.11.06.19.46.12.468.0 ]--
r 103         bo
--[ 2019.11.06.19.46.12.562.0 ]--
r 103         boa
--[ 2019.11.06.19.46.12.624.0 ]--
r 103         boar
--[ 2019.11.06.19.46.12.813.0 ]--
r 103         board
--[ 2019.11.06.19.46.12.919.0 ]--
r 103         board 
--[ 2019.11.06.19.46.12.982.0 ]--
r 103         board =
--[ 2019.11.06.19.46.13.122.0 ]--
r 103         board = 
--[ 2019.11.06.19.46.13.975.0 ]--
r 103         board = n
--[ 2019.11.06.19.46.14.053.0 ]--
r 103         board = ne
--[ 2019.11.06.19.46.14.131.0 ]--
r 103         board = new
--[ 2019.11.06.19.46.14.280.0 ]--
r 103         board = new 
--[ 2019.11.06.19.46.14.438.0 ]--
r 103         board = new P
--[ 2019.11.06.19.46.14.532.0 ]--
r 103         board = new PF
--[ 2019.11.06.19.46.14.672.0 ]--
r 103         board = new PFN
--[ 2019.11.06.19.46.15.284.0 ]--
r 103         board = new PFNo
--[ 2019.11.06.19.46.15.372.0 ]--
r 103         board = new PFNod
--[ 2019.11.06.19.46.15.576.0 ]--
r 103         board = new PFNode
--[ 2019.11.06.19.46.15.672.0 ]--
r 103         board = new PFNode[]
--[ 2019.11.06.19.46.15.970.0 ]--
r 103         board = new PFNode[N]
--[ 2019.11.06.19.46.16.473.0 ]--
r 103         board = new PFNode[N][]
--[ 2019.11.06.19.46.16.872.0 ]--
r 103         board = new PFNode[N][ ]
--[ 2019.11.06.19.46.17.264.0 ]--
r 103         board = new PFNode[N][]
--[ 2019.11.06.19.46.17.811.0 ]--
r 103         board = new PFNode[N][N]
--[ 2019.11.06.19.46.18.449.0 ]--
r 103         board = new PFNode[N][N];
--[ 2019.11.06.19.46.22.935.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.06.19.47.35.680.0 ]--
+ 180                 
--[ 2019.11.06.19.47.36.901.0 ]--
r 180                 S
--[ 2019.11.06.19.47.37.061.0 ]--
r 180                 St
--[ 2019.11.06.19.47.37.280.0 ]--
r 180                 Std
--[ 2019.11.06.19.47.37.421.0 ]--
r 180                 StdO
--[ 2019.11.06.19.47.37.592.0 ]--
r 180                 StdOu
--[ 2019.11.06.19.47.37.701.0 ]--
r 180                 StdOut
--[ 2019.11.06.19.47.37.795.0 ]--
r 180                 StdOut.
--[ 2019.11.06.19.47.38.093.0 ]--
r 180                 StdOut.p
--[ 2019.11.06.19.47.38.239.0 ]--
r 180                 StdOut.pr
--[ 2019.11.06.19.47.38.395.0 ]--
r 180                 StdOut.pri
--[ 2019.11.06.19.47.38.489.0 ]--
r 180                 StdOut.prin
--[ 2019.11.06.19.47.38.598.0 ]--
r 180                 StdOut.print
--[ 2019.11.06.19.47.38.725.0 ]--
r 180                 StdOut.printl
--[ 2019.11.06.19.47.38.775.0 ]--
r 180                 StdOut.println
--[ 2019.11.06.19.47.39.058.0 ]--
r 180                 StdOut.println()
--[ 2019.11.06.19.47.39.279.0 ]--
r 180                 StdOut.println("")
--[ 2019.11.06.19.47.39.456.0 ]--
r 180                 StdOut.println("f")
--[ 2019.11.06.19.47.39.534.0 ]--
r 180                 StdOut.println("fi")
--[ 2019.11.06.19.47.39.628.0 ]--
r 180                 StdOut.println("fir")
--[ 2019.11.06.19.47.39.706.0 ]--
r 180                 StdOut.println("firs")
--[ 2019.11.06.19.47.39.862.0 ]--
r 180                 StdOut.println("first")
--[ 2019.11.06.19.47.39.924.0 ]--
r 180                 StdOut.println("first ")
--[ 2019.11.06.19.47.40.065.0 ]--
r 180                 StdOut.println("first r")
--[ 2019.11.06.19.47.40.110.0 ]--
r 180                 StdOut.println("first ru")
--[ 2019.11.06.19.47.40.282.0 ]--
r 180                 StdOut.println("first run")
--[ 2019.11.06.19.47.40.955.0 ]--
r 180                 StdOut.println("first run");
--[ 2019.11.06.19.47.46.274.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.06.19.48.07.569.0 ]--
- 190
- 190
- 190
- 190
r 190             
--[ 2019.11.06.19.48.07.928.0 ]--
- 190
--[ 2019.11.06.19.48.11.426.0 ]--
+ 179             
--[ 2019.11.06.19.48.11.991.0 ]--
+ 179             if (currentNode.fromNode != null) {
+ 180                 StdOut.println("current loc: " + currentLoc + " from: " + currentNode.fromNode.getLoc() + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
+ 181             } else {
+ 182                 StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
r 183             }
--[ 2019.11.06.19.48.18.528.0 ]--
r 179             if (currentNode.fromNod != null) {
--[ 2019.11.06.19.48.19.010.0 ]--
r 179             if (currentNode.fromNo != null) {
--[ 2019.11.06.19.48.19.053.0 ]--
r 179             if (currentNode.fromN != null) {
--[ 2019.11.06.19.48.19.084.0 ]--
r 179             if (currentNode.from != null) {
--[ 2019.11.06.19.48.19.100.0 ]--
r 179             if (currentNode.fro != null) {
--[ 2019.11.06.19.48.19.131.0 ]--
r 179             if (currentNode.fr != null) {
--[ 2019.11.06.19.48.19.162.0 ]--
r 179             if (currentNode.f != null) {
--[ 2019.11.06.19.48.19.201.0 ]--
r 179             if (currentNode. != null) {
--[ 2019.11.06.19.48.19.236.0 ]--
r 179             if (currentNode != null) {
--[ 2019.11.06.19.48.19.267.0 ]--
r 179             if (currentNod != null) {
--[ 2019.11.06.19.48.19.298.0 ]--
r 179             if (currentNo != null) {
--[ 2019.11.06.19.48.19.329.0 ]--
r 179             if (currentN != null) {
--[ 2019.11.06.19.48.19.361.0 ]--
r 179             if (current != null) {
--[ 2019.11.06.19.48.19.392.0 ]--
r 179             if (curren != null) {
--[ 2019.11.06.19.48.19.439.0 ]--
r 179             if (curre != null) {
--[ 2019.11.06.19.48.19.470.0 ]--
r 179             if (curr != null) {
--[ 2019.11.06.19.48.19.722.0 ]--
r 179             if (cur != null) {
--[ 2019.11.06.19.48.19.900.0 ]--
r 179             if (cu != null) {
--[ 2019.11.06.19.48.20.087.0 ]--
r 179             if (c != null) {
--[ 2019.11.06.19.48.21.184.0 ]--
r 179             if (cu != null) {
--[ 2019.11.06.19.48.21.262.0 ]--
r 179             if (cur != null) {
--[ 2019.11.06.19.48.21.459.0 ]--
r 179             if (curr != null) {
--[ 2019.11.06.19.48.21.521.0 ]--
r 179             if (curre != null) {
--[ 2019.11.06.19.48.21.631.0 ]--
r 179             if (curren != null) {
--[ 2019.11.06.19.48.21.709.0 ]--
r 179             if (current != null) {
--[ 2019.11.06.19.48.21.849.0 ]--
r 179             if (currentN != null) {
--[ 2019.11.06.19.48.21.990.0 ]--
r 179             if (currentNo != null) {
--[ 2019.11.06.19.48.22.085.0 ]--
r 179             if (currentNod != null) {
--[ 2019.11.06.19.48.22.257.0 ]--
r 179             if (currentNode != null) {
--[ 2019.11.06.19.48.27.188.0 ]--
r 179             if (c != null) {
--[ 2019.11.06.19.48.27.778.0 ]--
r 179             if (currentNode.fromNode != null) {
--[ 2019.11.06.19.48.29.700.0 ]--
- 179
- 179
- 179
- 179
r 179             
--[ 2019.11.06.19.48.30.162.0 ]--
- 179
--[ 2019.11.06.19.48.31.356.0 ]--
+ 189             }
+ 190             if (currentNode.fromNode != null) {
+ 191                 StdOut.println("current loc: " + currentLoc + " from: " + currentNode.fromNode.getLoc() + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
+ 192             } else {
+ 193                 StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.06.19.48.34.213.0 ]--
+ 179             
--[ 2019.11.06.19.48.34.522.0 ]--
r 179             i
--[ 2019.11.06.19.48.34.594.0 ]--
r 179             if
--[ 2019.11.06.19.48.34.703.0 ]--
r 179             if 
--[ 2019.11.06.19.48.34.892.0 ]--
r 179             if ()
--[ 2019.11.06.19.48.35.276.0 ]--
r 179             if (!)
--[ 2019.11.06.19.48.35.932.0 ]--
r 179             if (!a)
--[ 2019.11.06.19.48.36.084.0 ]--
r 179             if (!at)
--[ 2019.11.06.19.48.36.304.0 ]--
r 179             if (!atS)
--[ 2019.11.06.19.48.36.430.0 ]--
r 179             if (!atST)
--[ 2019.11.06.19.48.36.524.0 ]--
r 179             if (!atSTa)
--[ 2019.11.06.19.48.36.602.0 ]--
r 179             if (!atSTar)
--[ 2019.11.06.19.48.36.789.0 ]--
r 179             if (!atSTart)
--[ 2019.11.06.19.48.37.181.0 ]--
r 179             if (!atSTar)
--[ 2019.11.06.19.48.37.353.0 ]--
r 179             if (!atSTa)
--[ 2019.11.06.19.48.37.478.0 ]--
r 179             if (!atST)
--[ 2019.11.06.19.48.38.020.0 ]--
r 179             if (!at)
--[ 2019.11.06.19.48.38.081.0 ]--
r 179             if (!)
--[ 2019.11.06.19.48.38.112.0 ]--
r 179             if ()
--[ 2019.11.06.19.48.38.128.0 ]--
r 179             if 
--[ 2019.11.06.19.48.38.190.0 ]--
r 179             if
--[ 2019.11.06.19.48.38.222.0 ]--
r 179             i
--[ 2019.11.06.19.48.38.440.0 ]--
r 179             
--[ 2019.11.06.19.48.38.639.0 ]--
- 179
--[ 2019.11.06.19.48.48.227.0 ]--
+ 189                 
--[ 2019.11.06.19.48.48.567.0 ]--
+ 189                 if (currentNode.fromNode != null) {
+ 190                 StdOut.println("current loc: " + currentLoc + " from: " + currentNode.fromNode.getLoc() + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
+ 191             } else {
+ 192                 StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
r 193             }
--[ 2019.11.06.19.48.48.614.0 ]--
r 190                     StdOut.println("current loc: " + currentLoc + " from: " + currentNode.fromNode.getLoc() + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
r 191                 } else {
r 192                     StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
r 193                 }
--[ 2019.11.06.19.48.52.028.0 ]--
- 195
- 195
- 195
- 195
r 195 
--[ 2019.11.06.19.48.52.424.0 ]--
- 195
--[ 2019.11.06.19.48.58.213.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.06.19.49.13.220.0 ]--
r 186                 if (!pq.isEmpty()) { StdOut.println("big oof"); break; }
--[ 2019.11.06.19.49.13.565.0 ]--
r 186                 if (!apq.isEmpty()) { StdOut.println("big oof"); break; }
--[ 2019.11.06.19.49.13.831.0 ]--
r 186                 if (!atpq.isEmpty()) { StdOut.println("big oof"); break; }
--[ 2019.11.06.19.49.14.287.0 ]--
r 186                 if (!atSpq.isEmpty()) { StdOut.println("big oof"); break; }
--[ 2019.11.06.19.49.14.616.0 ]--
r 186                 if (!atStarpq.isEmpty()) { StdOut.println("big oof"); break; }
--[ 2019.11.06.19.49.14.759.0 ]--
r 186                 if (!atStartpq.isEmpty()) { StdOut.println("big oof"); break; }
--[ 2019.11.06.19.49.14.846.0 ]--
r 186                 if (!atStart pq.isEmpty()) { StdOut.println("big oof"); break; }
--[ 2019.11.06.19.49.15.808.0 ]--
r 186                 if (!atStart &pq.isEmpty()) { StdOut.println("big oof"); break; }
--[ 2019.11.06.19.49.15.902.0 ]--
r 186                 if (!atStart &&pq.isEmpty()) { StdOut.println("big oof"); break; }
--[ 2019.11.06.19.49.15.980.0 ]--
r 186                 if (!atStart && pq.isEmpty()) { StdOut.println("big oof"); break; }
--[ 2019.11.06.19.49.20.750.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.06.19.49.46.456.0 ]--
r 202                     if (board[c.getLoc().getI()][c.getLoc().getJ()] = null) {
--[ 2019.11.06.19.49.46.674.0 ]--
r 202                     if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
--[ 2019.11.06.19.49.49.834.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.06.19.50.04.526.0 ]--
r 209                     }e
--[ 2019.11.06.19.50.04.560.0 ]--
r 209                     }el
--[ 2019.11.06.19.50.04.780.0 ]--
r 209                     }else
--[ 2019.11.06.19.50.05.454.0 ]--
r 209                     }els
--[ 2019.11.06.19.50.05.640.0 ]--
r 209                     }el
--[ 2019.11.06.19.50.05.875.0 ]--
r 209                     }e
--[ 2019.11.06.19.50.05.922.0 ]--
r 209                     }
--[ 2019.11.06.19.50.06.492.0 ]--
r 209                     } 
--[ 2019.11.06.19.50.06.695.0 ]--
r 209                     } e
--[ 2019.11.06.19.50.06.791.0 ]--
r 209                     } el
--[ 2019.11.06.19.50.06.950.0 ]--
r 209                     } els
--[ 2019.11.06.19.50.06.998.0 ]--
r 209                     } else
--[ 2019.11.06.19.50.07.138.0 ]--
r 209                     } else 
--[ 2019.11.06.19.50.07.265.0 ]--
r 209                     } else i
--[ 2019.11.06.19.50.07.344.0 ]--
r 209                     } else if
--[ 2019.11.06.19.50.07.485.0 ]--
r 209                     } else if 
--[ 2019.11.06.19.50.07.814.0 ]--
r 209                     } else if ()
--[ 2019.11.06.19.50.09.130.0 ]--
r 209                     } else if () 
--[ 2019.11.06.19.50.09.223.0 ]--
r 209                     } else if () {
--[ 2019.11.06.19.50.09.457.0 ]--
+ 210 
+ 211 }
--[ 2019.11.06.19.50.09.535.0 ]--
r 211                     }
--[ 2019.11.06.19.50.09.582.0 ]--
r 210                         
--[ 2019.11.06.19.50.16.012.0 ]--
r 209                     } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
--[ 2019.11.06.19.50.21.569.0 ]--
+ 210                         StdOut.println("inserting " + c.getLoc() + ' ' + c.getCost(h));
+ 211                             pq.insert(c);
+ 212                             //StdOut.println("AHHHHHHHHH --------------------------------------");
r 213                             board[c.getLoc().getI()][c.getLoc().getJ()] = c;
--[ 2019.11.06.19.50.21.662.0 ]--
r 211                         pq.insert(c);
r 212                         //StdOut.println("AHHHHHHHHH --------------------------------------");
r 213                         board[c.getLoc().getI()][c.getLoc().getJ()] = c;
--[ 2019.11.06.19.50.24.518.0 ]--
r 208 
--[ 2019.11.06.19.50.24.976.0 ]--
- 208
--[ 2019.11.06.19.50.26.492.0 ]--
+ 208 
--[ 2019.11.06.19.50.31.652.0 ]--
r 203 
--[ 2019.11.06.19.50.31.904.0 ]--
- 203
--[ 2019.11.06.19.50.35.908.0 ]--
r 203                         StdOut.println("inserting " + c.getLoc() + ' ' + c.getCost(h));
r 204                         pq.insert(c);
r 205                         //StdOut.println("AHHHHHHHHH --------------------------------------");
r 206                         board[c.getLoc().getI()][c.getLoc().getJ()] = c;
--[ 2019.11.06.19.50.40.048.0 ]--
- 207
--[ 2019.11.06.19.50.45.981.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.06.19.51.10.803.0 ]--
r 129                 StdOut.print(board[j][i].);
--[ 2019.11.06.19.51.10.914.0 ]--
r 129                 StdOut.print(board[j][i].g);
--[ 2019.11.06.19.51.10.961.0 ]--
r 129                 StdOut.print(board[j][i].ge);
--[ 2019.11.06.19.51.11.133.0 ]--
r 129                 StdOut.print(board[j][i].get);
--[ 2019.11.06.19.51.11.400.0 ]--
r 129                 StdOut.print(board[j][i].getC);
--[ 2019.11.06.19.51.11.562.0 ]--
r 129                 StdOut.print(board[j][i].getCo);
--[ 2019.11.06.19.51.11.656.0 ]--
r 129                 StdOut.print(board[j][i].getCos);
--[ 2019.11.06.19.51.11.782.0 ]--
r 129                 StdOut.print(board[j][i].getCost);
--[ 2019.11.06.19.51.11.990.0 ]--
r 129                 StdOut.print(board[j][i].getCost());
--[ 2019.11.06.19.51.23.419.0 ]--
r 129                 StdOut.print(board[j][i].getCost(h));
--[ 2019.11.06.19.51.29.800.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.06.19.51.36.862.0 ]--
r 129                 StdOut.print(board[j][i].getCost(h);
--[ 2019.11.06.19.51.37.071.0 ]--
r 129                 StdOut.print(board[j][i].getCost();
--[ 2019.11.06.19.51.37.244.0 ]--
r 129                 StdOut.print(board[j][i].getCost);
--[ 2019.11.06.19.51.37.408.0 ]--
r 129                 StdOut.print(board[j][i].getCos);
--[ 2019.11.06.19.51.37.595.0 ]--
r 129                 StdOut.print(board[j][i].getCo);
--[ 2019.11.06.19.51.37.736.0 ]--
r 129                 StdOut.print(board[j][i].getC);
--[ 2019.11.06.19.51.37.877.0 ]--
r 129                 StdOut.print(board[j][i].get);
--[ 2019.11.06.19.51.38.062.0 ]--
r 129                 StdOut.print(board[j][i].ge);
--[ 2019.11.06.19.51.38.218.0 ]--
r 129                 StdOut.print(board[j][i].g);
--[ 2019.11.06.19.51.38.390.0 ]--
r 129                 StdOut.print(board[j][i].);
--[ 2019.11.06.19.51.38.548.0 ]--
r 129                 StdOut.print(board[j][i]);
--[ 2019.11.06.19.51.59.379.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.06.19.52.29.352.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 48     private final static String emapFilename = emaps[0];        // change index to load a different elevation map
--[ 2019.11.06.19.52.32.618.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.06.19.52.41.550.0 ]--
:/src/Pathfinder.java
r 219         /printOrigBoard();
--[ 2019.11.06.19.52.41.761.0 ]--
r 219         //printOrigBoard();
--[ 2019.11.06.19.52.43.396.0 ]--
r 203                         /StdOut.println("inserting " + c.getLoc() + ' ' + c.getCost(h));
--[ 2019.11.06.19.52.43.622.0 ]--
r 203                         //StdOut.println("inserting " + c.getLoc() + ' ' + c.getCost(h));
--[ 2019.11.06.19.52.44.879.0 ]--
r 208                         /StdOut.println("inserting " + c.getLoc() + ' ' + c.getCost(h));
--[ 2019.11.06.19.52.45.082.0 ]--
r 208                         //StdOut.println("inserting " + c.getLoc() + ' ' + c.getCost(h));
--[ 2019.11.06.19.52.47.076.0 ]--
r 192                     /StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.06.19.52.47.297.0 ]--
r 192                     //StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.06.19.52.48.487.0 ]--
r 190                     /StdOut.println("current loc: " + currentLoc + " from: " + currentNode.fromNode.getLoc() + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.06.19.52.48.643.0 ]--
r 190                     //StdOut.println("current loc: " + currentLoc + " from: " + currentNode.fromNode.getLoc() + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
--[ 2019.11.06.19.52.55.872.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.06.19.53.51.499.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.06.19.53.54.652.0 ]--
r 48     private final static String emapFilename = emaps[2];        // change index to load a different elevation map
--[ 2019.11.06.19.53.57.831.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.06.20.07.49.477.0 ]--
:/src/Pathfinder.java
r 186                 if (! && pq.isEmpty()) { StdOut.println("big oof"); break; }
--[ 2019.11.06.20.07.49.807.0 ]--
r 186                 if ( && pq.isEmpty()) { StdOut.println("big oof"); break; }
--[ 2019.11.06.20.07.50.449.0 ]--
r 186                 if (&& pq.isEmpty()) { StdOut.println("big oof"); break; }
--[ 2019.11.06.20.07.50.607.0 ]--
r 186                 if (& pq.isEmpty()) { StdOut.println("big oof"); break; }
--[ 2019.11.06.20.07.50.812.0 ]--
r 186                 if ( pq.isEmpty()) { StdOut.println("big oof"); break; }
--[ 2019.11.06.20.07.50.982.0 ]--
r 186                 if (pq.isEmpty()) { StdOut.println("big oof"); break; }
--[ 2019.11.06.20.07.54.603.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.06.20.08.04.994.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.06.20.08.06.133.0 ]--
r 48     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2019.11.06.20.08.06.399.0 ]--
r 48     private final static String emapFilename = emaps[11];        // change index to load a different elevation map
--[ 2019.11.06.20.08.09.604.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.06.20.11.45.314.0 ]--
:/src/Pathfinder.java
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) ;
--[ 2019.11.06.20.11.45.567.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) *;
--[ 2019.11.06.20.11.45.636.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) * ;
--[ 2019.11.06.20.11.46.349.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) *;
--[ 2019.11.06.20.11.46.544.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) ;
--[ 2019.11.06.20.11.46.951.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) +;
--[ 2019.11.06.20.11.47.084.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + ;
--[ 2019.11.06.20.11.49.765.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + h;
--[ 2019.11.06.20.11.49.829.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + he;
--[ 2019.11.06.20.11.49.985.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heu;
--[ 2019.11.06.20.11.50.089.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heur;
--[ 2019.11.06.20.11.50.575.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuri;
--[ 2019.11.06.20.11.50.681.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuris;
--[ 2019.11.06.20.11.50.744.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heurist;
--[ 2019.11.06.20.11.50.837.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristi;
--[ 2019.11.06.20.11.50.993.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic;
--[ 2019.11.06.20.11.51.432.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*;
--[ 2019.11.06.20.11.54.103.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*t;
--[ 2019.11.06.20.11.54.209.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*te;
--[ 2019.11.06.20.11.54.398.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*ter;
--[ 2019.11.06.20.11.54.571.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terr;
--[ 2019.11.06.20.11.54.626.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terra;
--[ 2019.11.06.20.11.54.720.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrai;
--[ 2019.11.06.20.11.54.783.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain;
--[ 2019.11.06.20.11.55.065.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.;
--[ 2019.11.06.20.11.55.493.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.c;
--[ 2019.11.06.20.11.55.762.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.com;
--[ 2019.11.06.20.11.55.809.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.comp;
--[ 2019.11.06.20.11.55.887.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.compu;
--[ 2019.11.06.20.11.55.996.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.comput;
--[ 2019.11.06.20.11.56.074.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.compute;
--[ 2019.11.06.20.11.56.325.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.computeD;
--[ 2019.11.06.20.11.56.476.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.computeDi;
--[ 2019.11.06.20.11.56.617.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.computeDis;
--[ 2019.11.06.20.11.56.679.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.computeDist;
--[ 2019.11.06.20.11.56.742.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.computeDista;
--[ 2019.11.06.20.11.56.851.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.computeDistan;
--[ 2019.11.06.20.11.56.914.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.computeDistanc;
--[ 2019.11.06.20.11.57.181.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.computeDistance;
--[ 2019.11.06.20.11.57.461.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.computeDistance();
--[ 2019.11.06.20.11.58.255.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.computeDistance(l);
--[ 2019.11.06.20.11.58.360.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.computeDistance(lo);
--[ 2019.11.06.20.11.58.422.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.computeDistance(loc);
--[ 2019.11.06.20.11.58.610.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.computeDistance(loc,);
--[ 2019.11.06.20.11.58.764.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.computeDistance(loc, );
--[ 2019.11.06.20.11.59.187.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.computeDistance(loc, e);
--[ 2019.11.06.20.11.59.311.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.computeDistance(loc, en);
--[ 2019.11.06.20.11.59.404.0 ]--
r 58                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.computeDistance(loc, end);
--[ 2019.11.06.20.12.03.606.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.06.20.12.24.529.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 48     private final static String emapFilename = emaps[0];        // change index to load a different elevation map
--[ 2019.11.06.20.12.51.181.0 ]--
:/src/Pathfinder.java
r 147 
--[ 2019.11.06.20.12.51.455.0 ]--
- 147
--[ 2019.11.06.20.14.12.585.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.06.20.16.09.338.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.06.20.16.11.389.0 ]--
r 48     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2019.11.06.20.16.11.549.0 ]--
r 48     private final static String emapFilename = emaps[11];        // change index to load a different elevation map
--[ 2019.11.06.20.16.14.842.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.06.20.16.55.727.0 ]--
:/src/Pathfinder.java
r 176             /StdOut.println("goodbye, sanity!");
--[ 2019.11.06.20.16.55.963.0 ]--
r 176             //StdOut.println("goodbye, sanity!");
--[ 2019.11.06.20.16.57.472.0 ]--
r 179                 /StdOut.println("first run");
--[ 2019.11.06.20.16.57.667.0 ]--
r 179                 //StdOut.println("first run");
--[ 2019.11.06.20.17.04.442.0 ]--
+ 178             
--[ 2019.11.06.20.17.04.771.0 ]--
r 178             S
--[ 2019.11.06.20.17.04.874.0 ]--
r 178             St
--[ 2019.11.06.20.17.05.062.0 ]--
r 178             Sto
--[ 2019.11.06.20.17.05.124.0 ]--
r 178             Stop
--[ 2019.11.06.20.17.05.187.0 ]--
r 178             Stopw
--[ 2019.11.06.20.17.05.249.0 ]--
r 178             Stopwa
--[ 2019.11.06.20.17.05.312.0 ]--
r 178             Stopwat
--[ 2019.11.06.20.17.05.548.0 ]--
r 178             Stopwatc
--[ 2019.11.06.20.17.05.626.0 ]--
r 178             Stopwatch
--[ 2019.11.06.20.17.05.723.0 ]--
r 178             Stopwatch 
--[ 2019.11.06.20.17.05.816.0 ]--
r 178             Stopwatch s
--[ 2019.11.06.20.17.06.082.0 ]--
r 178             Stopwatch stop
--[ 2019.11.06.20.17.06.144.0 ]--
r 178             Stopwatch stopw
--[ 2019.11.06.20.17.06.207.0 ]--
r 178             Stopwatch stopwa
--[ 2019.11.06.20.17.06.285.0 ]--
r 178             Stopwatch stopwat
--[ 2019.11.06.20.17.06.504.0 ]--
r 178             Stopwatch stopwatc
--[ 2019.11.06.20.17.06.551.0 ]--
r 178             Stopwatch stopwatch
--[ 2019.11.06.20.17.06.660.0 ]--
r 178             Stopwatch stopwatch 
--[ 2019.11.06.20.17.06.754.0 ]--
r 178             Stopwatch stopwatch =
--[ 2019.11.06.20.17.06.832.0 ]--
r 178             Stopwatch stopwatch = 
--[ 2019.11.06.20.17.07.035.0 ]--
r 178             Stopwatch stopwatch = n
--[ 2019.11.06.20.17.07.264.0 ]--
r 178             Stopwatch stopwatch = ne
--[ 2019.11.06.20.17.07.405.0 ]--
r 178             Stopwatch stopwatch = new
--[ 2019.11.06.20.17.07.547.0 ]--
r 178             Stopwatch stopwatch = new 
--[ 2019.11.06.20.17.07.737.0 ]--
r 178             Stopwatch stopwatch = new S
--[ 2019.11.06.20.17.07.893.0 ]--
r 178             Stopwatch stopwatch = new St
--[ 2019.11.06.20.17.07.987.0 ]--
r 178             Stopwatch stopwatch = new Sto
--[ 2019.11.06.20.17.08.034.0 ]--
r 178             Stopwatch stopwatch = new Stop
--[ 2019.11.06.20.17.08.128.0 ]--
r 178             Stopwatch stopwatch = new Stopw
--[ 2019.11.06.20.17.08.206.0 ]--
r 178             Stopwatch stopwatch = new Stopwa
--[ 2019.11.06.20.17.08.268.0 ]--
r 178             Stopwatch stopwatch = new Stopwat
--[ 2019.11.06.20.17.08.488.0 ]--
r 178             Stopwatch stopwatch = new Stopwatc
--[ 2019.11.06.20.17.08.535.0 ]--
r 178             Stopwatch stopwatch = new Stopwatch
--[ 2019.11.06.20.17.08.821.0 ]--
r 178             Stopwatch stopwatch = new Stopwatch()
--[ 2019.11.06.20.17.09.148.0 ]--
r 178             Stopwatch stopwatch = new Stopwatch();
--[ 2019.11.06.20.17.16.912.0 ]--
+ 215             
--[ 2019.11.06.20.17.18.747.0 ]--
r 215             S
--[ 2019.11.06.20.17.19.154.0 ]--
r 215             St
--[ 2019.11.06.20.17.19.229.0 ]--
r 215             Std
--[ 2019.11.06.20.17.19.276.0 ]--
r 215             StdO
--[ 2019.11.06.20.17.19.496.0 ]--
r 215             StdOu
--[ 2019.11.06.20.17.19.558.0 ]--
r 215             StdOut
--[ 2019.11.06.20.17.19.668.0 ]--
r 215             StdOut.
--[ 2019.11.06.20.17.19.967.0 ]--
r 215             StdOut.p
--[ 2019.11.06.20.17.20.035.0 ]--
r 215             StdOut.pr
--[ 2019.11.06.20.17.20.097.0 ]--
r 215             StdOut.pri
--[ 2019.11.06.20.17.20.285.0 ]--
r 215             StdOut.prin
--[ 2019.11.06.20.17.20.376.0 ]--
r 215             StdOut.print
--[ 2019.11.06.20.17.20.454.0 ]--
r 215             StdOut.printl
--[ 2019.11.06.20.17.20.516.0 ]--
r 215             StdOut.println
--[ 2019.11.06.20.17.20.736.0 ]--
r 215             StdOut.println()
--[ 2019.11.06.20.17.20.931.0 ]--
r 215             StdOut.println("")
--[ 2019.11.06.20.17.21.134.0 ]--
r 215             StdOut.println("t")
--[ 2019.11.06.20.17.21.241.0 ]--
r 215             StdOut.println("ti")
--[ 2019.11.06.20.17.21.288.0 ]--
r 215             StdOut.println("tim")
--[ 2019.11.06.20.17.21.366.0 ]--
r 215             StdOut.println("time")
--[ 2019.11.06.20.17.21.522.0 ]--
r 215             StdOut.println("time:")
--[ 2019.11.06.20.17.21.663.0 ]--
r 215             StdOut.println("time: ")
--[ 2019.11.06.20.17.22.171.0 ]--
r 215             StdOut.println("time: " )
--[ 2019.11.06.20.17.22.360.0 ]--
r 215             StdOut.println("time: " +)
--[ 2019.11.06.20.17.22.440.0 ]--
r 215             StdOut.println("time: " + )
--[ 2019.11.06.20.17.28.663.0 ]--
r 215 
--[ 2019.11.06.20.17.28.901.0 ]--
- 215
--[ 2019.11.06.20.17.33.528.0 ]--
+ 175         
--[ 2019.11.06.20.17.34.139.0 ]--
r 175                     Stopwatch stopwatch = new Stopwatch();
--[ 2019.11.06.20.17.34.178.0 ]--
r 175         Stopwatch stopwatch = new Stopwatch();
--[ 2019.11.06.20.17.36.444.0 ]--
r 179 
--[ 2019.11.06.20.17.36.679.0 ]--
- 179
--[ 2019.11.06.20.17.40.187.0 ]--
+ 218         
--[ 2019.11.06.20.17.45.545.0 ]--
- 219
- 219
- 219
- 219
- 219
- 219
r 219 
--[ 2019.11.06.20.17.45.823.0 ]--
- 219
--[ 2019.11.06.20.17.47.758.0 ]--
r 218         S
--[ 2019.11.06.20.17.47.964.0 ]--
r 218         St
--[ 2019.11.06.20.17.48.117.0 ]--
r 218         Std
--[ 2019.11.06.20.17.48.322.0 ]--
r 218         StdO
--[ 2019.11.06.20.17.48.512.0 ]--
r 218         StdOu
--[ 2019.11.06.20.17.48.591.0 ]--
r 218         StdOut
--[ 2019.11.06.20.17.48.712.0 ]--
r 218         StdOut.
--[ 2019.11.06.20.17.48.979.0 ]--
r 218         StdOut.p
--[ 2019.11.06.20.17.49.064.0 ]--
r 218         StdOut.pr
--[ 2019.11.06.20.17.49.111.0 ]--
r 218         StdOut.pri
--[ 2019.11.06.20.17.49.264.0 ]--
r 218         StdOut.prin
--[ 2019.11.06.20.17.49.341.0 ]--
r 218         StdOut.print
--[ 2019.11.06.20.17.49.451.0 ]--
r 218         StdOut.printl
--[ 2019.11.06.20.17.49.498.0 ]--
r 218         StdOut.println
--[ 2019.11.06.20.17.49.717.0 ]--
r 218         StdOut.println()
--[ 2019.11.06.20.17.49.889.0 ]--
r 218         StdOut.println("")
--[ 2019.11.06.20.17.50.133.0 ]--
r 218         StdOut.println("s")
--[ 2019.11.06.20.17.50.211.0 ]--
r 218         StdOut.println("st")
--[ 2019.11.06.20.17.50.430.0 ]--
r 218         StdOut.println("stopw")
--[ 2019.11.06.20.17.50.477.0 ]--
r 218         StdOut.println("stopwa")
--[ 2019.11.06.20.17.50.523.0 ]--
r 218         StdOut.println("stopwat")
--[ 2019.11.06.20.17.50.729.0 ]--
r 218         StdOut.println("stopwatc")
--[ 2019.11.06.20.17.50.822.0 ]--
r 218         StdOut.println("stopwatch")
--[ 2019.11.06.20.17.51.047.0 ]--
r 218         StdOut.println("stopwatch:")
--[ 2019.11.06.20.17.51.183.0 ]--
r 218         StdOut.println("stopwatch: ")
--[ 2019.11.06.20.17.51.654.0 ]--
r 218         StdOut.println("stopwatch: " )
--[ 2019.11.06.20.17.51.799.0 ]--
r 218         StdOut.println("stopwatch: " +)
--[ 2019.11.06.20.17.51.955.0 ]--
r 218         StdOut.println("stopwatch: " + )
--[ 2019.11.06.20.17.52.096.0 ]--
r 218         StdOut.println("stopwatch: " + s)
--[ 2019.11.06.20.17.52.242.0 ]--
r 218         StdOut.println("stopwatch: " + st)
--[ 2019.11.06.20.17.52.289.0 ]--
r 218         StdOut.println("stopwatch: " + sto)
--[ 2019.11.06.20.17.52.367.0 ]--
r 218         StdOut.println("stopwatch: " + stop)
--[ 2019.11.06.20.17.52.790.0 ]--
r 218         StdOut.println("stopwatch: " + stopw)
--[ 2019.11.06.20.17.52.837.0 ]--
r 218         StdOut.println("stopwatch: " + stopwa)
--[ 2019.11.06.20.17.52.882.0 ]--
r 218         StdOut.println("stopwatch: " + stopwat)
--[ 2019.11.06.20.17.53.085.0 ]--
r 218         StdOut.println("stopwatch: " + stopwatc)
--[ 2019.11.06.20.17.53.150.0 ]--
r 218         StdOut.println("stopwatch: " + stopwatch)
--[ 2019.11.06.20.17.53.316.0 ]--
r 218         StdOut.println("stopwatch: " + stopwatch.)
--[ 2019.11.06.20.17.53.440.0 ]--
r 218         StdOut.println("stopwatch: " + stopwatch.e)
--[ 2019.11.06.20.17.53.534.0 ]--
r 218         StdOut.println("stopwatch: " + stopwatch.el)
--[ 2019.11.06.20.17.53.644.0 ]--
r 218         StdOut.println("stopwatch: " + stopwatch.ela)
--[ 2019.11.06.20.17.53.722.0 ]--
r 218         StdOut.println("stopwatch: " + stopwatch.elap)
--[ 2019.11.06.20.17.53.862.0 ]--
r 218         StdOut.println("stopwatch: " + stopwatch.elaps)
--[ 2019.11.06.20.17.53.943.0 ]--
r 218         StdOut.println("stopwatch: " + stopwatch.elapse)
--[ 2019.11.06.20.17.54.129.0 ]--
r 218         StdOut.println("stopwatch: " + stopwatch.elapsed)
--[ 2019.11.06.20.17.54.327.0 ]--
r 218         StdOut.println("stopwatch: " + stopwatch.elapsedT)
--[ 2019.11.06.20.17.54.499.0 ]--
r 218         StdOut.println("stopwatch: " + stopwatch.elapsedTim)
--[ 2019.11.06.20.17.54.548.0 ]--
r 218         StdOut.println("stopwatch: " + stopwatch.elapsedTime)
--[ 2019.11.06.20.17.54.874.0 ]--
r 218         StdOut.println("stopwatch: " + stopwatch.elapsedTime())
--[ 2019.11.06.20.17.55.356.0 ]--
r 218         StdOut.println("stopwatch: " + stopwatch.elapsedTime());
--[ 2019.11.06.20.18.02.482.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.06.20.21.09.821.0 ]--
DisposeComponent
--[ 2019.11.07.00.28.54.017.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.11.07.00.28.54.279.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml

--[ 2019.11.07.00.28.54.293.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.07.00.28.54.314.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.11.07.00.28.54.328.0 ]--
InitFile: /.cos265


--[ 2019.11.07.00.28.54.346.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.11.07.00.28.54.360.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.11.07.00.28.54.376.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[11];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.11.07.00.28.54.744.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.11.07.00.28.54.810.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return null;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return true;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
    }

}

--[ 2019.11.07.00.28.54.831.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private Terrain terrain;
    private PFNode[][] board;
    private int[][] origCost;
    private float h;
    private int N;
    private PFNode endNode;
    private boolean pathFound;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        public Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null)  this.cost = 0.0f;
                else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.computeDistance(loc, end);
            }
        }

        public float getCost(float heuristic) {
            return cost;
        }

        // returns if this PFNode is not marked invalid
        public boolean isValid() {
            return false;
        }

        // marks the PFNode as invalid
        public void invalidate() {

        }

        // returns if the PFNode is marked as used
        public boolean isUsed() {
            return true;
        }

        // marks the PFNode as used
        public void use() { }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        pathFound = false;
        board = new PFNode[N][N];

    }

    public void setPathStart(Coord loc) {
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    private void printOrigBoard() {
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board.length; j++) {
                //StdOut.print(terrain.getHeight(j, i));
                StdOut.print(board[j][i]);
                StdOut.print(' ');
            }
            StdOut.println();
        }
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        // Step 1: Look at all possible locations from starting point, create nodes for each
        origCost = new int[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                origCost[i][j] = this.terrain.getHeight(i, j);
            }
        }
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        Stopwatch stopwatch = new Stopwatch();
        while (true) {
            //StdOut.println("goodbye, sanity!");
            PFNode currentNode;
            if (atStart) {
                //StdOut.println("first run");
                currentNode = new PFNode(currentLoc, null);
                int i = currentNode.getLoc().getI();
                int j = currentNode.getLoc().getJ();
            }
            else {
                if (pq.isEmpty()) { StdOut.println("big oof"); break; }
                else currentNode = pq.delMin();
                currentLoc = currentNode.getLoc();
                if (currentNode.fromNode != null) {
                    //StdOut.println("current loc: " + currentLoc + " from: " + currentNode.fromNode.getLoc() + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
                } else {
                    //StdOut.println("current loc: " + currentLoc + " cost: " + currentNode.getCost(h) + " origVal: " + origCost[currentLoc.getI()][currentLoc.getJ()]);
                }
            }
            if (currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == getPathEnd().getJ()) {
                pathFound = true;
                endNode = currentNode;
                break;
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        //StdOut.println("inserting " + c.getLoc() + ' ' + c.getCost(h));
                        pq.insert(c);
                        //StdOut.println("AHHHHHHHHH --------------------------------------");
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        //StdOut.println("inserting " + c.getLoc() + ' ' + c.getCost(h));
                        pq.insert(c);
                        //StdOut.println("AHHHHHHHHH --------------------------------------");
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            atStart = false;
            //printOrigBoard();
        }
        StdOut.println("stopwatch: " + stopwatch.elapsedTime());

    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(h);
        else return 0;
    }

    public int getSearchSize() {
        return 0;
    }

    public Iterable<Coord> getPathSolution() {
        Stack<Coord> s = new Stack<>();
        PFNode c = endNode;
        while (c != null) {
            s.push(c.getLoc());
            c = c.fromNode;
        }
        return s;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2019.11.07.00.32.17.461.0 ]--
:/src/Pathfinder.java
+ 19     
--[ 2019.11.07.00.32.18.354.0 ]--
r 19     pr
--[ 2019.11.07.00.32.18.441.0 ]--
r 19     pri
--[ 2019.11.07.00.32.18.663.0 ]--
r 19     priva
--[ 2019.11.07.00.32.19.360.0 ]--
r 19     private
--[ 2019.11.07.00.32.19.673.0 ]--
r 19     private int sear
--[ 2019.11.07.00.32.19.816.0 ]--
r 19     private int searc
--[ 2019.11.07.00.32.19.926.0 ]--
r 19     private int search
--[ 2019.11.07.00.32.20.065.0 ]--
r 19     private int searchS
--[ 2019.11.07.00.32.20.206.0 ]--
r 19     private int searchSi
--[ 2019.11.07.00.32.20.301.0 ]--
r 19     private int searchSiz
--[ 2019.11.07.00.32.20.385.0 ]--
r 19     private int searchSize
--[ 2019.11.07.00.32.20.455.0 ]--
r 19     private int searchSize;
--[ 2019.11.07.00.32.30.820.0 ]--
+ 103         
--[ 2019.11.07.00.32.31.622.0 ]--
r 103         search
--[ 2019.11.07.00.32.31.736.0 ]--
r 103         searchS
--[ 2019.11.07.00.32.31.829.0 ]--
r 103         searchSi
--[ 2019.11.07.00.32.31.963.0 ]--
r 103         searchSiz
--[ 2019.11.07.00.32.32.063.0 ]--
r 103         searchSize
--[ 2019.11.07.00.32.32.130.0 ]--
r 103         searchSize 
--[ 2019.11.07.00.32.32.238.0 ]--
r 103         searchSize =
--[ 2019.11.07.00.32.32.329.0 ]--
r 103         searchSize = 
--[ 2019.11.07.00.32.32.446.0 ]--
r 103         searchSize = 0
--[ 2019.11.07.00.32.32.673.0 ]--
r 103         searchSize = 0;
--[ 2019.11.07.00.32.41.622.0 ]--
+ 150         
--[ 2019.11.07.00.32.42.405.0 ]--
r 150         search
--[ 2019.11.07.00.32.42.484.0 ]--
r 150         searchS
--[ 2019.11.07.00.32.42.597.0 ]--
r 150         searchSi
--[ 2019.11.07.00.32.42.679.0 ]--
r 150         searchSiz
--[ 2019.11.07.00.32.42.797.0 ]--
r 150         searchSize
--[ 2019.11.07.00.32.42.966.0 ]--
r 150         searchSize =
--[ 2019.11.07.00.32.43.043.0 ]--
r 150         searchSize = 
--[ 2019.11.07.00.32.43.139.0 ]--
r 150         searchSize = 0
--[ 2019.11.07.00.32.43.366.0 ]--
r 150         searchSize = 0;
--[ 2019.11.07.00.32.57.103.0 ]--
+ 208                         
--[ 2019.11.07.00.32.58.084.0 ]--
r 208                         searchS
--[ 2019.11.07.00.32.58.219.0 ]--
r 208                         searchSi
--[ 2019.11.07.00.32.58.299.0 ]--
r 208                         searchSiz
--[ 2019.11.07.00.32.58.388.0 ]--
r 208                         searchSize
--[ 2019.11.07.00.32.58.658.0 ]--
r 208                         searchSize+
--[ 2019.11.07.00.32.58.824.0 ]--
r 208                         searchSize++
--[ 2019.11.07.00.32.59.025.0 ]--
r 208                         searchSize++;
--[ 2019.11.07.00.33.02.580.0 ]--
+ 216                         
--[ 2019.11.07.00.33.02.716.0 ]--
r 216                         s
--[ 2019.11.07.00.33.02.832.0 ]--
r 216                         se
--[ 2019.11.07.00.33.02.919.0 ]--
r 216                         sea
--[ 2019.11.07.00.33.03.000.0 ]--
r 216                         sear
--[ 2019.11.07.00.33.03.150.0 ]--
r 216                         searc
--[ 2019.11.07.00.33.03.270.0 ]--
r 216                         search
--[ 2019.11.07.00.33.03.434.0 ]--
r 216                         searchS
--[ 2019.11.07.00.33.03.531.0 ]--
r 216                         searchSi
--[ 2019.11.07.00.33.03.645.0 ]--
r 216                         searchSiz
--[ 2019.11.07.00.33.03.791.0 ]--
r 216                         searchSize
--[ 2019.11.07.00.33.03.955.0 ]--
r 216                         searchSize+
--[ 2019.11.07.00.33.04.079.0 ]--
r 216                         searchSize++
--[ 2019.11.07.00.33.04.289.0 ]--
r 216                         searchSize++;
--[ 2019.11.07.00.33.07.395.0 ]--
r 208 
--[ 2019.11.07.00.33.08.241.0 ]--
- 208
--[ 2019.11.07.00.33.11.797.0 ]--
+ 210                         
--[ 2019.11.07.00.33.12.081.0 ]--
r 210                         se
--[ 2019.11.07.00.33.12.188.0 ]--
r 210                         sea
--[ 2019.11.07.00.33.12.302.0 ]--
r 210                         sear
--[ 2019.11.07.00.33.12.557.0 ]--
r 210                         searc
--[ 2019.11.07.00.33.12.699.0 ]--
r 210                         search
--[ 2019.11.07.00.33.12.807.0 ]--
r 210                         searchS
--[ 2019.11.07.00.33.13.007.0 ]--
r 210                         searchSi
--[ 2019.11.07.00.33.13.133.0 ]--
r 210                         searchSize
--[ 2019.11.07.00.33.13.401.0 ]--
r 210                         searchSize+
--[ 2019.11.07.00.33.13.499.0 ]--
r 210                         searchSize++
--[ 2019.11.07.00.33.13.677.0 ]--
r 210                         searchSize++;
--[ 2019.11.07.00.33.21.170.0 ]--
r 244         return ;
--[ 2019.11.07.00.33.21.924.0 ]--
r 244         return s;
--[ 2019.11.07.00.33.21.969.0 ]--
r 244         return se;
--[ 2019.11.07.00.33.22.113.0 ]--
r 244         return sea;
--[ 2019.11.07.00.33.22.160.0 ]--
r 244         return sear;
--[ 2019.11.07.00.33.22.378.0 ]--
r 244         return searc;
--[ 2019.11.07.00.33.22.479.0 ]--
r 244         return search;
--[ 2019.11.07.00.33.22.621.0 ]--
r 244         return searchS;
--[ 2019.11.07.00.33.22.790.0 ]--
r 244         return searchSi;
--[ 2019.11.07.00.33.22.910.0 ]--
r 244         return searchSiz;
--[ 2019.11.07.00.33.23.010.0 ]--
r 244         return searchSize;
--[ 2019.11.07.00.33.37.481.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 48     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2019.11.07.00.33.38.322.0 ]--
r 48     private final static String emapFilename = emaps[12];        // change index to load a different elevation map
--[ 2019.11.07.00.33.49.956.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.07.00.34.46.660.0 ]--
:/src/Pathfinder.java
r 216 
--[ 2019.11.07.00.34.46.809.0 ]--
- 216
--[ 2019.11.07.00.34.53.857.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.07.00.37.05.948.0 ]--
- 28
r 28 
--[ 2019.11.07.00.37.06.173.0 ]--
- 28
--[ 2019.11.07.00.37.19.819.0 ]--
- 125
- 125
- 125
- 125
- 125
- 125
- 125
- 125
- 125
- 125
--[ 2019.11.07.00.37.20.696.0 ]--
- 124
--[ 2019.11.07.00.37.30.693.0 ]--
- 157
- 157
- 157
- 157
- 157
r 157 
--[ 2019.11.07.00.37.31.517.0 ]--
- 157
--[ 2019.11.07.00.37.35.104.0 ]--
r 161 
--[ 2019.11.07.00.37.35.524.0 ]--
- 161
--[ 2019.11.07.00.37.37.749.0 ]--
r 163 
--[ 2019.11.07.00.37.37.943.0 ]--
- 163
--[ 2019.11.07.00.37.39.803.0 ]--
- 164
r 164 
--[ 2019.11.07.00.37.40.021.0 ]--
- 164
--[ 2019.11.07.00.37.42.029.0 ]--
- 162
r 162             if (atStart) { currentNode = new PFNode(currentLoc, null);
--[ 2019.11.07.00.37.43.613.0 ]--
r 162             if (atStart) {currentNode = new PFNode(currentLoc, null);
--[ 2019.11.07.00.37.43.759.0 ]--
r 162             if (atStart) currentNode = new PFNode(currentLoc, null);
--[ 2019.11.07.00.37.44.585.0 ]--
r 163             
--[ 2019.11.07.00.37.45.031.0 ]--
- 163
--[ 2019.11.07.00.37.51.913.0 ]--
r 164                 if (pq.isEmpty()) break; }
--[ 2019.11.07.00.37.53.080.0 ]--
r 164                 if (pq.isEmpty()) break; 
--[ 2019.11.07.00.37.55.547.0 ]--
r 164                 if (pq.isEmpty()) break;
--[ 2019.11.07.00.38.03.830.0 ]--
- 167
- 167
- 167
- 167
r 167 
--[ 2019.11.07.00.38.04.566.0 ]--
- 167
--[ 2019.11.07.00.38.12.319.0 ]--
r 176 
--[ 2019.11.07.00.38.12.511.0 ]--
- 176
--[ 2019.11.07.00.38.17.079.0 ]--
r 177 
--[ 2019.11.07.00.38.17.889.0 ]--
- 177
--[ 2019.11.07.00.38.21.027.0 ]--
r 182 
--[ 2019.11.07.00.38.21.231.0 ]--
- 182
--[ 2019.11.07.00.38.23.226.0 ]--
+ 182 
--[ 2019.11.07.00.38.24.243.0 ]--
r 182                         //StdOut.println("AHHHHHHHHH --------------------------------------");
--[ 2019.11.07.00.38.25.190.0 ]--
r 182 
--[ 2019.11.07.00.38.25.636.0 ]--
- 182
--[ 2019.11.07.00.38.29.260.0 ]--
r 180 
--[ 2019.11.07.00.38.30.004.0 ]--
- 180
--[ 2019.11.07.00.38.36.109.0 ]--
r 186 
--[ 2019.11.07.00.38.48.321.0 ]--
- 186
--[ 2019.11.07.00.38.53.964.0 ]--
- 188
--[ 2019.11.07.00.39.20.196.0 ]--
- 63
- 63
- 63
- 63
- 63
- 63
- 63
- 63
- 63
- 63
- 65
- 65
- 65
- 65
- 66
- 66
--[ 2019.11.07.00.39.21.241.0 ]--
- 64
r 64         
--[ 2019.11.07.00.39.22.219.0 ]--
- 64
--[ 2019.11.07.00.39.43.914.0 ]--
r 16 
--[ 2019.11.07.00.39.44.799.0 ]--
- 16
--[ 2019.11.07.00.40.03.904.0 ]--
r 137 
--[ 2019.11.07.00.40.04.823.0 ]--
- 137
--[ 2019.11.07.00.40.34.986.0 ]--
r 145                 else {currentNode = pq.delMin();
--[ 2019.11.07.00.40.36.403.0 ]--
r 145                 else { currentNode = pq.delMin();
--[ 2019.11.07.00.40.38.505.0 ]--
r 146                 currentLoc = currentNode.getLoc();}
--[ 2019.11.07.00.40.40.700.0 ]--
+ 146                 currentLoc = currentNode.getLoc();
r 147                 }
--[ 2019.11.07.00.40.43.607.0 ]--
+ 145                 else { 
r 146                     currentNode = pq.delMin();
--[ 2019.11.07.00.40.45.421.0 ]--
r 147                 c   urrentLoc = currentNode.getLoc();
--[ 2019.11.07.00.40.47.589.0 ]--
r 147                 c  urrentLoc = currentNode.getLoc();
--[ 2019.11.07.00.40.48.321.0 ]--
r 147                 c    urrentLoc = currentNode.getLoc();
--[ 2019.11.07.00.40.49.820.0 ]--
r 147                 c   urrentLoc = currentNode.getLoc();
--[ 2019.11.07.00.40.50.202.0 ]--
r 147                 c  urrentLoc = currentNode.getLoc();
--[ 2019.11.07.00.40.50.485.0 ]--
r 147                 c urrentLoc = currentNode.getLoc();
--[ 2019.11.07.00.40.50.652.0 ]--
r 147                 currentLoc = currentNode.getLoc();
--[ 2019.11.07.00.40.51.882.0 ]--
r 147                     currentLoc = currentNode.getLoc();
--[ 2019.11.07.00.40.57.771.0 ]--
r 145                 else {
--[ 2019.11.07.00.41.01.541.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.07.00.41.58.051.0 ]--
+ 137         
--[ 2019.11.07.00.41.58.831.0 ]--
r 137         if 
--[ 2019.11.07.00.41.59.680.0 ]--
r 137         if s
--[ 2019.11.07.00.41.59.776.0 ]--
r 137         if st
--[ 2019.11.07.00.41.59.930.0 ]--
r 137         if sta
--[ 2019.11.07.00.41.59.977.0 ]--
r 137         if star
--[ 2019.11.07.00.42.00.294.0 ]--
r 137         if start
--[ 2019.11.07.00.42.00.693.0 ]--
r 137         if star
--[ 2019.11.07.00.42.00.861.0 ]--
r 137         if sta
--[ 2019.11.07.00.42.00.993.0 ]--
r 137         if st
--[ 2019.11.07.00.42.01.142.0 ]--
r 137         if s
--[ 2019.11.07.00.42.02.082.0 ]--
r 137         if 
--[ 2019.11.07.00.42.02.453.0 ]--
r 137         if ()
--[ 2019.11.07.00.42.03.239.0 ]--
r 137         if (s)
--[ 2019.11.07.00.42.03.429.0 ]--
r 137         if (st)
--[ 2019.11.07.00.42.03.527.0 ]--
r 137         if (sta)
--[ 2019.11.07.00.42.03.625.0 ]--
r 137         if (star)
--[ 2019.11.07.00.42.03.874.0 ]--
r 137         if (start)
--[ 2019.11.07.00.42.04.008.0 ]--
r 137         if (start )
--[ 2019.11.07.00.42.04.381.0 ]--
r 137         if (start =)
--[ 2019.11.07.00.42.04.661.0 ]--
r 137         if (start ==)
--[ 2019.11.07.00.42.04.864.0 ]--
r 137         if (start == )
--[ 2019.11.07.00.42.04.914.0 ]--
r 137         if (start == n)
--[ 2019.11.07.00.42.05.105.0 ]--
r 137         if (start == nu)
--[ 2019.11.07.00.42.05.353.0 ]--
r 137         if (start == nul)
--[ 2019.11.07.00.42.05.487.0 ]--
r 137         if (start == null)
--[ 2019.11.07.00.42.06.027.0 ]--
r 137         if (start == null )
--[ 2019.11.07.00.42.06.221.0 ]--
r 137         if (start == null |)
--[ 2019.11.07.00.42.06.437.0 ]--
r 137         if (start == null ||)
--[ 2019.11.07.00.42.06.524.0 ]--
r 137         if (start == null || )
--[ 2019.11.07.00.42.07.512.0 ]--
r 137         if (start == null || e)
--[ 2019.11.07.00.42.07.648.0 ]--
r 137         if (start == null || en)
--[ 2019.11.07.00.42.07.720.0 ]--
r 137         if (start == null || end)
--[ 2019.11.07.00.42.07.814.0 ]--
r 137         if (start == null || end )
--[ 2019.11.07.00.42.08.321.0 ]--
r 137         if (start == null || end =)
--[ 2019.11.07.00.42.08.942.0 ]--
r 137         if (start == null || end == nu)
--[ 2019.11.07.00.42.09.109.0 ]--
r 137         if (start == null || end == nul)
--[ 2019.11.07.00.42.09.255.0 ]--
r 137         if (start == null || end == null)
--[ 2019.11.07.00.42.09.624.0 ]--
r 137         if (start == null || end == null) 
--[ 2019.11.07.00.42.10.865.0 ]--
r 137         if (start == null || end == null) t
--[ 2019.11.07.00.42.10.995.0 ]--
r 137         if (start == null || end == null) th
--[ 2019.11.07.00.42.11.201.0 ]--
r 137         if (start == null || end == null) thr
--[ 2019.11.07.00.42.11.611.0 ]--
r 137         if (start == null || end == null) thro
--[ 2019.11.07.00.42.11.759.0 ]--
r 137         if (start == null || end == null) throw
--[ 2019.11.07.00.42.11.907.0 ]--
r 137         if (start == null || end == null) throw 
--[ 2019.11.07.00.42.11.998.0 ]--
r 137         if (start == null || end == null) throw n
--[ 2019.11.07.00.42.12.135.0 ]--
r 137         if (start == null || end == null) throw new
--[ 2019.11.07.00.42.12.274.0 ]--
r 137         if (start == null || end == null) throw new 
--[ 2019.11.07.00.42.13.816.0 ]--
r 137         if (start == null || end == null) throw new J
--[ 2019.11.07.00.42.13.927.0 ]--
r 137         if (start == null || end == null) throw new Ja
--[ 2019.11.07.00.42.14.056.0 ]--
r 137         if (start == null || end == null) throw new Jav
--[ 2019.11.07.00.42.14.161.0 ]--
r 137         if (start == null || end == null) throw new Java
--[ 2019.11.07.00.42.15.228.0 ]--
r 137         if (start == null || end == null) throw new Java.
--[ 2019.11.07.00.42.16.441.0 ]--
r 137         if (start == null || end == null) throw new Java.l
--[ 2019.11.07.00.42.16.581.0 ]--
r 137         if (start == null || end == null) throw new Java.la
--[ 2019.11.07.00.42.16.718.0 ]--
r 137         if (start == null || end == null) throw new Java.lan
--[ 2019.11.07.00.42.16.830.0 ]--
r 137         if (start == null || end == null) throw new Java.lang
--[ 2019.11.07.00.42.16.973.0 ]--
r 137         if (start == null || end == null) throw new Java.langl
--[ 2019.11.07.00.42.17.332.0 ]--
r 137         if (start == null || end == null) throw new Java.lang
--[ 2019.11.07.00.42.17.594.0 ]--
r 137         if (start == null || end == null) throw new Java.lang.
--[ 2019.11.07.00.42.18.556.0 ]--
r 137         if (start == null || end == null) throw new Java.lang
--[ 2019.11.07.00.42.19.365.0 ]--
r 137         if (start == null || end == null) throw new J
--[ 2019.11.07.00.42.19.659.0 ]--
r 137         if (start == null || end == null) throw new 
--[ 2019.11.07.00.42.21.503.0 ]--
r 137         if (start == null || end == null) throw new I
--[ 2019.11.07.00.42.21.682.0 ]--
r 137         if (start == null || end == null) throw new In
--[ 2019.11.07.00.42.21.779.0 ]--
r 137         if (start == null || end == null) throw new Ind
--[ 2019.11.07.00.42.21.943.0 ]--
r 137         if (start == null || end == null) throw new Inde
--[ 2019.11.07.00.42.22.181.0 ]--
r 137         if (start == null || end == null) throw new Index
--[ 2019.11.07.00.42.22.751.0 ]--
r 137         if (start == null || end == null) throw new IndexO
--[ 2019.11.07.00.42.22.985.0 ]--
r 137         if (start == null || end == null) throw new IndexOu
--[ 2019.11.07.00.42.23.067.0 ]--
r 137         if (start == null || end == null) throw new IndexOut
--[ 2019.11.07.00.42.23.482.0 ]--
r 137         if (start == null || end == null) throw new IndexOutOfBoundsException
--[ 2019.11.07.00.42.23.600.0 ]--
r 137         if (start == null || end == null) throw new IndexOutOfBoundsException()
--[ 2019.11.07.00.42.24.727.0 ]--
r 137         if (start == null || end == null) throw new IndexOutOfBoundsException("")
--[ 2019.11.07.00.42.26.821.0 ]--
r 137         if (start == null || end == null) throw new IndexOutOfBoundsException("");
--[ 2019.11.07.00.42.37.941.0 ]--
r 137         if (start == null || end == null) throw new IndexOutOfBoundsException\("");
--[ 2019.11.07.00.42.38.683.0 ]--
r 137         if (start == null || end == null) throw new IndexOutOfBoundsException("");
--[ 2019.11.07.00.42.39.064.0 ]--
r 137         if (start == null || end == null) throw new IndexOutOfBoundsExcepti("");
--[ 2019.11.07.00.42.39.123.0 ]--
r 137         if (start == null || end == null) throw new IndexOutOfBoundsExcep("");
--[ 2019.11.07.00.42.39.165.0 ]--
r 137         if (start == null || end == null) throw new IndexOutOfBoundsExce("");
--[ 2019.11.07.00.42.39.209.0 ]--
r 137         if (start == null || end == null) throw new IndexOutOfBoundsExc("");
--[ 2019.11.07.00.42.39.285.0 ]--
r 137         if (start == null || end == null) throw new IndexOutOfBoundsE("");
--[ 2019.11.07.00.42.39.334.0 ]--
r 137         if (start == null || end == null) throw new IndexOutOfBound("");
--[ 2019.11.07.00.42.39.376.0 ]--
r 137         if (start == null || end == null) throw new IndexOutOfBou("");
--[ 2019.11.07.00.42.39.418.0 ]--
r 137         if (start == null || end == null) throw new IndexOutOfBo("");
--[ 2019.11.07.00.42.39.455.0 ]--
r 137         if (start == null || end == null) throw new IndexOutOfB("");
--[ 2019.11.07.00.42.39.495.0 ]--
r 137         if (start == null || end == null) throw new IndexOutOf("");
--[ 2019.11.07.00.42.39.539.0 ]--
r 137         if (start == null || end == null) throw new IndexOut("");
--[ 2019.11.07.00.42.39.573.0 ]--
r 137         if (start == null || end == null) throw new IndexOu("");
--[ 2019.11.07.00.42.39.643.0 ]--
r 137         if (start == null || end == null) throw new Index("");
--[ 2019.11.07.00.42.39.681.0 ]--
r 137         if (start == null || end == null) throw new Inde("");
--[ 2019.11.07.00.42.39.790.0 ]--
r 137         if (start == null || end == null) throw new Ind("");
--[ 2019.11.07.00.42.39.983.0 ]--
r 137         if (start == null || end == null) throw new In("");
--[ 2019.11.07.00.42.40.154.0 ]--
r 137         if (start == null || end == null) throw new I("");
--[ 2019.11.07.00.42.40.332.0 ]--
r 137         if (start == null || end == null) throw new ("");
--[ 2019.11.07.00.42.40.751.0 ]--
r 137         if (start == null || end == null) throw new I("");
--[ 2019.11.07.00.42.53.552.0 ]--
r 137         if (start == null || end == null) throw new IllegalA("");
--[ 2019.11.07.00.42.55.352.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("");
--[ 2019.11.07.00.42.58.365.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("E");
--[ 2019.11.07.00.42.58.599.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Er");
--[ 2019.11.07.00.42.58.749.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Err");
--[ 2019.11.07.00.42.58.842.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Erro");
--[ 2019.11.07.00.42.58.979.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error");
--[ 2019.11.07.00.42.59.159.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error:");
--[ 2019.11.07.00.42.59.227.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: ");
--[ 2019.11.07.00.42.59.510.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: s");
--[ 2019.11.07.00.42.59.620.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: st");
--[ 2019.11.07.00.42.59.699.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: sta");
--[ 2019.11.07.00.42.59.821.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: star");
--[ 2019.11.07.00.43.00.002.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start");
--[ 2019.11.07.00.43.00.085.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start ");
--[ 2019.11.07.00.43.00.417.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start i");
--[ 2019.11.07.00.43.00.540.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start is");
--[ 2019.11.07.00.43.00.639.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start is ");
--[ 2019.11.07.00.43.00.778.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start is n");
--[ 2019.11.07.00.43.01.415.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start is ");
--[ 2019.11.07.00.43.01.666.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start is");
--[ 2019.11.07.00.43.01.848.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start i");
--[ 2019.11.07.00.43.01.991.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start ");
--[ 2019.11.07.00.43.02.238.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start o");
--[ 2019.11.07.00.43.02.347.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or");
--[ 2019.11.07.00.43.02.434.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or ");
--[ 2019.11.07.00.43.02.541.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or e");
--[ 2019.11.07.00.43.02.681.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or en");
--[ 2019.11.07.00.43.02.739.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or end");
--[ 2019.11.07.00.43.02.857.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or end ");
--[ 2019.11.07.00.43.03.578.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or end is nu");
--[ 2019.11.07.00.43.03.692.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or end is nul");
--[ 2019.11.07.00.43.03.880.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or end is null");
--[ 2019.11.07.00.43.07.193.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or end is nul");
--[ 2019.11.07.00.43.07.439.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or end is nu");
--[ 2019.11.07.00.43.07.820.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or end is n");
--[ 2019.11.07.00.43.07.998.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or end is ");
--[ 2019.11.07.00.43.08.182.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or end is");
--[ 2019.11.07.00.43.08.349.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or end i");
--[ 2019.11.07.00.43.08.919.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or end ");
--[ 2019.11.07.00.43.09.271.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or end h");
--[ 2019.11.07.00.43.09.350.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or end ha");
--[ 2019.11.07.00.43.09.448.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or end hav");
--[ 2019.11.07.00.43.09.504.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or end have");
--[ 2019.11.07.00.43.09.585.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or end have ");
--[ 2019.11.07.00.43.09.709.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or end have n");
--[ 2019.11.07.00.43.09.823.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or end have no");
--[ 2019.11.07.00.43.09.923.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or end have not");
--[ 2019.11.07.00.43.10.008.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or end have not ");
--[ 2019.11.07.00.43.10.251.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or end have not b");
--[ 2019.11.07.00.43.10.354.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or end have not be");
--[ 2019.11.07.00.43.10.603.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or end have not bee");
--[ 2019.11.07.00.43.10.671.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or end have not been");
--[ 2019.11.07.00.43.10.835.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or end have not been ");
--[ 2019.11.07.00.43.10.967.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or end have not been s");
--[ 2019.11.07.00.43.11.060.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or end have not been se");
--[ 2019.11.07.00.43.11.222.0 ]--
r 137         if (start == null || end == null) throw new IllegalArgumentException("Error: start or end have not been set");
--[ 2019.11.07.00.44.04.615.0 ]--
+ 89         
--[ 2019.11.07.00.44.05.460.0 ]--
r 89         if 
--[ 2019.11.07.00.44.05.794.0 ]--
r 89         if ()
--[ 2019.11.07.00.44.06.000.0 ]--
r 89         if (s)
--[ 2019.11.07.00.44.06.112.0 ]--
r 89         if (st)
--[ 2019.11.07.00.44.06.236.0 ]--
r 89         if (sta)
--[ 2019.11.07.00.44.06.343.0 ]--
r 89         if (star)
--[ 2019.11.07.00.44.06.529.0 ]--
r 89         if (start)
--[ 2019.11.07.00.44.06.612.0 ]--
r 89         if (start )
--[ 2019.11.07.00.44.06.930.0 ]--
r 89         if (start =)
--[ 2019.11.07.00.44.07.131.0 ]--
r 89         if (start ==)
--[ 2019.11.07.00.44.07.336.0 ]--
r 89         if (start == )
--[ 2019.11.07.00.44.07.480.0 ]--
r 89         if (start == n)
--[ 2019.11.07.00.44.07.705.0 ]--
r 89         if (start == nu)
--[ 2019.11.07.00.44.07.886.0 ]--
r 89         if (start == nul)
--[ 2019.11.07.00.44.08.044.0 ]--
r 89         if (start == null)
--[ 2019.11.07.00.44.08.309.0 ]--
r 89         if (start == null) 
--[ 2019.11.07.00.44.10.226.0 ]--
r 89         if (start == null)
--[ 2019.11.07.00.44.10.684.0 ]--
r 89         if (start == null
--[ 2019.11.07.00.44.10.735.0 ]--
r 89         if (start == nul
--[ 2019.11.07.00.44.10.785.0 ]--
r 89         if (start == n
--[ 2019.11.07.00.44.10.841.0 ]--
r 89         if (start == 
--[ 2019.11.07.00.44.10.910.0 ]--
r 89         if (start ==
--[ 2019.11.07.00.44.10.954.0 ]--
r 89         if (start 
--[ 2019.11.07.00.44.11.032.0 ]--
r 89         if (start
--[ 2019.11.07.00.44.11.472.0 ]--
r 89         if (st
--[ 2019.11.07.00.44.11.532.0 ]--
r 89         if (s
--[ 2019.11.07.00.44.11.776.0 ]--
r 89         if (
--[ 2019.11.07.00.44.12.186.0 ]--
r 89         if (l
--[ 2019.11.07.00.44.12.341.0 ]--
r 89         if (lo
--[ 2019.11.07.00.44.12.465.0 ]--
r 89         if (loc
--[ 2019.11.07.00.44.12.603.0 ]--
r 89         if (loc 
--[ 2019.11.07.00.44.13.010.0 ]--
r 89         if (loc =
--[ 2019.11.07.00.44.13.097.0 ]--
r 89         if (loc == n
--[ 2019.11.07.00.44.13.313.0 ]--
r 89         if (loc == nu
--[ 2019.11.07.00.44.13.457.0 ]--
r 89         if (loc == nul
--[ 2019.11.07.00.44.13.560.0 ]--
r 89         if (loc == null
--[ 2019.11.07.00.44.13.819.0 ]--
r 89         if (loc == null)
--[ 2019.11.07.00.44.13.952.0 ]--
r 89         if (loc == null) 
--[ 2019.11.07.00.44.15.378.0 ]--
r 89         if (loc == null) t
--[ 2019.11.07.00.44.16.279.0 ]--
r 89         if (loc == null) throw new
--[ 2019.11.07.00.44.16.363.0 ]--
r 89         if (loc == null) throw new 
--[ 2019.11.07.00.44.19.054.0 ]--
r 89         if (loc == null) throw new I
--[ 2019.11.07.00.44.19.315.0 ]--
r 89         if (loc == null) throw new Il
--[ 2019.11.07.00.44.19.449.0 ]--
r 89         if (loc == null) throw new Ill
--[ 2019.11.07.00.44.19.618.0 ]--
r 89         if (loc == null) throw new Ille
--[ 2019.11.07.00.44.19.931.0 ]--
r 89         if (loc == null) throw new Illegal
--[ 2019.11.07.00.44.20.124.0 ]--
r 89         if (loc == null) throw new IllegalA
--[ 2019.11.07.00.44.20.419.0 ]--
r 89         if (loc == null) throw new IllegalAr
--[ 2019.11.07.00.44.20.593.0 ]--
r 89         if (loc == null) throw new IllegalArg
--[ 2019.11.07.00.44.20.712.0 ]--
r 89         if (loc == null) throw new IllegalArgu
--[ 2019.11.07.00.44.20.876.0 ]--
r 89         if (loc == null) throw new IllegalArgum
--[ 2019.11.07.00.44.20.978.0 ]--
r 89         if (loc == null) throw new IllegalArgume
--[ 2019.11.07.00.44.21.030.0 ]--
r 89         if (loc == null) throw new IllegalArgumen
--[ 2019.11.07.00.44.21.290.0 ]--
r 89         if (loc == null) throw new IllegalArgument
--[ 2019.11.07.00.44.21.580.0 ]--
r 89         if (loc == null) throw new IllegalArgumentE
--[ 2019.11.07.00.44.21.778.0 ]--
r 89         if (loc == null) throw new IllegalArgumentEx
--[ 2019.11.07.00.44.21.863.0 ]--
r 89         if (loc == null) throw new IllegalArgumentExc
--[ 2019.11.07.00.44.22.204.0 ]--
r 89         if (loc == null) throw new IllegalArgumentExce
--[ 2019.11.07.00.44.22.314.0 ]--
r 89         if (loc == null) throw new IllegalArgumentExcep
--[ 2019.11.07.00.44.22.402.0 ]--
r 89         if (loc == null) throw new IllegalArgumentExcept
--[ 2019.11.07.00.44.22.539.0 ]--
r 89         if (loc == null) throw new IllegalArgumentExcepti
--[ 2019.11.07.00.44.22.635.0 ]--
r 89         if (loc == null) throw new IllegalArgumentExceptio
--[ 2019.11.07.00.44.22.753.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException
--[ 2019.11.07.00.44.22.991.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException()
--[ 2019.11.07.00.44.24.240.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("")
--[ 2019.11.07.00.44.25.955.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("E")
--[ 2019.11.07.00.44.26.671.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Eror")
--[ 2019.11.07.00.44.27.376.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Ero")
--[ 2019.11.07.00.44.27.627.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Er")
--[ 2019.11.07.00.44.28.549.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Err")
--[ 2019.11.07.00.44.28.657.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Erro")
--[ 2019.11.07.00.44.28.734.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error")
--[ 2019.11.07.00.44.28.984.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error:")
--[ 2019.11.07.00.44.29.069.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: ")
--[ 2019.11.07.00.44.48.531.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: l")
--[ 2019.11.07.00.44.51.069.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: ")
--[ 2019.11.07.00.44.51.434.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: i")
--[ 2019.11.07.00.44.51.490.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: in")
--[ 2019.11.07.00.44.51.633.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: inp")
--[ 2019.11.07.00.44.51.769.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: inpu")
--[ 2019.11.07.00.44.51.842.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: input")
--[ 2019.11.07.00.44.51.939.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: input ")
--[ 2019.11.07.00.44.52.101.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: input c")
--[ 2019.11.07.00.44.52.224.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: input co")
--[ 2019.11.07.00.44.52.322.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: input coo")
--[ 2019.11.07.00.44.52.414.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: input coor")
--[ 2019.11.07.00.44.52.630.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: input coord")
--[ 2019.11.07.00.44.52.724.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: input coord ")
--[ 2019.11.07.00.44.52.899.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: input coord n")
--[ 2019.11.07.00.44.52.935.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: input coord no")
--[ 2019.11.07.00.44.53.010.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: input coord not")
--[ 2019.11.07.00.44.53.074.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: input coord not ")
--[ 2019.11.07.00.44.53.170.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: input coord not s")
--[ 2019.11.07.00.44.53.273.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: input coord not se")
--[ 2019.11.07.00.44.53.411.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: input coord not set")
--[ 2019.11.07.00.44.54.260.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: input coord not set");
--[ 2019.11.07.00.44.56.959.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: input coord no set");
--[ 2019.11.07.00.44.57.179.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: input coord n set");
--[ 2019.11.07.00.44.57.378.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: input coord  set");
--[ 2019.11.07.00.44.57.625.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: input coord set");
--[ 2019.11.07.00.44.57.854.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: input coord et");
--[ 2019.11.07.00.44.58.043.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: input coord t");
--[ 2019.11.07.00.44.58.234.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: input coord ");
--[ 2019.11.07.00.44.58.991.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: input coord i");
--[ 2019.11.07.00.44.59.859.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: input coord is null");
--[ 2019.11.07.00.45.00.024.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: input coord is null)");
--[ 2019.11.07.00.45.00.999.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: input coord is null");
--[ 2019.11.07.00.45.02.881.0 ]--
+ 90         
--[ 2019.11.07.00.45.04.769.0 ]--
r 90         i
--[ 2019.11.07.00.45.04.885.0 ]--
r 90         if
--[ 2019.11.07.00.45.04.998.0 ]--
r 90         if 
--[ 2019.11.07.00.45.05.161.0 ]--
r 90         if ()
--[ 2019.11.07.00.45.08.032.0 ]--
r 90         if (!)
--[ 2019.11.07.00.45.08.590.0 ]--
r 90         if (!v)
--[ 2019.11.07.00.45.08.711.0 ]--
r 90         if (!va)
--[ 2019.11.07.00.45.08.829.0 ]--
r 90         if (!val)
--[ 2019.11.07.00.45.08.900.0 ]--
r 90         if (!vali)
--[ 2019.11.07.00.45.08.987.0 ]--
r 90         if (!valid)
--[ 2019.11.07.00.45.09.608.0 ]--
r 90         if (!valida)
--[ 2019.11.07.00.45.10.591.0 ]--
r 90         if (!validateCoo)
--[ 2019.11.07.00.45.11.015.0 ]--
r 90         if (!validateCoord())
--[ 2019.11.07.00.45.11.057.0 ]--
r 90         if (!validateCoord(l))
--[ 2019.11.07.00.45.11.279.0 ]--
r 90         if (!validateCoord(lo))
--[ 2019.11.07.00.45.11.370.0 ]--
r 90         if (!validateCoord(loc))
--[ 2019.11.07.00.45.11.713.0 ]--
r 90         if (!validateCoord(loc) )
--[ 2019.11.07.00.45.12.270.0 ]--
r 90         if (!validateCoord(loc))
--[ 2019.11.07.00.45.12.684.0 ]--
r 90         if (!validateCoord(loc)) 
--[ 2019.11.07.00.45.12.875.0 ]--
r 90         if (!validateCoord(loc)) t
--[ 2019.11.07.00.45.12.978.0 ]--
r 90         if (!validateCoord(loc)) th
--[ 2019.11.07.00.45.13.080.0 ]--
r 90         if (!validateCoord(loc)) thr
--[ 2019.11.07.00.45.13.165.0 ]--
r 90         if (!validateCoord(loc)) thro
--[ 2019.11.07.00.45.13.247.0 ]--
r 90         if (!validateCoord(loc)) throw
--[ 2019.11.07.00.45.13.378.0 ]--
r 90         if (!validateCoord(loc)) throw 
--[ 2019.11.07.00.45.13.414.0 ]--
r 90         if (!validateCoord(loc)) throw n
--[ 2019.11.07.00.45.13.700.0 ]--
r 90         if (!validateCoord(loc)) throw ne
--[ 2019.11.07.00.45.13.841.0 ]--
r 90         if (!validateCoord(loc)) throw ne 
--[ 2019.11.07.00.45.14.179.0 ]--
r 90         if (!validateCoord(loc)) throw ne
--[ 2019.11.07.00.45.14.322.0 ]--
r 90         if (!validateCoord(loc)) throw new
--[ 2019.11.07.00.45.14.443.0 ]--
r 90         if (!validateCoord(loc)) throw new 
--[ 2019.11.07.00.45.14.671.0 ]--
r 90         if (!validateCoord(loc)) throw new I
--[ 2019.11.07.00.45.14.869.0 ]--
r 90         if (!validateCoord(loc)) throw new Il
--[ 2019.11.07.00.45.14.980.0 ]--
r 90         if (!validateCoord(loc)) throw new Ill
--[ 2019.11.07.00.45.15.103.0 ]--
r 90         if (!validateCoord(loc)) throw new Ille
--[ 2019.11.07.00.45.15.304.0 ]--
r 90         if (!validateCoord(loc)) throw new Illeg
--[ 2019.11.07.00.45.15.417.0 ]--
r 90         if (!validateCoord(loc)) throw new Illega
--[ 2019.11.07.00.45.15.491.0 ]--
r 90         if (!validateCoord(loc)) throw new Illegal
--[ 2019.11.07.00.45.15.661.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalA
--[ 2019.11.07.00.45.15.910.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalAr
--[ 2019.11.07.00.45.16.100.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArg
--[ 2019.11.07.00.45.16.195.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgu
--[ 2019.11.07.00.45.16.364.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgum
--[ 2019.11.07.00.45.16.464.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgume
--[ 2019.11.07.00.45.16.559.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumen
--[ 2019.11.07.00.45.16.629.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgument
--[ 2019.11.07.00.45.16.716.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgument 
--[ 2019.11.07.00.45.17.123.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgument
--[ 2019.11.07.00.45.17.345.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentE
--[ 2019.11.07.00.45.17.597.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentEx
--[ 2019.11.07.00.45.17.692.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentExc
--[ 2019.11.07.00.45.17.960.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentExce
--[ 2019.11.07.00.45.18.061.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentExcep
--[ 2019.11.07.00.45.18.156.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentExcept
--[ 2019.11.07.00.45.18.243.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentExcepti
--[ 2019.11.07.00.45.18.331.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentExceptio
--[ 2019.11.07.00.45.18.420.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException
--[ 2019.11.07.00.45.18.652.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException()
--[ 2019.11.07.00.45.18.834.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("")
--[ 2019.11.07.00.45.19.438.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("E")
--[ 2019.11.07.00.45.19.629.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Er")
--[ 2019.11.07.00.45.19.992.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Eror")
--[ 2019.11.07.00.45.20.573.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Ero")
--[ 2019.11.07.00.45.20.666.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Er")
--[ 2019.11.07.00.45.20.792.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Err")
--[ 2019.11.07.00.45.20.894.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Erro")
--[ 2019.11.07.00.45.21.024.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Error")
--[ 2019.11.07.00.45.21.190.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Error:")
--[ 2019.11.07.00.45.21.309.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: ")
--[ 2019.11.07.00.45.21.482.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: s")
--[ 2019.11.07.00.45.21.614.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: st")
--[ 2019.11.07.00.45.21.713.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: sta")
--[ 2019.11.07.00.45.21.813.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: star")
--[ 2019.11.07.00.45.22.010.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: start")
--[ 2019.11.07.00.45.22.091.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: start ")
--[ 2019.11.07.00.45.22.742.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: start c")
--[ 2019.11.07.00.45.22.839.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: start co")
--[ 2019.11.07.00.45.22.981.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: start coo")
--[ 2019.11.07.00.45.23.086.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: start coor")
--[ 2019.11.07.00.45.23.230.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: start coord")
--[ 2019.11.07.00.45.23.309.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: start coord ")
--[ 2019.11.07.00.45.23.414.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: start coord i")
--[ 2019.11.07.00.45.23.525.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: start coord is")
--[ 2019.11.07.00.45.23.593.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: start coord is ")
--[ 2019.11.07.00.45.23.771.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: start coord is o")
--[ 2019.11.07.00.45.23.839.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: start coord is ou")
--[ 2019.11.07.00.45.23.958.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: start coord is out")
--[ 2019.11.07.00.45.24.041.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: start coord is out ")
--[ 2019.11.07.00.45.24.115.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: start coord is out o")
--[ 2019.11.07.00.45.24.210.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: start coord is out of")
--[ 2019.11.07.00.45.24.322.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: start coord is out of ")
--[ 2019.11.07.00.45.24.450.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: start coord is out of b")
--[ 2019.11.07.00.45.24.529.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: start coord is out of bo")
--[ 2019.11.07.00.45.24.633.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: start coord is out of bou")
--[ 2019.11.07.00.45.24.732.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: start coord is out of boun")
--[ 2019.11.07.00.45.24.835.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: start coord is out of bound")
--[ 2019.11.07.00.45.24.921.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: start coord is out of bounds")
--[ 2019.11.07.00.45.25.545.0 ]--
r 90         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: start coord is out of bounds");
--[ 2019.11.07.00.45.28.386.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: s coord is null");
--[ 2019.11.07.00.45.28.464.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: st coord is null");
--[ 2019.11.07.00.45.28.599.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: sta coord is null");
--[ 2019.11.07.00.45.28.686.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: star coord is null");
--[ 2019.11.07.00.45.28.872.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: start coord is null");
--[ 2019.11.07.00.45.30.235.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: start  coord is null");
--[ 2019.11.07.00.45.31.021.0 ]--
r 89         if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
--[ 2019.11.07.00.45.40.592.0 ]--
+ 100         
--[ 2019.11.07.00.45.41.402.0 ]--
+ 100         if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
r 101         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: start coord is out of bounds");
--[ 2019.11.07.00.45.44.071.0 ]--
r 100         if (loc == null) throw new IllegalArgumentException("Error: e input coord is null");
--[ 2019.11.07.00.45.44.149.0 ]--
r 100         if (loc == null) throw new IllegalArgumentException("Error: en input coord is null");
--[ 2019.11.07.00.45.44.256.0 ]--
r 100         if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
--[ 2019.11.07.00.45.47.336.0 ]--
r 101         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: e coord is out of bounds");
--[ 2019.11.07.00.45.47.443.0 ]--
r 101         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: en coord is out of bounds");
--[ 2019.11.07.00.45.47.505.0 ]--
r 101         if (!validateCoord(loc)) throw new IllegalArgumentException("Error: end coord is out of bounds");
--[ 2019.11.07.00.45.54.989.0 ]--
+ 141         
--[ 2019.11.07.00.45.55.761.0 ]--
r 141         star
--[ 2019.11.07.00.45.55.866.0 ]--
r 141         start
--[ 2019.11.07.00.45.55.914.0 ]--
r 141         start 
--[ 2019.11.07.00.45.56.009.0 ]--
r 141         start =
--[ 2019.11.07.00.45.56.112.0 ]--
r 141         start = 
--[ 2019.11.07.00.45.57.082.0 ]--
r 141         start = n
--[ 2019.11.07.00.45.57.300.0 ]--
r 141         start = nu
--[ 2019.11.07.00.45.57.524.0 ]--
r 141         start = nul
--[ 2019.11.07.00.45.57.630.0 ]--
r 141         start = null
--[ 2019.11.07.00.45.57.854.0 ]--
r 141         start = null;
--[ 2019.11.07.00.46.04.821.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.07.00.46.21.874.0 ]--
r 141         e = null;
--[ 2019.11.07.00.46.21.961.0 ]--
r 141         en = null;
--[ 2019.11.07.00.46.22.044.0 ]--
r 141         end = null;
--[ 2019.11.07.00.46.28.519.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.07.00.46.33.422.0 ]--
+ 143         
--[ 2019.11.07.00.46.34.239.0 ]--
r 143         i
--[ 2019.11.07.00.46.34.385.0 ]--
r 143         if
--[ 2019.11.07.00.46.34.719.0 ]--
r 143         if e
--[ 2019.11.07.00.46.35.021.0 ]--
r 143         if 
--[ 2019.11.07.00.46.35.743.0 ]--
r 143         if ()
--[ 2019.11.07.00.46.35.966.0 ]--
r 143         if (e)
--[ 2019.11.07.00.46.36.071.0 ]--
r 143         if (en)
--[ 2019.11.07.00.46.36.152.0 ]--
r 143         if (end)
--[ 2019.11.07.00.46.36.256.0 ]--
r 143         if (end )
--[ 2019.11.07.00.46.36.509.0 ]--
r 143         if (end =)
--[ 2019.11.07.00.46.36.684.0 ]--
r 143         if (end ==)
--[ 2019.11.07.00.46.36.810.0 ]--
r 143         if (end == )
--[ 2019.11.07.00.46.36.882.0 ]--
r 143         if (end == n)
--[ 2019.11.07.00.46.37.108.0 ]--
r 143         if (end == nu)
--[ 2019.11.07.00.46.37.489.0 ]--
r 143         if (end == null)
--[ 2019.11.07.00.46.37.816.0 ]--
r 143         if (end == null) 
--[ 2019.11.07.00.46.38.066.0 ]--
r 143         if (end == null) t
--[ 2019.11.07.00.46.38.195.0 ]--
r 143         if (end == null) th
--[ 2019.11.07.00.46.38.392.0 ]--
r 143         if (end == null) thr
--[ 2019.11.07.00.46.38.724.0 ]--
r 143         if (end == null) throw
--[ 2019.11.07.00.46.38.955.0 ]--
r 143         if (end == null) throw 
--[ 2019.11.07.00.46.39.046.0 ]--
r 143         if (end == null) throw n
--[ 2019.11.07.00.46.39.231.0 ]--
r 143         if (end == null) throw new
--[ 2019.11.07.00.46.39.369.0 ]--
r 143         if (end == null) throw new 
--[ 2019.11.07.00.46.39.510.0 ]--
r 143         if (end == null) throw new I
--[ 2019.11.07.00.46.39.683.0 ]--
r 143         if (end == null) throw new Il
--[ 2019.11.07.00.46.39.781.0 ]--
r 143         if (end == null) throw new Ill
--[ 2019.11.07.00.46.39.866.0 ]--
r 143         if (end == null) throw new Ille
--[ 2019.11.07.00.46.39.964.0 ]--
r 143         if (end == null) throw new Illeg
--[ 2019.11.07.00.46.40.029.0 ]--
r 143         if (end == null) throw new Illega
--[ 2019.11.07.00.46.40.134.0 ]--
r 143         if (end == null) throw new Illegal
--[ 2019.11.07.00.46.40.424.0 ]--
r 143         if (end == null) throw new IllegalA
--[ 2019.11.07.00.46.40.549.0 ]--
r 143         if (end == null) throw new IllegalAr
--[ 2019.11.07.00.46.40.760.0 ]--
r 143         if (end == null) throw new IllegalArg
--[ 2019.11.07.00.46.41.143.0 ]--
r 143         if (end == null) throw new IllegalArgume
--[ 2019.11.07.00.46.41.237.0 ]--
r 143         if (end == null) throw new IllegalArgumen
--[ 2019.11.07.00.46.41.365.0 ]--
r 143         if (end == null) throw new IllegalArgument
--[ 2019.11.07.00.46.41.590.0 ]--
r 143         if (end == null) throw new IllegalArgumentE
--[ 2019.11.07.00.46.41.811.0 ]--
r 143         if (end == null) throw new IllegalArgumentEx
--[ 2019.11.07.00.46.41.992.0 ]--
r 143         if (end == null) throw new IllegalArgumentExc
--[ 2019.11.07.00.46.42.146.0 ]--
r 143         if (end == null) throw new IllegalArgumentExce
--[ 2019.11.07.00.46.42.238.0 ]--
r 143         if (end == null) throw new IllegalArgumentExcep
--[ 2019.11.07.00.46.42.387.0 ]--
r 143         if (end == null) throw new IllegalArgumentExcept
--[ 2019.11.07.00.46.42.479.0 ]--
r 143         if (end == null) throw new IllegalArgumentExcepti
--[ 2019.11.07.00.46.42.560.0 ]--
r 143         if (end == null) throw new IllegalArgumentExceptio
--[ 2019.11.07.00.46.42.682.0 ]--
r 143         if (end == null) throw new IllegalArgumentException
--[ 2019.11.07.00.46.42.867.0 ]--
r 143         if (end == null) throw new IllegalArgumentException()
--[ 2019.11.07.00.46.43.110.0 ]--
r 143         if (end == null) throw new IllegalArgumentException("")
--[ 2019.11.07.00.46.43.708.0 ]--
r 143         if (end == null) throw new IllegalArgumentException("E")
--[ 2019.11.07.00.46.43.912.0 ]--
r 143         if (end == null) throw new IllegalArgumentException("Er")
--[ 2019.11.07.00.46.44.102.0 ]--
r 143         if (end == null) throw new IllegalArgumentException("Erro")
--[ 2019.11.07.00.46.44.579.0 ]--
r 143         if (end == null) throw new IllegalArgumentException("Error")
--[ 2019.11.07.00.46.44.841.0 ]--
r 143         if (end == null) throw new IllegalArgumentException("Error:")
--[ 2019.11.07.00.46.44.978.0 ]--
r 143         if (end == null) throw new IllegalArgumentException("Error: ")
--[ 2019.11.07.00.46.45.165.0 ]--
r 143         if (end == null) throw new IllegalArgumentException("Error: e")
--[ 2019.11.07.00.46.45.273.0 ]--
r 143         if (end == null) throw new IllegalArgumentException("Error: en")
--[ 2019.11.07.00.46.45.359.0 ]--
r 143         if (end == null) throw new IllegalArgumentException("Error: end")
--[ 2019.11.07.00.46.45.437.0 ]--
r 143         if (end == null) throw new IllegalArgumentException("Error: end ")
--[ 2019.11.07.00.46.45.559.0 ]--
r 143         if (end == null) throw new IllegalArgumentException("Error: end h")
--[ 2019.11.07.00.46.45.616.0 ]--
r 143         if (end == null) throw new IllegalArgumentException("Error: end ha")
--[ 2019.11.07.00.46.45.692.0 ]--
r 143         if (end == null) throw new IllegalArgumentException("Error: end has")
--[ 2019.11.07.00.46.45.776.0 ]--
r 143         if (end == null) throw new IllegalArgumentException("Error: end has ")
--[ 2019.11.07.00.46.45.899.0 ]--
r 143         if (end == null) throw new IllegalArgumentException("Error: end has n")
--[ 2019.11.07.00.46.45.980.0 ]--
r 143         if (end == null) throw new IllegalArgumentException("Error: end has no")
--[ 2019.11.07.00.46.46.043.0 ]--
r 143         if (end == null) throw new IllegalArgumentException("Error: end has not")
--[ 2019.11.07.00.46.46.131.0 ]--
r 143         if (end == null) throw new IllegalArgumentException("Error: end has not ")
--[ 2019.11.07.00.46.46.292.0 ]--
r 143         if (end == null) throw new IllegalArgumentException("Error: end has not b")
--[ 2019.11.07.00.46.46.436.0 ]--
r 143         if (end == null) throw new IllegalArgumentException("Error: end has not be")
--[ 2019.11.07.00.46.46.634.0 ]--
r 143         if (end == null) throw new IllegalArgumentException("Error: end has not bee")
--[ 2019.11.07.00.46.46.738.0 ]--
r 143         if (end == null) throw new IllegalArgumentException("Error: end has not been")
--[ 2019.11.07.00.46.46.833.0 ]--
r 143         if (end == null) throw new IllegalArgumentException("Error: end has not been ")
--[ 2019.11.07.00.46.46.939.0 ]--
r 143         if (end == null) throw new IllegalArgumentException("Error: end has not been s")
--[ 2019.11.07.00.46.47.029.0 ]--
r 143         if (end == null) throw new IllegalArgumentException("Error: end has not been se")
--[ 2019.11.07.00.46.47.121.0 ]--
r 143         if (end == null) throw new IllegalArgumentException("Error: end has not been set")
--[ 2019.11.07.00.46.47.755.0 ]--
r 143         if (end == null) throw new IllegalArgumentException("Error: end has not been set");
--[ 2019.11.07.00.46.50.997.0 ]--
r 142         if (start == null || end == nul) throw new IllegalArgumentException("Error: start or end have not been set");
--[ 2019.11.07.00.46.51.486.0 ]--
r 142         if (start == null || end == nu) throw new IllegalArgumentException("Error: start or end have not been set");
--[ 2019.11.07.00.46.51.532.0 ]--
r 142         if (start == null || end == n) throw new IllegalArgumentException("Error: start or end have not been set");
--[ 2019.11.07.00.46.51.573.0 ]--
r 142         if (start == null || end == ) throw new IllegalArgumentException("Error: start or end have not been set");
--[ 2019.11.07.00.46.51.616.0 ]--
r 142         if (start == null || end ==) throw new IllegalArgumentException("Error: start or end have not been set");
--[ 2019.11.07.00.46.51.674.0 ]--
r 142         if (start == null || end =) throw new IllegalArgumentException("Error: start or end have not been set");
--[ 2019.11.07.00.46.51.717.0 ]--
r 142         if (start == null || end) throw new IllegalArgumentException("Error: start or end have not been set");
--[ 2019.11.07.00.46.51.771.0 ]--
r 142         if (start == null || e) throw new IllegalArgumentException("Error: start or end have not been set");
--[ 2019.11.07.00.46.51.809.0 ]--
r 142         if (start == null || ) throw new IllegalArgumentException("Error: start or end have not been set");
--[ 2019.11.07.00.46.51.918.0 ]--
r 142         if (start == null) throw new IllegalArgumentException("Error: start or end have not been set");
--[ 2019.11.07.00.46.52.003.0 ]--
r 142         if (start == nu) throw new IllegalArgumentException("Error: start or end have not been set");
--[ 2019.11.07.00.46.52.044.0 ]--
r 142         if (start == n) throw new IllegalArgumentException("Error: start or end have not been set");
--[ 2019.11.07.00.46.53.614.0 ]--
r 142         if (start == nu) throw new IllegalArgumentException("Error: start or end have not been set");
--[ 2019.11.07.00.46.53.774.0 ]--
r 142         if (start == nul) throw new IllegalArgumentException("Error: start or end have not been set");
--[ 2019.11.07.00.46.53.925.0 ]--
r 142         if (start == null) throw new IllegalArgumentException("Error: start or end have not been set");
--[ 2019.11.07.00.46.58.081.0 ]--
r 142         if (start == null) throw new IllegalArgumentException("Error: start h not been set");
--[ 2019.11.07.00.46.58.851.0 ]--
r 142         if (start == null) throw new IllegalArgumentException("Error: start has not been set");
--[ 2019.11.07.00.47.11.655.0 ]--
r 141         s
--[ 2019.11.07.00.47.12.433.0 ]--
r 141         setPa
--[ 2019.11.07.00.47.12.500.0 ]--
r 141         setPat
--[ 2019.11.07.00.47.12.606.0 ]--
r 141         setPath
--[ 2019.11.07.00.47.12.781.0 ]--
r 141         setPathS
--[ 2019.11.07.00.47.12.969.0 ]--
r 141         setPathSt
--[ 2019.11.07.00.47.13.094.0 ]--
r 141         setPathSta
--[ 2019.11.07.00.47.13.212.0 ]--
r 141         setPathStar
--[ 2019.11.07.00.47.13.340.0 ]--
r 141         setPathStart
--[ 2019.11.07.00.47.13.540.0 ]--
r 141         setPathStart()
--[ 2019.11.07.00.47.13.700.0 ]--
r 141         setPathStart(n)
--[ 2019.11.07.00.47.14.160.0 ]--
r 141         setPathStart(nu)
--[ 2019.11.07.00.47.14.411.0 ]--
r 141         setPathStart(nul)
--[ 2019.11.07.00.47.14.562.0 ]--
r 141         setPathStart(null)
--[ 2019.11.07.00.47.14.992.0 ]--
r 141         setPathStart(null);
--[ 2019.11.07.00.47.20.401.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.07.00.47.24.842.0 ]--
r 141         setPathStart(n);
--[ 2019.11.07.00.47.24.955.0 ]--
r 141         setPathStart(ne);
--[ 2019.11.07.00.47.25.041.0 ]--
r 141         setPathStart(new);
--[ 2019.11.07.00.47.25.106.0 ]--
r 141         setPathStart(new );
--[ 2019.11.07.00.47.25.391.0 ]--
r 141         setPathStart(new C);
--[ 2019.11.07.00.47.25.658.0 ]--
r 141         setPathStart(new Co);
--[ 2019.11.07.00.47.25.789.0 ]--
r 141         setPathStart(new Coo);
--[ 2019.11.07.00.47.25.923.0 ]--
r 141         setPathStart(new Coor);
--[ 2019.11.07.00.47.26.544.0 ]--
r 141         setPathStart(new Coord());
--[ 2019.11.07.00.47.27.675.0 ]--
r 141         setPathStart(new Coord(N));
--[ 2019.11.07.00.47.27.981.0 ]--
r 141         setPathStart(new Coord(N,));
--[ 2019.11.07.00.47.28.042.0 ]--
r 141         setPathStart(new Coord(N, ));
--[ 2019.11.07.00.47.28.214.0 ]--
r 141         setPathStart(new Coord(N, N));
--[ 2019.11.07.00.47.37.879.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.07.00.47.42.419.0 ]--
r 141         e(new Coord(N, N));
--[ 2019.11.07.00.47.42.511.0 ]--
r 141         en(new Coord(N, N));
--[ 2019.11.07.00.47.42.654.0 ]--
r 141         end(new Coord(N, N));
--[ 2019.11.07.00.47.42.854.0 ]--
r 141         endP(new Coord(N, N));
--[ 2019.11.07.00.47.43.059.0 ]--
r 141         endPa(new Coord(N, N));
--[ 2019.11.07.00.47.43.110.0 ]--
r 141         endPat(new Coord(N, N));
--[ 2019.11.07.00.47.43.221.0 ]--
r 141         endPath(new Coord(N, N));
--[ 2019.11.07.00.47.43.542.0 ]--
r 141         endPathS(new Coord(N, N));
--[ 2019.11.07.00.47.43.720.0 ]--
r 141         endPathSt(new Coord(N, N));
--[ 2019.11.07.00.47.43.804.0 ]--
r 141         endPathSta(new Coord(N, N));
--[ 2019.11.07.00.47.43.924.0 ]--
r 141         endPathStar(new Coord(N, N));
--[ 2019.11.07.00.47.44.125.0 ]--
r 141         endPathStart(new Coord(N, N));
--[ 2019.11.07.00.47.45.266.0 ]--
r 141         endPathStar(new Coord(N, N));
--[ 2019.11.07.00.47.45.745.0 ]--
r 141         endPathSta(new Coord(N, N));
--[ 2019.11.07.00.47.45.806.0 ]--
r 141         endPathSt(new Coord(N, N));
--[ 2019.11.07.00.47.45.849.0 ]--
r 141         endPath(new Coord(N, N));
--[ 2019.11.07.00.47.45.912.0 ]--
r 141         endPat(new Coord(N, N));
--[ 2019.11.07.00.47.46.027.0 ]--
r 141         endPa(new Coord(N, N));
--[ 2019.11.07.00.47.46.230.0 ]--
r 141         endP(new Coord(N, N));
--[ 2019.11.07.00.47.46.404.0 ]--
r 141         end(new Coord(N, N));
--[ 2019.11.07.00.47.46.622.0 ]--
r 141         en(new Coord(N, N));
--[ 2019.11.07.00.47.47.002.0 ]--
r 141         e(new Coord(N, N));
--[ 2019.11.07.00.47.47.505.0 ]--
r 141         (new Coord(N, N));
--[ 2019.11.07.00.47.48.060.0 ]--
r 141         set(new Coord(N, N));
--[ 2019.11.07.00.47.48.299.0 ]--
r 141         setE(new Coord(N, N));
--[ 2019.11.07.00.47.48.400.0 ]--
r 141         setEn(new Coord(N, N));
--[ 2019.11.07.00.47.48.514.0 ]--
r 141         setEnd(new Coord(N, N));
--[ 2019.11.07.00.47.48.681.0 ]--
r 141         setEndP(new Coord(N, N));
--[ 2019.11.07.00.47.49.041.0 ]--
r 141         setEnd(new Coord(N, N));
--[ 2019.11.07.00.47.49.214.0 ]--
r 141         setEn(new Coord(N, N));
--[ 2019.11.07.00.47.49.401.0 ]--
r 141         setE(new Coord(N, N));
--[ 2019.11.07.00.47.49.550.0 ]--
r 141         set(new Coord(N, N));
--[ 2019.11.07.00.47.49.752.0 ]--
r 141         setP(new Coord(N, N));
--[ 2019.11.07.00.47.49.962.0 ]--
r 141         setPa(new Coord(N, N));
--[ 2019.11.07.00.47.50.099.0 ]--
r 141         setPat(new Coord(N, N));
--[ 2019.11.07.00.47.50.194.0 ]--
r 141         setPath(new Coord(N, N));
--[ 2019.11.07.00.47.50.351.0 ]--
r 141         setPathE(new Coord(N, N));
--[ 2019.11.07.00.47.50.575.0 ]--
r 141         setPathEn(new Coord(N, N));
--[ 2019.11.07.00.47.50.708.0 ]--
r 141         setPathEnd(new Coord(N, N));
--[ 2019.11.07.00.47.57.017.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.07.00.48.02.499.0 ]--
r 141         setPathEnd(n);
--[ 2019.11.07.00.48.02.710.0 ]--
r 141         setPathEnd(nu);
--[ 2019.11.07.00.48.02.940.0 ]--
r 141         setPathEnd(nul);
--[ 2019.11.07.00.48.03.055.0 ]--
r 141         setPathEnd(null);
--[ 2019.11.07.00.48.10.588.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.07.00.48.14.513.0 ]--
r 141 
--[ 2019.11.07.00.48.14.660.0 ]--
- 141
--[ 2019.11.07.00.49.35.177.0 ]--
+ 11     
--[ 2019.11.07.00.49.36.082.0 ]--
r 11     priva
--[ 2019.11.07.00.49.36.229.0 ]--
r 11     privat
--[ 2019.11.07.00.49.36.321.0 ]--
r 11     private
--[ 2019.11.07.00.49.36.455.0 ]--
r 11     private 
--[ 2019.11.07.00.49.37.159.0 ]--
r 11     private f
--[ 2019.11.07.00.49.37.349.0 ]--
r 11     private fl
--[ 2019.11.07.00.49.37.439.0 ]--
r 11     private flo
--[ 2019.11.07.00.49.37.524.0 ]--
r 11     private floa
--[ 2019.11.07.00.49.37.606.0 ]--
r 11     private float
--[ 2019.11.07.00.49.37.705.0 ]--
r 11     private float 
--[ 2019.11.07.00.49.37.829.0 ]--
r 11     private float h
--[ 2019.11.07.00.49.38.105.0 ]--
r 11     private float h;
--[ 2019.11.07.00.49.38.365.0 ]--
+ 12     
--[ 2019.11.07.00.49.38.749.0 ]--
r 12     p
--[ 2019.11.07.00.49.38.893.0 ]--
r 12     pr
--[ 2019.11.07.00.49.39.002.0 ]--
r 12     pri
--[ 2019.11.07.00.49.39.080.0 ]--
r 12     priv
--[ 2019.11.07.00.49.39.151.0 ]--
r 12     priva
--[ 2019.11.07.00.49.39.414.0 ]--
r 12     private
--[ 2019.11.07.00.49.39.536.0 ]--
r 12     private 
--[ 2019.11.07.00.49.39.579.0 ]--
r 12     private i
--[ 2019.11.07.00.49.39.674.0 ]--
r 12     private in
--[ 2019.11.07.00.49.39.775.0 ]--
r 12     private int
--[ 2019.11.07.00.49.39.852.0 ]--
r 12     private int 
--[ 2019.11.07.00.49.39.953.0 ]--
r 12     private int N
--[ 2019.11.07.00.49.40.141.0 ]--
r 12     private int N;
--[ 2019.11.07.00.49.40.351.0 ]--
+ 13     
--[ 2019.11.07.00.49.40.636.0 ]--
r 13     p
--[ 2019.11.07.00.49.40.751.0 ]--
r 13     pr
--[ 2019.11.07.00.49.40.831.0 ]--
r 13     pri
--[ 2019.11.07.00.49.40.949.0 ]--
r 13     priv
--[ 2019.11.07.00.49.41.050.0 ]--
r 13     priva
--[ 2019.11.07.00.49.41.179.0 ]--
r 13     privat
--[ 2019.11.07.00.49.41.282.0 ]--
r 13     private
--[ 2019.11.07.00.49.41.420.0 ]--
r 13     private 
--[ 2019.11.07.00.49.41.472.0 ]--
r 13     private i
--[ 2019.11.07.00.49.41.600.0 ]--
r 13     private int
--[ 2019.11.07.00.49.41.693.0 ]--
r 13     private int 
--[ 2019.11.07.00.49.41.781.0 ]--
r 13     private int s
--[ 2019.11.07.00.49.41.909.0 ]--
r 13     private int se
--[ 2019.11.07.00.49.42.361.0 ]--
r 13     private int search
--[ 2019.11.07.00.49.42.532.0 ]--
r 13     private int searchS
--[ 2019.11.07.00.49.42.700.0 ]--
r 13     private int searchSi
--[ 2019.11.07.00.49.42.822.0 ]--
r 13     private int searchSiz
--[ 2019.11.07.00.49.42.882.0 ]--
r 13     private int searchSize
--[ 2019.11.07.00.49.43.039.0 ]--
r 13     private int searchSize;
--[ 2019.11.07.00.49.46.319.0 ]--
- 19
- 19
r 19 
--[ 2019.11.07.00.49.47.151.0 ]--
- 19
--[ 2019.11.07.00.49.49.681.0 ]--
+ 14     
--[ 2019.11.07.00.49.49.970.0 ]--
r 14     p
--[ 2019.11.07.00.49.50.101.0 ]--
r 14     pr
--[ 2019.11.07.00.49.50.157.0 ]--
r 14     pri
--[ 2019.11.07.00.49.50.289.0 ]--
r 14     priv
--[ 2019.11.07.00.49.50.390.0 ]--
r 14     priva
--[ 2019.11.07.00.49.50.522.0 ]--
r 14     privat
--[ 2019.11.07.00.49.50.614.0 ]--
r 14     private
--[ 2019.11.07.00.49.50.800.0 ]--
r 14     private 
--[ 2019.11.07.00.49.50.904.0 ]--
r 14     private b
--[ 2019.11.07.00.49.51.003.0 ]--
r 14     private bo
--[ 2019.11.07.00.49.51.068.0 ]--
r 14     private boo
--[ 2019.11.07.00.49.51.260.0 ]--
r 14     private bool
--[ 2019.11.07.00.49.51.386.0 ]--
r 14     private boole
--[ 2019.11.07.00.49.51.472.0 ]--
r 14     private boolea
--[ 2019.11.07.00.49.51.580.0 ]--
r 14     private boolean 
--[ 2019.11.07.00.49.51.779.0 ]--
r 14     private boolean p
--[ 2019.11.07.00.49.51.924.0 ]--
r 14     private boolean pa
--[ 2019.11.07.00.49.52.022.0 ]--
r 14     private boolean pat
--[ 2019.11.07.00.49.52.079.0 ]--
r 14     private boolean path
--[ 2019.11.07.00.49.52.299.0 ]--
r 14     private boolean pathF
--[ 2019.11.07.00.49.52.410.0 ]--
r 14     private boolean pathFo
--[ 2019.11.07.00.49.52.496.0 ]--
r 14     private boolean pathFou
--[ 2019.11.07.00.49.52.711.0 ]--
r 14     private boolean pathFoun
--[ 2019.11.07.00.49.52.879.0 ]--
r 14     private boolean pathFound
--[ 2019.11.07.00.49.52.972.0 ]--
r 14     private boolean pathFound;
--[ 2019.11.07.00.49.56.660.0 ]--
r 21 
--[ 2019.11.07.00.49.57.454.0 ]--
- 21
--[ 2019.11.07.00.49.59.019.0 ]--
+ 15     
--[ 2019.11.07.00.49.59.509.0 ]--
r 15     p
--[ 2019.11.07.00.49.59.597.0 ]--
r 15     pr
--[ 2019.11.07.00.49.59.700.0 ]--
r 15     pri
--[ 2019.11.07.00.49.59.830.0 ]--
r 15     priv
--[ 2019.11.07.00.49.59.919.0 ]--
r 15     priva
--[ 2019.11.07.00.50.00.056.0 ]--
r 15     privat
--[ 2019.11.07.00.50.00.155.0 ]--
r 15     private
--[ 2019.11.07.00.50.00.265.0 ]--
r 15     private 
--[ 2019.11.07.00.50.00.315.0 ]--
r 15     private t
--[ 2019.11.07.00.50.00.949.0 ]--
r 15     private te
--[ 2019.11.07.00.50.01.469.0 ]--
r 15     private t
--[ 2019.11.07.00.50.01.652.0 ]--
r 15     private 
--[ 2019.11.07.00.50.01.869.0 ]--
r 15     private T
--[ 2019.11.07.00.50.02.010.0 ]--
r 15     private Te
--[ 2019.11.07.00.50.02.184.0 ]--
r 15     private Ter
--[ 2019.11.07.00.50.02.409.0 ]--
r 15     private Terr
--[ 2019.11.07.00.50.02.516.0 ]--
r 15     private Terra
--[ 2019.11.07.00.50.02.640.0 ]--
r 15     private Terrai
--[ 2019.11.07.00.50.02.694.0 ]--
r 15     private Terrain
--[ 2019.11.07.00.50.02.796.0 ]--
r 15     private Terrain 
--[ 2019.11.07.00.50.02.906.0 ]--
r 15     private Terrain t
--[ 2019.11.07.00.50.03.012.0 ]--
r 15     private Terrain te
--[ 2019.11.07.00.50.03.170.0 ]--
r 15     private Terrain ter
--[ 2019.11.07.00.50.03.339.0 ]--
r 15     private Terrain terr
--[ 2019.11.07.00.50.03.492.0 ]--
r 15     private Terrain terrai
--[ 2019.11.07.00.50.03.651.0 ]--
r 15     private Terrain terrain;
--[ 2019.11.07.00.50.06.659.0 ]--
r 19 
--[ 2019.11.07.00.50.07.629.0 ]--
- 19
--[ 2019.11.07.00.51.42.122.0 ]--
- 85
--[ 2019.11.07.01.05.15.827.0 ]--
DisposeComponent
--[ 2019.11.07.11.36.19.413.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.11.07.11.36.19.578.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml

--[ 2019.11.07.11.36.19.582.0 ]--
InitFile: /.cos265


--[ 2019.11.07.11.36.19.587.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.11.07.11.36.19.592.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.11.07.11.36.19.599.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        public Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null)  this.cost = 0.0f;
                else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.computeDistance(loc, end);
            }
        }

        public float getCost(float heuristic) {
            return cost;
        }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IllegalArgumentException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IllegalArgumentException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        Stopwatch stopwatch = new Stopwatch();
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            if (currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == getPathEnd().getJ()) {
                pathFound = true;
                endNode = currentNode;
                break;
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            atStart = false;
        }
        StdOut.println("stopwatch: " + stopwatch.elapsedTime());
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(h);
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        Stack<Coord> s = new Stack<>();
        PFNode c = endNode;
        while (c != null) {
            s.push(c.getLoc());
            c = c.fromNode;
        }
        return s;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2019.11.07.11.36.19.604.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return null;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return true;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
    }

}

--[ 2019.11.07.11.36.19.610.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.11.07.11.36.19.616.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.11.07.11.36.19.621.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[12];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.11.07.11.36.19.636.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.07.11.38.10.707.0 ]--
:/src/Pathfinder.java
r 100         if (!validateCoord(loc)) throw new I("Error: end coord is out of bounds");
--[ 2019.11.07.11.38.10.957.0 ]--
r 100         if (!validateCoord(loc)) throw new In("Error: end coord is out of bounds");
--[ 2019.11.07.11.38.10.988.0 ]--
r 100         if (!validateCoord(loc)) throw new Ind("Error: end coord is out of bounds");
--[ 2019.11.07.11.38.11.160.0 ]--
r 100         if (!validateCoord(loc)) throw new Inde("Error: end coord is out of bounds");
--[ 2019.11.07.11.38.11.285.0 ]--
r 100         if (!validateCoord(loc)) throw new Index("Error: end coord is out of bounds");
--[ 2019.11.07.11.38.11.582.0 ]--
r 100         if (!validateCoord(loc)) throw new IndexO("Error: end coord is out of bounds");
--[ 2019.11.07.11.38.11.848.0 ]--
r 100         if (!validateCoord(loc)) throw new IndexOu("Error: end coord is out of bounds");
--[ 2019.11.07.11.38.11.895.0 ]--
r 100         if (!validateCoord(loc)) throw new IndexOut("Error: end coord is out of bounds");
--[ 2019.11.07.11.38.12.231.0 ]--
r 100         if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
--[ 2019.11.07.11.38.15.423.0 ]--
r 89         if (!validateCoord(loc)) throw new I("Error: start coord is out of bounds");
--[ 2019.11.07.11.38.15.556.0 ]--
r 89         if (!validateCoord(loc)) throw new In("Error: start coord is out of bounds");
--[ 2019.11.07.11.38.15.634.0 ]--
r 89         if (!validateCoord(loc)) throw new Ind("Error: start coord is out of bounds");
--[ 2019.11.07.11.38.15.852.0 ]--
r 89         if (!validateCoord(loc)) throw new Inde("Error: start coord is out of bounds");
--[ 2019.11.07.11.38.16.058.0 ]--
r 89         if (!validateCoord(loc)) throw new Index("Error: start coord is out of bounds");
--[ 2019.11.07.11.38.16.944.0 ]--
r 89         if (!validateCoord(loc)) throw new IndexO("Error: start coord is out of bounds");
--[ 2019.11.07.11.38.17.129.0 ]--
r 89         if (!validateCoord(loc)) throw new IndexOu("Error: start coord is out of bounds");
--[ 2019.11.07.11.38.17.245.0 ]--
r 89         if (!validateCoord(loc)) throw new IndexOut("Error: start coord is out of bounds");
--[ 2019.11.07.11.38.17.370.0 ]--
r 89         if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
--[ 2019.11.07.11.39.25.671.0 ]--
:/src/Walker.java
+ 12         
--[ 2019.11.07.11.39.33.700.0 ]--
+ 28         
--[ 2019.11.07.11.41.46.096.0 ]--
+ 8     
--[ 2019.11.07.11.41.46.288.0 ]--
+ 8     
--[ 2019.11.07.11.41.49.066.0 ]--
r 9     I
--[ 2019.11.07.11.41.49.175.0 ]--
r 9     It
--[ 2019.11.07.11.41.49.347.0 ]--
r 9     Ite
--[ 2019.11.07.11.41.49.488.0 ]--
r 9     Iter
--[ 2019.11.07.11.41.49.645.0 ]--
r 9     Itera
--[ 2019.11.07.11.41.49.770.0 ]--
r 9     Iterab
--[ 2019.11.07.11.41.49.926.0 ]--
r 9     Iterabl
--[ 2019.11.07.11.41.50.067.0 ]--
r 9     Iterable
--[ 2019.11.07.11.41.50.427.0 ]--
r 9     Iterable<>
--[ 2019.11.07.11.41.50.552.0 ]--
r 9     Iterable<c>
--[ 2019.11.07.11.41.50.599.0 ]--
r 9     Iterable<co>
--[ 2019.11.07.11.41.50.755.0 ]--
r 9     Iterable<coo>
--[ 2019.11.07.11.41.50.927.0 ]--
r 9     Iterable<coor>
--[ 2019.11.07.11.41.51.130.0 ]--
r 9     Iterable<coord>
--[ 2019.11.07.11.41.51.905.0 ]--
r 9     Iterable<coor>
--[ 2019.11.07.11.41.51.998.0 ]--
r 9     Iterable<coo>
--[ 2019.11.07.11.41.52.170.0 ]--
r 9     Iterable<co>
--[ 2019.11.07.11.41.52.327.0 ]--
r 9     Iterable<c>
--[ 2019.11.07.11.41.52.501.0 ]--
r 9     Iterable<>
--[ 2019.11.07.11.41.52.760.0 ]--
r 9     Iterable<C>
--[ 2019.11.07.11.41.53.355.0 ]--
r 9     Iterable<Co>
--[ 2019.11.07.11.41.53.444.0 ]--
r 9     Iterable<Coor>
--[ 2019.11.07.11.41.53.648.0 ]--
r 9     Iterable<Coord>
--[ 2019.11.07.11.41.53.929.0 ]--
r 9     Iterable<Coord> 
--[ 2019.11.07.11.41.54.070.0 ]--
r 9     Iterable<Coord> p
--[ 2019.11.07.11.41.54.195.0 ]--
r 9     Iterable<Coord> pa
--[ 2019.11.07.11.41.54.273.0 ]--
r 9     Iterable<Coord> pat
--[ 2019.11.07.11.41.54.335.0 ]--
r 9     Iterable<Coord> path
--[ 2019.11.07.11.41.54.476.0 ]--
r 9     Iterable<Coord> path;
--[ 2019.11.07.11.41.54.649.0 ]--
+ 10     
--[ 2019.11.07.11.41.56.134.0 ]--
r 10     C
--[ 2019.11.07.11.41.56.384.0 ]--
r 10     Co
--[ 2019.11.07.11.41.56.527.0 ]--
r 10     Coo
--[ 2019.11.07.11.41.56.581.0 ]--
r 10     Coor
--[ 2019.11.07.11.41.56.847.0 ]--
r 10     Coorc
--[ 2019.11.07.11.41.57.211.0 ]--
r 10     Coor
--[ 2019.11.07.11.41.57.355.0 ]--
r 10     Coord
--[ 2019.11.07.11.41.57.433.0 ]--
r 10     Coord 
--[ 2019.11.07.11.41.58.805.0 ]--
r 10     Coord l
--[ 2019.11.07.11.41.58.961.0 ]--
r 10     Coord lo
--[ 2019.11.07.11.41.59.008.0 ]--
r 10     Coord loc
--[ 2019.11.07.11.41.59.133.0 ]--
r 10     Coord loc;
--[ 2019.11.07.11.42.03.706.0 ]--
+ 11     
--[ 2019.11.07.11.42.03.989.0 ]--
r 11     T
--[ 2019.11.07.11.42.04.179.0 ]--
r 11     Te
--[ 2019.11.07.11.42.04.369.0 ]--
r 11     Ter
--[ 2019.11.07.11.42.04.557.0 ]--
r 11     Terr
--[ 2019.11.07.11.42.04.619.0 ]--
r 11     Terra
--[ 2019.11.07.11.42.04.698.0 ]--
r 11     Terrai
--[ 2019.11.07.11.42.04.760.0 ]--
r 11     Terrain
--[ 2019.11.07.11.42.04.885.0 ]--
r 11     Terrain 
--[ 2019.11.07.11.42.05.041.0 ]--
r 11     Terrain t
--[ 2019.11.07.11.42.05.166.0 ]--
r 11     Terrain te
--[ 2019.11.07.11.42.05.338.0 ]--
r 11     Terrain ter
--[ 2019.11.07.11.42.05.526.0 ]--
r 11     Terrain terr
--[ 2019.11.07.11.42.05.620.0 ]--
r 11     Terrain terra
--[ 2019.11.07.11.42.05.714.0 ]--
r 11     Terrain terrai
--[ 2019.11.07.11.42.05.803.0 ]--
r 11     Terrain terrain
--[ 2019.11.07.11.42.05.881.0 ]--
r 11     Terrain terrain;
--[ 2019.11.07.11.42.10.073.0 ]--
r 16         p
--[ 2019.11.07.11.42.10.338.0 ]--
r 16         pat
--[ 2019.11.07.11.42.10.369.0 ]--
r 16         path
--[ 2019.11.07.11.42.10.652.0 ]--
r 16         pat
--[ 2019.11.07.11.42.10.793.0 ]--
r 16         pa
--[ 2019.11.07.11.42.10.980.0 ]--
r 16         p
--[ 2019.11.07.11.42.11.105.0 ]--
r 16         
--[ 2019.11.07.11.42.11.646.0 ]--
r 16         t
--[ 2019.11.07.11.42.11.780.0 ]--
r 16         th
--[ 2019.11.07.11.42.11.796.0 ]--
r 16         thi
--[ 2019.11.07.11.42.11.874.0 ]--
r 16         this
--[ 2019.11.07.11.42.11.999.0 ]--
r 16         this.
--[ 2019.11.07.11.42.12.249.0 ]--
r 16         this.p
--[ 2019.11.07.11.42.12.374.0 ]--
r 16         this.pa
--[ 2019.11.07.11.42.12.452.0 ]--
r 16         this.pat
--[ 2019.11.07.11.42.12.530.0 ]--
r 16         this.path
--[ 2019.11.07.11.42.12.577.0 ]--
r 16         this.path 
--[ 2019.11.07.11.42.12.749.0 ]--
r 16         this.path =
--[ 2019.11.07.11.42.12.843.0 ]--
r 16         this.path = 
--[ 2019.11.07.11.42.13.063.0 ]--
r 16         this.path = p
--[ 2019.11.07.11.42.13.153.0 ]--
r 16         this.path = pa
--[ 2019.11.07.11.42.13.231.0 ]--
r 16         this.path = pat
--[ 2019.11.07.11.42.13.278.0 ]--
r 16         this.path = path
--[ 2019.11.07.11.42.13.419.0 ]--
r 16         this.path = path;
--[ 2019.11.07.11.42.13.686.0 ]--
+ 17         
--[ 2019.11.07.11.42.16.330.0 ]--
r 17         t
--[ 2019.11.07.11.42.16.419.0 ]--
r 17         th
--[ 2019.11.07.11.42.16.486.0 ]--
r 17         thi
--[ 2019.11.07.11.42.16.604.0 ]--
r 17         this
--[ 2019.11.07.11.42.16.762.0 ]--
r 17         this.
--[ 2019.11.07.11.42.17.730.0 ]--
r 17         this.t
--[ 2019.11.07.11.42.17.776.0 ]--
r 17         this.te
--[ 2019.11.07.11.42.17.933.0 ]--
r 17         this.ter
--[ 2019.11.07.11.42.18.137.0 ]--
r 17         this.terr
--[ 2019.11.07.11.42.18.200.0 ]--
r 17         this.terra
--[ 2019.11.07.11.42.18.231.0 ]--
r 17         this.terrai
--[ 2019.11.07.11.42.18.310.0 ]--
r 17         this.terrain
--[ 2019.11.07.11.42.18.372.0 ]--
r 17         this.terrain 
--[ 2019.11.07.11.42.18.528.0 ]--
r 17         this.terrain
--[ 2019.11.07.11.42.18.560.0 ]--
r 17         this.terrain=
--[ 2019.11.07.11.42.18.653.0 ]--
r 17         this.terrain= 
--[ 2019.11.07.11.42.19.127.0 ]--
r 17         this.terrain=
--[ 2019.11.07.11.42.19.267.0 ]--
r 17         this.terrain
--[ 2019.11.07.11.42.19.409.0 ]--
r 17         this.terrain 
--[ 2019.11.07.11.42.19.481.0 ]--
r 17         this.terrain =
--[ 2019.11.07.11.42.19.622.0 ]--
r 17         this.terrain = 
--[ 2019.11.07.11.42.19.794.0 ]--
r 17         this.terrain = t
--[ 2019.11.07.11.42.19.903.0 ]--
r 17         this.terrain = te
--[ 2019.11.07.11.42.20.044.0 ]--
r 17         this.terrain = ter
--[ 2019.11.07.11.42.20.226.0 ]--
r 17         this.terrain = terr
--[ 2019.11.07.11.42.20.821.0 ]--
r 17         this.terrain = terrain;
--[ 2019.11.07.11.42.21.676.0 ]--
+ 17         
--[ 2019.11.07.11.42.24.910.0 ]--
r 17         t
--[ 2019.11.07.11.42.24.983.0 ]--
r 17         th
--[ 2019.11.07.11.42.25.030.0 ]--
r 17         thi
--[ 2019.11.07.11.42.25.124.0 ]--
r 17         this
--[ 2019.11.07.11.42.25.265.0 ]--
r 17         this.
--[ 2019.11.07.11.42.25.474.0 ]--
r 17         this.l
--[ 2019.11.07.11.42.25.630.0 ]--
r 17         this.lo
--[ 2019.11.07.11.42.25.804.0 ]--
r 17         this.loc
--[ 2019.11.07.11.42.25.883.0 ]--
r 17         this.loc 
--[ 2019.11.07.11.42.26.024.0 ]--
r 17         this.loc
--[ 2019.11.07.11.42.26.102.0 ]--
r 17         this.loc 
--[ 2019.11.07.11.42.26.802.0 ]--
r 17         this.loc =
--[ 2019.11.07.11.42.26.869.0 ]--
r 17         this.loc = 
--[ 2019.11.07.11.43.33.502.0 ]--
r 9     Q
--[ 2019.11.07.11.43.34.402.0 ]--
r 9     Qu
--[ 2019.11.07.11.43.34.471.0 ]--
r 9     Que
--[ 2019.11.07.11.43.34.549.0 ]--
r 9     Queu
--[ 2019.11.07.11.43.34.658.0 ]--
r 9     Queue
--[ 2019.11.07.11.43.35.676.0 ]--
r 9     Queue<>
--[ 2019.11.07.11.43.37.414.0 ]--
r 9     Queue<C>
--[ 2019.11.07.11.43.37.617.0 ]--
r 9     Queue<Co>
--[ 2019.11.07.11.43.37.741.0 ]--
r 9     Queue<Coo>
--[ 2019.11.07.11.43.37.851.0 ]--
r 9     Queue<Coor>
--[ 2019.11.07.11.43.38.118.0 ]--
r 9     Queue<Coord>
--[ 2019.11.07.11.43.38.346.0 ]--
r 9     Queue<Coord> 
--[ 2019.11.07.11.43.38.688.0 ]--
r 9     Queue<Coord> p
--[ 2019.11.07.11.43.38.850.0 ]--
r 9     Queue<Coord> pa
--[ 2019.11.07.11.43.38.897.0 ]--
r 9     Queue<Coord> pat
--[ 2019.11.07.11.43.38.975.0 ]--
r 9     Queue<Coord> path
--[ 2019.11.07.11.43.39.053.0 ]--
r 9     Queue<Coord> path 
--[ 2019.11.07.11.43.39.194.0 ]--
r 9     Queue<Coord> path =
--[ 2019.11.07.11.43.39.288.0 ]--
r 9     Queue<Coord> path = 
--[ 2019.11.07.11.43.40.284.0 ]--
r 9     Queue<Coord> path = p
--[ 2019.11.07.11.43.40.411.0 ]--
r 9     Queue<Coord> path = pa
--[ 2019.11.07.11.43.40.458.0 ]--
r 9     Queue<Coord> path = pat
--[ 2019.11.07.11.43.40.520.0 ]--
r 9     Queue<Coord> path = path
--[ 2019.11.07.11.43.41.006.0 ]--
r 9     Queue<Coord> path = path;
--[ 2019.11.07.11.43.41.366.0 ]--
r 9     Queue<Coord> path = path
--[ 2019.11.07.11.43.41.525.0 ]--
r 9     Queue<Coord> path = pat
--[ 2019.11.07.11.43.41.696.0 ]--
r 9     Queue<Coord> path = pa
--[ 2019.11.07.11.43.41.853.0 ]--
r 9     Queue<Coord> path = p
--[ 2019.11.07.11.43.42.010.0 ]--
r 9     Queue<Coord> path = 
--[ 2019.11.07.11.43.42.169.0 ]--
r 9     Queue<Coord> path =
--[ 2019.11.07.11.43.42.341.0 ]--
r 9     Queue<Coord> path 
--[ 2019.11.07.11.43.42.498.0 ]--
r 9     Queue<Coord> path
--[ 2019.11.07.11.43.42.890.0 ]--
r 9     Queue<Coord> path;
--[ 2019.11.07.11.43.48.967.0 ]--
r 16         f
--[ 2019.11.07.11.43.49.225.0 ]--
r 16         for
--[ 2019.11.07.11.43.49.272.0 ]--
r 16         for 
--[ 2019.11.07.11.43.50.397.0 ]--
r 16         for ()
--[ 2019.11.07.11.43.50.764.0 ]--
r 16         for (C)
--[ 2019.11.07.11.43.51.042.0 ]--
r 16         for (Co)
--[ 2019.11.07.11.43.51.171.0 ]--
r 16         for (Coo)
--[ 2019.11.07.11.43.51.234.0 ]--
r 16         for (Coor)
--[ 2019.11.07.11.43.51.455.0 ]--
r 16         for (Coord)
--[ 2019.11.07.11.43.51.630.0 ]--
r 16         for (Coord )
--[ 2019.11.07.11.43.51.786.0 ]--
r 16         for (Coord c)
--[ 2019.11.07.11.43.51.942.0 ]--
r 16         for (Coord c )
--[ 2019.11.07.11.43.52.211.0 ]--
r 16         for (Coord c :)
--[ 2019.11.07.11.43.52.320.0 ]--
r 16         for (Coord c : )
--[ 2019.11.07.11.43.52.525.0 ]--
r 16         for (Coord c : p)
--[ 2019.11.07.11.43.52.710.0 ]--
r 16         for (Coord c : pa)
--[ 2019.11.07.11.43.52.757.0 ]--
r 16         for (Coord c : pat)
--[ 2019.11.07.11.43.52.867.0 ]--
r 16         for (Coord c : path)
--[ 2019.11.07.11.43.53.582.0 ]--
r 16         for (Coord c : path) 
--[ 2019.11.07.11.43.53.757.0 ]--
r 16         for (Coord c : path) {
--[ 2019.11.07.11.43.53.945.0 ]--
+ 17 
+ 18 }
--[ 2019.11.07.11.43.53.992.0 ]--
r 18         }
--[ 2019.11.07.11.43.54.007.0 ]--
r 17             
--[ 2019.11.07.11.43.55.067.0 ]--
r 17             t
--[ 2019.11.07.11.43.55.118.0 ]--
r 17             th
--[ 2019.11.07.11.43.55.212.0 ]--
r 17             thi
--[ 2019.11.07.11.43.55.290.0 ]--
r 17             this
--[ 2019.11.07.11.43.55.399.0 ]--
r 17             this.
--[ 2019.11.07.11.43.55.619.0 ]--
r 17             this.p
--[ 2019.11.07.11.43.55.776.0 ]--
r 17             this.pa
--[ 2019.11.07.11.43.55.853.0 ]--
r 17             this.pat
--[ 2019.11.07.11.43.55.900.0 ]--
r 17             this.path
--[ 2019.11.07.11.43.57.043.0 ]--
r 17             this.path.
--[ 2019.11.07.11.43.57.315.0 ]--
r 17             this.path.p
--[ 2019.11.07.11.43.57.387.0 ]--
r 17             this.path.pu
--[ 2019.11.07.11.43.57.481.0 ]--
r 17             this.path.pus
--[ 2019.11.07.11.43.57.590.0 ]--
r 17             this.path.push
--[ 2019.11.07.11.43.57.967.0 ]--
r 17             this.path.push()
--[ 2019.11.07.11.43.58.316.0 ]--
r 17             this.path.push(c)
--[ 2019.11.07.11.43.58.811.0 ]--
r 17             this.path.push(c);
--[ 2019.11.07.11.44.02.521.0 ]--
r 17             this.path.e(c);
--[ 2019.11.07.11.44.02.781.0 ]--
r 17             this.path.enq(c);
--[ 2019.11.07.11.44.02.812.0 ]--
r 17             this.path.enqu(c);
--[ 2019.11.07.11.44.02.890.0 ]--
r 17             this.path.enque(c);
--[ 2019.11.07.11.44.02.953.0 ]--
r 17             this.path.enqueu(c);
--[ 2019.11.07.11.44.03.047.0 ]--
r 17             this.path.enqueue(c);
--[ 2019.11.07.11.44.08.436.0 ]--
r 19 
--[ 2019.11.07.11.44.08.554.0 ]--
- 19
--[ 2019.11.07.11.44.10.920.0 ]--
+ 19         
--[ 2019.11.07.11.44.12.016.0 ]--
r 19         t
--[ 2019.11.07.11.44.12.184.0 ]--
r 19         th
--[ 2019.11.07.11.44.12.246.0 ]--
r 19         thi
--[ 2019.11.07.11.44.12.262.0 ]--
r 19         this
--[ 2019.11.07.11.44.12.481.0 ]--
r 19         this.
--[ 2019.11.07.11.44.12.733.0 ]--
r 19         this.l
--[ 2019.11.07.11.44.12.983.0 ]--
r 19         this.loc
--[ 2019.11.07.11.44.13.014.0 ]--
r 19         this.loc 
--[ 2019.11.07.11.44.13.186.0 ]--
r 19         this.loc =
--[ 2019.11.07.11.44.13.247.0 ]--
r 19         this.loc = 
--[ 2019.11.07.11.44.17.128.0 ]--
r 19         this.loc = t
--[ 2019.11.07.11.44.17.217.0 ]--
r 19         this.loc = th
--[ 2019.11.07.11.44.17.260.0 ]--
r 19         this.loc = thi
--[ 2019.11.07.11.44.17.363.0 ]--
r 19         this.loc = this
--[ 2019.11.07.11.44.17.456.0 ]--
r 19         this.loc = this.
--[ 2019.11.07.11.44.17.695.0 ]--
r 19         this.loc = this.p
--[ 2019.11.07.11.44.17.851.0 ]--
r 19         this.loc = this.pa
--[ 2019.11.07.11.44.17.898.0 ]--
r 19         this.loc = this.pat
--[ 2019.11.07.11.44.17.945.0 ]--
r 19         this.loc = this.path
--[ 2019.11.07.11.44.18.150.0 ]--
r 19         this.loc = this.path.
--[ 2019.11.07.11.44.18.315.0 ]--
r 19         this.loc = this.path.d
--[ 2019.11.07.11.44.18.755.0 ]--
r 19         this.loc = this.path.de
--[ 2019.11.07.11.44.18.919.0 ]--
r 19         this.loc = this.path.deq
--[ 2019.11.07.11.44.18.997.0 ]--
r 19         this.loc = this.path.dequ
--[ 2019.11.07.11.44.19.122.0 ]--
r 19         this.loc = this.path.deque
--[ 2019.11.07.11.44.19.153.0 ]--
r 19         this.loc = this.path.dequeu
--[ 2019.11.07.11.44.19.278.0 ]--
r 19         this.loc = this.path.dequeue
--[ 2019.11.07.11.44.19.639.0 ]--
r 19         this.loc = this.path.dequeue()
--[ 2019.11.07.11.44.20.382.0 ]--
r 19         this.loc = this.path.dequeue();
--[ 2019.11.07.11.44.24.090.0 ]--
r 25         return t;
--[ 2019.11.07.11.44.24.262.0 ]--
r 25         return th;
--[ 2019.11.07.11.44.24.309.0 ]--
r 25         return this;
--[ 2019.11.07.11.44.24.654.0 ]--
r 25         return this.;
--[ 2019.11.07.11.44.24.854.0 ]--
r 25         return this.l;
--[ 2019.11.07.11.44.25.010.0 ]--
r 25         return this.lo;
--[ 2019.11.07.11.44.25.041.0 ]--
r 25         return this.loc;
--[ 2019.11.07.11.44.34.465.0 ]--
r 30         return p;
--[ 2019.11.07.11.44.34.681.0 ]--
r 30         return pat;
--[ 2019.11.07.11.44.34.712.0 ]--
r 30         return path;
--[ 2019.11.07.11.44.34.949.0 ]--
r 30         return path.;
--[ 2019.11.07.11.44.35.607.0 ]--
r 30         return path.i;
--[ 2019.11.07.11.44.35.682.0 ]--
r 30         return path.is;
--[ 2019.11.07.11.44.35.996.0 ]--
r 30         return path.isE;
--[ 2019.11.07.11.44.36.139.0 ]--
r 30         return path.isEm;
--[ 2019.11.07.11.44.36.264.0 ]--
r 30         return path.isEmp;
--[ 2019.11.07.11.44.36.357.0 ]--
r 30         return path.isEmpt;
--[ 2019.11.07.11.44.36.496.0 ]--
r 30         return path.isEmpty;
--[ 2019.11.07.11.44.36.863.0 ]--
r 30         return path.isEmpty();
--[ 2019.11.07.11.44.50.279.0 ]--
r 36         t
--[ 2019.11.07.11.44.50.488.0 ]--
r 36         th
--[ 2019.11.07.11.44.50.519.0 ]--
r 36         this
--[ 2019.11.07.11.44.50.644.0 ]--
r 36         this.
--[ 2019.11.07.11.44.50.927.0 ]--
r 36         this.l
--[ 2019.11.07.11.44.51.083.0 ]--
r 36         this.lo
--[ 2019.11.07.11.44.51.177.0 ]--
r 36         this.loc
--[ 2019.11.07.11.44.51.224.0 ]--
r 36         this.loc 
--[ 2019.11.07.11.44.51.302.0 ]--
r 36         this.loc =
--[ 2019.11.07.11.44.51.427.0 ]--
r 36         this.loc = 
--[ 2019.11.07.11.44.51.835.0 ]--
r 36         this.loc = p
--[ 2019.11.07.11.44.51.968.0 ]--
r 36         this.loc = pa
--[ 2019.11.07.11.44.52.046.0 ]--
r 36         this.loc = pat
--[ 2019.11.07.11.44.52.124.0 ]--
r 36         this.loc = path
--[ 2019.11.07.11.44.52.375.0 ]--
r 36         this.loc = pat
--[ 2019.11.07.11.44.52.882.0 ]--
r 36         this.loc = pa
--[ 2019.11.07.11.44.52.918.0 ]--
r 36         this.loc = p
--[ 2019.11.07.11.44.52.950.0 ]--
r 36         this.loc = 
--[ 2019.11.07.11.44.52.981.0 ]--
r 36         this.loc =
--[ 2019.11.07.11.44.53.012.0 ]--
r 36         this.loc 
--[ 2019.11.07.11.44.53.043.0 ]--
r 36         this.loc
--[ 2019.11.07.11.44.53.074.0 ]--
r 36         this.lo
--[ 2019.11.07.11.44.53.121.0 ]--
r 36         this.l
--[ 2019.11.07.11.44.53.153.0 ]--
r 36         this.
--[ 2019.11.07.11.44.53.184.0 ]--
r 36         this
--[ 2019.11.07.11.44.53.371.0 ]--
r 36         thi
--[ 2019.11.07.11.44.53.537.0 ]--
r 36         th
--[ 2019.11.07.11.44.53.726.0 ]--
r 36         t
--[ 2019.11.07.11.44.53.929.0 ]--
r 36         
--[ 2019.11.07.11.44.54.305.0 ]--
r 36         l
--[ 2019.11.07.11.44.54.467.0 ]--
r 36         lo
--[ 2019.11.07.11.44.54.561.0 ]--
r 36         loc
--[ 2019.11.07.11.44.54.671.0 ]--
r 36         loc 
--[ 2019.11.07.11.44.54.795.0 ]--
r 36         loc =
--[ 2019.11.07.11.44.54.889.0 ]--
r 36         loc = 
--[ 2019.11.07.11.44.55.141.0 ]--
r 36         loc = p
--[ 2019.11.07.11.44.55.276.0 ]--
r 36         loc = pa
--[ 2019.11.07.11.44.55.324.0 ]--
r 36         loc = pat
--[ 2019.11.07.11.44.55.386.0 ]--
r 36         loc = path
--[ 2019.11.07.11.44.55.590.0 ]--
r 36         loc = path.
--[ 2019.11.07.11.44.55.728.0 ]--
r 36         loc = path.d
--[ 2019.11.07.11.44.55.946.0 ]--
r 36         loc = path.de
--[ 2019.11.07.11.44.56.071.0 ]--
r 36         loc = path.deq
--[ 2019.11.07.11.44.56.181.0 ]--
r 36         loc = path.dequ
--[ 2019.11.07.11.44.56.292.0 ]--
r 36         loc = path.deque
--[ 2019.11.07.11.44.56.389.0 ]--
r 36         loc = path.dequeu
--[ 2019.11.07.11.44.56.460.0 ]--
r 36         loc = path.dequeue
--[ 2019.11.07.11.44.57.223.0 ]--
r 36         loc = path.dequeue)
--[ 2019.11.07.11.44.57.277.0 ]--
r 36         loc = path.dequeue)_
--[ 2019.11.07.11.44.57.829.0 ]--
r 36         loc = path.dequeue)
--[ 2019.11.07.11.44.57.983.0 ]--
r 36         loc = path.dequeue
--[ 2019.11.07.11.44.58.523.0 ]--
r 36         loc = path.dequeue()
--[ 2019.11.07.11.44.58.799.0 ]--
r 36         loc = path.dequeue();
--[ 2019.11.07.11.45.02.730.0 ]--
r 8 
--[ 2019.11.07.11.45.07.241.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.07.11.45.35.167.0 ]--
r 9     Queue<Coord> wa;
--[ 2019.11.07.11.45.35.432.0 ]--
r 9     Queue<Coord> walk;
--[ 2019.11.07.11.45.35.619.0 ]--
r 9     Queue<Coord> walkp;
--[ 2019.11.07.11.45.35.746.0 ]--
r 9     Queue<Coord> walkpa;
--[ 2019.11.07.11.45.35.847.0 ]--
r 9     Queue<Coord> walkpat;
--[ 2019.11.07.11.45.35.910.0 ]--
r 9     Queue<Coord> walkpath;
--[ 2019.11.07.11.45.37.572.0 ]--
r 9     Queue<Coord> walkpat;
--[ 2019.11.07.11.45.37.790.0 ]--
r 9     Queue<Coord> walkpa;
--[ 2019.11.07.11.45.37.945.0 ]--
r 9     Queue<Coord> walkp;
--[ 2019.11.07.11.45.38.116.0 ]--
r 9     Queue<Coord> walk;
--[ 2019.11.07.11.45.38.790.0 ]--
r 9     Queue<Coord> walkP;
--[ 2019.11.07.11.45.39.036.0 ]--
r 9     Queue<Coord> walkPa;
--[ 2019.11.07.11.45.39.114.0 ]--
r 9     Queue<Coord> walkPat;
--[ 2019.11.07.11.45.39.192.0 ]--
r 9     Queue<Coord> walkPath;
--[ 2019.11.07.11.45.42.757.0 ]--
r 17             this.walkPath.enqueue(c);
--[ 2019.11.07.11.45.43.770.0 ]--
r 19         this.loc = this.walkPath.dequeue();
--[ 2019.11.07.11.45.46.741.0 ]--
r 30         return walkPath.isEmpty();
--[ 2019.11.07.11.45.48.256.0 ]--
r 36         loc = walkPath.dequeue();
--[ 2019.11.07.11.45.51.811.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.07.11.47.39.870.0 ]--
+ 17             
--[ 2019.11.07.11.47.40.292.0 ]--
r 17             S
--[ 2019.11.07.11.47.40.556.0 ]--
r 17             St
--[ 2019.11.07.11.47.40.743.0 ]--
r 17             Std
--[ 2019.11.07.11.47.40.899.0 ]--
r 17             StdO
--[ 2019.11.07.11.47.41.103.0 ]--
r 17             StdOu
--[ 2019.11.07.11.47.41.196.0 ]--
r 17             StdOut
--[ 2019.11.07.11.47.41.368.0 ]--
r 17             StdOut.
--[ 2019.11.07.11.47.41.697.0 ]--
r 17             StdOut.p
--[ 2019.11.07.11.47.41.761.0 ]--
r 17             StdOut.pr
--[ 2019.11.07.11.47.41.902.0 ]--
r 17             StdOut.pri
--[ 2019.11.07.11.47.42.011.0 ]--
r 17             StdOut.prin
--[ 2019.11.07.11.47.42.105.0 ]--
r 17             StdOut.print
--[ 2019.11.07.11.47.42.214.0 ]--
r 17             StdOut.printl
--[ 2019.11.07.11.47.42.292.0 ]--
r 17             StdOut.println
--[ 2019.11.07.11.47.42.496.0 ]--
r 17             StdOut.println()
--[ 2019.11.07.11.47.42.751.0 ]--
r 17             StdOut.println("")
--[ 2019.11.07.11.47.43.353.0 ]--
r 17             StdOut.println("c")
--[ 2019.11.07.11.47.43.833.0 ]--
r 17             StdOut.println("co")
--[ 2019.11.07.11.47.43.983.0 ]--
r 17             StdOut.println("coo")
--[ 2019.11.07.11.47.44.014.0 ]--
r 17             StdOut.println("coor")
--[ 2019.11.07.11.47.44.375.0 ]--
r 17             StdOut.println("coord")
--[ 2019.11.07.11.47.44.386.0 ]--
r 17             StdOut.println("coord:")
--[ 2019.11.07.11.47.44.511.0 ]--
r 17             StdOut.println("coord: ")
--[ 2019.11.07.11.47.44.965.0 ]--
r 17             StdOut.println("coord: " )
--[ 2019.11.07.11.47.45.137.0 ]--
r 17             StdOut.println("coord: " +)
--[ 2019.11.07.11.47.45.231.0 ]--
r 17             StdOut.println("coord: " + )
--[ 2019.11.07.11.47.45.403.0 ]--
r 17             StdOut.println("coord: " + c)
--[ 2019.11.07.11.47.45.980.0 ]--
r 17             StdOut.println("coord: " + c);
--[ 2019.11.07.11.47.49.494.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.07.11.48.16.295.0 ]--
+ 16         
--[ 2019.11.07.11.48.18.113.0 ]--
r 16         w
--[ 2019.11.07.11.48.18.395.0 ]--
r 16         walk
--[ 2019.11.07.11.48.18.551.0 ]--
r 16         walkP
--[ 2019.11.07.11.48.18.740.0 ]--
r 16         walkPa
--[ 2019.11.07.11.48.18.818.0 ]--
r 16         walkPat
--[ 2019.11.07.11.48.18.865.0 ]--
r 16         walkPath
--[ 2019.11.07.11.48.18.943.0 ]--
r 16         walkPath 
--[ 2019.11.07.11.48.19.052.0 ]--
r 16         walkPath =
--[ 2019.11.07.11.48.19.218.0 ]--
r 16         walkPath = 
--[ 2019.11.07.11.48.19.375.0 ]--
r 16         walkPath = n
--[ 2019.11.07.11.48.19.484.0 ]--
r 16         walkPath = ne
--[ 2019.11.07.11.48.19.562.0 ]--
r 16         walkPath = new
--[ 2019.11.07.11.48.19.625.0 ]--
r 16         walkPath = new 
--[ 2019.11.07.11.48.20.677.0 ]--
r 16         walkPath = new Q
--[ 2019.11.07.11.48.20.952.0 ]--
r 16         walkPath = new Qu
--[ 2019.11.07.11.48.21.030.0 ]--
r 16         walkPath = new Que
--[ 2019.11.07.11.48.21.107.0 ]--
r 16         walkPath = new Queu
--[ 2019.11.07.11.48.21.200.0 ]--
r 16         walkPath = new Queue
--[ 2019.11.07.11.48.22.014.0 ]--
r 16         walkPath = new Queue<>
--[ 2019.11.07.11.48.22.375.0 ]--
r 16         walkPath = new Queue<C>
--[ 2019.11.07.11.48.22.486.0 ]--
r 16         walkPath = new Queue<Co>
--[ 2019.11.07.11.48.22.612.0 ]--
r 16         walkPath = new Queue<Coo>
--[ 2019.11.07.11.48.22.781.0 ]--
r 16         walkPath = new Queue<Coor>
--[ 2019.11.07.11.48.22.952.0 ]--
r 16         walkPath = new Queue<Coord>
--[ 2019.11.07.11.48.23.579.0 ]--
r 16         walkPath = new Queue<Coord>;
--[ 2019.11.07.11.48.24.235.0 ]--
r 16         walkPath = new Queue<Coord>
--[ 2019.11.07.11.48.25.282.0 ]--
r 16         walkPath = new Queue<Coord>()
--[ 2019.11.07.11.48.25.555.0 ]--
r 16         walkPath = new Queue<Coord>();
--[ 2019.11.07.11.48.29.588.0 ]--
r 16         walkPath = new Queue<>();
--[ 2019.11.07.11.48.35.532.0 ]--
r 18 
--[ 2019.11.07.11.48.35.677.0 ]--
- 18
--[ 2019.11.07.11.48.39.572.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.07.11.50.16.824.0 ]--
+ 38         
--[ 2019.11.07.11.50.17.657.0 ]--
r 38         T
--[ 2019.11.07.11.50.17.859.0 ]--
r 38         Th
--[ 2019.11.07.11.50.18.066.0 ]--
r 38         Thre
--[ 2019.11.07.11.50.18.101.0 ]--
r 38         Threa
--[ 2019.11.07.11.50.18.203.0 ]--
r 38         Thread
--[ 2019.11.07.11.50.18.335.0 ]--
r 38         Thread.
--[ 2019.11.07.11.50.19.111.0 ]--
r 38         Thread.s
--[ 2019.11.07.11.50.19.204.0 ]--
r 38         Thread.sl
--[ 2019.11.07.11.50.19.324.0 ]--
r 38         Thread.sle
--[ 2019.11.07.11.50.19.507.0 ]--
r 38         Thread.slee
--[ 2019.11.07.11.50.19.580.0 ]--
r 38         Thread.sleep
--[ 2019.11.07.11.50.19.789.0 ]--
r 38         Thread.sleep()
--[ 2019.11.07.11.50.20.775.0 ]--
r 38         Thread.sleep(b)
--[ 2019.11.07.11.50.20.849.0 ]--
r 38         Thread.sleep(by)
--[ 2019.11.07.11.50.21.162.0 ]--
r 38         Thread.sleep(byT)
--[ 2019.11.07.11.50.21.373.0 ]--
r 38         Thread.sleep(byTi)
--[ 2019.11.07.11.50.21.419.0 ]--
r 38         Thread.sleep(byTim)
--[ 2019.11.07.11.50.21.480.0 ]--
r 38         Thread.sleep(byTime)
--[ 2019.11.07.11.50.21.867.0 ]--
r 38         Thread.sleep(byTime);
--[ 2019.11.07.11.50.21.888.0 ]--
r 38         Thread.sleep(byTime);''
--[ 2019.11.07.11.50.22.749.0 ]--
r 38         Thread.sleep(byTime);
--[ 2019.11.07.11.50.25.778.0 ]--
UpdateTree (AD): 0 1
- /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.50.25.778.1 ]--
CompilationStatus (AEW): 0 1 0
[Ljava.lang.String;@51699c16
--[ 2019.11.07.11.50.53.954.0 ]--
r 38         Thread.sleep((byTime);
--[ 2019.11.07.11.50.54.116.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.50.54.131.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.50.54.131.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.50.54.334.0 ]--
r 38         Thread.sleep((lbyTime);
--[ 2019.11.07.11.50.54.350.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.50.54.366.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.50.54.538.0 ]--
r 38         Thread.sleep((lobyTime);
--[ 2019.11.07.11.50.54.538.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.50.54.553.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.50.54.616.0 ]--
r 38         Thread.sleep((lonbyTime);
--[ 2019.11.07.11.50.54.616.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.50.54.631.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.50.54.678.0 ]--
r 38         Thread.sleep((longbyTime);
--[ 2019.11.07.11.50.54.694.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.50.54.709.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.50.54.903.0 ]--
r 38         Thread.sleep((long)byTime);
--[ 2019.11.07.11.50.54.918.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.50.54.950.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.50.54.950.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.50.55.106.0 ]--
r 38         Thread.sleep((long) byTime);
--[ 2019.11.07.11.50.55.121.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.50.55.121.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.50.59.915.0 ]--
r 38         Thread.sleep(((long) byTime);
--[ 2019.11.07.11.50.59.931.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.50.59.931.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.50.59.947.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.07.523.0 ]--
r 38         Thread.sleep(((long) byTime)
--[ 2019.11.07.11.51.07.723.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.07.731.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.07.747.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.07.983.0 ]--
r 38         Thread.sleep(((long) byTime
--[ 2019.11.07.11.51.08.001.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.08.007.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.08.023.0 ]--
r 38         Thread.sleep(((long) byTim
--[ 2019.11.07.11.51.08.039.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.08.039.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.08.054.0 ]--
r 38         Thread.sleep(((long) byTi
--[ 2019.11.07.11.51.08.070.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.08.070.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.08.117.0 ]--
r 38         Thread.sleep(((long) byT
--[ 2019.11.07.11.51.08.132.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.08.148.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.08.163.0 ]--
r 38         Thread.sleep(((long) b
--[ 2019.11.07.11.51.08.163.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.08.179.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.08.226.0 ]--
r 38         Thread.sleep(((long) 
--[ 2019.11.07.11.51.08.226.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.08.242.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.08.257.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.08.273.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.08.273.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.08.288.0 ]--
r 38         Thread.sleep(((long)
--[ 2019.11.07.11.51.08.304.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.08.304.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.08.320.0 ]--
r 38         Thread.sleep(((lon
--[ 2019.11.07.11.51.08.335.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.08.335.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.08.351.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.08.367.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.08.367.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.08.382.0 ]--
r 38         Thread.sleep(((lo
--[ 2019.11.07.11.51.08.398.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.08.398.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.08.492.0 ]--
r 38         Thread.sleep(((l
--[ 2019.11.07.11.51.08.492.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.08.507.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.08.684.0 ]--
r 38         Thread.sleep(((
--[ 2019.11.07.11.51.08.715.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.08.731.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.08.762.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.08.887.0 ]--
r 38         Thread.sleep((
--[ 2019.11.07.11.51.08.887.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.08.903.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.08.903.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.09.059.0 ]--
r 38         Thread.sleep(
--[ 2019.11.07.11.51.09.090.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.09.106.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.09.247.0 ]--
r 38         Thread.sleep
--[ 2019.11.07.11.51.09.247.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.09.262.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.09.278.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.10.049.0 ]--
r 38         Thread.sleep()
--[ 2019.11.07.11.51.10.080.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.10.095.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.10.946.0 ]--
r 38         Thread.sleep(())
--[ 2019.11.07.11.51.10.962.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.10.978.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.11.235.0 ]--
r 38         Thread.sleep((l))
--[ 2019.11.07.11.51.11.235.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.11.250.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.11.445.0 ]--
r 38         Thread.sleep((lo))
--[ 2019.11.07.11.51.11.452.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.11.468.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.11.515.0 ]--
r 38         Thread.sleep((lon))
--[ 2019.11.07.11.51.11.515.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.11.530.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.11.624.0 ]--
r 38         Thread.sleep((long))
--[ 2019.11.07.11.51.11.624.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.11.640.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.11.655.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.11.655.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.11.671.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.11.938.0 ]--
r 38         Thread.sleep((long) )
--[ 2019.11.07.11.51.11.953.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.11.969.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.12.224.0 ]--
r 38         Thread.sleep((long) b)
--[ 2019.11.07.11.51.12.255.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.12.255.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.12.285.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.12.306.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.12.337.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.12.337.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.12.369.0 ]--
r 38         Thread.sleep((long) by)
--[ 2019.11.07.11.51.12.369.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.12.384.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.12.593.0 ]--
r 38         Thread.sleep((long) byT)
--[ 2019.11.07.11.51.12.609.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.12.627.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.12.737.0 ]--
r 38         Thread.sleep((long) byTi)
--[ 2019.11.07.11.51.12.737.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.12.752.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.12.799.0 ]--
r 38         Thread.sleep((long) byTim)
--[ 2019.11.07.11.51.12.799.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.12.815.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.12.877.0 ]--
r 38         Thread.sleep((long) byTime)
--[ 2019.11.07.11.51.12.877.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.12.893.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.13.270.0 ]--
r 38         Thread.sleep((long) byTime);
--[ 2019.11.07.11.51.13.286.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.13.320.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.21.577.0 ]--
r 38 
--[ 2019.11.07.11.51.21.760.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.21.776.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.21.791.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.21.807.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.21.838.0 ]--
- 38
--[ 2019.11.07.11.51.21.838.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.51.21.854.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.11.52.05.226.0 ]--
+ 38         
--[ 2019.11.07.11.52.05.573.0 ]--
r 38         T
--[ 2019.11.07.11.52.05.863.0 ]--
r 38         Th
--[ 2019.11.07.11.52.05.943.0 ]--
r 38         Thr
--[ 2019.11.07.11.52.06.052.0 ]--
r 38         Thre
--[ 2019.11.07.11.52.06.115.0 ]--
r 38         Threa
--[ 2019.11.07.11.52.06.209.0 ]--
r 38         Thread
--[ 2019.11.07.11.52.06.322.0 ]--
r 38         Thread.
--[ 2019.11.07.11.52.06.519.0 ]--
r 38         Thread.d
--[ 2019.11.07.11.52.06.634.0 ]--
r 38         Thread.de
--[ 2019.11.07.11.52.06.698.0 ]--
r 38         Thread.del
--[ 2019.11.07.11.52.06.827.0 ]--
r 38         Thread.dela
--[ 2019.11.07.11.52.06.901.0 ]--
r 38         Thread.delay
--[ 2019.11.07.11.52.07.325.0 ]--
r 38         Thread.delay()
--[ 2019.11.07.11.52.07.959.0 ]--
r 38         Thread.delay(())
--[ 2019.11.07.11.52.08.319.0 ]--
r 38         Thread.delay((i))
--[ 2019.11.07.11.52.08.434.0 ]--
r 38         Thread.delay((in))
--[ 2019.11.07.11.52.08.512.0 ]--
r 38         Thread.delay((int))
--[ 2019.11.07.11.52.08.935.0 ]--
r 38         Thread.delay((int) )
--[ 2019.11.07.11.52.09.217.0 ]--
r 38         Thread.delay((int) b)
--[ 2019.11.07.11.52.09.358.0 ]--
r 38         Thread.delay((int) by)
--[ 2019.11.07.11.52.09.593.0 ]--
r 38         Thread.delay((int) byT)
--[ 2019.11.07.11.52.09.756.0 ]--
r 38         Thread.delay((int) byTi)
--[ 2019.11.07.11.52.09.803.0 ]--
r 38         Thread.delay((int) byTim)
--[ 2019.11.07.11.52.09.866.0 ]--
r 38         Thread.delay((int) byTime)
--[ 2019.11.07.11.52.10.226.0 ]--
r 38         Thread.delay((int) byTime);
--[ 2019.11.07.11.52.12.956.0 ]--
r 38         Thread.s((int) byTime);
--[ 2019.11.07.11.52.13.325.0 ]--
r 38         Thread.sl((int) byTime);
--[ 2019.11.07.11.52.13.437.0 ]--
r 38         Thread.sle((int) byTime);
--[ 2019.11.07.11.52.13.594.0 ]--
r 38         Thread.slee((int) byTime);
--[ 2019.11.07.11.52.13.688.0 ]--
r 38         Thread.sleep((int) byTime);
--[ 2019.11.07.11.52.22.629.0 ]--
CompilationStatus (AEW): 0 1 0
[Ljava.lang.String;@3fc79934
--[ 2019.11.07.11.52.27.255.0 ]--
+ 38         
--[ 2019.11.07.11.52.28.228.0 ]--
r 38         i
--[ 2019.11.07.11.52.28.306.0 ]--
r 38         in
--[ 2019.11.07.11.52.28.337.0 ]--
r 38         int
--[ 2019.11.07.11.52.28.446.0 ]--
r 38         int 
--[ 2019.11.07.11.52.28.603.0 ]--
r 38         int t
--[ 2019.11.07.11.52.28.696.0 ]--
r 38         int ti
--[ 2019.11.07.11.52.28.790.0 ]--
r 38         int tim
--[ 2019.11.07.11.52.28.868.0 ]--
r 38         int time
--[ 2019.11.07.11.52.28.978.0 ]--
r 38         int time 
--[ 2019.11.07.11.52.29.071.0 ]--
r 38         int time =
--[ 2019.11.07.11.52.29.196.0 ]--
r 38         int time = 
--[ 2019.11.07.11.52.30.044.0 ]--
r 38         int time = ()
--[ 2019.11.07.11.52.30.242.0 ]--
r 38         int time = (i)
--[ 2019.11.07.11.52.30.383.0 ]--
r 38         int time = (in)
--[ 2019.11.07.11.52.30.446.0 ]--
r 38         int time = (int)
--[ 2019.11.07.11.52.30.775.0 ]--
r 38         int time = (int) 
--[ 2019.11.07.11.52.30.915.0 ]--
r 38         int time = (int) b
--[ 2019.11.07.11.52.31.056.0 ]--
r 38         int time = (int) by
--[ 2019.11.07.11.52.31.333.0 ]--
r 38         int time = (int) byT
--[ 2019.11.07.11.52.31.465.0 ]--
r 38         int time = (int) byTi
--[ 2019.11.07.11.52.31.519.0 ]--
r 38         int time = (int) byTim
--[ 2019.11.07.11.52.31.591.0 ]--
r 38         int time = (int) byTime
--[ 2019.11.07.11.52.31.683.0 ]--
r 38         int time = (int) byTime;
--[ 2019.11.07.11.52.36.450.0 ]--
r 39         Thread.sleep((t);
--[ 2019.11.07.11.52.36.589.0 ]--
r 39         Thread.sleep((ti);
--[ 2019.11.07.11.52.36.646.0 ]--
r 39         Thread.sleep((tim);
--[ 2019.11.07.11.52.36.727.0 ]--
r 39         Thread.sleep((time);
--[ 2019.11.07.11.52.38.791.0 ]--
r 39         Thread.sleep(time);
--[ 2019.11.07.11.52.43.383.0 ]--
- 38
r 38 
--[ 2019.11.07.11.52.43.524.0 ]--
- 38
--[ 2019.11.07.11.53.05.819.0 ]--
DisposeComponent
--[ 2019.11.07.12.24.58.441.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.11.07.12.24.58.808.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml

--[ 2019.11.07.12.24.58.829.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.07.12.24.58.850.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.11.07.12.24.58.882.0 ]--
InitFile: /.cos265


--[ 2019.11.07.12.24.58.909.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.11.07.12.24.58.936.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.11.07.12.24.58.959.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[12];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.11.07.12.24.58.999.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.11.07.12.24.59.019.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> walkPath;
    Coord loc;
    Terrain terrain;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        walkPath = new Queue<>();
        for (Coord c : path) {
            this.walkPath.enqueue(c);
        }
        this.loc = this.walkPath.dequeue();
        this.terrain = terrain;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return walkPath.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        loc = walkPath.dequeue();
    }

}

--[ 2019.11.07.12.24.59.038.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        public Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null)  this.cost = 0.0f;
                else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.computeDistance(loc, end);
            }
        }

        public float getCost(float heuristic) {
            return cost;
        }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        Stopwatch stopwatch = new Stopwatch();
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            if (currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == getPathEnd().getJ()) {
                pathFound = true;
                endNode = currentNode;
                break;
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            atStart = false;
        }
        StdOut.println("stopwatch: " + stopwatch.elapsedTime());
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(h);
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        Stack<Coord> s = new Stack<>();
        PFNode c = endNode;
        while (c != null) {
            s.push(c.getLoc());
            c = c.fromNode;
        }
        return s;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2019.11.07.12.25.05.480.0 ]--
UpdateTree (AD): 0 1
- /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.12.25.05.530.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.12.25.05.590.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.12.25.59.200.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 48     private final static String emapFilename = emaps[0];        // change index to load a different elevation map
--[ 2019.11.07.12.26.12.074.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.07.12.28.34.568.0 ]--
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.07.12.28.35.587.0 ]--
UpdateTree (AD): 1 0
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.12.28.35.738.0 ]--
r 48     private final static String emapFilename = emaps[9];        // change index to load a different elevation map
--[ 2019.11.07.12.28.46.488.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.07.12.31.55.664.0 ]--
:/src/Walker.java
+ 38         
--[ 2019.11.07.12.31.57.142.0 ]--
r 38         time = 
--[ 2019.11.07.12.31.57.501.0 ]--
r 38         time =
--[ 2019.11.07.12.31.57.689.0 ]--
r 38         time 
--[ 2019.11.07.12.31.57.860.0 ]--
r 38         time
--[ 2019.11.07.12.31.57.991.0 ]--
r 38         tim
--[ 2019.11.07.12.31.58.162.0 ]--
r 38         ti
--[ 2019.11.07.12.31.58.346.0 ]--
r 38         t
--[ 2019.11.07.12.31.58.542.0 ]--
r 38         
--[ 2019.11.07.12.31.58.940.0 ]--
r 38         i
--[ 2019.11.07.12.31.59.071.0 ]--
r 38         in
--[ 2019.11.07.12.31.59.134.0 ]--
r 38         int
--[ 2019.11.07.12.31.59.307.0 ]--
r 38         int 
--[ 2019.11.07.12.31.59.377.0 ]--
r 38         int t
--[ 2019.11.07.12.31.59.431.0 ]--
r 38         int ti
--[ 2019.11.07.12.31.59.483.0 ]--
r 38         int tim
--[ 2019.11.07.12.31.59.556.0 ]--
r 38         int time
--[ 2019.11.07.12.31.59.849.0 ]--
r 38         int time =
--[ 2019.11.07.12.31.59.988.0 ]--
r 38         int time = 
--[ 2019.11.07.12.32.00.323.0 ]--
r 38         int time = b
--[ 2019.11.07.12.32.00.640.0 ]--
r 38         int time = by
--[ 2019.11.07.12.32.00.780.0 ]--
r 38         int time = byT
--[ 2019.11.07.12.32.01.008.0 ]--
r 38         int time = byTi
--[ 2019.11.07.12.32.01.091.0 ]--
r 38         int time = byTim
--[ 2019.11.07.12.32.01.187.0 ]--
r 38         int time = byTime
--[ 2019.11.07.12.32.01.955.0 ]--
r 38         int time = byTim
--[ 2019.11.07.12.32.02.101.0 ]--
r 38         int time = byTi
--[ 2019.11.07.12.32.02.274.0 ]--
r 38         int time = byT
--[ 2019.11.07.12.32.02.447.0 ]--
r 38         int time = by
--[ 2019.11.07.12.32.02.596.0 ]--
r 38         int time = b
--[ 2019.11.07.12.32.02.767.0 ]--
r 38         int time = 
--[ 2019.11.07.12.32.03.346.0 ]--
r 38         int time = )
--[ 2019.11.07.12.32.03.667.0 ]--
r 38         int time = )i
--[ 2019.11.07.12.32.03.729.0 ]--
r 38         int time = )in
--[ 2019.11.07.12.32.03.847.0 ]--
r 38         int time = )int
--[ 2019.11.07.12.32.04.113.0 ]--
r 38         int time = )int_
--[ 2019.11.07.12.32.04.250.0 ]--
r 38         int time = )int_ 
--[ 2019.11.07.12.32.04.516.0 ]--
r 38         int time = )int_ b
--[ 2019.11.07.12.32.04.771.0 ]--
r 38         int time = )int_ 
--[ 2019.11.07.12.32.05.259.0 ]--
r 38         int time = )int_
--[ 2019.11.07.12.32.05.324.0 ]--
r 38         int time = )in
--[ 2019.11.07.12.32.05.438.0 ]--
r 38         int time = )
--[ 2019.11.07.12.32.05.576.0 ]--
r 38         int time = 
--[ 2019.11.07.12.32.06.213.0 ]--
r 38         int time = ()
--[ 2019.11.07.12.32.07.220.0 ]--
r 38         int time = (int) b
--[ 2019.11.07.12.32.07.282.0 ]--
r 38         int time = (int) by
--[ 2019.11.07.12.32.07.517.0 ]--
r 38         int time = (int) byT
--[ 2019.11.07.12.32.07.691.0 ]--
r 38         int time = (int) byTi
--[ 2019.11.07.12.32.07.794.0 ]--
r 38         int time = (int) byTim
--[ 2019.11.07.12.32.07.971.0 ]--
r 38         int time = (int) byTime
--[ 2019.11.07.12.32.08.015.0 ]--
r 38         int time = (int) byTime;
--[ 2019.11.07.12.32.09.789.0 ]--
+ 39         
--[ 2019.11.07.12.32.10.174.0 ]--
r 39         T
--[ 2019.11.07.12.32.10.322.0 ]--
r 39         Th
--[ 2019.11.07.12.32.10.446.0 ]--
r 39         Thr
--[ 2019.11.07.12.32.10.655.0 ]--
r 39         Thrae
--[ 2019.11.07.12.32.10.712.0 ]--
r 39         Thraed
--[ 2019.11.07.12.32.10.800.0 ]--
r 39         Thraed.
--[ 2019.11.07.12.32.10.980.0 ]--
r 39         Thraed.s
--[ 2019.11.07.12.32.11.056.0 ]--
r 39         Thraed.sl
--[ 2019.11.07.12.32.11.161.0 ]--
r 39         Thraed.sle
--[ 2019.11.07.12.32.11.333.0 ]--
r 39         Thraed.slee
--[ 2019.11.07.12.32.11.427.0 ]--
r 39         Thraed.sleep
--[ 2019.11.07.12.32.12.683.0 ]--
r 39         Thraed.slee
--[ 2019.11.07.12.32.13.155.0 ]--
r 39         Thraed.sle
--[ 2019.11.07.12.32.13.239.0 ]--
r 39         Thraed.sl
--[ 2019.11.07.12.32.13.326.0 ]--
r 39         Thraed.s
--[ 2019.11.07.12.32.13.395.0 ]--
r 39         Thrae
--[ 2019.11.07.12.32.13.475.0 ]--
r 39         Th
--[ 2019.11.07.12.32.13.619.0 ]--
r 39         T
--[ 2019.11.07.12.32.14.346.0 ]--
r 39         Th
--[ 2019.11.07.12.32.14.454.0 ]--
r 39         Thr
--[ 2019.11.07.12.32.14.552.0 ]--
r 39         Thre
--[ 2019.11.07.12.32.14.615.0 ]--
r 39         Threa
--[ 2019.11.07.12.32.14.714.0 ]--
r 39         Thread
--[ 2019.11.07.12.32.15.140.0 ]--
r 39         Thread.
--[ 2019.11.07.12.32.15.656.0 ]--
r 39         Thread.s
--[ 2019.11.07.12.32.15.751.0 ]--
r 39         Thread.sl
--[ 2019.11.07.12.32.15.869.0 ]--
r 39         Thread.sle
--[ 2019.11.07.12.32.16.043.0 ]--
r 39         Thread.slee
--[ 2019.11.07.12.32.16.123.0 ]--
r 39         Thread.sleep
--[ 2019.11.07.12.32.16.441.0 ]--
r 39         Thread.sleep()
--[ 2019.11.07.12.32.18.102.0 ]--
r 39         Thread.sleep(t)
--[ 2019.11.07.12.32.18.234.0 ]--
r 39         Thread.sleep(tmi)
--[ 2019.11.07.12.32.18.621.0 ]--
r 39         Thread.sleep(tmie)
--[ 2019.11.07.12.32.19.023.0 ]--
r 39         Thread.sleep(tmi)
--[ 2019.11.07.12.32.19.186.0 ]--
r 39         Thread.sleep(tm)
--[ 2019.11.07.12.32.19.369.0 ]--
r 39         Thread.sleep(t)
--[ 2019.11.07.12.32.20.017.0 ]--
r 39         Thread.sleep(ti)
--[ 2019.11.07.12.32.20.078.0 ]--
r 39         Thread.sleep(tim)
--[ 2019.11.07.12.32.20.202.0 ]--
r 39         Thread.sleep(time)
--[ 2019.11.07.12.32.20.607.0 ]--
r 39         Thread.sleep(time);
--[ 2019.11.07.12.32.22.349.0 ]--
r 39         Thread.sleep(tim);
--[ 2019.11.07.12.32.22.542.0 ]--
r 39         Thread.sleep(ti);
--[ 2019.11.07.12.32.22.729.0 ]--
r 39         Thread.sleep(t);
--[ 2019.11.07.12.32.23.395.0 ]--
r 39         Thread.sleep();
--[ 2019.11.07.12.32.23.692.0 ]--
r 39         Thread.sleep(1);
--[ 2019.11.07.12.32.23.781.0 ]--
r 39         Thread.sleep(10);
--[ 2019.11.07.12.32.27.654.0 ]--
r 39         Thread.sleep(100);
--[ 2019.11.07.12.32.28.600.0 ]--
r 39         Thread.sleep(1000);
--[ 2019.11.07.12.32.37.309.0 ]--
UpdateTree (AD): 0 1
- /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.12.32.37.551.0 ]--
CompilationStatus (AEW): 0 1 0
[Ljava.lang.String;@67f6e9a4
--[ 2019.11.07.12.32.54.918.0 ]--
r 39         
--[ 2019.11.07.12.32.55.863.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.12.32.55.939.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.12.32.56.004.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.12.32.56.059.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.12.33.34.307.0 ]--
r 39         S
--[ 2019.11.07.12.33.34.485.0 ]--
r 39         St
--[ 2019.11.07.12.33.34.768.0 ]--
r 39         Std
--[ 2019.11.07.12.33.35.174.0 ]--
r 39         St
--[ 2019.11.07.12.33.35.269.0 ]--
r 39         S
--[ 2019.11.07.12.33.35.432.0 ]--
r 39         
--[ 2019.11.07.12.33.36.442.0 ]--
- 39
--[ 2019.11.07.12.33.39.911.0 ]--
r 38         l time = (int) byTime;
--[ 2019.11.07.12.33.40.069.0 ]--
r 38         lo time = (int) byTime;
--[ 2019.11.07.12.33.40.200.0 ]--
r 38         lon time = (int) byTime;
--[ 2019.11.07.12.33.40.317.0 ]--
r 38         long time = (int) byTime;
--[ 2019.11.07.12.33.43.754.0 ]--
r 38         long time = (l) byTime;
--[ 2019.11.07.12.33.43.934.0 ]--
r 38         long time = (lo) byTime;
--[ 2019.11.07.12.33.43.995.0 ]--
r 38         long time = (lon) byTime;
--[ 2019.11.07.12.33.44.133.0 ]--
r 38         long time = (long) byTime;
--[ 2019.11.07.12.33.46.559.0 ]--
+ 39         
--[ 2019.11.07.12.33.47.390.0 ]--
r 39         S
--[ 2019.11.07.12.33.47.530.0 ]--
r 39         St
--[ 2019.11.07.12.33.47.770.0 ]--
r 39         Std
--[ 2019.11.07.12.33.48.011.0 ]--
r 39         StdO
--[ 2019.11.07.12.33.48.159.0 ]--
r 39         StdOu
--[ 2019.11.07.12.33.48.291.0 ]--
r 39         StdOut
--[ 2019.11.07.12.33.48.461.0 ]--
r 39         StdOut.
--[ 2019.11.07.12.33.48.688.0 ]--
r 39         StdOut.p
--[ 2019.11.07.12.33.48.787.0 ]--
r 39         StdOut.pr
--[ 2019.11.07.12.33.48.875.0 ]--
r 39         StdOut.pri
--[ 2019.11.07.12.33.49.009.0 ]--
r 39         StdOut.prin
--[ 2019.11.07.12.33.49.108.0 ]--
r 39         StdOut.print
--[ 2019.11.07.12.33.49.304.0 ]--
r 39         StdOut.println
--[ 2019.11.07.12.33.49.459.0 ]--
r 39         StdOut.println()
--[ 2019.11.07.12.33.49.680.0 ]--
r 39         StdOut.println("")
--[ 2019.11.07.12.33.49.883.0 ]--
r 39         StdOut.println("t")
--[ 2019.11.07.12.33.49.975.0 ]--
r 39         StdOut.println("ti")
--[ 2019.11.07.12.33.50.050.0 ]--
r 39         StdOut.println("tim")
--[ 2019.11.07.12.33.50.133.0 ]--
r 39         StdOut.println("time")
--[ 2019.11.07.12.33.50.290.0 ]--
r 39         StdOut.println("time:")
--[ 2019.11.07.12.33.50.383.0 ]--
r 39         StdOut.println("time: ")
--[ 2019.11.07.12.34.04.842.0 ]--
r 39         StdOut.println("time: "+)
--[ 2019.11.07.12.34.06.200.0 ]--
r 39         StdOut.println("time: "+ tim)
--[ 2019.11.07.12.34.06.308.0 ]--
r 39         StdOut.println("time: "+ time)
--[ 2019.11.07.12.34.06.553.0 ]--
r 39         StdOut.println("time: "+ time);
--[ 2019.11.07.12.34.16.261.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.07.12.41.34.629.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.07.12.41.35.506.0 ]--
UpdateTree (AD): 1 0
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.07.12.41.35.683.0 ]--
r 48     private final static String emapFilename = emaps[11];        // change index to load a different elevation map
--[ 2019.11.07.12.41.43.389.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.07.12.41.54.273.0 ]--
r 48     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2019.11.07.12.41.54.435.0 ]--
r 48     private final static String emapFilename = emaps[12];        // change index to load a different elevation map
--[ 2019.11.07.12.42.01.675.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.07.12.42.35.451.0 ]--
r 48     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2019.11.07.12.42.36.821.0 ]--
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.07.12.42.39.906.0 ]--
r 48     private final static String emapFilename = emaps[4];        // change index to load a different elevation map
--[ 2019.11.07.12.42.48.299.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.07.12.44.30.723.0 ]--
:/src/Walker.java
+ 37         
--[ 2019.11.07.12.44.31.636.0 ]--
r 37         Stop
--[ 2019.11.07.12.44.31.772.0 ]--
r 37         Stopwa
--[ 2019.11.07.12.44.31.944.0 ]--
r 37         Stopwatc
--[ 2019.11.07.12.44.32.069.0 ]--
r 37         Stopwatch
--[ 2019.11.07.12.44.32.138.0 ]--
r 37         Stopwatch 
--[ 2019.11.07.12.44.32.208.0 ]--
r 37         Stopwatch s
--[ 2019.11.07.12.44.32.317.0 ]--
r 37         Stopwatch st
--[ 2019.11.07.12.44.32.411.0 ]--
r 37         Stopwatch sto
--[ 2019.11.07.12.44.32.564.0 ]--
r 37         Stopwatch stopw
--[ 2019.11.07.12.44.32.672.0 ]--
r 37         Stopwatch stopwa
--[ 2019.11.07.12.44.32.765.0 ]--
r 37         Stopwatch stopwat
--[ 2019.11.07.12.44.33.007.0 ]--
r 37         Stopwatch stopwatch
--[ 2019.11.07.12.44.33.070.0 ]--
r 37         Stopwatch stopwatch 
--[ 2019.11.07.12.44.33.156.0 ]--
r 37         Stopwatch stopwatch =
--[ 2019.11.07.12.44.33.317.0 ]--
r 37         Stopwatch stopwatch = 
--[ 2019.11.07.12.44.33.653.0 ]--
r 37         Stopwatch stopwatch = n
--[ 2019.11.07.12.44.33.857.0 ]--
r 37         Stopwatch stopwatch = new
--[ 2019.11.07.12.44.34.054.0 ]--
r 37         Stopwatch stopwatch = new 
--[ 2019.11.07.12.44.34.208.0 ]--
r 37         Stopwatch stopwatch = new S
--[ 2019.11.07.12.44.34.356.0 ]--
r 37         Stopwatch stopwatch = new St
--[ 2019.11.07.12.44.34.544.0 ]--
r 37         Stopwatch stopwatch = new Stop
--[ 2019.11.07.12.44.34.603.0 ]--
r 37         Stopwatch stopwatch = new Stopw
--[ 2019.11.07.12.44.34.665.0 ]--
r 37         Stopwatch stopwatch = new Stopwa
--[ 2019.11.07.12.44.34.747.0 ]--
r 37         Stopwatch stopwatch = new Stopwat
--[ 2019.11.07.12.44.34.924.0 ]--
r 37         Stopwatch stopwatch = new Stopwatc
--[ 2019.11.07.12.44.35.020.0 ]--
r 37         Stopwatch stopwatch = new Stopwatch
--[ 2019.11.07.12.44.35.294.0 ]--
r 37         Stopwatch stopwatch = new Stopwatch()
--[ 2019.11.07.12.44.35.637.0 ]--
r 37         Stopwatch stopwatch = new Stopwatch();
--[ 2019.11.07.12.44.37.443.0 ]--
+ 38         
--[ 2019.11.07.12.44.37.807.0 ]--
r 38         w
--[ 2019.11.07.12.44.37.898.0 ]--
r 38         wh
--[ 2019.11.07.12.44.37.959.0 ]--
r 38         whi
--[ 2019.11.07.12.44.38.160.0 ]--
r 38         whil
--[ 2019.11.07.12.44.38.277.0 ]--
r 38         while
--[ 2019.11.07.12.44.38.362.0 ]--
r 38         while 
--[ 2019.11.07.12.44.38.698.0 ]--
r 38         while s
--[ 2019.11.07.12.44.38.833.0 ]--
r 38         while st
--[ 2019.11.07.12.44.38.929.0 ]--
r 38         while sto
--[ 2019.11.07.12.44.39.004.0 ]--
r 38         while stop
--[ 2019.11.07.12.44.39.129.0 ]--
r 38         while stopw
--[ 2019.11.07.12.44.39.229.0 ]--
r 38         while stopwat
--[ 2019.11.07.12.44.39.613.0 ]--
r 38         while stopwa
--[ 2019.11.07.12.44.40.129.0 ]--
r 38         while stop
--[ 2019.11.07.12.44.40.209.0 ]--
r 38         while st
--[ 2019.11.07.12.44.40.344.0 ]--
r 38         while s
--[ 2019.11.07.12.44.40.562.0 ]--
r 38         while 
--[ 2019.11.07.12.44.41.115.0 ]--
r 38         while ()
--[ 2019.11.07.12.44.42.121.0 ]--
r 38         while (stopwatch)
--[ 2019.11.07.12.44.42.260.0 ]--
r 38         while (stopwatch.)
--[ 2019.11.07.12.44.42.395.0 ]--
r 38         while (stopwatch.e)
--[ 2019.11.07.12.44.42.477.0 ]--
r 38         while (stopwatch.el)
--[ 2019.11.07.12.44.42.610.0 ]--
r 38         while (stopwatch.ela)
--[ 2019.11.07.12.44.42.725.0 ]--
r 38         while (stopwatch.elap)
--[ 2019.11.07.12.44.42.846.0 ]--
r 38         while (stopwatch.elaps)
--[ 2019.11.07.12.44.42.931.0 ]--
r 38         while (stopwatch.elapse)
--[ 2019.11.07.12.44.43.080.0 ]--
r 38         while (stopwatch.elapsed)
--[ 2019.11.07.12.44.43.410.0 ]--
r 38         while (stopwatch.elapsedT)
--[ 2019.11.07.12.44.43.581.0 ]--
r 38         while (stopwatch.elapsedTi)
--[ 2019.11.07.12.44.43.707.0 ]--
r 38         while (stopwatch.elapsedTime)
--[ 2019.11.07.12.44.44.047.0 ]--
r 38         while (stopwatch.elapsedTime())
--[ 2019.11.07.12.44.44.498.0 ]--
r 38         while (stopwatch.elapsedTime() )
--[ 2019.11.07.12.44.44.725.0 ]--
r 38         while (stopwatch.elapsedTime() <)
--[ 2019.11.07.12.44.44.790.0 ]--
r 38         while (stopwatch.elapsedTime() < )
--[ 2019.11.07.12.44.44.980.0 ]--
r 38         while (stopwatch.elapsedTime() < b)
--[ 2019.11.07.12.44.45.092.0 ]--
r 38         while (stopwatch.elapsedTime() < by)
--[ 2019.11.07.12.44.45.366.0 ]--
r 38         while (stopwatch.elapsedTime() < byT)
--[ 2019.11.07.12.44.45.478.0 ]--
r 38         while (stopwatch.elapsedTime() < byTi)
--[ 2019.11.07.12.44.45.582.0 ]--
r 38         while (stopwatch.elapsedTime() < byTim)
--[ 2019.11.07.12.44.45.681.0 ]--
r 38         while (stopwatch.elapsedTime() < byTime)
--[ 2019.11.07.12.44.46.384.0 ]--
r 38         while (stopwatch.elapsedTime() < byTime) 
--[ 2019.11.07.12.44.46.492.0 ]--
r 38         while (stopwatch.elapsedTime() < byTime) {
--[ 2019.11.07.12.44.47.000.0 ]--
+ 39 
+ 40 }
--[ 2019.11.07.12.44.47.124.0 ]--
r 40         }
--[ 2019.11.07.12.44.47.189.0 ]--
r 39             
--[ 2019.11.07.12.44.56.480.0 ]--
r 39             l
--[ 2019.11.07.12.44.57.536.0 ]--
r 39             loc = 
--[ 2019.11.07.12.44.57.683.0 ]--
r 39             loc = w
--[ 2019.11.07.12.44.57.774.0 ]--
r 39             loc = wa
--[ 2019.11.07.12.44.57.894.0 ]--
r 39             loc = wal
--[ 2019.11.07.12.44.57.991.0 ]--
r 39             loc = walk
--[ 2019.11.07.12.44.58.245.0 ]--
r 39             loc = walkP
--[ 2019.11.07.12.44.58.358.0 ]--
r 39             loc = walkPa
--[ 2019.11.07.12.44.58.425.0 ]--
r 39             loc = walkPat
--[ 2019.11.07.12.44.58.545.0 ]--
r 39             loc = walkPath
--[ 2019.11.07.12.44.58.726.0 ]--
r 39             loc = walkPath.
--[ 2019.11.07.12.44.58.892.0 ]--
r 39             loc = walkPath.d
--[ 2019.11.07.12.44.59.061.0 ]--
r 39             loc = walkPath.de
--[ 2019.11.07.12.44.59.219.0 ]--
r 39             loc = walkPath.deq
--[ 2019.11.07.12.44.59.320.0 ]--
r 39             loc = walkPath.dequ
--[ 2019.11.07.12.44.59.394.0 ]--
r 39             loc = walkPath.deque
--[ 2019.11.07.12.44.59.476.0 ]--
r 39             loc = walkPath.dequeu
--[ 2019.11.07.12.44.59.544.0 ]--
r 39             loc = walkPath.dequeue
--[ 2019.11.07.12.44.59.843.0 ]--
r 39             loc = walkPath.dequeue()
--[ 2019.11.07.12.45.00.309.0 ]--
r 39             loc = walkPath.dequeue();
--[ 2019.11.07.12.45.03.426.0 ]--
- 41
- 41
r 41 
--[ 2019.11.07.12.45.03.545.0 ]--
- 41
--[ 2019.11.07.12.45.10.925.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.07.13.04.47.149.0 ]--
r 38         /while (stopwatch.elapsedTime() < byTime) {
--[ 2019.11.07.13.04.48.045.0 ]--
r 38         //while (stopwatch.elapsedTime() < byTime) {
--[ 2019.11.07.13.04.49.493.0 ]--
r 40         /}
--[ 2019.11.07.13.04.49.663.0 ]--
r 40         //}
--[ 2019.11.07.13.05.03.491.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.07.13.05.04.808.0 ]--
r 48     private final static String emapFilename = emaps[0];        // change index to load a different elevation map
--[ 2019.11.07.13.05.10.522.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.07.14.51.16.738.0 ]--
DisposeComponent
--[ 2019.11.09.13.24.40.794.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.11.09.13.24.40.924.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml

--[ 2019.11.09.13.24.40.928.0 ]--
InitFile: /.cos265


--[ 2019.11.09.13.24.40.932.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.11.09.13.24.40.936.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.11.09.13.24.40.940.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        public Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null)  this.cost = 0.0f;
                else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.computeDistance(loc, end);
            }
        }

        public float getCost(float heuristic) {
            return cost;
        }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        Stopwatch stopwatch = new Stopwatch();
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            if (currentLoc.getI() == getPathEnd().getI() && currentLoc.getJ() == getPathEnd().getJ()) {
                pathFound = true;
                endNode = currentNode;
                break;
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            atStart = false;
        }
        StdOut.println("stopwatch: " + stopwatch.elapsedTime());
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(h);
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        Stack<Coord> s = new Stack<>();
        PFNode c = endNode;
        while (c != null) {
            s.push(c.getLoc());
            c = c.fromNode;
        }
        return s;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2019.11.09.13.24.40.944.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> walkPath;
    Coord loc;
    Terrain terrain;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        walkPath = new Queue<>();
        for (Coord c : path) {
            this.walkPath.enqueue(c);
        }
        this.loc = this.walkPath.dequeue();
        this.terrain = terrain;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return walkPath.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        Stopwatch stopwatch = new Stopwatch();
        //while (stopwatch.elapsedTime() < byTime) {
            loc = walkPath.dequeue();
        //}
    }

}

--[ 2019.11.09.13.24.40.948.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.11.09.13.24.40.951.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.11.09.13.24.40.955.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[0];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.11.09.13.24.40.959.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.09.13.24.44.289.0 ]--
UpdateTree (AD): 1 0
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.13.28.13.304.0 ]--
:/src/Walker.java
+ 38         
--[ 2019.11.09.13.28.14.072.0 ]--
r 38         l
--[ 2019.11.09.13.28.14.229.0 ]--
r 38         lo
--[ 2019.11.09.13.28.14.291.0 ]--
r 38         loc
--[ 2019.11.09.13.28.14.463.0 ]--
r 38         loc 
--[ 2019.11.09.13.28.15.011.0 ]--
r 38         loc =
--[ 2019.11.09.13.28.15.301.0 ]--
r 38         loc = 
--[ 2019.11.09.13.28.15.704.0 ]--
r 38         loc = p
--[ 2019.11.09.13.28.15.782.0 ]--
r 38         loc = pa
--[ 2019.11.09.13.28.15.860.0 ]--
r 38         loc = pat
--[ 2019.11.09.13.28.15.923.0 ]--
r 38         loc = path
--[ 2019.11.09.13.28.16.158.0 ]--
r 38         loc = path.
--[ 2019.11.09.13.28.16.273.0 ]--
r 38         loc = path.n
--[ 2019.11.09.13.28.16.348.0 ]--
r 38         loc = path.ne
--[ 2019.11.09.13.28.16.584.0 ]--
r 38         loc = path.nex
--[ 2019.11.09.13.28.16.913.0 ]--
r 38         loc = path.next
--[ 2019.11.09.13.28.17.416.0 ]--
r 38         loc = path.next()
--[ 2019.11.09.13.28.17.683.0 ]--
r 38         loc = path.next();
--[ 2019.11.09.13.28.18.377.0 ]--
r 38         loc = path.next()
--[ 2019.11.09.13.28.18.832.0 ]--
r 38         loc = path.next(
--[ 2019.11.09.13.28.18.875.0 ]--
r 38         loc = path.next
--[ 2019.11.09.13.28.18.907.0 ]--
r 38         loc = path.nex
--[ 2019.11.09.13.28.18.938.0 ]--
r 38         loc = path.ne
--[ 2019.11.09.13.28.18.969.0 ]--
r 38         loc = path.n
--[ 2019.11.09.13.28.19.000.0 ]--
r 38         loc = path.
--[ 2019.11.09.13.28.19.032.0 ]--
r 38         loc = path
--[ 2019.11.09.13.28.19.079.0 ]--
r 38         loc = pat
--[ 2019.11.09.13.28.19.344.0 ]--
r 38         loc = pa
--[ 2019.11.09.13.28.19.547.0 ]--
r 38         loc = p
--[ 2019.11.09.13.28.19.722.0 ]--
r 38         loc = 
--[ 2019.11.09.13.28.20.065.0 ]--
r 38         loc = p
--[ 2019.11.09.13.28.20.223.0 ]--
r 38         loc = pa
--[ 2019.11.09.13.28.20.297.0 ]--
r 38         loc = pat
--[ 2019.11.09.13.28.20.387.0 ]--
r 38         loc = path
--[ 2019.11.09.13.28.24.715.0 ]--
+ 10     
--[ 2019.11.09.13.28.27.521.0 ]--
r 10     I
--[ 2019.11.09.13.28.27.742.0 ]--
r 10     It
--[ 2019.11.09.13.28.27.789.0 ]--
r 10     Ite
--[ 2019.11.09.13.28.27.899.0 ]--
r 10     Iter
--[ 2019.11.09.13.28.28.071.0 ]--
r 10     Itera
--[ 2019.11.09.13.28.28.134.0 ]--
r 10     Iterab
--[ 2019.11.09.13.28.28.244.0 ]--
r 10     Iterabl
--[ 2019.11.09.13.28.28.354.0 ]--
r 10     Iterable
--[ 2019.11.09.13.28.28.698.0 ]--
r 10     Iterable<>
--[ 2019.11.09.13.28.28.980.0 ]--
r 10     Iterable<C>
--[ 2019.11.09.13.28.29.232.0 ]--
r 10     Iterable<Co>
--[ 2019.11.09.13.28.29.358.0 ]--
r 10     Iterable<Coo>
--[ 2019.11.09.13.28.29.436.0 ]--
r 10     Iterable<Coor>
--[ 2019.11.09.13.28.29.609.0 ]--
r 10     Iterable<Coord>
--[ 2019.11.09.13.28.29.995.0 ]--
r 10     Iterable<Coord> 
--[ 2019.11.09.13.28.30.121.0 ]--
r 10     Iterable<Coord> p
--[ 2019.11.09.13.28.30.261.0 ]--
r 10     Iterable<Coord> pa
--[ 2019.11.09.13.28.30.324.0 ]--
r 10     Iterable<Coord> pat
--[ 2019.11.09.13.28.30.402.0 ]--
r 10     Iterable<Coord> path
--[ 2019.11.09.13.28.30.497.0 ]--
r 10     Iterable<Coord> path;
--[ 2019.11.09.13.28.33.448.0 ]--
+ 22         
--[ 2019.11.09.13.28.33.922.0 ]--
r 22         t
--[ 2019.11.09.13.28.34.074.0 ]--
r 22         th
--[ 2019.11.09.13.28.34.121.0 ]--
r 22         thi
--[ 2019.11.09.13.28.34.247.0 ]--
r 22         this
--[ 2019.11.09.13.28.34.350.0 ]--
r 22         this.
--[ 2019.11.09.13.28.34.651.0 ]--
r 22         this.p
--[ 2019.11.09.13.28.34.798.0 ]--
r 22         this.pa
--[ 2019.11.09.13.28.35.059.0 ]--
r 22         this.path
--[ 2019.11.09.13.28.35.106.0 ]--
r 22         this.path 
--[ 2019.11.09.13.28.35.153.0 ]--
r 22         this.path =
--[ 2019.11.09.13.28.35.296.0 ]--
r 22         this.path = 
--[ 2019.11.09.13.28.35.492.0 ]--
r 22         this.path = p
--[ 2019.11.09.13.28.35.647.0 ]--
r 22         this.path = pa
--[ 2019.11.09.13.28.35.677.0 ]--
r 22         this.path = pat
--[ 2019.11.09.13.28.35.737.0 ]--
r 22         this.path = path
--[ 2019.11.09.13.28.35.852.0 ]--
r 22         this.path = path;
--[ 2019.11.09.13.28.39.569.0 ]--
r 40         loc = pat
--[ 2019.11.09.13.28.39.710.0 ]--
r 40         loc = pa
--[ 2019.11.09.13.28.39.883.0 ]--
r 40         loc = p
--[ 2019.11.09.13.28.40.024.0 ]--
r 40         loc = 
--[ 2019.11.09.13.28.40.607.0 ]--
r 40         loc = p
--[ 2019.11.09.13.28.40.785.0 ]--
r 40         loc = pa
--[ 2019.11.09.13.28.40.847.0 ]--
r 40         loc = pat
--[ 2019.11.09.13.28.40.942.0 ]--
r 40         loc = path
--[ 2019.11.09.13.28.41.327.0 ]--
r 40         loc = path.
--[ 2019.11.09.13.28.51.031.0 ]--
r 40         loc = path.n
--[ 2019.11.09.13.28.51.583.0 ]--
r 40         loc = path.ne
--[ 2019.11.09.13.28.51.883.0 ]--
r 40         loc = path.nex
--[ 2019.11.09.13.28.52.176.0 ]--
r 40         loc = path.next
--[ 2019.11.09.13.28.52.476.0 ]--
r 40         loc = path.nex
--[ 2019.11.09.13.28.52.979.0 ]--
r 40         loc = path.ne
--[ 2019.11.09.13.28.53.024.0 ]--
r 40         loc = path.n
--[ 2019.11.09.13.28.53.102.0 ]--
r 40         loc = path.
--[ 2019.11.09.13.28.53.149.0 ]--
r 40         loc = path
--[ 2019.11.09.13.28.53.196.0 ]--
r 40         loc = pa
--[ 2019.11.09.13.28.53.212.0 ]--
r 40         loc = 
--[ 2019.11.09.13.28.53.259.0 ]--
r 40         loc =
--[ 2019.11.09.13.28.53.275.0 ]--
r 40         loc 
--[ 2019.11.09.13.28.53.306.0 ]--
r 40         loc
--[ 2019.11.09.13.28.53.338.0 ]--
r 40         lo
--[ 2019.11.09.13.28.53.369.0 ]--
r 40         l
--[ 2019.11.09.13.28.53.731.0 ]--
r 40         
--[ 2019.11.09.13.28.54.093.0 ]--
- 40
--[ 2019.11.09.13.29.39.094.0 ]--
:/src/Pathfinder.java
r 155             if (c {
--[ 2019.11.09.13.29.39.353.0 ]--
r 155             if (cu {
--[ 2019.11.09.13.29.39.566.0 ]--
r 155             if (cur {
--[ 2019.11.09.13.29.40.367.0 ]--
r 155             if (curr {
--[ 2019.11.09.13.29.40.480.0 ]--
r 155             if (curre {
--[ 2019.11.09.13.29.40.612.0 ]--
r 155             if (curren {
--[ 2019.11.09.13.29.40.663.0 ]--
r 155             if (current {
--[ 2019.11.09.13.29.40.870.0 ]--
r 155             if (currentL {
--[ 2019.11.09.13.29.41.028.0 ]--
r 155             if (currentLo {
--[ 2019.11.09.13.29.41.138.0 ]--
r 155             if (currentLoc {
--[ 2019.11.09.13.29.41.233.0 ]--
r 155             if (currentLoc. {
--[ 2019.11.09.13.29.41.391.0 ]--
r 155             if (currentLoc.e {
--[ 2019.11.09.13.29.41.637.0 ]--
r 155             if (currentLoc.eq {
--[ 2019.11.09.13.29.41.773.0 ]--
r 155             if (currentLoc.equ {
--[ 2019.11.09.13.29.41.915.0 ]--
r 155             if (currentLoc.equa {
--[ 2019.11.09.13.29.41.977.0 ]--
r 155             if (currentLoc.equal {
--[ 2019.11.09.13.29.42.072.0 ]--
r 155             if (currentLoc.equals {
--[ 2019.11.09.13.29.42.325.0 ]--
r 155             if (currentLoc.equals() {
--[ 2019.11.09.13.29.43.370.0 ]--
r 155             if (currentLoc.equals(g) {
--[ 2019.11.09.13.29.43.401.0 ]--
r 155             if (currentLoc.equals(ge) {
--[ 2019.11.09.13.29.43.590.0 ]--
r 155             if (currentLoc.equals(get) {
--[ 2019.11.09.13.29.43.882.0 ]--
r 155             if (currentLoc.equals(getP) {
--[ 2019.11.09.13.29.44.063.0 ]--
r 155             if (currentLoc.equals(getPa) {
--[ 2019.11.09.13.29.44.142.0 ]--
r 155             if (currentLoc.equals(getPat) {
--[ 2019.11.09.13.29.44.204.0 ]--
r 155             if (currentLoc.equals(getPath) {
--[ 2019.11.09.13.29.44.645.0 ]--
r 155             if (currentLoc.equals(getPathE) {
--[ 2019.11.09.13.29.44.784.0 ]--
r 155             if (currentLoc.equals(getPathEn) {
--[ 2019.11.09.13.29.44.894.0 ]--
r 155             if (currentLoc.equals(getPathEnd) {
--[ 2019.11.09.13.29.45.210.0 ]--
r 155             if (currentLoc.equals(getPathEnd()) {
--[ 2019.11.09.13.29.45.307.0 ]--
r 155             if (currentLoc.equals(getPathEnd())) {
--[ 2019.11.09.13.40.30.981.0 ]--
:/src/Walker.java
+ 41         
--[ 2019.11.09.13.40.32.109.0 ]--
r 41         p
--[ 2019.11.09.13.40.32.312.0 ]--
r 41         pa
--[ 2019.11.09.13.40.32.359.0 ]--
r 41         pat
--[ 2019.11.09.13.40.32.390.0 ]--
r 41         path
--[ 2019.11.09.13.40.32.562.0 ]--
r 41         path.
--[ 2019.11.09.13.40.34.024.0 ]--
r 41         path.i
--[ 2019.11.09.13.40.34.067.0 ]--
r 41         path.it
--[ 2019.11.09.13.40.34.192.0 ]--
r 41         path.ite
--[ 2019.11.09.13.40.34.317.0 ]--
r 41         path.iter
--[ 2019.11.09.13.40.34.740.0 ]--
r 41         path.itera
--[ 2019.11.09.13.40.34.788.0 ]--
r 41         path.iterat
--[ 2019.11.09.13.40.34.888.0 ]--
r 41         path.iterato
--[ 2019.11.09.13.40.35.013.0 ]--
r 41         path.iterator
--[ 2019.11.09.13.40.35.342.0 ]--
r 41         path.iterator()
--[ 2019.11.09.13.40.35.800.0 ]--
r 41         path.iterator();
--[ 2019.11.09.13.40.47.411.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.13.45.28.936.0 ]--
+ 12     
--[ 2019.11.09.13.45.29.745.0 ]--
r 12     C
--[ 2019.11.09.13.45.30.041.0 ]--
r 12     Co
--[ 2019.11.09.13.45.30.135.0 ]--
r 12     Coo
--[ 2019.11.09.13.45.30.291.0 ]--
r 12     Coor
--[ 2019.11.09.13.45.30.432.0 ]--
r 12     Coord
--[ 2019.11.09.13.45.30.572.0 ]--
r 12     Coord 
--[ 2019.11.09.13.45.30.652.0 ]--
r 12     Coord p
--[ 2019.11.09.13.45.30.783.0 ]--
r 12     Coord pr
--[ 2019.11.09.13.45.30.877.0 ]--
r 12     Coord pre
--[ 2019.11.09.13.45.31.113.0 ]--
r 12     Coord prev
--[ 2019.11.09.13.45.31.381.0 ]--
r 12     Coord prevL
--[ 2019.11.09.13.45.31.530.0 ]--
r 12     Coord prevLo
--[ 2019.11.09.13.45.31.577.0 ]--
r 12     Coord prevLoc
--[ 2019.11.09.13.45.31.671.0 ]--
r 12     Coord prevLoc;
--[ 2019.11.09.13.45.54.655.0 ]--
+ 18         
--[ 2019.11.09.13.45.55.045.0 ]--
r 18         t
--[ 2019.11.09.13.45.55.171.0 ]--
r 18         th
--[ 2019.11.09.13.45.55.202.0 ]--
r 18         thi
--[ 2019.11.09.13.45.55.343.0 ]--
r 18         this
--[ 2019.11.09.13.45.55.421.0 ]--
r 18         this.
--[ 2019.11.09.13.45.55.689.0 ]--
r 18         this.p
--[ 2019.11.09.13.45.55.832.0 ]--
r 18         this.pa
--[ 2019.11.09.13.45.55.879.0 ]--
r 18         this.pat
--[ 2019.11.09.13.45.55.957.0 ]--
r 18         this.path
--[ 2019.11.09.13.45.56.067.0 ]--
r 18         this.path 
--[ 2019.11.09.13.45.56.160.0 ]--
r 18         this.path =
--[ 2019.11.09.13.45.56.254.0 ]--
r 18         this.path = 
--[ 2019.11.09.13.45.57.177.0 ]--
r 18         this.path = p
--[ 2019.11.09.13.45.57.256.0 ]--
r 18         this.path = pa
--[ 2019.11.09.13.45.57.334.0 ]--
r 18         this.path = pat
--[ 2019.11.09.13.45.57.365.0 ]--
r 18         this.path = path
--[ 2019.11.09.13.45.57.506.0 ]--
r 18         this.path = path;
--[ 2019.11.09.13.45.59.780.0 ]--
r 24 
--[ 2019.11.09.13.45.59.962.0 ]--
- 24
--[ 2019.11.09.13.46.14.261.0 ]--
r 21             /this.walkPath.enqueue(c);
--[ 2019.11.09.13.46.14.487.0 ]--
r 21             //this.walkPath.enqueue(c);
--[ 2019.11.09.13.46.19.402.0 ]--
r 43 
--[ 2019.11.09.13.46.19.552.0 ]--
- 43
--[ 2019.11.09.13.46.21.656.0 ]--
- 40
- 40
- 40
r 40 
--[ 2019.11.09.13.46.22.577.0 ]--
- 40
--[ 2019.11.09.13.46.23.006.0 ]--
+ 40         
--[ 2019.11.09.13.46.25.272.0 ]--
r 34 
--[ 2019.11.09.13.46.25.530.0 ]--
- 34
--[ 2019.11.09.13.46.25.844.0 ]--
+ 34         
--[ 2019.11.09.13.46.58.098.0 ]--
+ 22             
--[ 2019.11.09.13.46.58.905.0 ]--
r 22             l
--[ 2019.11.09.13.46.59.085.0 ]--
r 22             lo
--[ 2019.11.09.13.46.59.163.0 ]--
r 22             loc
--[ 2019.11.09.13.46.59.241.0 ]--
r 22             loc 
--[ 2019.11.09.13.46.59.368.0 ]--
r 22             loc =
--[ 2019.11.09.13.46.59.463.0 ]--
r 22             loc = 
--[ 2019.11.09.13.46.59.684.0 ]--
r 22             loc = p
--[ 2019.11.09.13.46.59.958.0 ]--
r 22             loc = pat
--[ 2019.11.09.13.46.59.990.0 ]--
r 22             loc = path
--[ 2019.11.09.13.47.00.099.0 ]--
r 22             loc = path;
--[ 2019.11.09.13.47.00.976.0 ]--
r 22             loc = path
--[ 2019.11.09.13.47.01.450.0 ]--
r 22             loc = pat
--[ 2019.11.09.13.47.01.486.0 ]--
r 22             loc = pa
--[ 2019.11.09.13.47.01.517.0 ]--
r 22             loc = p
--[ 2019.11.09.13.47.01.548.0 ]--
r 22             loc = 
--[ 2019.11.09.13.47.01.579.0 ]--
r 22             loc =
--[ 2019.11.09.13.47.01.611.0 ]--
r 22             loc 
--[ 2019.11.09.13.47.01.657.0 ]--
r 22             loc
--[ 2019.11.09.13.47.01.689.0 ]--
r 22             lo
--[ 2019.11.09.13.47.01.720.0 ]--
r 22             l
--[ 2019.11.09.13.47.01.751.0 ]--
r 22             
--[ 2019.11.09.13.47.02.254.0 ]--
- 22
--[ 2019.11.09.13.47.03.224.0 ]--
+ 23         
--[ 2019.11.09.13.47.03.855.0 ]--
r 23         l
--[ 2019.11.09.13.47.04.060.0 ]--
r 23         lo
--[ 2019.11.09.13.47.04.125.0 ]--
r 23         loc
--[ 2019.11.09.13.47.04.203.0 ]--
r 23         loc 
--[ 2019.11.09.13.47.04.312.0 ]--
r 23         loc =
--[ 2019.11.09.13.47.04.500.0 ]--
r 23         loc = 
--[ 2019.11.09.13.47.04.609.0 ]--
r 23         loc = p
--[ 2019.11.09.13.47.04.876.0 ]--
r 23         loc = pat
--[ 2019.11.09.13.47.04.926.0 ]--
r 23         loc = path
--[ 2019.11.09.13.47.05.130.0 ]--
r 23         loc = path.
--[ 2019.11.09.13.47.09.805.0 ]--
r 23         loc = path
--[ 2019.11.09.13.47.10.271.0 ]--
r 23         loc = pat
--[ 2019.11.09.13.47.10.302.0 ]--
r 23         loc = pa
--[ 2019.11.09.13.47.10.338.0 ]--
r 23         loc = p
--[ 2019.11.09.13.47.10.369.0 ]--
r 23         loc = 
--[ 2019.11.09.13.47.10.556.0 ]--
r 23         loc =
--[ 2019.11.09.13.47.10.760.0 ]--
r 23         loc 
--[ 2019.11.09.13.47.10.946.0 ]--
r 23         loc
--[ 2019.11.09.13.47.11.102.0 ]--
r 23         lo
--[ 2019.11.09.13.47.11.289.0 ]--
r 23         l
--[ 2019.11.09.13.47.11.444.0 ]--
r 23         
--[ 2019.11.09.13.47.11.758.0 ]--
- 23
--[ 2019.11.09.13.47.14.302.0 ]--
+ 22             
--[ 2019.11.09.13.47.15.897.0 ]--
r 22             p
--[ 2019.11.09.13.47.16.077.0 ]--
r 22             pa
--[ 2019.11.09.13.47.16.156.0 ]--
r 22             pat
--[ 2019.11.09.13.47.16.519.0 ]--
r 22             pa
--[ 2019.11.09.13.47.16.668.0 ]--
r 22             p
--[ 2019.11.09.13.47.16.841.0 ]--
r 22             
--[ 2019.11.09.13.47.17.264.0 ]--
r 22             t
--[ 2019.11.09.13.47.17.385.0 ]--
r 22             th
--[ 2019.11.09.13.47.17.463.0 ]--
r 22             thi
--[ 2019.11.09.13.47.17.526.0 ]--
r 22             this
--[ 2019.11.09.13.47.17.651.0 ]--
r 22             this.
--[ 2019.11.09.13.47.17.905.0 ]--
r 22             this.l
--[ 2019.11.09.13.47.18.037.0 ]--
r 22             this.lo
--[ 2019.11.09.13.47.18.123.0 ]--
r 22             this.loc
--[ 2019.11.09.13.47.18.224.0 ]--
r 22             this.loc 
--[ 2019.11.09.13.47.18.306.0 ]--
r 22             this.loc =
--[ 2019.11.09.13.47.18.400.0 ]--
r 22             this.loc = 
--[ 2019.11.09.13.47.18.538.0 ]--
r 22             this.loc = c
--[ 2019.11.09.13.47.18.618.0 ]--
r 22             this.loc = c;
--[ 2019.11.09.13.47.18.816.0 ]--
+ 23             
--[ 2019.11.09.13.47.19.211.0 ]--
r 23             t
--[ 2019.11.09.13.47.19.336.0 ]--
r 23             th
--[ 2019.11.09.13.47.19.383.0 ]--
r 23             thi
--[ 2019.11.09.13.47.19.493.0 ]--
r 23             this
--[ 2019.11.09.13.47.19.618.0 ]--
r 23             thisl
--[ 2019.11.09.13.47.19.853.0 ]--
r 23             thisl.
--[ 2019.11.09.13.47.20.102.0 ]--
r 23             thisl.o
--[ 2019.11.09.13.47.20.196.0 ]--
r 23             thisl.oc
--[ 2019.11.09.13.47.20.289.0 ]--
r 23             thisl.oc 
--[ 2019.11.09.13.47.20.869.0 ]--
r 23             thisl.oc
--[ 2019.11.09.13.47.21.040.0 ]--
r 23             thisl.o
--[ 2019.11.09.13.47.21.210.0 ]--
r 23             thisl.
--[ 2019.11.09.13.47.21.382.0 ]--
r 23             thisl
--[ 2019.11.09.13.47.21.553.0 ]--
r 23             this
--[ 2019.11.09.13.47.21.905.0 ]--
r 23             this.
--[ 2019.11.09.13.47.22.117.0 ]--
r 23             this.p
--[ 2019.11.09.13.47.22.201.0 ]--
r 23             this.pr
--[ 2019.11.09.13.47.22.304.0 ]--
r 23             this.pre
--[ 2019.11.09.13.47.22.520.0 ]--
r 23             this.prev
--[ 2019.11.09.13.47.22.712.0 ]--
r 23             this.prevLoc
--[ 2019.11.09.13.47.23.187.0 ]--
r 23             this.prevLoc 
--[ 2019.11.09.13.47.23.255.0 ]--
r 23             this.prevLoc =
--[ 2019.11.09.13.47.23.380.0 ]--
r 23             this.prevLoc = 
--[ 2019.11.09.13.47.23.552.0 ]--
r 23             this.prevLoc = c
--[ 2019.11.09.13.47.23.614.0 ]--
r 23             this.prevLoc = c;
--[ 2019.11.09.13.47.33.951.0 ]--
r 42         i
--[ 2019.11.09.13.47.34.232.0 ]--
r 42         if 
--[ 2019.11.09.13.47.34.295.0 ]--
r 42         if ()
--[ 2019.11.09.13.47.34.952.0 ]--
r 42         if (c)
--[ 2019.11.09.13.47.35.070.0 ]--
r 42         if (c.)
--[ 2019.11.09.13.47.35.289.0 ]--
r 42         if (c.e)
--[ 2019.11.09.13.47.35.447.0 ]--
r 42         if (c.eq)
--[ 2019.11.09.13.47.35.638.0 ]--
r 42         if (c.equ)
--[ 2019.11.09.13.47.35.748.0 ]--
r 42         if (c.equa)
--[ 2019.11.09.13.47.35.841.0 ]--
r 42         if (c.equal)
--[ 2019.11.09.13.47.35.967.0 ]--
r 42         if (c.equals)
--[ 2019.11.09.13.47.36.358.0 ]--
r 42         if (c.equal)
--[ 2019.11.09.13.47.36.858.0 ]--
r 42         if (c.equa)
--[ 2019.11.09.13.47.36.890.0 ]--
r 42         if (c.equ)
--[ 2019.11.09.13.47.36.936.0 ]--
r 42         if (c.e)
--[ 2019.11.09.13.47.36.977.0 ]--
r 42         if (c.)
--[ 2019.11.09.13.47.37.006.0 ]--
r 42         if (c)
--[ 2019.11.09.13.47.37.119.0 ]--
r 42         if ()
--[ 2019.11.09.13.47.37.645.0 ]--
r 42         if (l)
--[ 2019.11.09.13.47.37.811.0 ]--
r 42         if (lo)
--[ 2019.11.09.13.47.37.878.0 ]--
r 42         if (loc)
--[ 2019.11.09.13.47.38.021.0 ]--
r 42         if (loc.)
--[ 2019.11.09.13.47.38.138.0 ]--
r 42         if (loc.e)
--[ 2019.11.09.13.47.38.262.0 ]--
r 42         if (loc.eq)
--[ 2019.11.09.13.47.38.397.0 ]--
r 42         if (loc.equ)
--[ 2019.11.09.13.47.38.527.0 ]--
r 42         if (loc.equa)
--[ 2019.11.09.13.47.38.589.0 ]--
r 42         if (loc.equal)
--[ 2019.11.09.13.47.38.703.0 ]--
r 42         if (loc.equals)
--[ 2019.11.09.13.47.39.031.0 ]--
r 42         if (loc.equals())
--[ 2019.11.09.13.47.39.809.0 ]--
r 42         if (loc.equals(p))
--[ 2019.11.09.13.47.39.934.0 ]--
r 42         if (loc.equals(pr))
--[ 2019.11.09.13.47.39.998.0 ]--
r 42         if (loc.equals(pre))
--[ 2019.11.09.13.47.40.218.0 ]--
r 42         if (loc.equals(prev))
--[ 2019.11.09.13.47.40.438.0 ]--
r 42         if (loc.equals(prevL))
--[ 2019.11.09.13.47.40.595.0 ]--
r 42         if (loc.equals(prevLo))
--[ 2019.11.09.13.47.40.631.0 ]--
r 42         if (loc.equals(prevLoc))
--[ 2019.11.09.13.47.41.331.0 ]--
r 42         if (loc.equals(prevLoc)) 
--[ 2019.11.09.13.47.41.440.0 ]--
r 42         if (loc.equals(prevLoc)) {
--[ 2019.11.09.13.47.41.603.0 ]--
+ 43 
+ 44 }
--[ 2019.11.09.13.47.41.635.0 ]--
r 44         }
--[ 2019.11.09.13.47.41.666.0 ]--
r 43             
--[ 2019.11.09.14.01.05.905.0 ]--
:/src/InteractivePathfinderVisualizer.java
+ 56         
--[ 2019.11.09.14.01.06.892.0 ]--
r 56         i
--[ 2019.11.09.14.01.06.973.0 ]--
r 56         in
--[ 2019.11.09.14.01.07.068.0 ]--
r 56         int
--[ 2019.11.09.14.01.07.188.0 ]--
r 56         int 
--[ 2019.11.09.14.01.07.426.0 ]--
r 56         int M
--[ 2019.11.09.14.01.07.550.0 ]--
r 56         int M 
--[ 2019.11.09.14.01.07.715.0 ]--
r 56         int M =
--[ 2019.11.09.14.01.07.847.0 ]--
r 56         int M = 
--[ 2019.11.09.14.01.08.180.0 ]--
r 56         int M = 0
--[ 2019.11.09.14.01.08.378.0 ]--
r 56         int M = 0;
--[ 2019.11.09.14.01.16.379.0 ]--
+ 160                     
--[ 2019.11.09.14.01.16.640.0 ]--
r 160                     S
--[ 2019.11.09.14.01.16.906.0 ]--
r 160                     St
--[ 2019.11.09.14.01.17.062.0 ]--
r 160                     Std
--[ 2019.11.09.14.01.17.265.0 ]--
r 160                     StdO
--[ 2019.11.09.14.01.17.453.0 ]--
r 160                     StdOu
--[ 2019.11.09.14.01.17.564.0 ]--
r 160                     StdOut
--[ 2019.11.09.14.01.17.689.0 ]--
r 160                     StdOut.
--[ 2019.11.09.14.01.17.965.0 ]--
r 160                     StdOut.p
--[ 2019.11.09.14.01.18.056.0 ]--
r 160                     StdOut.pr
--[ 2019.11.09.14.01.18.157.0 ]--
r 160                     StdOut.pri
--[ 2019.11.09.14.01.18.322.0 ]--
r 160                     StdOut.prin
--[ 2019.11.09.14.01.18.394.0 ]--
r 160                     StdOut.print
--[ 2019.11.09.14.01.18.451.0 ]--
r 160                     StdOut.printl
--[ 2019.11.09.14.01.18.514.0 ]--
r 160                     StdOut.println
--[ 2019.11.09.14.01.18.860.0 ]--
r 160                     StdOut.println()
--[ 2019.11.09.14.01.19.289.0 ]--
r 160                     StdOut.println(M)
--[ 2019.11.09.14.01.19.589.0 ]--
r 160                     StdOut.println(M+)
--[ 2019.11.09.14.01.19.714.0 ]--
r 160                     StdOut.println(M++)
--[ 2019.11.09.14.01.19.980.0 ]--
r 160                     StdOut.println(M+)
--[ 2019.11.09.14.01.20.136.0 ]--
r 160                     StdOut.println(M)
--[ 2019.11.09.14.01.20.278.0 ]--
r 160                     StdOut.println()
--[ 2019.11.09.14.01.20.546.0 ]--
r 160                     StdOut.println(+)
--[ 2019.11.09.14.01.20.732.0 ]--
r 160                     StdOut.println(++)
--[ 2019.11.09.14.01.21.180.0 ]--
r 160                     StdOut.println(++M)
--[ 2019.11.09.14.01.21.747.0 ]--
r 160                     StdOut.println(++M);
--[ 2019.11.09.14.01.27.065.0 ]--
:/src/Walker.java
r 36 
r 43 
--[ 2019.11.09.14.01.28.548.0 ]--
UpdateTree (AD): 0 1
- /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.28.552.0 ]--
CompilationStatus (AEW): 0 1 0
[Ljava.lang.String;@2e652760
--[ 2019.11.09.14.01.33.307.0 ]--
r 36     
--[ 2019.11.09.14.01.33.317.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.33.335.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.33.451.0 ]--
r 36         
--[ 2019.11.09.14.01.33.459.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.33.469.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.34.100.0 ]--
r 36         r
--[ 2019.11.09.14.01.34.100.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.34.116.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.34.116.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.34.131.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.34.178.0 ]--
r 36         re
--[ 2019.11.09.14.01.34.178.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.34.194.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.34.681.0 ]--
r 36         ret
--[ 2019.11.09.14.01.34.696.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.34.712.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.34.837.0 ]--
r 36         retu
--[ 2019.11.09.14.01.34.837.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.34.853.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.34.962.0 ]--
r 36         retur
--[ 2019.11.09.14.01.34.978.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.34.978.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.35.040.0 ]--
r 36         return
--[ 2019.11.09.14.01.35.040.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.35.056.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.36.043.0 ]--
r 36         returnw
--[ 2019.11.09.14.01.36.058.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.36.090.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.36.199.0 ]--
r 36         returnwa
--[ 2019.11.09.14.01.36.199.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.36.215.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.36.246.0 ]--
r 36         returnwal
--[ 2019.11.09.14.01.36.261.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.36.261.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.36.308.0 ]--
r 36         returnwalk
--[ 2019.11.09.14.01.36.308.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.36.324.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.36.606.0 ]--
r 36         returnwalkp
--[ 2019.11.09.14.01.36.622.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.36.653.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.36.875.0 ]--
r 36         returnwalk
--[ 2019.11.09.14.01.36.884.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.36.893.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.37.048.0 ]--
r 36         returnwal
--[ 2019.11.09.14.01.37.060.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.37.080.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.37.203.0 ]--
r 36         returnwa
--[ 2019.11.09.14.01.37.387.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.37.411.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.37.429.0 ]--
r 36         returnw
--[ 2019.11.09.14.01.37.440.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.37.453.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.37.523.0 ]--
r 36         return
--[ 2019.11.09.14.01.37.531.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.37.541.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.37.780.0 ]--
r 36         return 
--[ 2019.11.09.14.01.37.788.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.37.801.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.37.862.0 ]--
r 36         return w
--[ 2019.11.09.14.01.37.873.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.37.882.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.37.891.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.37.961.0 ]--
r 36         return wa
--[ 2019.11.09.14.01.37.968.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.37.977.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.38.087.0 ]--
r 36         return wakl
--[ 2019.11.09.14.01.38.105.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.38.115.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.38.819.0 ]--
r 36         return wak
--[ 2019.11.09.14.01.38.864.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.38.877.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.38.956.0 ]--
r 36         return wa
--[ 2019.11.09.14.01.38.971.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.38.987.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.39.644.0 ]--
r 36         return w
--[ 2019.11.09.14.01.39.691.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.39.715.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.39.810.0 ]--
r 36         return 
--[ 2019.11.09.14.01.39.825.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.39.841.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.39.856.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.40.169.0 ]--
r 36         return t
--[ 2019.11.09.14.01.40.169.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.40.184.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.40.200.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.40.231.0 ]--
r 36         return th
--[ 2019.11.09.14.01.40.231.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.40.247.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.40.309.0 ]--
r 36         return thi
--[ 2019.11.09.14.01.40.309.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.40.325.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.40.388.0 ]--
r 36         return this
--[ 2019.11.09.14.01.40.388.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.40.403.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.40.497.0 ]--
r 36         return this.
--[ 2019.11.09.14.01.40.512.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.40.512.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.40.795.0 ]--
r 36         return this.p
--[ 2019.11.09.14.01.40.795.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.40.816.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.40.914.0 ]--
r 36         return this.pa
--[ 2019.11.09.14.01.40.914.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.40.930.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.40.961.0 ]--
r 36         return this.pat
--[ 2019.11.09.14.01.40.961.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.40.977.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.41.024.0 ]--
r 36         return this.path
--[ 2019.11.09.14.01.41.024.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.41.039.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.41.211.0 ]--
r 36         return this.path.
--[ 2019.11.09.14.01.41.235.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.41.257.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.41.272.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.41.491.0 ]--
r 36         return this.path.i
--[ 2019.11.09.14.01.41.507.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.41.522.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.41.587.0 ]--
r 36         return this.path.is
--[ 2019.11.09.14.01.41.596.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.41.601.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.41.853.0 ]--
r 36         return this.path.isE
--[ 2019.11.09.14.01.41.880.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.41.886.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.41.995.0 ]--
r 36         return this.path.isEm
--[ 2019.11.09.14.01.41.995.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.42.011.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.42.089.0 ]--
r 36         return this.path.isEmp
--[ 2019.11.09.14.01.42.089.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.42.105.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.42.167.0 ]--
r 36         return this.path.isEmpt
--[ 2019.11.09.14.01.42.183.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.42.198.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.42.292.0 ]--
r 36         return this.path.isEmpty
--[ 2019.11.09.14.01.42.308.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.42.308.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.42.559.0 ]--
r 36         return this.path.isEmpty()
--[ 2019.11.09.14.01.42.573.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.42.578.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.42.890.0 ]--
r 36         return this.path.isEmpty();
--[ 2019.11.09.14.01.42.906.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.42.921.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.48.156.0 ]--
r 19         t = new Queue<>();
--[ 2019.11.09.14.01.48.305.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.48.320.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.48.344.0 ]--
r 19         thi = new Queue<>();
--[ 2019.11.09.14.01.48.353.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.48.362.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.48.379.0 ]--
r 19         this = new Queue<>();
--[ 2019.11.09.14.01.48.379.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.48.395.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.48.473.0 ]--
r 19         this. = new Queue<>();
--[ 2019.11.09.14.01.48.473.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.48.489.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.48.710.0 ]--
r 19         this.p = new Queue<>();
--[ 2019.11.09.14.01.48.731.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.48.747.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.48.841.0 ]--
r 19         this.pa = new Queue<>();
--[ 2019.11.09.14.01.48.841.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.48.872.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.48.903.0 ]--
r 19         this.pat = new Queue<>();
--[ 2019.11.09.14.01.48.903.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.48.919.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.48.950.0 ]--
r 19         this.path = new Queue<>();
--[ 2019.11.09.14.01.48.950.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.48.966.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.51.361.0 ]--
r 18 
--[ 2019.11.09.14.01.51.408.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.51.427.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.51.429.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.51.445.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.51.476.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.51.476.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.51.492.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.51.508.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.51.508.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.51.523.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.51.523.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.51.539.0 ]--
- 18
--[ 2019.11.09.14.01.51.554.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.51.554.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.54.671.0 ]--
r 9     Queue<Coord> p;
--[ 2019.11.09.14.01.54.671.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.54.692.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.54.775.0 ]--
r 9     Queue<Coord> pa;
--[ 2019.11.09.14.01.54.775.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.54.790.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.54.822.0 ]--
r 9     Queue<Coord> pat;
--[ 2019.11.09.14.01.54.837.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.54.853.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.54.978.0 ]--
r 9     Queue<Coord> path;
--[ 2019.11.09.14.01.54.978.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.54.993.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.57.487.0 ]--
r 10 
--[ 2019.11.09.14.01.57.505.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.57.510.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.57.510.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.57.526.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.57.651.0 ]--
- 10
--[ 2019.11.09.14.01.57.666.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.57.682.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.59.470.0 ]--
r 23         this.loc = this.p.dequeue();
--[ 2019.11.09.14.01.59.626.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.59.642.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.59.694.0 ]--
r 23         this.loc = this.path.dequeue();
--[ 2019.11.09.14.01.59.709.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.01.59.709.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.06.282.0 ]--
r 23         this.loc = this.path.p();
--[ 2019.11.09.14.02.06.301.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.06.317.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.06.348.0 ]--
r 23         this.loc = this.path.pe();
--[ 2019.11.09.14.02.06.348.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.06.364.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.06.504.0 ]--
r 23         this.loc = this.path.pee();
--[ 2019.11.09.14.02.06.504.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.06.520.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.06.582.0 ]--
r 23         this.loc = this.path.peek();
--[ 2019.11.09.14.02.06.598.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.06.598.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.09.458.0 ]--
+ 24         
--[ 2019.11.09.14.02.09.489.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.09.582.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.09.911.0 ]--
r 24         t
--[ 2019.11.09.14.02.09.968.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.09.984.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.09.999.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.10.015.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.10.015.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.10.062.0 ]--
r 24         thi
--[ 2019.11.09.14.02.10.077.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.10.093.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.10.140.0 ]--
r 24         this
--[ 2019.11.09.14.02.10.140.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.10.156.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.10.249.0 ]--
r 24         this.
--[ 2019.11.09.14.02.10.249.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.10.265.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.10.533.0 ]--
r 24         this.p
--[ 2019.11.09.14.02.10.542.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.10.546.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.10.593.0 ]--
r 24         this.pr
--[ 2019.11.09.14.02.10.593.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.10.609.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.10.671.0 ]--
r 24         this.pre
--[ 2019.11.09.14.02.10.671.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.10.687.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.10.859.0 ]--
r 24         this.prev
--[ 2019.11.09.14.02.10.859.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.10.874.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.11.078.0 ]--
r 24         this.prevL
--[ 2019.11.09.14.02.11.078.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.11.093.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.11.250.0 ]--
r 24         this.prevLo
--[ 2019.11.09.14.02.11.265.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.11.281.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.11.312.0 ]--
r 24         this.prevLoc
--[ 2019.11.09.14.02.11.328.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.11.343.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.11.390.0 ]--
r 24         this.prevLoc 
--[ 2019.11.09.14.02.11.390.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.11.406.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.11.453.0 ]--
r 24         this.prevLoc =
--[ 2019.11.09.14.02.11.468.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.11.484.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.11.484.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.11.500.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.11.593.0 ]--
r 24         this.prevLoc = 
--[ 2019.11.09.14.02.11.609.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.11.640.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.11.781.0 ]--
r 24         this.prevLoc = t
--[ 2019.11.09.14.02.11.781.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.11.796.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.11.812.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.11.812.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.11.843.0 ]--
r 24         this.prevLoc = th
--[ 2019.11.09.14.02.11.859.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.11.874.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.11.906.0 ]--
r 24         this.prevLoc = thi
--[ 2019.11.09.14.02.11.921.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.11.921.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.11.984.0 ]--
r 24         this.prevLoc = this
--[ 2019.11.09.14.02.11.999.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.11.999.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.12.109.0 ]--
r 24         this.prevLoc = this.
--[ 2019.11.09.14.02.12.124.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.12.140.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.12.360.0 ]--
r 24         this.prevLoc = this.p
--[ 2019.11.09.14.02.12.360.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.12.391.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.12.476.0 ]--
r 24         this.prevLoc = this.pa
--[ 2019.11.09.14.02.12.492.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.12.508.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.12.539.0 ]--
r 24         this.prevLoc = this.pat
--[ 2019.11.09.14.02.12.539.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.12.570.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.12.602.0 ]--
r 24         this.prevLoc = this.path
--[ 2019.11.09.14.02.12.602.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.12.617.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.12.868.0 ]--
r 24         this.prevLoc = this.path.
--[ 2019.11.09.14.02.12.889.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.12.894.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.13.051.0 ]--
r 24         this.prevLoc = this.path.p
--[ 2019.11.09.14.02.13.066.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.13.066.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.13.082.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.13.144.0 ]--
r 24         this.prevLoc = this.path.pe
--[ 2019.11.09.14.02.13.160.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.13.160.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.13.316.0 ]--
r 24         this.prevLoc = this.path.pee
--[ 2019.11.09.14.02.13.316.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.13.347.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.13.394.0 ]--
r 24         this.prevLoc = this.path.peek
--[ 2019.11.09.14.02.13.410.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.13.426.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.13.739.0 ]--
r 24         this.prevLoc = this.path.peek()
--[ 2019.11.09.14.02.13.755.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.13.775.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.13.997.0 ]--
r 24         this.prevLoc = this.path.peek();
--[ 2019.11.09.14.02.14.012.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.14.027.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.19.211.0 ]--
r 19             /this.walkPath.enqueue(c);
--[ 2019.11.09.14.02.19.241.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.19.257.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.19.257.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.19.320.0 ]--
r 19             this.walkPath.enqueue(c);
--[ 2019.11.09.14.02.19.320.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.19.335.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.21.782.0 ]--
r 19             this.alkPath.enqueue(c);
--[ 2019.11.09.14.02.21.949.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.21.958.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.21.973.0 ]--
r 19             this.lkPath.enqueue(c);
--[ 2019.11.09.14.02.21.987.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.22.004.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.22.121.0 ]--
r 19             this.kPath.enqueue(c);
--[ 2019.11.09.14.02.22.129.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.22.138.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.22.288.0 ]--
r 19             this.Path.enqueue(c);
--[ 2019.11.09.14.02.22.305.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.22.318.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.22.660.0 ]--
r 19             this.ath.enqueue(c);
--[ 2019.11.09.14.02.22.668.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.22.676.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.23.461.0 ]--
r 19             this.path.enqueue(c);
--[ 2019.11.09.14.02.23.478.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.23.482.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.27.437.0 ]--
- 20
r 20 
--[ 2019.11.09.14.02.27.454.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.27.461.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.27.477.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.27.477.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.27.493.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.27.493.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.27.555.0 ]--
- 20
--[ 2019.11.09.14.02.27.555.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.27.571.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.33.975.0 ]--
- 39
- 40
--[ 2019.11.09.14.02.34.166.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.34.166.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.34.182.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.34.198.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.34.291.0 ]--
- 39
--[ 2019.11.09.14.02.34.307.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.34.323.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.34.893.0 ]--
+ 39         
--[ 2019.11.09.14.02.34.893.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.34.910.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.43.246.0 ]--
r 39         p
--[ 2019.11.09.14.02.43.262.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.43.277.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.43.296.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.43.302.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.43.365.0 ]--
r 39         pr
--[ 2019.11.09.14.02.43.365.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.43.380.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.43.443.0 ]--
r 39         pre
--[ 2019.11.09.14.02.43.443.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.43.458.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.43.664.0 ]--
r 39         prev
--[ 2019.11.09.14.02.43.691.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.43.706.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.43.911.0 ]--
r 39         prevL
--[ 2019.11.09.14.02.43.931.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.43.951.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.44.092.0 ]--
r 39         prevLo
--[ 2019.11.09.14.02.44.312.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.44.345.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.44.377.0 ]--
r 39         prevLoc 
--[ 2019.11.09.14.02.44.393.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.44.424.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.44.455.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.44.486.0 ]--
r 39         prevLoc =
--[ 2019.11.09.14.02.44.502.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.44.533.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.44.533.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.44.564.0 ]--
r 39         prevLoc = 
--[ 2019.11.09.14.02.44.580.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.44.596.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.45.113.0 ]--
r 39         prevLoc = p
--[ 2019.11.09.14.02.45.145.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.45.157.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.45.160.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.45.316.0 ]--
r 39         prevLoc = pa
--[ 2019.11.09.14.02.45.332.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.45.332.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.45.693.0 ]--
r 39         prevLoc = p
--[ 2019.11.09.14.02.45.715.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.45.734.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.45.844.0 ]--
r 39         prevLoc = 
--[ 2019.11.09.14.02.45.859.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.45.875.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.45.875.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.46.142.0 ]--
r 39         prevLoc = t
--[ 2019.11.09.14.02.46.157.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.46.189.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.46.204.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.46.283.0 ]--
r 39         prevLoc = thi
--[ 2019.11.09.14.02.46.298.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.46.298.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.46.361.0 ]--
r 39         prevLoc = this
--[ 2019.11.09.14.02.46.361.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.46.376.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.46.470.0 ]--
r 39         prevLoc = this.
--[ 2019.11.09.14.02.46.470.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.46.486.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.46.738.0 ]--
r 39         prevLoc = this.p
--[ 2019.11.09.14.02.46.738.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.46.769.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.46.832.0 ]--
r 39         prevLoc = this.pa
--[ 2019.11.09.14.02.46.852.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.46.872.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.46.950.0 ]--
r 39         prevLoc = this.pat
--[ 2019.11.09.14.02.46.950.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.46.965.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.46.997.0 ]--
r 39         prevLoc = this.path
--[ 2019.11.09.14.02.46.997.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.47.012.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.47.169.0 ]--
r 39         prevLoc = this.path.
--[ 2019.11.09.14.02.47.184.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.47.200.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.47.223.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.47.230.0 ]--
r 39         prevLoc = this.path.d
--[ 2019.11.09.14.02.47.245.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.47.277.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.47.481.0 ]--
r 39         prevLoc = this.path.de
--[ 2019.11.09.14.02.47.481.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.47.500.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.47.678.0 ]--
r 39         prevLoc = this.path.deq
--[ 2019.11.09.14.02.47.678.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.47.694.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.47.742.0 ]--
r 39         prevLoc = this.path.dequ
--[ 2019.11.09.14.02.47.765.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.47.770.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.47.848.0 ]--
r 39         prevLoc = this.path.deque
--[ 2019.11.09.14.02.47.863.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.47.879.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.47.897.0 ]--
r 39         prevLoc = this.path.dequeu
--[ 2019.11.09.14.02.47.913.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.47.929.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.48.007.0 ]--
r 39         prevLoc = this.path.dequeue
--[ 2019.11.09.14.02.48.007.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.48.022.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.48.350.0 ]--
r 39         prevLoc = this.path.dequeue()
--[ 2019.11.09.14.02.48.382.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.48.413.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.48.648.0 ]--
r 39         prevLoc = this.path.dequeue();
--[ 2019.11.09.14.02.48.648.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.48.664.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.48.892.0 ]--
+ 40         
--[ 2019.11.09.14.02.48.907.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.48.907.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.50.400.0 ]--
r 40         l
--[ 2019.11.09.14.02.50.415.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.50.431.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.50.448.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.50.452.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.50.657.0 ]--
r 40         loc
--[ 2019.11.09.14.02.50.678.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.50.685.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.50.764.0 ]--
r 40         loc 
--[ 2019.11.09.14.02.50.764.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.50.779.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.50.935.0 ]--
r 40         loc  
--[ 2019.11.09.14.02.50.951.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.50.967.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.51.312.0 ]--
r 40         loc 
--[ 2019.11.09.14.02.51.340.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.51.344.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.51.642.0 ]--
r 40         loc =
--[ 2019.11.09.14.02.51.664.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.51.670.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.51.670.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.51.780.0 ]--
r 40         loc = 
--[ 2019.11.09.14.02.51.795.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.51.842.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.52.315.0 ]--
r 40         loc = p
--[ 2019.11.09.14.02.52.323.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.52.333.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.52.342.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.52.457.0 ]--
r 40         loc = pa
--[ 2019.11.09.14.02.52.465.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.52.475.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.52.528.0 ]--
r 40         loc = pat
--[ 2019.11.09.14.02.52.536.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.52.545.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.52.583.0 ]--
r 40         loc = path
--[ 2019.11.09.14.02.52.591.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.52.599.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.53.054.0 ]--
r 40         loc = path.
--[ 2019.11.09.14.02.53.069.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.53.103.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.53.107.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.53.122.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.53.452.0 ]--
r 40         loc = path.p
--[ 2019.11.09.14.02.53.478.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.53.494.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.53.556.0 ]--
r 40         loc = path.pe
--[ 2019.11.09.14.02.53.556.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.53.587.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.53.697.0 ]--
r 40         loc = path.pee
--[ 2019.11.09.14.02.53.712.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.53.712.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.53.822.0 ]--
r 40         loc = path.peek
--[ 2019.11.09.14.02.53.837.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.53.837.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.54.211.0 ]--
r 40         loc = path.peek()
--[ 2019.11.09.14.02.54.384.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.54.399.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.54.438.0 ]--
r 40         loc = path.peek();
--[ 2019.11.09.14.02.54.438.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.54.454.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.56.495.0 ]--
r 39         prevLoc = thispath.dequeue();
--[ 2019.11.09.14.02.56.510.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.56.526.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.56.526.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.56.541.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.56.635.0 ]--
r 39         prevLoc = thipath.dequeue();
--[ 2019.11.09.14.02.56.635.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.56.651.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.56.823.0 ]--
r 39         prevLoc = thpath.dequeue();
--[ 2019.11.09.14.02.56.839.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.56.861.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.57.022.0 ]--
r 39         prevLoc = tpath.dequeue();
--[ 2019.11.09.14.02.57.022.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.57.037.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.57.210.0 ]--
r 39         prevLoc = path.dequeue();
--[ 2019.11.09.14.02.57.229.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.57.234.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.59.625.0 ]--
+ 41         
--[ 2019.11.09.14.02.59.625.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.02.59.641.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.07.732.0 ]--
- 41
--[ 2019.11.09.14.03.07.927.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.07.938.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.09.572.0 ]--
r 40         iloc = path.peek();
--[ 2019.11.09.14.03.09.598.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.09.603.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.09.681.0 ]--
r 40         ifloc = path.peek();
--[ 2019.11.09.14.03.09.697.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.09.713.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.09.744.0 ]--
r 40         if loc = path.peek();
--[ 2019.11.09.14.03.09.744.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.09.759.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.09.759.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.09.775.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.09.900.0 ]--
r 40         if (loc = path.peek();
--[ 2019.11.09.14.03.09.916.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.09.931.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.09.931.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.10.260.0 ]--
r 40         if (!loc = path.peek();
--[ 2019.11.09.14.03.10.270.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.10.276.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.10.511.0 ]--
r 40         if (!iloc = path.peek();
--[ 2019.11.09.14.03.10.511.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.10.534.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.10.618.0 ]--
r 40         if (!isloc = path.peek();
--[ 2019.11.09.14.03.10.633.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.10.664.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.10.900.0 ]--
r 40         if (!isEloc = path.peek();
--[ 2019.11.09.14.03.10.915.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.10.955.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.11.039.0 ]--
r 40         if (!isEmloc = path.peek();
--[ 2019.11.09.14.03.11.055.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.11.055.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.11.101.0 ]--
r 40         if (!isEmploc = path.peek();
--[ 2019.11.09.14.03.11.101.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.11.117.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.11.195.0 ]--
r 40         if (!isEmptloc = path.peek();
--[ 2019.11.09.14.03.11.211.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.11.211.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.11.336.0 ]--
r 40         if (!isEmptyloc = path.peek();
--[ 2019.11.09.14.03.11.336.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.11.351.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.12.309.0 ]--
r 40         if (!isEmptloc = path.peek();
--[ 2019.11.09.14.03.12.325.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.12.340.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.12.481.0 ]--
r 40         if (!isEmploc = path.peek();
--[ 2019.11.09.14.03.12.497.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.12.512.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.12.637.0 ]--
r 40         if (!isEmloc = path.peek();
--[ 2019.11.09.14.03.12.653.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.12.653.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.12.840.0 ]--
r 40         if (!isEloc = path.peek();
--[ 2019.11.09.14.03.12.856.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.12.871.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.13.012.0 ]--
r 40         if (!isloc = path.peek();
--[ 2019.11.09.14.03.13.028.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.13.028.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.13.199.0 ]--
r 40         if (!iloc = path.peek();
--[ 2019.11.09.14.03.13.199.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.13.215.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.13.371.0 ]--
r 40         if (!loc = path.peek();
--[ 2019.11.09.14.03.13.387.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.13.420.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.13.743.0 ]--
r 40         if (loc = path.peek();
--[ 2019.11.09.14.03.13.759.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.13.759.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.14.600.0 ]--
r 40         if (!loc = path.peek();
--[ 2019.11.09.14.03.14.615.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.14.615.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.15.009.0 ]--
r 40         if (!ploc = path.peek();
--[ 2019.11.09.14.03.15.024.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.15.024.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.15.182.0 ]--
r 40         if (!paloc = path.peek();
--[ 2019.11.09.14.03.15.192.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.15.198.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.15.245.0 ]--
r 40         if (!patloc = path.peek();
--[ 2019.11.09.14.03.15.245.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.15.261.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.15.308.0 ]--
r 40         if (!pathloc = path.peek();
--[ 2019.11.09.14.03.15.308.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.15.323.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.15.512.0 ]--
r 40         if (!path.loc = path.peek();
--[ 2019.11.09.14.03.15.529.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.15.545.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.15.545.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.15.561.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.15.733.0 ]--
r 40         if (!path.iloc = path.peek();
--[ 2019.11.09.14.03.15.733.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.15.748.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.15.811.0 ]--
r 40         if (!path.isloc = path.peek();
--[ 2019.11.09.14.03.15.811.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.15.826.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.16.096.0 ]--
r 40         if (!path.isEloc = path.peek();
--[ 2019.11.09.14.03.16.096.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.16.127.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.16.237.0 ]--
r 40         if (!path.isEmloc = path.peek();
--[ 2019.11.09.14.03.16.237.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.16.268.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.16.315.0 ]--
r 40         if (!path.isEmploc = path.peek();
--[ 2019.11.09.14.03.16.330.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.16.346.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.16.377.0 ]--
r 40         if (!path.isEmptloc = path.peek();
--[ 2019.11.09.14.03.16.393.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.16.408.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.16.518.0 ]--
r 40         if (!path.isEmptyloc = path.peek();
--[ 2019.11.09.14.03.16.533.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.16.549.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.16.902.0 ]--
r 40         if (!path.isEmpty(loc = path.peek();
--[ 2019.11.09.14.03.16.933.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.16.949.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.16.964.0 ]--
r 40         if (!path.isEmpty()loc = path.peek();
--[ 2019.11.09.14.03.16.964.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.16.980.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.16.995.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.16.995.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.17.136.0 ]--
r 40         if (!path.isEmpty())loc = path.peek();
--[ 2019.11.09.14.03.17.152.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.17.183.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.17.214.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.17.450.0 ]--
r 40         if (!path.isEmpty()) loc = path.peek();
--[ 2019.11.09.14.03.17.484.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.17.504.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.20.565.0 ]--
+ 41         
--[ 2019.11.09.14.03.20.768.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.20.784.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.20.987.0 ]--
r 41         e
--[ 2019.11.09.14.03.21.014.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.21.014.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.21.029.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.21.045.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.21.139.0 ]--
r 41         el
--[ 2019.11.09.14.03.21.139.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.21.154.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.21.248.0 ]--
r 41         els
--[ 2019.11.09.14.03.21.264.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.21.264.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.21.326.0 ]--
r 41         else
--[ 2019.11.09.14.03.21.326.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.21.342.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.21.342.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.21.357.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.21.420.0 ]--
r 41         else 
--[ 2019.11.09.14.03.21.436.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.21.451.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.21.576.0 ]--
r 41         else p
--[ 2019.11.09.14.03.21.607.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.21.607.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.21.623.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.21.906.0 ]--
r 41         else 
--[ 2019.11.09.14.03.21.916.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.21.927.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.21.937.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.22.123.0 ]--
r 41         else l
--[ 2019.11.09.14.03.22.146.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.22.157.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.22.180.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.22.326.0 ]--
r 41         else lo
--[ 2019.11.09.14.03.22.335.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.22.360.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.22.398.0 ]--
r 41         else loc
--[ 2019.11.09.14.03.22.422.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.22.432.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.22.478.0 ]--
r 41         else loc 
--[ 2019.11.09.14.03.22.487.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.22.501.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.22.582.0 ]--
r 41         else loc =
--[ 2019.11.09.14.03.22.594.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.22.620.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.22.634.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.22.670.0 ]--
r 41         else loc = 
--[ 2019.11.09.14.03.22.688.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.22.698.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.22.881.0 ]--
r 41         else loc = n
--[ 2019.11.09.14.03.22.897.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.22.897.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.22.918.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.23.130.0 ]--
r 41         else loc = nu
--[ 2019.11.09.14.03.23.146.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.23.180.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.23.282.0 ]--
r 41         else loc = nul
--[ 2019.11.09.14.03.23.297.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.23.297.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.23.409.0 ]--
r 41         else loc = null
--[ 2019.11.09.14.03.23.420.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.23.424.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.23.502.0 ]--
r 41         else loc = null;
--[ 2019.11.09.14.03.23.518.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.23.518.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.24.523.0 ]--
+ 42         
--[ 2019.11.09.14.03.24.538.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.24.538.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.29.187.0 ]--
- 42
--[ 2019.11.09.14.03.29.187.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.29.203.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.32.924.0 ]--
UpdateTree (AD): 1 0
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.03.32.928.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.14.05.38.829.0 ]--
r 22         this.n = this.path.peek();
--[ 2019.11.09.14.05.39.043.0 ]--
r 22         this.ne = this.path.peek();
--[ 2019.11.09.14.05.39.089.0 ]--
r 22         this.nex = this.path.peek();
--[ 2019.11.09.14.05.39.310.0 ]--
r 22         this.next = this.path.peek();
--[ 2019.11.09.14.05.39.513.0 ]--
r 22         this.nextL = this.path.peek();
--[ 2019.11.09.14.05.39.658.0 ]--
r 22         this.nextLo = this.path.peek();
--[ 2019.11.09.14.05.39.736.0 ]--
r 22         this.nextLoc = this.path.peek();
--[ 2019.11.09.14.05.42.780.0 ]--
r 11     Coord n;
--[ 2019.11.09.14.05.42.811.0 ]--
r 11     Coord ne;
--[ 2019.11.09.14.05.43.019.0 ]--
r 11     Coord nex;
--[ 2019.11.09.14.05.43.239.0 ]--
r 11     Coord next;
--[ 2019.11.09.14.05.43.547.0 ]--
r 11     Coord nextL;
--[ 2019.11.09.14.05.43.640.0 ]--
r 11     Coord nextLo;
--[ 2019.11.09.14.05.43.770.0 ]--
r 11     Coord nextLoc;
--[ 2019.11.09.14.05.46.712.0 ]--
r 39         l = path.dequeue();
--[ 2019.11.09.14.05.46.815.0 ]--
r 39         lo = path.dequeue();
--[ 2019.11.09.14.05.46.894.0 ]--
r 39         loc = path.dequeue();
--[ 2019.11.09.14.05.52.005.0 ]--
r 40         if (!path.isEmpty()) n = path.peek();
--[ 2019.11.09.14.05.52.254.0 ]--
r 40         if (!path.isEmpty()) nex = path.peek();
--[ 2019.11.09.14.05.52.463.0 ]--
r 40         if (!path.isEmpty()) next = path.peek();
--[ 2019.11.09.14.05.52.725.0 ]--
r 40         if (!path.isEmpty()) nextL = path.peek();
--[ 2019.11.09.14.05.52.883.0 ]--
r 40         if (!path.isEmpty()) nextLo = path.peek();
--[ 2019.11.09.14.05.52.945.0 ]--
r 40         if (!path.isEmpty()) nextLoc = path.peek();
--[ 2019.11.09.14.05.55.879.0 ]--
r 41         else n = null;
--[ 2019.11.09.14.05.55.988.0 ]--
r 41         else ne = null;
--[ 2019.11.09.14.05.56.190.0 ]--
r 41         else nex = null;
--[ 2019.11.09.14.05.56.390.0 ]--
r 41         else next = null;
--[ 2019.11.09.14.05.56.596.0 ]--
r 41         else nextL = null;
--[ 2019.11.09.14.05.56.755.0 ]--
r 41         else nextLo = null;
--[ 2019.11.09.14.05.56.833.0 ]--
r 41         else nextLoc = null;
--[ 2019.11.09.14.06.36.721.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.14.08.14.249.0 ]--
r 40         if (!path.isEmpty()) {nextLoc = path.peek();
--[ 2019.11.09.14.08.14.603.0 ]--
+ 40         if (!path.isEmpty()) {
+ 41 nextLoc = path.peek();
r 42 }
--[ 2019.11.09.14.08.14.619.0 ]--
r 41             nextLoc = path.peek();
r 42         }
--[ 2019.11.09.14.08.16.933.0 ]--
+ 42             
--[ 2019.11.09.14.11.56.009.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.09.14.11.56.845.0 ]--
r 48     private final static String emapFilename = emaps[7];        // change index to load a different elevation map
--[ 2019.11.09.14.11.58.739.0 ]--
:/src/Walker.java
r 42 
--[ 2019.11.09.14.12.00.254.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.14.12.46.940.0 ]--
:/src/InteractivePathfinderVisualizer.java
+ 158                     
--[ 2019.11.09.14.12.47.323.0 ]--
r 158                     M
--[ 2019.11.09.14.12.47.533.0 ]--
r 158                     M 
--[ 2019.11.09.14.12.47.643.0 ]--
r 158                     M =
--[ 2019.11.09.14.12.47.737.0 ]--
r 158                     M = 
--[ 2019.11.09.14.12.47.830.0 ]--
r 158                     M = 0
--[ 2019.11.09.14.12.48.077.0 ]--
r 158                     M = 0;
--[ 2019.11.09.14.12.52.683.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.14.13.12.225.0 ]--
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.09.14.13.13.137.0 ]--
r 48     private final static String emapFilename = emaps[8];        // change index to load a different elevation map
--[ 2019.11.09.14.13.16.673.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.14.13.58.007.0 ]--
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.09.14.13.58.769.0 ]--
r 48     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2019.11.09.14.13.58.843.0 ]--
r 48     private final static String emapFilename = emaps[12];        // change index to load a different elevation map
--[ 2019.11.09.14.13.59.079.0 ]--
r 48     private final static String emapFilename = emaps[128];        // change index to load a different elevation map
--[ 2019.11.09.14.14.01.322.0 ]--
r 48     private final static String emapFilename = emaps[12];        // change index to load a different elevation map
--[ 2019.11.09.14.14.01.424.0 ]--
r 48     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2019.11.09.14.14.01.613.0 ]--
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.09.14.14.02.516.0 ]--
r 48     private final static String emapFilename = emaps[9];        // change index to load a different elevation map
--[ 2019.11.09.14.14.04.985.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.14.23.25.341.0 ]--
:/src/Walker.java
+ 39         
--[ 2019.11.09.14.23.26.091.0 ]--
r 39         /
--[ 2019.11.09.14.23.26.232.0 ]--
r 39         //
--[ 2019.11.09.14.23.26.513.0 ]--
r 39         // 
--[ 2019.11.09.14.23.27.075.0 ]--
r 39         // I
--[ 2019.11.09.14.23.27.138.0 ]--
r 39         // I 
--[ 2019.11.09.14.23.27.388.0 ]--
r 39         // I T
--[ 2019.11.09.14.23.27.481.0 ]--
r 39         // I TH
--[ 2019.11.09.14.23.27.544.0 ]--
r 39         // I THI
--[ 2019.11.09.14.23.27.653.0 ]--
r 39         // I THIN
--[ 2019.11.09.14.23.27.731.0 ]--
r 39         // I THINK
--[ 2019.11.09.14.23.28.449.0 ]--
r 39         // I THINK 
--[ 2019.11.09.14.23.28.593.0 ]--
r 39         // I THINK t
--[ 2019.11.09.14.23.28.697.0 ]--
r 39         // I THINK th
--[ 2019.11.09.14.23.28.745.0 ]--
r 39         // I THINK thi
--[ 2019.11.09.14.23.28.841.0 ]--
r 39         // I THINK this
--[ 2019.11.09.14.23.28.987.0 ]--
r 39         // I THINK this 
--[ 2019.11.09.14.23.29.160.0 ]--
r 39         // I THINK this m
--[ 2019.11.09.14.23.29.255.0 ]--
r 39         // I THINK this me
--[ 2019.11.09.14.23.29.348.0 ]--
r 39         // I THINK this mea
--[ 2019.11.09.14.23.29.426.0 ]--
r 39         // I THINK this mean
--[ 2019.11.09.14.23.29.583.0 ]--
r 39         // I THINK this means
--[ 2019.11.09.14.23.29.850.0 ]--
r 39         // I THINK this means:
--[ 2019.11.09.14.23.29.954.0 ]--
r 39         // I THINK this means: 
--[ 2019.11.09.14.23.45.565.0 ]--
r 39         // I THINK this means: m
--[ 2019.11.09.14.23.45.799.0 ]--
r 39         // I THINK this means: mov
--[ 2019.11.09.14.23.45.862.0 ]--
r 39         // I THINK this means: move
--[ 2019.11.09.14.23.45.924.0 ]--
r 39         // I THINK this means: move 
--[ 2019.11.09.14.23.46.002.0 ]--
r 39         // I THINK this means: move w
--[ 2019.11.09.14.23.46.096.0 ]--
r 39         // I THINK this means: move wa
--[ 2019.11.09.14.23.46.174.0 ]--
r 39         // I THINK this means: move wal
--[ 2019.11.09.14.23.46.268.0 ]--
r 39         // I THINK this means: move walk
--[ 2019.11.09.14.23.46.377.0 ]--
r 39         // I THINK this means: move walke
--[ 2019.11.09.14.23.46.471.0 ]--
r 39         // I THINK this means: move walker
--[ 2019.11.09.14.23.46.549.0 ]--
r 39         // I THINK this means: move walker 
--[ 2019.11.09.14.23.46.690.0 ]--
r 39         // I THINK this means: move walker a
--[ 2019.11.09.14.23.46.799.0 ]--
r 39         // I THINK this means: move walker as
--[ 2019.11.09.14.23.46.877.0 ]--
r 39         // I THINK this means: move walker as 
--[ 2019.11.09.14.23.47.018.0 ]--
r 39         // I THINK this means: move walker as m
--[ 2019.11.09.14.23.47.143.0 ]--
r 39         // I THINK this means: move walker as ma
--[ 2019.11.09.14.23.47.205.0 ]--
r 39         // I THINK this means: move walker as man
--[ 2019.11.09.14.23.47.464.0 ]--
r 39         // I THINK this means: move walker as many
--[ 2019.11.09.14.23.47.604.0 ]--
r 39         // I THINK this means: move walker as many 
--[ 2019.11.09.14.23.48.242.0 ]--
r 39         // I THINK this means: move walker as many p
--[ 2019.11.09.14.23.48.345.0 ]--
r 39         // I THINK this means: move walker as many po
--[ 2019.11.09.14.23.48.491.0 ]--
r 39         // I THINK this means: move walker as many pos
--[ 2019.11.09.14.23.48.631.0 ]--
r 39         // I THINK this means: move walker as many posi
--[ 2019.11.09.14.23.48.710.0 ]--
r 39         // I THINK this means: move walker as many posit
--[ 2019.11.09.14.23.48.771.0 ]--
r 39         // I THINK this means: move walker as many positi
--[ 2019.11.09.14.23.48.896.0 ]--
r 39         // I THINK this means: move walker as many positio
--[ 2019.11.09.14.23.48.943.0 ]--
r 39         // I THINK this means: move walker as many position
--[ 2019.11.09.14.23.49.037.0 ]--
r 39         // I THINK this means: move walker as many positions
--[ 2019.11.09.14.23.49.193.0 ]--
r 39         // I THINK this means: move walker as many positions 
--[ 2019.11.09.14.23.49.380.0 ]--
r 39         // I THINK this means: move walker as many positions a
--[ 2019.11.09.14.23.49.444.0 ]--
r 39         // I THINK this means: move walker as many positions as
--[ 2019.11.09.14.23.49.635.0 ]--
r 39         // I THINK this means: move walker as many positions as 
--[ 2019.11.09.14.23.49.776.0 ]--
r 39         // I THINK this means: move walker as many positions as p
--[ 2019.11.09.14.23.49.870.0 ]--
r 39         // I THINK this means: move walker as many positions as po
--[ 2019.11.09.14.23.50.074.0 ]--
r 39         // I THINK this means: move walker as many positions as pos
--[ 2019.11.09.14.23.50.275.0 ]--
r 39         // I THINK this means: move walker as many positions as poss
--[ 2019.11.09.14.23.50.384.0 ]--
r 39         // I THINK this means: move walker as many positions as possi
--[ 2019.11.09.14.23.50.493.0 ]--
r 39         // I THINK this means: move walker as many positions as possib
--[ 2019.11.09.14.23.50.587.0 ]--
r 39         // I THINK this means: move walker as many positions as possibl
--[ 2019.11.09.14.23.50.728.0 ]--
r 39         // I THINK this means: move walker as many positions as possible
--[ 2019.11.09.14.23.50.837.0 ]--
r 39         // I THINK this means: move walker as many positions as possible 
--[ 2019.11.09.14.23.54.830.0 ]--
r 39         // I THINK this means: move walker as many positions as possible b
--[ 2019.11.09.14.23.55.095.0 ]--
r 39         // I THINK this means: move walker as many positions as possible be
--[ 2019.11.09.14.23.55.137.0 ]--
r 39         // I THINK this means: move walker as many positions as possible bef
--[ 2019.11.09.14.23.55.308.0 ]--
r 39         // I THINK this means: move walker as many positions as possible befo
--[ 2019.11.09.14.23.55.433.0 ]--
r 39         // I THINK this means: move walker as many positions as possible befor
--[ 2019.11.09.14.23.55.529.0 ]--
r 39         // I THINK this means: move walker as many positions as possible before
--[ 2019.11.09.14.23.55.654.0 ]--
r 39         // I THINK this means: move walker as many positions as possible before 
--[ 2019.11.09.14.23.55.912.0 ]--
r 39         // I THINK this means: move walker as many positions as possible before th
--[ 2019.11.09.14.23.55.990.0 ]--
r 39         // I THINK this means: move walker as many positions as possible before the
--[ 2019.11.09.14.23.56.130.0 ]--
r 39         // I THINK this means: move walker as many positions as possible before the 
--[ 2019.11.09.14.23.56.302.0 ]--
r 39         // I THINK this means: move walker as many positions as possible before the
--[ 2019.11.09.14.23.56.819.0 ]--
r 39         // I THINK this means: move walker as many positions as possible before th
--[ 2019.11.09.14.23.57.084.0 ]--
r 39         // I THINK this means: move walker as many positions as possible before t
--[ 2019.11.09.14.23.57.248.0 ]--
r 39         // I THINK this means: move walker as many positions as possible before 
--[ 2019.11.09.14.23.59.525.0 ]--
r 39         // I THINK this means: move walker as many positions as possible before b
--[ 2019.11.09.14.23.59.593.0 ]--
r 39         // I THINK this means: move walker as many positions as possible before by
--[ 2019.11.09.14.23.59.954.0 ]--
r 39         // I THINK this means: move walker as many positions as possible before byT
--[ 2019.11.09.14.24.00.185.0 ]--
r 39         // I THINK this means: move walker as many positions as possible before byTi
--[ 2019.11.09.14.24.00.247.0 ]--
r 39         // I THINK this means: move walker as many positions as possible before byTim
--[ 2019.11.09.14.24.00.325.0 ]--
r 39         // I THINK this means: move walker as many positions as possible before byTime
--[ 2019.11.09.14.24.00.434.0 ]--
r 39         // I THINK this means: move walker as many positions as possible before byTime 
--[ 2019.11.09.14.24.00.528.0 ]--
r 39         // I THINK this means: move walker as many positions as possible before byTime e
--[ 2019.11.09.14.24.00.700.0 ]--
r 39         // I THINK this means: move walker as many positions as possible before byTime ex
--[ 2019.11.09.14.24.00.779.0 ]--
r 39         // I THINK this means: move walker as many positions as possible before byTime exp
--[ 2019.11.09.14.24.00.916.0 ]--
r 39         // I THINK this means: move walker as many positions as possible before byTime expi
--[ 2019.11.09.14.24.01.041.0 ]--
r 39         // I THINK this means: move walker as many positions as possible before byTime expir
--[ 2019.11.09.14.24.01.103.0 ]--
r 39         // I THINK this means: move walker as many positions as possible before byTime expire
--[ 2019.11.09.14.24.01.181.0 ]--
r 39         // I THINK this means: move walker as many positions as possible before byTime expires
--[ 2019.11.09.14.24.02.115.0 ]--
+ 40         
--[ 2019.11.09.14.24.02.593.0 ]--
r 40         S
--[ 2019.11.09.14.24.02.828.0 ]--
r 40         St
--[ 2019.11.09.14.24.02.977.0 ]--
r 40         Std
--[ 2019.11.09.14.24.03.120.0 ]--
r 40         StdO
--[ 2019.11.09.14.24.03.318.0 ]--
r 40         StdOu
--[ 2019.11.09.14.24.03.443.0 ]--
r 40         StdOut
--[ 2019.11.09.14.24.03.533.0 ]--
r 40         StdOut.
--[ 2019.11.09.14.24.03.779.0 ]--
r 40         StdOut.p
--[ 2019.11.09.14.24.03.894.0 ]--
r 40         StdOut.pr
--[ 2019.11.09.14.24.04.161.0 ]--
r 40         StdOut.prin
--[ 2019.11.09.14.24.04.258.0 ]--
r 40         StdOut.print
--[ 2019.11.09.14.24.04.510.0 ]--
r 40         StdOut.print()
--[ 2019.11.09.14.24.04.778.0 ]--
r 40         StdOut.print(:)
--[ 2019.11.09.14.24.05.270.0 ]--
r 40         StdOut.print()
--[ 2019.11.09.14.24.05.520.0 ]--
r 40         StdOut.print("")
--[ 2019.11.09.14.24.05.723.0 ]--
r 40         StdOut.print("t")
--[ 2019.11.09.14.24.05.943.0 ]--
r 40         StdOut.print("tim")
--[ 2019.11.09.14.24.05.976.0 ]--
r 40         StdOut.print("time")
--[ 2019.11.09.14.24.06.085.0 ]--
r 40         StdOut.print("time:")
--[ 2019.11.09.14.24.06.274.0 ]--
r 40         StdOut.print("time: ")
--[ 2019.11.09.14.24.06.972.0 ]--
r 40         StdOut.print("time: " )
--[ 2019.11.09.14.24.07.187.0 ]--
r 40         StdOut.print("time: " +)
--[ 2019.11.09.14.24.07.296.0 ]--
r 40         StdOut.print("time: " + )
--[ 2019.11.09.14.24.07.451.0 ]--
r 40         StdOut.print("time: " + b)
--[ 2019.11.09.14.24.07.553.0 ]--
r 40         StdOut.print("time: " + by)
--[ 2019.11.09.14.24.07.796.0 ]--
r 40         StdOut.print("time: " + byT)
--[ 2019.11.09.14.24.07.930.0 ]--
r 40         StdOut.print("time: " + byTi)
--[ 2019.11.09.14.24.07.977.0 ]--
r 40         StdOut.print("time: " + byTim)
--[ 2019.11.09.14.24.08.089.0 ]--
r 40         StdOut.print("time: " + byTime)
--[ 2019.11.09.14.24.08.425.0 ]--
r 40         StdOut.print("time: " + byTime);
--[ 2019.11.09.14.24.12.781.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.14.24.53.826.0 ]--
r 40 
--[ 2019.11.09.14.24.54.033.0 ]--
- 40
--[ 2019.11.09.14.25.19.760.0 ]--
+ 40         
--[ 2019.11.09.14.25.27.780.0 ]--
r 40         f
--[ 2019.11.09.14.25.27.981.0 ]--
r 40         fl
--[ 2019.11.09.14.25.28.145.0 ]--
r 40         flo
--[ 2019.11.09.14.25.28.294.0 ]--
r 40         floa
--[ 2019.11.09.14.25.28.342.0 ]--
r 40         float
--[ 2019.11.09.14.25.28.625.0 ]--
r 40         float 
--[ 2019.11.09.14.25.29.118.0 ]--
r 40         float S
--[ 2019.11.09.14.25.29.404.0 ]--
r 40         float St
--[ 2019.11.09.14.25.29.483.0 ]--
r 40         float Sta
--[ 2019.11.09.14.25.29.597.0 ]--
r 40         float Star
--[ 2019.11.09.14.25.29.779.0 ]--
r 40         float Start
--[ 2019.11.09.14.25.29.886.0 ]--
r 40         float Start 
--[ 2019.11.09.14.25.30.007.0 ]--
r 40         float Start =
--[ 2019.11.09.14.25.30.074.0 ]--
r 40         float Start = 
--[ 2019.11.09.14.25.30.526.0 ]--
r 40         float Start = S
--[ 2019.11.09.14.25.30.893.0 ]--
r 40         float Start = Sys
--[ 2019.11.09.14.25.30.940.0 ]--
r 40         float Start = Syst
--[ 2019.11.09.14.25.31.032.0 ]--
r 40         float Start = Syste
--[ 2019.11.09.14.25.31.152.0 ]--
r 40         float Start = System
--[ 2019.11.09.14.25.31.358.0 ]--
r 40         float Start = System.
--[ 2019.11.09.14.25.31.556.0 ]--
r 40         float Start = System.c
--[ 2019.11.09.14.25.31.700.0 ]--
r 40         float Start = System.cu
--[ 2019.11.09.14.25.32.007.0 ]--
r 40         float Start = System.cur
--[ 2019.11.09.14.25.32.389.0 ]--
r 40         float Start = System.curr
--[ 2019.11.09.14.25.32.674.0 ]--
r 40         float Start = System.currentTimeMillis
--[ 2019.11.09.14.25.32.675.0 ]--
r 40         float Start = System.currentTimeMillis()
--[ 2019.11.09.14.25.33.649.0 ]--
r 40         float Start = System.currentTimeMillis();
--[ 2019.11.09.14.25.35.518.0 ]--
+ 41         
--[ 2019.11.09.14.25.37.685.0 ]--
r 41         f
--[ 2019.11.09.14.25.37.803.0 ]--
r 41         fl
--[ 2019.11.09.14.25.38.039.0 ]--
r 41         flo
--[ 2019.11.09.14.25.38.081.0 ]--
r 41         floa
--[ 2019.11.09.14.25.38.112.0 ]--
r 41         float
--[ 2019.11.09.14.25.38.293.0 ]--
r 41         float 
--[ 2019.11.09.14.25.38.490.0 ]--
r 41         float e
--[ 2019.11.09.14.25.38.586.0 ]--
r 41         float en
--[ 2019.11.09.14.25.38.689.0 ]--
r 41         float end
--[ 2019.11.09.14.25.38.753.0 ]--
r 41         float end 
--[ 2019.11.09.14.25.38.888.0 ]--
r 41         float end =
--[ 2019.11.09.14.25.38.955.0 ]--
r 41         float end = 
--[ 2019.11.09.14.25.39.244.0 ]--
r 41         float end = s
--[ 2019.11.09.14.25.39.312.0 ]--
r 41         float end = st
--[ 2019.11.09.14.25.39.452.0 ]--
r 41         float end = sta
--[ 2019.11.09.14.25.39.641.0 ]--
r 41         float end = st
--[ 2019.11.09.14.25.39.809.0 ]--
r 41         float end = s
--[ 2019.11.09.14.25.39.998.0 ]--
r 41         float end = 
--[ 2019.11.09.14.25.40.206.0 ]--
r 41         float end = s
--[ 2019.11.09.14.25.40.329.0 ]--
r 41         float end = st
--[ 2019.11.09.14.25.40.448.0 ]--
r 41         float end = sta
--[ 2019.11.09.14.25.40.574.0 ]--
r 41         float end = star
--[ 2019.11.09.14.25.40.738.0 ]--
r 41         float end = start
--[ 2019.11.09.14.25.40.841.0 ]--
r 41         float end = start 
--[ 2019.11.09.14.25.41.029.0 ]--
r 41         float end = start +
--[ 2019.11.09.14.25.41.135.0 ]--
r 41         float end = start + 
--[ 2019.11.09.14.25.41.904.0 ]--
r 41         float end = start + b
--[ 2019.11.09.14.25.42.010.0 ]--
r 41         float end = start + by
--[ 2019.11.09.14.25.42.272.0 ]--
r 41         float end = start + byT
--[ 2019.11.09.14.25.42.370.0 ]--
r 41         float end = start + byTi
--[ 2019.11.09.14.25.42.428.0 ]--
r 41         float end = start + byTim
--[ 2019.11.09.14.25.42.507.0 ]--
r 41         float end = start + byTime
--[ 2019.11.09.14.25.42.583.0 ]--
r 41         float end = start + byTime;
--[ 2019.11.09.14.25.44.186.0 ]--
r 40         float s = System.currentTimeMillis();
--[ 2019.11.09.14.25.44.287.0 ]--
r 40         float st = System.currentTimeMillis();
--[ 2019.11.09.14.25.44.372.0 ]--
r 40         float sta = System.currentTimeMillis();
--[ 2019.11.09.14.25.44.499.0 ]--
r 40         float star = System.currentTimeMillis();
--[ 2019.11.09.14.25.44.687.0 ]--
r 40         float start = System.currentTimeMillis();
--[ 2019.11.09.14.25.47.359.0 ]--
+ 42         
--[ 2019.11.09.14.25.48.477.0 ]--
r 42         w
--[ 2019.11.09.14.25.48.713.0 ]--
r 42         whi
--[ 2019.11.09.14.25.48.814.0 ]--
r 42         whil
--[ 2019.11.09.14.25.48.902.0 ]--
r 42         while
--[ 2019.11.09.14.25.48.987.0 ]--
r 42         while 
--[ 2019.11.09.14.25.49.178.0 ]--
r 42         while ()
--[ 2019.11.09.14.25.55.103.0 ]--
r 42         while (S)
--[ 2019.11.09.14.25.55.363.0 ]--
r 42         while (Sy)
--[ 2019.11.09.14.25.55.462.0 ]--
r 42         while (Sys)
--[ 2019.11.09.14.25.55.630.0 ]--
r 42         while (Syst)
--[ 2019.11.09.14.25.55.717.0 ]--
r 42         while (Syste)
--[ 2019.11.09.14.25.55.815.0 ]--
r 42         while (System)
--[ 2019.11.09.14.25.56.021.0 ]--
r 42         while (System.)
--[ 2019.11.09.14.25.56.150.0 ]--
r 42         while (System.c)
--[ 2019.11.09.14.25.56.270.0 ]--
r 42         while (System.cu)
--[ 2019.11.09.14.25.56.424.0 ]--
r 42         while (System.cur)
--[ 2019.11.09.14.25.56.567.0 ]--
r 42         while (System.curr)
--[ 2019.11.09.14.25.56.667.0 ]--
r 42         while (System.curre)
--[ 2019.11.09.14.25.56.833.0 ]--
r 42         while (System.curren)
--[ 2019.11.09.14.25.56.926.0 ]--
r 42         while (System.current)
--[ 2019.11.09.14.25.57.010.0 ]--
r 42         while (System.currentTimeMillis)
--[ 2019.11.09.14.25.57.016.0 ]--
r 42         while (System.currentTimeMillis())
--[ 2019.11.09.14.25.58.892.0 ]--
r 42         while (System.currentTimeMillis() )
--[ 2019.11.09.14.25.59.073.0 ]--
r 42         while (System.currentTimeMillis() <)
--[ 2019.11.09.14.25.59.121.0 ]--
r 42         while (System.currentTimeMillis() < )
--[ 2019.11.09.14.25.59.281.0 ]--
r 42         while (System.currentTimeMillis() < e)
--[ 2019.11.09.14.25.59.409.0 ]--
r 42         while (System.currentTimeMillis() < en)
--[ 2019.11.09.14.25.59.470.0 ]--
r 42         while (System.currentTimeMillis() < end)
--[ 2019.11.09.14.26.00.050.0 ]--
r 42         while (System.currentTimeMillis() < end);
--[ 2019.11.09.14.26.00.562.0 ]--
r 42         while (System.currentTimeMillis() < end)
--[ 2019.11.09.14.26.01.055.0 ]--
r 42         while (System.currentTimeMillis() < end) 
--[ 2019.11.09.14.26.01.255.0 ]--
r 42         while (System.currentTimeMillis() < end) }
--[ 2019.11.09.14.26.02.232.0 ]--
r 42         while (System.currentTimeMillis() < end) 
--[ 2019.11.09.14.26.02.530.0 ]--
r 42         while (System.currentTimeMillis() < end) {
--[ 2019.11.09.14.26.04.473.0 ]--
+ 49         
--[ 2019.11.09.14.26.05.347.0 ]--
r 49         }
--[ 2019.11.09.14.26.05.417.0 ]--
r 43             loc = path.dequeue();
--[ 2019.11.09.14.26.05.420.0 ]--
r 44             if (!path.isEmpty()) {
--[ 2019.11.09.14.26.05.446.0 ]--
r 45                 nextLoc = path.peek();
--[ 2019.11.09.14.26.05.458.0 ]--
r 47             }
--[ 2019.11.09.14.26.05.470.0 ]--
- 47
r 47             } else nextLoc = null;
--[ 2019.11.09.14.26.14.217.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.14.26.45.756.0 ]--
r 46     
--[ 2019.11.09.14.26.45.970.0 ]--
r 46         
--[ 2019.11.09.14.26.46.183.0 ]--
r 46             
--[ 2019.11.09.14.26.46.466.0 ]--
r 46                 
--[ 2019.11.09.14.26.46.768.0 ]--
r 46                     
--[ 2019.11.09.14.26.47.165.0 ]--
r 46                 
--[ 2019.11.09.14.26.47.370.0 ]--
- 46
--[ 2019.11.09.14.26.47.552.0 ]--
r 45                 nextLoc = path.peek()
--[ 2019.11.09.14.26.49.259.0 ]--
r 45                 nextLoc = path.peek();
--[ 2019.11.09.14.26.53.496.0 ]--
r 46             } else {nextLoc = null;
--[ 2019.11.09.14.26.53.625.0 ]--
r 46             } else { nextLoc = null;
--[ 2019.11.09.14.26.53.942.0 ]--
r 46             } else { bnextLoc = null;
--[ 2019.11.09.14.26.54.270.0 ]--
r 46             } else { brnextLoc = null;
--[ 2019.11.09.14.26.54.362.0 ]--
r 46             } else { brenextLoc = null;
--[ 2019.11.09.14.26.54.422.0 ]--
r 46             } else { breanextLoc = null;
--[ 2019.11.09.14.26.54.452.0 ]--
r 46             } else { breaknextLoc = null;
--[ 2019.11.09.14.26.54.554.0 ]--
r 46             } else { break;nextLoc = null;
--[ 2019.11.09.14.26.55.018.0 ]--
r 46             } else { break; nextLoc = null;
--[ 2019.11.09.14.26.55.987.0 ]--
r 46             } else { break; nextLoc = null; 
--[ 2019.11.09.14.26.56.173.0 ]--
r 46             } else { break; nextLoc = null; }
--[ 2019.11.09.14.27.03.093.0 ]--
r 46             } else { break; nextLoc = null; b}
--[ 2019.11.09.14.27.03.503.0 ]--
r 46             } else { break; nextLoc = null; br}
--[ 2019.11.09.14.27.03.552.0 ]--
r 46             } else { break; nextLoc = null; bre}
--[ 2019.11.09.14.27.03.636.0 ]--
r 46             } else { break; nextLoc = null; brea}
--[ 2019.11.09.14.27.03.679.0 ]--
r 46             } else { break; nextLoc = null; break}
--[ 2019.11.09.14.27.03.787.0 ]--
r 46             } else { break; nextLoc = null; break;}
--[ 2019.11.09.14.27.06.877.0 ]--
r 46             } else { nextLoc = null; break;}
--[ 2019.11.09.14.27.10.713.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.14.27.35.736.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 92             }e
--[ 2019.11.09.14.27.37.708.0 ]--
r 92             }
--[ 2019.11.09.14.28.41.377.0 ]--
:/src/Walker.java
+ 13     
--[ 2019.11.09.14.28.41.683.0 ]--
r 13     F
--[ 2019.11.09.14.28.41.869.0 ]--
r 13     Fl
--[ 2019.11.09.14.28.42.059.0 ]--
r 13     Flo
--[ 2019.11.09.14.28.42.136.0 ]--
r 13     Floa
--[ 2019.11.09.14.28.42.213.0 ]--
r 13     Float
--[ 2019.11.09.14.28.42.367.0 ]--
r 13     Float 
--[ 2019.11.09.14.28.42.457.0 ]--
r 13     Float c
--[ 2019.11.09.14.28.42.583.0 ]--
r 13     Float co
--[ 2019.11.09.14.28.42.738.0 ]--
r 13     Float cos
--[ 2019.11.09.14.28.42.807.0 ]--
r 13     Float cost
--[ 2019.11.09.14.28.42.896.0 ]--
r 13     Float cost;
--[ 2019.11.09.14.28.53.446.0 ]--
+ 44             
--[ 2019.11.09.14.28.57.733.0 ]--
+ 25         
--[ 2019.11.09.14.28.57.948.0 ]--
r 25         t
--[ 2019.11.09.14.28.58.000.0 ]--
r 25         th
--[ 2019.11.09.14.28.58.070.0 ]--
r 25         thi
--[ 2019.11.09.14.28.58.187.0 ]--
r 25         this
--[ 2019.11.09.14.28.58.266.0 ]--
r 25         this.
--[ 2019.11.09.14.28.58.465.0 ]--
r 25         this.c
--[ 2019.11.09.14.28.58.510.0 ]--
r 25         this.co
--[ 2019.11.09.14.28.58.641.0 ]--
r 25         this.cos
--[ 2019.11.09.14.28.58.734.0 ]--
r 25         this.cost
--[ 2019.11.09.14.28.58.818.0 ]--
r 25         this.cost 
--[ 2019.11.09.14.28.59.020.0 ]--
r 25         this.cost =
--[ 2019.11.09.14.28.59.159.0 ]--
r 25         this.cost = 
--[ 2019.11.09.14.28.59.356.0 ]--
r 25         this.cost = n
--[ 2019.11.09.14.28.59.640.0 ]--
r 25         this.cost = nu
--[ 2019.11.09.14.28.59.825.0 ]--
r 25         this.cost = nul
--[ 2019.11.09.14.28.59.941.0 ]--
r 25         this.cost = null
--[ 2019.11.09.14.29.00.050.0 ]--
r 25         this.cost = null;
--[ 2019.11.09.14.29.30.862.0 ]--
r 22         this.loc = this.path.d();
--[ 2019.11.09.14.29.31.040.0 ]--
r 22         this.loc = this.path.de();
--[ 2019.11.09.14.29.31.206.0 ]--
r 22         this.loc = this.path.deq();
--[ 2019.11.09.14.29.31.292.0 ]--
r 22         this.loc = this.path.dequ();
--[ 2019.11.09.14.29.31.396.0 ]--
r 22         this.loc = this.path.deque();
--[ 2019.11.09.14.29.31.445.0 ]--
r 22         this.loc = this.path.dequeu();
--[ 2019.11.09.14.29.31.559.0 ]--
r 22         this.loc = this.path.dequeue();
--[ 2019.11.09.14.30.43.662.0 ]--
r 45             c
--[ 2019.11.09.14.30.43.946.0 ]--
r 45             cos
--[ 2019.11.09.14.30.43.992.0 ]--
r 45             cost
--[ 2019.11.09.14.30.44.118.0 ]--
r 45             cost 
--[ 2019.11.09.14.30.44.255.0 ]--
r 45             cost =
--[ 2019.11.09.14.30.44.322.0 ]--
r 45             cost = 
--[ 2019.11.09.14.30.46.248.0 ]--
r 45             cost = t
--[ 2019.11.09.14.30.46.374.0 ]--
r 45             cost = te
--[ 2019.11.09.14.30.46.528.0 ]--
r 45             cost = ter
--[ 2019.11.09.14.30.46.676.0 ]--
r 45             cost = terr
--[ 2019.11.09.14.30.46.755.0 ]--
r 45             cost = terra
--[ 2019.11.09.14.30.46.813.0 ]--
r 45             cost = terrai
--[ 2019.11.09.14.30.46.898.0 ]--
r 45             cost = terrain
--[ 2019.11.09.14.30.47.079.0 ]--
r 45             cost = terrain.
--[ 2019.11.09.14.30.47.208.0 ]--
r 45             cost = terrain.c
--[ 2019.11.09.14.30.47.346.0 ]--
r 45             cost = terrain.co
--[ 2019.11.09.14.30.47.483.0 ]--
r 45             cost = terrain.com
--[ 2019.11.09.14.30.47.605.0 ]--
r 45             cost = terrain.comp
--[ 2019.11.09.14.30.47.736.0 ]--
r 45             cost = terrain.compu
--[ 2019.11.09.14.30.47.851.0 ]--
r 45             cost = terrain.comput
--[ 2019.11.09.14.30.47.929.0 ]--
r 45             cost = terrain.compute
--[ 2019.11.09.14.30.48.205.0 ]--
r 45             cost = terrain.computeC
--[ 2019.11.09.14.30.48.375.0 ]--
r 45             cost = terrain.computeCo
--[ 2019.11.09.14.30.48.480.0 ]--
r 45             cost = terrain.computeCos
--[ 2019.11.09.14.30.48.635.0 ]--
r 45             cost = terrain.computeCost
--[ 2019.11.09.14.30.48.905.0 ]--
r 45             cost = terrain.computeCost()
--[ 2019.11.09.14.30.49.193.0 ]--
r 45             cost = terrain.computeCost();
--[ 2019.11.09.14.30.51.445.0 ]--
r 45             cost = terrain.computeCost(l);
--[ 2019.11.09.14.30.51.612.0 ]--
r 45             cost = terrain.computeCost(lo);
--[ 2019.11.09.14.30.51.649.0 ]--
r 45             cost = terrain.computeCost(loc);
--[ 2019.11.09.14.30.51.840.0 ]--
r 45             cost = terrain.computeCost(loc,);
--[ 2019.11.09.14.30.51.943.0 ]--
r 45             cost = terrain.computeCost(loc, );
--[ 2019.11.09.14.30.52.075.0 ]--
r 45             cost = terrain.computeCost(loc, n);
--[ 2019.11.09.14.30.52.134.0 ]--
r 45             cost = terrain.computeCost(loc, ne);
--[ 2019.11.09.14.30.52.322.0 ]--
r 45             cost = terrain.computeCost(loc, nex);
--[ 2019.11.09.14.30.52.521.0 ]--
r 45             cost = terrain.computeCost(loc, next);
--[ 2019.11.09.14.30.52.740.0 ]--
r 45             cost = terrain.computeCost(loc, nextL);
--[ 2019.11.09.14.30.52.965.0 ]--
r 45             cost = terrain.computeCost(loc, nextLo);
--[ 2019.11.09.14.30.53.032.0 ]--
r 45             cost = terrain.computeCost(loc, nextLoc);
--[ 2019.11.09.14.31.41.335.0 ]--
r 45             cost = terrain.c(loc, nextLoc);
--[ 2019.11.09.14.31.41.453.0 ]--
r 45             cost = terrain.co(loc, nextLoc);
--[ 2019.11.09.14.31.41.531.0 ]--
r 45             cost = terrain.com(loc, nextLoc);
--[ 2019.11.09.14.31.41.703.0 ]--
r 45             cost = terrain.comp(loc, nextLoc);
--[ 2019.11.09.14.31.41.796.0 ]--
r 45             cost = terrain.compu(loc, nextLoc);
--[ 2019.11.09.14.31.41.921.0 ]--
r 45             cost = terrain.comput(loc, nextLoc);
--[ 2019.11.09.14.31.42.015.0 ]--
r 45             cost = terrain.compute(loc, nextLoc);
--[ 2019.11.09.14.31.42.510.0 ]--
r 45             cost = terrain.computeTravelCost(loc, nextLoc);
--[ 2019.11.09.14.32.05.992.0 ]--
+ 46             
--[ 2019.11.09.14.32.06.987.0 ]--
r 46             T
--[ 2019.11.09.14.32.07.233.0 ]--
r 46             Th
--[ 2019.11.09.14.32.07.357.0 ]--
r 46             Thr
--[ 2019.11.09.14.32.07.454.0 ]--
r 46             Thre
--[ 2019.11.09.14.32.07.530.0 ]--
r 46             Threa
--[ 2019.11.09.14.32.07.614.0 ]--
r 46             Thread
--[ 2019.11.09.14.32.07.770.0 ]--
r 46             Thread.
--[ 2019.11.09.14.32.07.918.0 ]--
r 46             Thread.s
--[ 2019.11.09.14.32.08.058.0 ]--
r 46             Thread.sl
--[ 2019.11.09.14.32.08.216.0 ]--
r 46             Thread.sle
--[ 2019.11.09.14.32.08.390.0 ]--
r 46             Thread.slee
--[ 2019.11.09.14.32.08.484.0 ]--
r 46             Thread.sleep
--[ 2019.11.09.14.32.08.970.0 ]--
r 46             Thread.sleep()
--[ 2019.11.09.14.32.09.714.0 ]--
r 46             Thread.sleep(c)
--[ 2019.11.09.14.32.09.782.0 ]--
r 46             Thread.sleep(co)
--[ 2019.11.09.14.32.09.939.0 ]--
r 46             Thread.sleep(cos)
--[ 2019.11.09.14.32.10.018.0 ]--
r 46             Thread.sleep(cost)
--[ 2019.11.09.14.32.10.411.0 ]--
r 46             Thread.sleep(cost);
--[ 2019.11.09.14.32.16.092.0 ]--
r 46             Thread.sleep((cost);
--[ 2019.11.09.14.32.16.372.0 ]--
r 46             Thread.sleep((lcost);
--[ 2019.11.09.14.32.16.592.0 ]--
r 46             Thread.sleep((locost);
--[ 2019.11.09.14.32.16.671.0 ]--
r 46             Thread.sleep((loncost);
--[ 2019.11.09.14.32.16.717.0 ]--
r 46             Thread.sleep((longcost);
--[ 2019.11.09.14.32.16.858.0 ]--
r 46             Thread.sleep((long)cost);
--[ 2019.11.09.14.32.16.999.0 ]--
r 46             Thread.sleep((long) cost);
--[ 2019.11.09.14.32.25.605.0 ]--
r 13     L cost;
--[ 2019.11.09.14.32.26.031.0 ]--
r 13     Lo cost;
--[ 2019.11.09.14.32.26.109.0 ]--
r 13     Lon cost;
--[ 2019.11.09.14.32.26.281.0 ]--
r 13     Long cost;
--[ 2019.11.09.14.32.26.462.0 ]--
r 13     Lon cost;
--[ 2019.11.09.14.32.26.651.0 ]--
r 13     Lo cost;
--[ 2019.11.09.14.32.26.835.0 ]--
r 13     L cost;
--[ 2019.11.09.14.32.26.976.0 ]--
r 13      cost;
--[ 2019.11.09.14.32.27.257.0 ]--
r 13     l cost;
--[ 2019.11.09.14.32.27.460.0 ]--
r 13     lo cost;
--[ 2019.11.09.14.32.27.536.0 ]--
r 13     lon cost;
--[ 2019.11.09.14.32.27.567.0 ]--
r 13     long cost;
--[ 2019.11.09.14.32.34.600.0 ]--
r 45             cost = terrain.computeTravelCost((loc, nextLoc);
--[ 2019.11.09.14.32.35.845.0 ]--
r 45             cost = terrain.computeTravelCost(loc, nextLoc);
--[ 2019.11.09.14.32.40.867.0 ]--
r 45             cost = (terrain.computeTravelCost(loc, nextLoc);
--[ 2019.11.09.14.32.41.267.0 ]--
r 45             cost = (lterrain.computeTravelCost(loc, nextLoc);
--[ 2019.11.09.14.32.41.455.0 ]--
r 45             cost = (loterrain.computeTravelCost(loc, nextLoc);
--[ 2019.11.09.14.32.41.504.0 ]--
r 45             cost = (lonterrain.computeTravelCost(loc, nextLoc);
--[ 2019.11.09.14.32.41.566.0 ]--
r 45             cost = (longterrain.computeTravelCost(loc, nextLoc);
--[ 2019.11.09.14.32.41.724.0 ]--
r 45             cost = (long)terrain.computeTravelCost(loc, nextLoc);
--[ 2019.11.09.14.32.41.827.0 ]--
r 45             cost = (long) terrain.computeTravelCost(loc, nextLoc);
--[ 2019.11.09.14.32.46.624.0 ]--
r 46             Thread.sleep((long cost);
--[ 2019.11.09.14.32.46.814.0 ]--
r 46             Thread.sleep((lon cost);
--[ 2019.11.09.14.32.47.017.0 ]--
r 46             Thread.sleep((lo cost);
--[ 2019.11.09.14.32.47.191.0 ]--
r 46             Thread.sleep((l cost);
--[ 2019.11.09.14.32.47.370.0 ]--
r 46             Thread.sleep(( cost);
--[ 2019.11.09.14.32.47.573.0 ]--
r 46             Thread.sleep( cost);
--[ 2019.11.09.14.32.48.552.0 ]--
r 46             Thread.sleep(cost);
--[ 2019.11.09.14.32.56.193.0 ]--
UpdateTree (AD): 0 1
- /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.32.56.193.1 ]--
CompilationStatus (AEW): 0 1 0
[Ljava.lang.String;@4557984a
--[ 2019.11.09.14.33.20.260.0 ]--
r 25         this.cost = ;
--[ 2019.11.09.14.33.20.486.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.33.20.517.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.33.20.517.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.33.20.579.0 ]--
r 25         this.cost =;
--[ 2019.11.09.14.33.20.595.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.33.20.595.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.33.20.658.0 ]--
r 25         this.cost ;
--[ 2019.11.09.14.33.20.658.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.33.20.673.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.33.20.689.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.33.21.081.0 ]--
r 25         this.cost;
--[ 2019.11.09.14.33.21.081.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.33.21.104.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.33.24.716.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.33.27.070.0 ]--
r 25 
--[ 2019.11.09.14.33.27.086.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.33.27.101.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.33.27.101.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.33.27.117.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.33.27.211.0 ]--
- 25
--[ 2019.11.09.14.33.27.211.1 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.33.27.226.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.33.30.284.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.36.43.212.0 ]--
r 44             c
--[ 2019.11.09.14.36.43.374.0 ]--
r 44             co
--[ 2019.11.09.14.36.43.530.0 ]--
r 44             cos
--[ 2019.11.09.14.36.43.639.0 ]--
r 44             cost
--[ 2019.11.09.14.36.43.733.0 ]--
r 44             cost 
--[ 2019.11.09.14.36.43.842.0 ]--
r 44             cost =
--[ 2019.11.09.14.36.43.998.0 ]--
r 44             cost = 
--[ 2019.11.09.14.36.44.139.0 ]--
r 44             cost = t
--[ 2019.11.09.14.36.44.280.0 ]--
r 44             cost = te
--[ 2019.11.09.14.36.44.589.0 ]--
r 44             cost = terr
--[ 2019.11.09.14.36.44.667.0 ]--
r 44             cost = terra
--[ 2019.11.09.14.36.44.682.0 ]--
r 44             cost = terrai
--[ 2019.11.09.14.36.44.745.0 ]--
r 44             cost = terrain
--[ 2019.11.09.14.36.44.932.0 ]--
r 44             cost = terrain.
--[ 2019.11.09.14.36.45.120.0 ]--
r 44             cost = terrain.c
--[ 2019.11.09.14.36.45.198.0 ]--
r 44             cost = terrain.co
--[ 2019.11.09.14.36.45.292.0 ]--
r 44             cost = terrain.com
--[ 2019.11.09.14.36.45.432.0 ]--
r 44             cost = terrain.comp
--[ 2019.11.09.14.36.45.557.0 ]--
r 44             cost = terrain.compu
--[ 2019.11.09.14.36.45.667.0 ]--
r 44             cost = terrain.comput
--[ 2019.11.09.14.36.45.745.0 ]--
r 44             cost = terrain.compute
--[ 2019.11.09.14.36.45.870.0 ]--
r 44             cost = terrain.computeTravelCost
--[ 2019.11.09.14.36.45.885.0 ]--
r 44             cost = terrain.computeTravelCost()
--[ 2019.11.09.14.36.46.705.0 ]--
r 44             cost = terrain.computeTravelCost(l)
--[ 2019.11.09.14.36.46.846.0 ]--
r 44             cost = terrain.computeTravelCost(lo)
--[ 2019.11.09.14.36.46.955.0 ]--
r 44             cost = terrain.computeTravelCost(loc)
--[ 2019.11.09.14.36.47.080.0 ]--
r 44             cost = terrain.computeTravelCost(loc,)
--[ 2019.11.09.14.36.47.189.0 ]--
r 44             cost = terrain.computeTravelCost(loc, )
--[ 2019.11.09.14.36.47.283.0 ]--
r 44             cost = terrain.computeTravelCost(loc, n)
--[ 2019.11.09.14.36.47.361.0 ]--
r 44             cost = terrain.computeTravelCost(loc, ne)
--[ 2019.11.09.14.36.47.629.0 ]--
r 44             cost = terrain.computeTravelCost(loc, nex)
--[ 2019.11.09.14.36.47.792.0 ]--
r 44             cost = terrain.computeTravelCost(loc, next)
--[ 2019.11.09.14.36.47.990.0 ]--
r 44             cost = terrain.computeTravelCost(loc, nextL)
--[ 2019.11.09.14.36.48.182.0 ]--
r 44             cost = terrain.computeTravelCost(loc, nextLo)
--[ 2019.11.09.14.36.48.227.0 ]--
r 44             cost = terrain.computeTravelCost(loc, nextLoc)
--[ 2019.11.09.14.36.53.402.0 ]--
r 13     f cost;
--[ 2019.11.09.14.36.53.730.0 ]--
r 13     fl cost;
--[ 2019.11.09.14.36.53.924.0 ]--
r 13     flo cost;
--[ 2019.11.09.14.36.54.009.0 ]--
r 13     floa cost;
--[ 2019.11.09.14.36.54.056.0 ]--
r 13     float cost;
--[ 2019.11.09.14.36.57.281.0 ]--
r 44             cost = terrain.computeTravelCost(loc, nextLoc) 
--[ 2019.11.09.14.36.57.514.0 ]--
r 44             cost = terrain.computeTravelCost(loc, nextLoc) * 
--[ 2019.11.09.14.36.57.750.0 ]--
r 44             cost = terrain.computeTravelCost(loc, nextLoc) * 1
--[ 2019.11.09.14.36.57.808.0 ]--
r 44             cost = terrain.computeTravelCost(loc, nextLoc) * 10
--[ 2019.11.09.14.36.57.959.0 ]--
r 44             cost = terrain.computeTravelCost(loc, nextLoc) * 100
--[ 2019.11.09.14.36.58.104.0 ]--
r 44             cost = terrain.computeTravelCost(loc, nextLoc) * 1000
--[ 2019.11.09.14.36.58.376.0 ]--
r 44             cost = terrain.computeTravelCost(loc, nextLoc) * 1000;
--[ 2019.11.09.14.37.03.361.0 ]--
r 45             T.sleep(cost);
--[ 2019.11.09.14.37.03.529.0 ]--
r 45             Th.sleep(cost);
--[ 2019.11.09.14.37.03.618.0 ]--
r 45             Thr.sleep(cost);
--[ 2019.11.09.14.37.03.693.0 ]--
r 45             Thre.sleep(cost);
--[ 2019.11.09.14.37.03.759.0 ]--
r 45             Threa.sleep(cost);
--[ 2019.11.09.14.37.03.860.0 ]--
r 45             Thread.sleep(cost);
--[ 2019.11.09.14.37.04.011.0 ]--
r 45             Threadi.sleep(cost);
--[ 2019.11.09.14.37.04.058.0 ]--
r 45             Threadin.sleep(cost);
--[ 2019.11.09.14.37.04.168.0 ]--
r 45             Threading.sleep(cost);
--[ 2019.11.09.14.37.07.379.0 ]--
r 45             T.sleep(cost);
--[ 2019.11.09.14.37.07.799.0 ]--
r 45             Th.sleep(cost);
--[ 2019.11.09.14.37.07.870.0 ]--
r 45             Thr.sleep(cost);
--[ 2019.11.09.14.37.07.947.0 ]--
r 45             Thre.sleep(cost);
--[ 2019.11.09.14.37.08.001.0 ]--
r 45             Threa.sleep(cost);
--[ 2019.11.09.14.37.08.107.0 ]--
r 45             Thread.sleep(cost);
--[ 2019.11.09.14.37.12.867.0 ]--
r 45             Thread.sleep(icost);
--[ 2019.11.09.14.37.12.913.0 ]--
r 45             Thread.sleep(incost);
--[ 2019.11.09.14.37.13.029.0 ]--
r 45             Thread.sleep(intcost);
--[ 2019.11.09.14.37.13.421.0 ]--
r 45             Thread.sleep(incost);
--[ 2019.11.09.14.37.13.583.0 ]--
r 45             Thread.sleep(icost);
--[ 2019.11.09.14.37.13.756.0 ]--
r 45             Thread.sleep(cost);
--[ 2019.11.09.14.37.14.011.0 ]--
r 45             Thread.sleep((cost);
--[ 2019.11.09.14.37.14.284.0 ]--
r 45             Thread.sleep((icost);
--[ 2019.11.09.14.37.14.354.0 ]--
r 45             Thread.sleep((incost);
--[ 2019.11.09.14.37.14.417.0 ]--
r 45             Thread.sleep((intcost);
--[ 2019.11.09.14.37.14.621.0 ]--
r 45             Thread.sleep((int)cost);
--[ 2019.11.09.14.37.14.706.0 ]--
r 45             Thread.sleep((int) cost);
--[ 2019.11.09.14.37.17.759.0 ]--
r 45             Thread.sleep((int)cost);
--[ 2019.11.09.14.37.17.974.0 ]--
r 45             Thread.sleep((intcost);
--[ 2019.11.09.14.37.18.086.0 ]--
r 45             Thread.sleep((incost);
--[ 2019.11.09.14.37.18.260.0 ]--
r 45             Thread.sleep((icost);
--[ 2019.11.09.14.37.18.461.0 ]--
r 45             Thread.sleep((cost);
--[ 2019.11.09.14.37.21.148.0 ]--
r 45             Thread.sleep(cost);
--[ 2019.11.09.14.40.17.043.0 ]--
r 45             T
--[ 2019.11.09.14.40.17.141.0 ]--
r 45             
--[ 2019.11.09.14.40.17.689.0 ]--
r 45             t
--[ 2019.11.09.14.40.17.792.0 ]--
r 45             th
--[ 2019.11.09.14.40.17.861.0 ]--
r 45             thi
--[ 2019.11.09.14.40.17.921.0 ]--
r 45             this
--[ 2019.11.09.14.40.18.086.0 ]--
r 45             this.
--[ 2019.11.09.14.40.18.368.0 ]--
r 45             this.w
--[ 2019.11.09.14.40.18.437.0 ]--
r 45             this.wa
--[ 2019.11.09.14.40.18.568.0 ]--
r 45             this.wai
--[ 2019.11.09.14.40.18.637.0 ]--
r 45             this.wait
--[ 2019.11.09.14.40.19.137.0 ]--
r 45             this.wait()
--[ 2019.11.09.14.40.20.527.0 ]--
r 45             this.wait(c)
--[ 2019.11.09.14.40.20.599.0 ]--
r 45             this.wait(co)
--[ 2019.11.09.14.40.20.770.0 ]--
r 45             this.wait(cos)
--[ 2019.11.09.14.40.20.858.0 ]--
r 45             this.wait(cost)
--[ 2019.11.09.14.40.21.365.0 ]--
r 45             this.wait(cost);
--[ 2019.11.09.14.40.25.953.0 ]--
r 45             this.wait((cost);
--[ 2019.11.09.14.40.26.235.0 ]--
r 45             this.wait((lcost);
--[ 2019.11.09.14.40.26.497.0 ]--
r 45             this.wait((locost);
--[ 2019.11.09.14.40.26.564.0 ]--
r 45             this.wait((loncost);
--[ 2019.11.09.14.40.26.615.0 ]--
r 45             this.wait((longcost);
--[ 2019.11.09.14.40.26.760.0 ]--
r 45             this.wait((long)cost);
--[ 2019.11.09.14.40.26.854.0 ]--
r 45             this.wait((long) cost);
--[ 2019.11.09.14.40.32.190.0 ]--
r 45 
--[ 2019.11.09.14.40.32.408.0 ]--
- 45
--[ 2019.11.09.14.42.42.562.0 ]--
r 44             cost = (terrain.computeTravelCost(loc, nextLoc) * 1000;
--[ 2019.11.09.14.42.42.905.0 ]--
r 44             cost = (iterrain.computeTravelCost(loc, nextLoc) * 1000;
--[ 2019.11.09.14.42.43.014.0 ]--
r 44             cost = (interrain.computeTravelCost(loc, nextLoc) * 1000;
--[ 2019.11.09.14.42.43.077.0 ]--
r 44             cost = (intterrain.computeTravelCost(loc, nextLoc) * 1000;
--[ 2019.11.09.14.42.43.219.0 ]--
r 44             cost = (int)terrain.computeTravelCost(loc, nextLoc) * 1000;
--[ 2019.11.09.14.42.43.344.0 ]--
r 44             cost = (int) terrain.computeTravelCost(loc, nextLoc) * 1000;
--[ 2019.11.09.14.42.44.267.0 ]--
+ 45             
--[ 2019.11.09.14.42.45.333.0 ]--
r 45             i
--[ 2019.11.09.14.42.45.396.0 ]--
r 45             in
--[ 2019.11.09.14.42.45.443.0 ]--
r 45             int
--[ 2019.11.09.14.42.45.583.0 ]--
r 45             int 
--[ 2019.11.09.14.42.45.693.0 ]--
r 45             int j
--[ 2019.11.09.14.42.45.865.0 ]--
r 45             int j 
--[ 2019.11.09.14.42.45.927.0 ]--
r 45             int j =
--[ 2019.11.09.14.42.46.083.0 ]--
r 45             int j = 
--[ 2019.11.09.14.42.46.179.0 ]--
r 45             int j = 0
--[ 2019.11.09.14.42.46.454.0 ]--
r 45             int j = 0;
--[ 2019.11.09.14.42.46.634.0 ]--
+ 46             
--[ 2019.11.09.14.42.46.995.0 ]--
r 46             f
--[ 2019.11.09.14.42.47.106.0 ]--
r 46             fo
--[ 2019.11.09.14.42.47.231.0 ]--
r 46             for
--[ 2019.11.09.14.42.47.356.0 ]--
r 46             for 
--[ 2019.11.09.14.42.47.466.0 ]--
r 46             for ()
--[ 2019.11.09.14.42.47.637.0 ]--
r 46             for (i)
--[ 2019.11.09.14.42.47.762.0 ]--
r 46             for (in)
--[ 2019.11.09.14.42.47.825.0 ]--
r 46             for (int)
--[ 2019.11.09.14.42.47.940.0 ]--
r 46             for (inti)
--[ 2019.11.09.14.42.47.967.0 ]--
r 46             for (inti )
--[ 2019.11.09.14.42.48.720.0 ]--
r 46             for (inti)
--[ 2019.11.09.14.42.49.233.0 ]--
r 46             for (int)
--[ 2019.11.09.14.42.49.468.0 ]--
r 46             for (int )
--[ 2019.11.09.14.42.49.567.0 ]--
r 46             for (int i)
--[ 2019.11.09.14.42.49.676.0 ]--
r 46             for (int i )
--[ 2019.11.09.14.42.49.801.0 ]--
r 46             for (int i =)
--[ 2019.11.09.14.42.49.926.0 ]--
r 46             for (int i = )
--[ 2019.11.09.14.42.50.129.0 ]--
r 46             for (int i = 0)
--[ 2019.11.09.14.42.50.584.0 ]--
r 46             for (int i = 0;)
--[ 2019.11.09.14.42.50.725.0 ]--
r 46             for (int i = 0; )
--[ 2019.11.09.14.42.50.788.0 ]--
r 46             for (int i = 0; i)
--[ 2019.11.09.14.42.50.991.0 ]--
r 46             for (int i = 0; i )
--[ 2019.11.09.14.42.51.150.0 ]--
r 46             for (int i = 0; i <)
--[ 2019.11.09.14.42.51.208.0 ]--
r 46             for (int i = 0; i < )
--[ 2019.11.09.14.42.51.333.0 ]--
r 46             for (int i = 0; i < c)
--[ 2019.11.09.14.42.51.443.0 ]--
r 46             for (int i = 0; i < co)
--[ 2019.11.09.14.42.51.599.0 ]--
r 46             for (int i = 0; i < cos)
--[ 2019.11.09.14.42.51.677.0 ]--
r 46             for (int i = 0; i < cost)
--[ 2019.11.09.14.42.51.755.0 ]--
r 46             for (int i = 0; i < cost;)
--[ 2019.11.09.14.42.52.109.0 ]--
r 46             for (int i = 0; i < cost; )
--[ 2019.11.09.14.42.52.240.0 ]--
r 46             for (int i = 0; i < cost; i)
--[ 2019.11.09.14.42.52.738.0 ]--
r 46             for (int i = 0; i < cost; i+)
--[ 2019.11.09.14.42.52.917.0 ]--
r 46             for (int i = 0; i < cost; i++)
--[ 2019.11.09.14.42.53.434.0 ]--
r 46             for (int i = 0; i < cost; i++) 
--[ 2019.11.09.14.42.53.878.0 ]--
r 46             for (int i = 0; i < cost; i++) {
--[ 2019.11.09.14.42.54.134.0 ]--
r 46             for (int i = 0; i < cost; i++) {}
--[ 2019.11.09.14.43.01.179.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.14.43.23.042.0 ]--
r 46             for (int i = 0; i < cost; i++) {S}
--[ 2019.11.09.14.43.23.068.0 ]--
UpdateTree (AD): 1 0
+ /out/production/P04_Pathfinding/Walker.class

--[ 2019.11.09.14.43.23.398.0 ]--
r 46             for (int i = 0; i < cost; i++) {St}
--[ 2019.11.09.14.43.23.697.0 ]--
r 46             for (int i = 0; i < cost; i++) {Std}
--[ 2019.11.09.14.43.23.826.0 ]--
r 46             for (int i = 0; i < cost; i++) {StdO}
--[ 2019.11.09.14.43.24.077.0 ]--
r 46             for (int i = 0; i < cost; i++) {StdOu}
--[ 2019.11.09.14.43.24.349.0 ]--
r 46             for (int i = 0; i < cost; i++) {StdOut.}
--[ 2019.11.09.14.43.24.742.0 ]--
r 46             for (int i = 0; i < cost; i++) {StdOut.p}
--[ 2019.11.09.14.43.24.898.0 ]--
r 46             for (int i = 0; i < cost; i++) {StdOut.pr}
--[ 2019.11.09.14.43.25.026.0 ]--
r 46             for (int i = 0; i < cost; i++) {StdOut.pri}
--[ 2019.11.09.14.43.25.104.0 ]--
r 46             for (int i = 0; i < cost; i++) {StdOut.prin}
--[ 2019.11.09.14.43.25.261.0 ]--
r 46             for (int i = 0; i < cost; i++) {StdOut.print}
--[ 2019.11.09.14.43.25.339.0 ]--
r 46             for (int i = 0; i < cost; i++) {StdOut.printl}
--[ 2019.11.09.14.43.25.448.0 ]--
r 46             for (int i = 0; i < cost; i++) {StdOut.println}
--[ 2019.11.09.14.43.25.809.0 ]--
r 46             for (int i = 0; i < cost; i++) {StdOut.println()}
--[ 2019.11.09.14.43.30.888.0 ]--
r 46             for (int i = 0; i < cost; i++) {StdOut.println(i)}
--[ 2019.11.09.14.43.32.865.0 ]--
r 46             for (int i = 0; i < cost; i++) {StdOut.println(i)};
--[ 2019.11.09.14.43.34.511.0 ]--
r 46             for (int i = 0; i < cost; i++) {StdOut.println(i);};
--[ 2019.11.09.14.43.35.815.0 ]--
r 46             for (int i = 0; i < cost; i++) {StdOut.println(i);}
--[ 2019.11.09.14.43.41.623.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.14.44.01.785.0 ]--
r 46             for (int i = 0; i < cost; i++) {}
--[ 2019.11.09.14.44.04.252.0 ]--
r 46             for (int i = 0; i < cost; i+) {}
--[ 2019.11.09.14.44.04.585.0 ]--
r 46             for (int i = 0; i < cost; i) {}
--[ 2019.11.09.14.44.04.775.0 ]--
r 46             for (int i = 0; i < cost; i*) {}
--[ 2019.11.09.14.44.05.198.0 ]--
r 46             for (int i = 0; i < cost; i*=) {}
--[ 2019.11.09.14.44.05.405.0 ]--
r 46             for (int i = 0; i < cost; i*=2) {}
--[ 2019.11.09.14.44.09.901.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.14.44.36.305.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.14.45.26.366.0 ]--
r 46             for (int i = ; i < cost; i*=2) {}
--[ 2019.11.09.14.45.26.404.0 ]--
r 46             for (int i = 1; i < cost; i*=2) {}
--[ 2019.11.09.14.45.29.923.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.14.46.10.299.0 ]--
r 46             for (int i = 1; i < cost; i*=) {}
--[ 2019.11.09.14.46.10.482.0 ]--
r 46             for (int i = 1; i < cost; i*) {}
--[ 2019.11.09.14.46.10.639.0 ]--
r 46             for (int i = 1; i < cost; i) {}
--[ 2019.11.09.14.46.11.311.0 ]--
r 46             for (int i = 1; i < cost; i+) {}
--[ 2019.11.09.14.46.11.572.0 ]--
r 46             for (int i = 1; i < cost; i+=) {}
--[ 2019.11.09.14.46.12.761.0 ]--
r 46             for (int i = 1; i < cost; i+=b) {}
--[ 2019.11.09.14.46.12.854.0 ]--
r 46             for (int i = 1; i < cost; i+=by) {}
--[ 2019.11.09.14.46.13.142.0 ]--
r 46             for (int i = 1; i < cost; i+=byT) {}
--[ 2019.11.09.14.46.13.349.0 ]--
r 46             for (int i = 1; i < cost; i+=byTi) {}
--[ 2019.11.09.14.46.13.382.0 ]--
r 46             for (int i = 1; i < cost; i+=byTim) {}
--[ 2019.11.09.14.46.13.437.0 ]--
r 46             for (int i = 1; i < cost; i+=byTime) {}
--[ 2019.11.09.14.46.14.532.0 ]--
r 46             for (int i = 1; i < cost; i+=byTim) {}
--[ 2019.11.09.14.46.14.661.0 ]--
r 46             for (int i = 1; i < cost; i+=byTi) {}
--[ 2019.11.09.14.46.14.850.0 ]--
r 46             for (int i = 1; i < cost; i+=byT) {}
--[ 2019.11.09.14.46.14.991.0 ]--
r 46             for (int i = 1; i < cost; i+=by) {}
--[ 2019.11.09.14.46.15.179.0 ]--
r 46             for (int i = 1; i < cost; i+=b) {}
--[ 2019.11.09.14.46.15.350.0 ]--
r 46             for (int i = 1; i < cost; i+=) {}
--[ 2019.11.09.14.46.16.679.0 ]--
r 46             for (int i = 1; i < cost; i+=1) {}
--[ 2019.11.09.14.46.16.725.0 ]--
r 46             for (int i = 1; i < cost; i+=10) {}
--[ 2019.11.09.14.46.16.866.0 ]--
r 46             for (int i = 1; i < cost; i+=100) {}
--[ 2019.11.09.14.46.17.710.0 ]--
r 46             for (int i = 1; i < cost; i+=10) {}
--[ 2019.11.09.14.46.17.851.0 ]--
r 46             for (int i = 1; i < cost; i+=1) {}
--[ 2019.11.09.14.46.18.027.0 ]--
r 46             for (int i = 1; i < cost; i+=) {}
--[ 2019.11.09.14.46.19.407.0 ]--
r 46             for (int i = 1; i < cost; i+=()) {}
--[ 2019.11.09.14.46.19.675.0 ]--
r 46             for (int i = 1; i < cost; i+=(i)) {}
--[ 2019.11.09.14.46.19.768.0 ]--
r 46             for (int i = 1; i < cost; i+=(in)) {}
--[ 2019.11.09.14.46.19.867.0 ]--
r 46             for (int i = 1; i < cost; i+=(int)) {}
--[ 2019.11.09.14.46.20.148.0 ]--
r 46             for (int i = 1; i < cost; i+=(int) ) {}
--[ 2019.11.09.14.46.20.304.0 ]--
r 46             for (int i = 1; i < cost; i+=(int) b) {}
--[ 2019.11.09.14.46.20.382.0 ]--
r 46             for (int i = 1; i < cost; i+=(int) by) {}
--[ 2019.11.09.14.46.20.649.0 ]--
r 46             for (int i = 1; i < cost; i+=(int) byT) {}
--[ 2019.11.09.14.46.20.911.0 ]--
r 46             for (int i = 1; i < cost; i+=(int) byTi) {}
--[ 2019.11.09.14.46.20.962.0 ]--
r 46             for (int i = 1; i < cost; i+=(int) byTim) {}
--[ 2019.11.09.14.46.21.087.0 ]--
r 46             for (int i = 1; i < cost; i+=(int) byTime) {}
--[ 2019.11.09.14.46.24.899.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.14.46.37.118.0 ]--
r 46             for (int i = 1; i < cost; i+=(int) byTim) {}
--[ 2019.11.09.14.46.37.343.0 ]--
r 46             for (int i = 1; i < cost; i+=(int) byTi) {}
--[ 2019.11.09.14.46.37.500.0 ]--
r 46             for (int i = 1; i < cost; i+=(int) byT) {}
--[ 2019.11.09.14.46.38.012.0 ]--
r 46             for (int i = 1; i < cost; i+=(int) by) {}
--[ 2019.11.09.14.46.38.048.0 ]--
r 46             for (int i = 1; i < cost; i+=(int) b) {}
--[ 2019.11.09.14.46.38.070.0 ]--
r 46             for (int i = 1; i < cost; i+=(int) ) {}
--[ 2019.11.09.14.46.38.115.0 ]--
r 46             for (int i = 1; i < cost; i+=(int)) {}
--[ 2019.11.09.14.46.38.137.0 ]--
r 46             for (int i = 1; i < cost; i+=(int) {}
--[ 2019.11.09.14.46.38.420.0 ]--
r 46             for (int i = 1; i < cost; i+=(in) {}
--[ 2019.11.09.14.46.38.439.0 ]--
r 46             for (int i = 1; i < cost; i+=(i) {}
--[ 2019.11.09.14.46.38.625.0 ]--
r 46             for (int i = 1; i < cost; i+=() {}
--[ 2019.11.09.14.46.38.797.0 ]--
r 46             for (int i = 1; i < cost; i+=) {}
--[ 2019.11.09.14.46.38.999.0 ]--
r 46             for (int i = 1; i < cost; i+) {}
--[ 2019.11.09.14.46.39.186.0 ]--
r 46             for (int i = 1; i < cost; i) {}
--[ 2019.11.09.14.46.40.102.0 ]--
r 46             for (int i = 1; i < cost; i+) {}
--[ 2019.11.09.14.46.40.305.0 ]--
r 46             for (int i = 1; i < cost; i+=) {}
--[ 2019.11.09.14.46.40.608.0 ]--
r 46             for (int i = 1; i < cost; i+=1) {}
--[ 2019.11.09.14.46.40.764.0 ]--
r 46             for (int i = 1; i < cost; i+=10) {}
--[ 2019.11.09.14.46.40.947.0 ]--
r 46             for (int i = 1; i < cost; i+=100) {}
--[ 2019.11.09.14.46.44.022.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.14.46.57.344.0 ]--
r 46             for (int i = 1; i < cost; i+=10) {}
--[ 2019.11.09.14.46.57.516.0 ]--
r 46             for (int i = 1; i < cost; i+=1) {}
--[ 2019.11.09.14.47.00.838.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.14.47.16.399.0 ]--
r 46             for (int i = 1; i < cost; i+=) {}
--[ 2019.11.09.14.47.16.986.0 ]--
r 46             for (int i = 1; i < cost; i+=5) {}
--[ 2019.11.09.14.47.20.213.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.14.48.10.433.0 ]--
r 46             for (int i = 1; i < cost; i+=) {}
--[ 2019.11.09.14.48.11.013.0 ]--
r 46             for (int i = 1; i < cost; i+=1) {}
--[ 2019.11.09.14.48.11.187.0 ]--
r 46             for (int i = 1; i < cost; i+=10) {}
--[ 2019.11.09.14.48.14.585.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.14.55.32.803.0 ]--
- 43
- 43
- 43
r 43 
--[ 2019.11.09.14.55.32.967.0 ]--
- 43
--[ 2019.11.09.14.55.35.298.0 ]--
- 41
r 41 
--[ 2019.11.09.14.55.35.530.0 ]--
- 41
--[ 2019.11.09.14.55.37.091.0 ]--
- 44
r 44 
--[ 2019.11.09.14.55.38.331.0 ]--
+ 44             } else { nextLoc = null; break;}
r 45         }
--[ 2019.11.09.14.55.40.521.0 ]--
r 45 
--[ 2019.11.09.14.55.41.162.0 ]--
- 45
--[ 2019.11.09.14.55.42.492.0 ]--
r 44             } else { nextLoc = null; break}
--[ 2019.11.09.14.55.42.663.0 ]--
r 44             } else { nextLoc = null; brea}
--[ 2019.11.09.14.55.42.834.0 ]--
r 44             } else { nextLoc = null; bre}
--[ 2019.11.09.14.55.43.022.0 ]--
r 44             } else { nextLoc = null; br}
--[ 2019.11.09.14.55.43.209.0 ]--
r 44             } else { nextLoc = null; b}
--[ 2019.11.09.14.55.43.399.0 ]--
r 44             } else { nextLoc = null; }
--[ 2019.11.09.14.55.47.563.0 ]--
r 13     float t;
--[ 2019.11.09.14.55.47.770.0 ]--
r 13     float to;
--[ 2019.11.09.14.55.47.801.0 ]--
r 13     float tot;
--[ 2019.11.09.14.55.47.816.0 ]--
r 13     float tota;
--[ 2019.11.09.14.55.47.948.0 ]--
r 13     float total;
--[ 2019.11.09.14.55.48.206.0 ]--
r 13     float totalC;
--[ 2019.11.09.14.55.48.397.0 ]--
r 13     float totalCo;
--[ 2019.11.09.14.55.48.469.0 ]--
r 13     float totalCos;
--[ 2019.11.09.14.55.48.550.0 ]--
r 13     float totalCost;
--[ 2019.11.09.14.55.51.944.0 ]--
+ 25         
--[ 2019.11.09.14.55.52.740.0 ]--
r 25         t
--[ 2019.11.09.14.55.52.837.0 ]--
r 25         th
--[ 2019.11.09.14.55.52.916.0 ]--
r 25         thi
--[ 2019.11.09.14.55.53.041.0 ]--
r 25         this
--[ 2019.11.09.14.55.53.150.0 ]--
r 25         this.
--[ 2019.11.09.14.55.53.291.0 ]--
r 25         this.t
--[ 2019.11.09.14.55.53.415.0 ]--
r 25         this.to
--[ 2019.11.09.14.55.53.494.0 ]--
r 25         this.tot
--[ 2019.11.09.14.55.53.540.0 ]--
r 25         this.tota
--[ 2019.11.09.14.55.53.634.0 ]--
r 25         this.total
--[ 2019.11.09.14.55.53.886.0 ]--
r 25         this.totalC
--[ 2019.11.09.14.55.54.051.0 ]--
r 25         this.totalCo
--[ 2019.11.09.14.55.54.145.0 ]--
r 25         this.totalCos
--[ 2019.11.09.14.55.54.254.0 ]--
r 25         this.totalCost
--[ 2019.11.09.14.55.54.301.0 ]--
r 25         this.totalCost 
--[ 2019.11.09.14.55.54.426.0 ]--
r 25         this.totalCost =
--[ 2019.11.09.14.55.54.488.0 ]--
r 25         this.totalCost = 
--[ 2019.11.09.14.55.54.613.0 ]--
r 25         this.totalCost = 0
--[ 2019.11.09.14.55.54.911.0 ]--
r 25         this.totalCost = 0.
--[ 2019.11.09.14.55.55.186.0 ]--
r 25         this.totalCost = 0.0
--[ 2019.11.09.14.55.55.296.0 ]--
r 25         this.totalCost = 0.0f
--[ 2019.11.09.14.55.55.411.0 ]--
r 25         this.totalCost = 0.0f;
--[ 2019.11.09.14.58.34.401.0 ]--
+ 42         
--[ 2019.11.09.14.58.50.582.0 ]--
r 42         f
--[ 2019.11.09.14.58.50.836.0 ]--
r 42         flo
--[ 2019.11.09.14.58.50.883.0 ]--
r 42         floa
--[ 2019.11.09.14.58.50.930.0 ]--
r 42         float
--[ 2019.11.09.14.58.51.117.0 ]--
r 42         float 
--[ 2019.11.09.14.58.51.441.0 ]--
r 42         float c
--[ 2019.11.09.14.58.51.626.0 ]--
r 42         float co
--[ 2019.11.09.14.58.51.782.0 ]--
r 42         float cos
--[ 2019.11.09.14.58.51.886.0 ]--
r 42         float cost
--[ 2019.11.09.14.58.52.140.0 ]--
r 42         float cost=
--[ 2019.11.09.14.58.52.580.0 ]--
r 42         float cost
--[ 2019.11.09.14.58.53.230.0 ]--
r 42         float cost 
--[ 2019.11.09.14.58.53.399.0 ]--
r 42         float cost
--[ 2019.11.09.14.58.53.477.0 ]--
r 42         float cost 
--[ 2019.11.09.14.58.54.166.0 ]--
r 42         float cost =
--[ 2019.11.09.14.58.54.236.0 ]--
r 42         float cost = 
--[ 2019.11.09.14.58.55.050.0 ]--
r 42         float cost = l
--[ 2019.11.09.14.58.55.249.0 ]--
r 42         float cost = lo
--[ 2019.11.09.14.58.55.312.0 ]--
r 42         float cost = loc
--[ 2019.11.09.14.58.56.258.0 ]--
r 42         float cost = lo
--[ 2019.11.09.14.58.56.411.0 ]--
r 42         float cost = l
--[ 2019.11.09.14.58.56.616.0 ]--
r 42         float cost = 
--[ 2019.11.09.14.58.57.307.0 ]--
r 42         float cost = t
--[ 2019.11.09.14.58.57.432.0 ]--
r 42         float cost = te
--[ 2019.11.09.14.58.57.588.0 ]--
r 42         float cost = ter
--[ 2019.11.09.14.58.57.760.0 ]--
r 42         float cost = terr
--[ 2019.11.09.14.58.57.825.0 ]--
r 42         float cost = terra
--[ 2019.11.09.14.58.57.849.0 ]--
r 42         float cost = terrai
--[ 2019.11.09.14.58.57.896.0 ]--
r 42         float cost = terrain
--[ 2019.11.09.14.58.58.091.0 ]--
r 42         float cost = terrain.
--[ 2019.11.09.14.58.58.337.0 ]--
r 42         float cost = terrain.g
--[ 2019.11.09.14.58.58.410.0 ]--
r 42         float cost = terrain.ge
--[ 2019.11.09.14.58.58.593.0 ]--
r 42         float cost = terrain.get
--[ 2019.11.09.14.58.59.023.0 ]--
r 42         float cost = terrain.ge
--[ 2019.11.09.14.58.59.195.0 ]--
r 42         float cost = terrain.g
--[ 2019.11.09.14.58.59.353.0 ]--
r 42         float cost = terrain.
--[ 2019.11.09.14.58.59.464.0 ]--
r 42         float cost = terrain.c
--[ 2019.11.09.14.58.59.668.0 ]--
r 42         float cost = terrain.co
--[ 2019.11.09.14.58.59.761.0 ]--
r 42         float cost = terrain.com
--[ 2019.11.09.14.58.59.886.0 ]--
r 42         float cost = terrain.comp
--[ 2019.11.09.14.58.59.979.0 ]--
r 42         float cost = terrain.compu
--[ 2019.11.09.14.59.00.105.0 ]--
r 42         float cost = terrain.comput
--[ 2019.11.09.14.59.00.167.0 ]--
r 42         float cost = terrain.compute
--[ 2019.11.09.14.59.00.261.0 ]--
r 42         float cost = terrain.computeTravelCost
--[ 2019.11.09.14.59.00.276.0 ]--
r 42         float cost = terrain.computeTravelCost()
--[ 2019.11.09.14.59.01.090.0 ]--
r 42         float cost = terrain.computeTravelCost(l)
--[ 2019.11.09.14.59.01.373.0 ]--
r 42         float cost = terrain.computeTravelCost(loc)
--[ 2019.11.09.14.59.01.450.0 ]--
r 42         float cost = terrain.computeTravelCost(loc,)
--[ 2019.11.09.14.59.01.850.0 ]--
r 42         float cost = terrain.computeTravelCost(loc, )
--[ 2019.11.09.14.59.02.117.0 ]--
r 42         float cost = terrain.computeTravelCost(loc, n)
--[ 2019.11.09.14.59.02.222.0 ]--
r 42         float cost = terrain.computeTravelCost(loc, ne)
--[ 2019.11.09.14.59.02.441.0 ]--
r 42         float cost = terrain.computeTravelCost(loc, nex)
--[ 2019.11.09.14.59.02.661.0 ]--
r 42         float cost = terrain.computeTravelCost(loc, next)
--[ 2019.11.09.14.59.02.906.0 ]--
r 42         float cost = terrain.computeTravelCost(loc, nextL)
--[ 2019.11.09.14.59.03.082.0 ]--
r 42         float cost = terrain.computeTravelCost(loc, nextLo)
--[ 2019.11.09.14.59.03.132.0 ]--
r 42         float cost = terrain.computeTravelCost(loc, nextLoc)
--[ 2019.11.09.14.59.03.621.0 ]--
r 42         float cost = terrain.computeTravelCost(loc, nextLoc);
--[ 2019.11.09.14.59.06.968.0 ]--
+ 43         
--[ 2019.11.09.14.59.07.315.0 ]--
r 43         w
--[ 2019.11.09.14.59.07.394.0 ]--
r 43         wh
--[ 2019.11.09.14.59.07.447.0 ]--
r 43         whi
--[ 2019.11.09.14.59.07.623.0 ]--
r 43         whil
--[ 2019.11.09.14.59.07.696.0 ]--
r 43         while
--[ 2019.11.09.14.59.07.763.0 ]--
r 43         while 
--[ 2019.11.09.14.59.07.919.0 ]--
r 43         while ()
--[ 2019.11.09.14.59.10.092.0 ]--
r 43         while (c)
--[ 2019.11.09.14.59.10.248.0 ]--
r 43         while (co)
--[ 2019.11.09.14.59.10.418.0 ]--
r 43         while (cos)
--[ 2019.11.09.14.59.10.590.0 ]--
r 43         while (cost)
--[ 2019.11.09.14.59.11.185.0 ]--
r 43         while (cos)
--[ 2019.11.09.14.59.11.461.0 ]--
r 43         while (co)
--[ 2019.11.09.14.59.11.596.0 ]--
r 43         while (c)
--[ 2019.11.09.14.59.11.721.0 ]--
r 43         while ()
--[ 2019.11.09.14.59.12.144.0 ]--
r 43         while (t)
--[ 2019.11.09.14.59.12.245.0 ]--
r 43         while (to)
--[ 2019.11.09.14.59.12.386.0 ]--
r 43         while (tot)
--[ 2019.11.09.14.59.12.448.0 ]--
r 43         while (tota)
--[ 2019.11.09.14.59.12.464.0 ]--
r 43         while (total)
--[ 2019.11.09.14.59.12.793.0 ]--
r 43         while (totalC)
--[ 2019.11.09.14.59.13.018.0 ]--
r 43         while (totalCo)
--[ 2019.11.09.14.59.13.175.0 ]--
r 43         while (totalCos)
--[ 2019.11.09.14.59.13.235.0 ]--
r 43         while (totalCost)
--[ 2019.11.09.14.59.13.752.0 ]--
r 43         while (totalCost )
--[ 2019.11.09.14.59.13.977.0 ]--
r 43         while (totalCost <)
--[ 2019.11.09.14.59.14.100.0 ]--
r 43         while (totalCost < )
--[ 2019.11.09.14.59.15.249.0 ]--
r 43         while (totalCost < b)
--[ 2019.11.09.14.59.15.327.0 ]--
r 43         while (totalCost < by)
--[ 2019.11.09.14.59.16.443.0 ]--
r 43         while (totalCost < b)
--[ 2019.11.09.14.59.19.465.0 ]--
r 43         while (totalCost < )
--[ 2019.11.09.14.59.20.006.0 ]--
r 43         while (totalCost < t)
--[ 2019.11.09.14.59.20.128.0 ]--
r 43         while (totalCost < to)
--[ 2019.11.09.14.59.20.206.0 ]--
r 43         while (totalCost < tot)
--[ 2019.11.09.14.59.20.331.0 ]--
r 43         while (totalCost < tota)
--[ 2019.11.09.14.59.20.456.0 ]--
r 43         while (totalCost < total)
--[ 2019.11.09.14.59.20.762.0 ]--
r 43         while (totalCost < totalC)
--[ 2019.11.09.14.59.21.060.0 ]--
r 43         while (totalCost < totalCo)
--[ 2019.11.09.14.59.21.155.0 ]--
r 43         while (totalCost < totalCos)
--[ 2019.11.09.14.59.21.249.0 ]--
r 43         while (totalCost < totalCost)
--[ 2019.11.09.14.59.21.516.0 ]--
r 43         while (totalCost < totalCost )
--[ 2019.11.09.14.59.21.549.0 ]--
r 43         while (totalCost < totalCost +)
--[ 2019.11.09.14.59.21.643.0 ]--
r 43         while (totalCost < totalCost + )
--[ 2019.11.09.14.59.21.848.0 ]--
r 43         while (totalCost < totalCost + b)
--[ 2019.11.09.14.59.21.929.0 ]--
r 43         while (totalCost < totalCost + by)
--[ 2019.11.09.14.59.22.202.0 ]--
r 43         while (totalCost < totalCost + byT)
--[ 2019.11.09.14.59.22.325.0 ]--
r 43         while (totalCost < totalCost + byTi)
--[ 2019.11.09.14.59.22.378.0 ]--
r 43         while (totalCost < totalCost + byTim)
--[ 2019.11.09.14.59.22.490.0 ]--
r 43         while (totalCost < totalCost + byTime)
--[ 2019.11.09.14.59.23.184.0 ]--
r 43         while (totalCost < totalCost + byTime) 
--[ 2019.11.09.14.59.23.278.0 ]--
r 43         while (totalCost < totalCost + byTime) {
--[ 2019.11.09.14.59.29.214.0 ]--
+ 43         
--[ 2019.11.09.14.59.29.973.0 ]--
r 43         i
--[ 2019.11.09.14.59.30.107.0 ]--
r 43         in
--[ 2019.11.09.14.59.30.154.0 ]--
r 43         int
--[ 2019.11.09.14.59.30.217.0 ]--
r 43         int 
--[ 2019.11.09.14.59.30.938.0 ]--
r 43         int
--[ 2019.11.09.14.59.31.100.0 ]--
r 43         in
--[ 2019.11.09.14.59.31.272.0 ]--
r 43         i
--[ 2019.11.09.14.59.31.547.0 ]--
r 43         
--[ 2019.11.09.14.59.31.815.0 ]--
r 43         f
--[ 2019.11.09.14.59.31.909.0 ]--
r 43         fl
--[ 2019.11.09.14.59.32.065.0 ]--
r 43         flo
--[ 2019.11.09.14.59.32.127.0 ]--
r 43         floa
--[ 2019.11.09.14.59.32.190.0 ]--
r 43         float
--[ 2019.11.09.14.59.32.346.0 ]--
r 43         float 
--[ 2019.11.09.14.59.32.424.0 ]--
r 43         float e
--[ 2019.11.09.14.59.32.549.0 ]--
r 43         float en
--[ 2019.11.09.14.59.32.643.0 ]--
r 43         float end
--[ 2019.11.09.14.59.32.721.0 ]--
r 43         float end 
--[ 2019.11.09.14.59.32.862.0 ]--
r 43         float end =
--[ 2019.11.09.14.59.32.937.0 ]--
r 43         float end = 
--[ 2019.11.09.14.59.33.191.0 ]--
r 43         float end = t
--[ 2019.11.09.14.59.33.309.0 ]--
r 43         float end = to
--[ 2019.11.09.14.59.33.384.0 ]--
r 43         float end = tot
--[ 2019.11.09.14.59.33.492.0 ]--
r 43         float end = tota
--[ 2019.11.09.14.59.33.578.0 ]--
r 43         float end = total
--[ 2019.11.09.14.59.34.025.0 ]--
r 43         float end = totalC
--[ 2019.11.09.14.59.34.218.0 ]--
r 43         float end = totalCo
--[ 2019.11.09.14.59.34.359.0 ]--
r 43         float end = totalCos
--[ 2019.11.09.14.59.34.421.0 ]--
r 43         float end = totalCost
--[ 2019.11.09.14.59.34.483.0 ]--
r 43         float end = totalCost 
--[ 2019.11.09.14.59.34.704.0 ]--
r 43         float end = totalCost +
--[ 2019.11.09.14.59.34.776.0 ]--
r 43         float end = totalCost + 
--[ 2019.11.09.14.59.35.277.0 ]--
r 43         float end = totalCost + b
--[ 2019.11.09.14.59.35.369.0 ]--
r 43         float end = totalCost + by
--[ 2019.11.09.14.59.35.629.0 ]--
r 43         float end = totalCost + byT
--[ 2019.11.09.14.59.35.769.0 ]--
r 43         float end = totalCost + byTi
--[ 2019.11.09.14.59.35.832.0 ]--
r 43         float end = totalCost + byTim
--[ 2019.11.09.14.59.35.894.0 ]--
r 43         float end = totalCost + byTime
--[ 2019.11.09.14.59.37.534.0 ]--
r 43         float end = totalCost + byTime;
--[ 2019.11.09.14.59.41.632.0 ]--
r 44         while (totalCost < e) {
--[ 2019.11.09.14.59.41.839.0 ]--
r 44         while (totalCost < end) {
--[ 2019.11.09.14.59.45.451.0 ]--
+ 49             
--[ 2019.11.09.14.59.46.185.0 ]--
- 49
--[ 2019.11.09.14.59.46.569.0 ]--
r 48             } else { nextLoc = null; }}
--[ 2019.11.09.14.59.48.496.0 ]--
+ 48             } else { nextLoc = null; }
r 49         }
--[ 2019.11.09.14.59.53.854.0 ]--
r 48             } else { nextLoc = null; b}
--[ 2019.11.09.14.59.54.213.0 ]--
r 48             } else { nextLoc = null; br}
--[ 2019.11.09.14.59.54.297.0 ]--
r 48             } else { nextLoc = null; bre}
--[ 2019.11.09.14.59.54.360.0 ]--
r 48             } else { nextLoc = null; breka}
--[ 2019.11.09.14.59.54.485.0 ]--
r 48             } else { nextLoc = null; breka;}
--[ 2019.11.09.14.59.55.498.0 ]--
r 48             } else { nextLoc = null; breka}
--[ 2019.11.09.14.59.55.639.0 ]--
r 48             } else { nextLoc = null; brek}
--[ 2019.11.09.14.59.55.810.0 ]--
r 48             } else { nextLoc = null; bre}
--[ 2019.11.09.14.59.56.234.0 ]--
r 48             } else { nextLoc = null; brea}
--[ 2019.11.09.14.59.56.315.0 ]--
r 48             } else { nextLoc = null; break}
--[ 2019.11.09.14.59.56.440.0 ]--
r 48             } else { nextLoc = null; break;}
--[ 2019.11.09.14.59.56.599.0 ]--
r 48             } else { nextLoc = null; break; }
--[ 2019.11.09.15.00.06.079.0 ]--
+ 49             
--[ 2019.11.09.15.00.06.725.0 ]--
r 49             c
--[ 2019.11.09.15.00.06.795.0 ]--
r 49             co
--[ 2019.11.09.15.00.07.095.0 ]--
r 49             cos
--[ 2019.11.09.15.00.07.153.0 ]--
r 49             cost
--[ 2019.11.09.15.00.07.586.0 ]--
r 49             cost 
--[ 2019.11.09.15.00.07.702.0 ]--
r 49             cost =
--[ 2019.11.09.15.00.07.769.0 ]--
r 49             cost = 
--[ 2019.11.09.15.00.08.118.0 ]--
r 49             cost = t
--[ 2019.11.09.15.00.08.206.0 ]--
r 49             cost = te
--[ 2019.11.09.15.00.08.367.0 ]--
r 49             cost = ter
--[ 2019.11.09.15.00.08.550.0 ]--
r 49             cost = terr
--[ 2019.11.09.15.00.08.608.0 ]--
r 49             cost = terra
--[ 2019.11.09.15.00.08.663.0 ]--
r 49             cost = terrai
--[ 2019.11.09.15.00.08.752.0 ]--
r 49             cost = terrain
--[ 2019.11.09.15.00.08.963.0 ]--
r 49             cost = terrain.
--[ 2019.11.09.15.00.09.145.0 ]--
r 49             cost = terrain.c
--[ 2019.11.09.15.00.09.270.0 ]--
r 49             cost = terrain.co
--[ 2019.11.09.15.00.09.348.0 ]--
r 49             cost = terrain.com
--[ 2019.11.09.15.00.09.488.0 ]--
r 49             cost = terrain.comp
--[ 2019.11.09.15.00.09.582.0 ]--
r 49             cost = terrain.compu
--[ 2019.11.09.15.00.09.676.0 ]--
r 49             cost = terrain.comput
--[ 2019.11.09.15.00.09.769.0 ]--
r 49             cost = terrain.compute
--[ 2019.11.09.15.00.10.067.0 ]--
r 49             cost = terrain.computeT
--[ 2019.11.09.15.00.10.243.0 ]--
r 49             cost = terrain.computeTr
--[ 2019.11.09.15.00.10.305.0 ]--
r 49             cost = terrain.computeTra
--[ 2019.11.09.15.00.10.494.0 ]--
r 49             cost = terrain.computeTrav
--[ 2019.11.09.15.00.10.571.0 ]--
r 49             cost = terrain.computeTrave
--[ 2019.11.09.15.00.10.696.0 ]--
r 49             cost = terrain.computeTravel
--[ 2019.11.09.15.00.10.836.0 ]--
r 49             cost = terrain.computeTravelC
--[ 2019.11.09.15.00.10.978.0 ]--
r 49             cost = terrain.computeTravelCo
--[ 2019.11.09.15.00.11.089.0 ]--
r 49             cost = terrain.computeTravelCos
--[ 2019.11.09.15.00.11.167.0 ]--
r 49             cost = terrain.computeTravelCost
--[ 2019.11.09.15.00.11.354.0 ]--
r 49             cost = terrain.computeTravelCost()
--[ 2019.11.09.15.00.11.543.0 ]--
r 49             cost = terrain.computeTravelCost(l)
--[ 2019.11.09.15.00.11.963.0 ]--
r 49             cost = terrain.computeTravelCost(lo)
--[ 2019.11.09.15.00.12.050.0 ]--
r 49             cost = terrain.computeTravelCost(loc)
--[ 2019.11.09.15.00.12.159.0 ]--
r 49             cost = terrain.computeTravelCost(loc,)
--[ 2019.11.09.15.00.12.268.0 ]--
r 49             cost = terrain.computeTravelCost(loc, )
--[ 2019.11.09.15.00.12.362.0 ]--
r 49             cost = terrain.computeTravelCost(loc, n)
--[ 2019.11.09.15.00.12.471.0 ]--
r 49             cost = terrain.computeTravelCost(loc, ne)
--[ 2019.11.09.15.00.12.674.0 ]--
r 49             cost = terrain.computeTravelCost(loc, nex)
--[ 2019.11.09.15.00.12.895.0 ]--
r 49             cost = terrain.computeTravelCost(loc, next)
--[ 2019.11.09.15.00.13.093.0 ]--
r 49             cost = terrain.computeTravelCost(loc, nextL)
--[ 2019.11.09.15.00.13.265.0 ]--
r 49             cost = terrain.computeTravelCost(loc, nextLo)
--[ 2019.11.09.15.00.13.312.0 ]--
r 49             cost = terrain.computeTravelCost(loc, nextLoc)
--[ 2019.11.09.15.00.13.704.0 ]--
r 49             cost = terrain.computeTravelCost(loc, nextLoc);
--[ 2019.11.09.15.00.22.190.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.15.00.54.246.0 ]--
+ 49             
--[ 2019.11.09.15.00.54.869.0 ]--
r 49             t
--[ 2019.11.09.15.00.55.128.0 ]--
r 49             tot
--[ 2019.11.09.15.00.55.160.0 ]--
r 49             tota
--[ 2019.11.09.15.00.55.222.0 ]--
r 49             total
--[ 2019.11.09.15.00.55.505.0 ]--
r 49             totalC
--[ 2019.11.09.15.00.55.652.0 ]--
r 49             totalCo
--[ 2019.11.09.15.00.55.747.0 ]--
r 49             totalCos
--[ 2019.11.09.15.00.55.827.0 ]--
r 49             totalCost
--[ 2019.11.09.15.00.55.936.0 ]--
r 49             totalCost 
--[ 2019.11.09.15.00.56.077.0 ]--
r 49             totalCost +
--[ 2019.11.09.15.00.56.266.0 ]--
r 49             totalCost +=
--[ 2019.11.09.15.00.56.337.0 ]--
r 49             totalCost += 
--[ 2019.11.09.15.00.56.619.0 ]--
r 49             totalCost += c
--[ 2019.11.09.15.00.56.690.0 ]--
r 49             totalCost += co
--[ 2019.11.09.15.00.56.910.0 ]--
r 49             totalCost += cos
--[ 2019.11.09.15.00.56.962.0 ]--
r 49             totalCost += cost
--[ 2019.11.09.15.00.57.008.0 ]--
r 49             totalCost += cost;
--[ 2019.11.09.15.01.01.523.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.15.06.10.672.0 ]--
+ 45             
--[ 2019.11.09.15.06.11.517.0 ]--
r 45             t
--[ 2019.11.09.15.06.11.637.0 ]--
r 45             to
--[ 2019.11.09.15.06.11.683.0 ]--
r 45             tot
--[ 2019.11.09.15.06.11.793.0 ]--
r 45             tota
--[ 2019.11.09.15.06.11.855.0 ]--
r 45             total
--[ 2019.11.09.15.06.12.122.0 ]--
r 45             totalC
--[ 2019.11.09.15.06.12.225.0 ]--
r 45             totalCo
--[ 2019.11.09.15.06.12.367.0 ]--
r 45             totalCos
--[ 2019.11.09.15.06.12.444.0 ]--
r 45             totalCost
--[ 2019.11.09.15.06.12.538.0 ]--
r 45             totalCost 
--[ 2019.11.09.15.06.12.663.0 ]--
r 45             totalCost +
--[ 2019.11.09.15.06.12.868.0 ]--
r 45             totalCost +=
--[ 2019.11.09.15.06.12.941.0 ]--
r 45             totalCost += 
--[ 2019.11.09.15.06.13.144.0 ]--
r 45             totalCost += c
--[ 2019.11.09.15.06.13.218.0 ]--
r 45             totalCost += co
--[ 2019.11.09.15.06.13.390.0 ]--
r 45             totalCost += cos
--[ 2019.11.09.15.06.13.452.0 ]--
r 45             totalCost += cost
--[ 2019.11.09.15.06.13.484.0 ]--
r 45             totalCost += cost;
--[ 2019.11.09.15.06.17.625.0 ]--
r 50 
--[ 2019.11.09.15.06.17.808.0 ]--
- 50
--[ 2019.11.09.15.09.50.206.0 ]--
+ 14     
--[ 2019.11.09.15.09.51.468.0 ]--
r 14     f
--[ 2019.11.09.15.09.51.545.0 ]--
r 14     fl
--[ 2019.11.09.15.09.51.748.0 ]--
r 14     flo
--[ 2019.11.09.15.09.51.826.0 ]--
r 14     floa
--[ 2019.11.09.15.09.51.873.0 ]--
r 14     float
--[ 2019.11.09.15.09.51.967.0 ]--
r 14     float 
--[ 2019.11.09.15.09.52.075.0 ]--
r 14     float p
--[ 2019.11.09.15.09.52.165.0 ]--
r 14     float pr
--[ 2019.11.09.15.09.52.258.0 ]--
r 14     float pre
--[ 2019.11.09.15.09.52.456.0 ]--
r 14     float prev
--[ 2019.11.09.15.09.52.690.0 ]--
r 14     float prevC
--[ 2019.11.09.15.09.52.800.0 ]--
r 14     float prevCo
--[ 2019.11.09.15.09.52.955.0 ]--
r 14     float prevCos
--[ 2019.11.09.15.09.53.002.0 ]--
r 14     float prevCost
--[ 2019.11.09.15.09.53.080.0 ]--
r 14     float prevCost;
--[ 2019.11.09.15.10.03.219.0 ]--
r 14     float p;
--[ 2019.11.09.15.10.03.444.0 ]--
r 14     float pre;
--[ 2019.11.09.15.10.03.561.0 ]--
r 14     float prev;
--[ 2019.11.09.15.10.08.031.0 ]--
+ 27         
--[ 2019.11.09.15.10.08.523.0 ]--
r 27         t
--[ 2019.11.09.15.10.08.628.0 ]--
r 27         th
--[ 2019.11.09.15.10.08.698.0 ]--
r 27         thi
--[ 2019.11.09.15.10.08.743.0 ]--
r 27         this
--[ 2019.11.09.15.10.08.882.0 ]--
r 27         this.
--[ 2019.11.09.15.10.09.157.0 ]--
r 27         this.p
--[ 2019.11.09.15.10.09.219.0 ]--
r 27         this.pr
--[ 2019.11.09.15.10.09.344.0 ]--
r 27         this.pre
--[ 2019.11.09.15.10.09.517.0 ]--
r 27         this.prev
--[ 2019.11.09.15.10.09.596.0 ]--
r 27         this.prev 
--[ 2019.11.09.15.10.09.705.0 ]--
r 27         this.prev =
--[ 2019.11.09.15.10.09.783.0 ]--
r 27         this.prev = 
--[ 2019.11.09.15.10.09.924.0 ]--
r 27         this.prev = 0
--[ 2019.11.09.15.10.10.191.0 ]--
r 27         this.prev = 0.
--[ 2019.11.09.15.10.10.495.0 ]--
r 27         this.prev = 0.0
--[ 2019.11.09.15.10.10.638.0 ]--
r 27         this.prev = 0.0f
--[ 2019.11.09.15.10.10.749.0 ]--
r 27         this.prev = 0.0f;
--[ 2019.11.09.15.10.29.831.0 ]--
+ 47             
--[ 2019.11.09.15.10.31.253.0 ]--
r 47             t
--[ 2019.11.09.15.10.31.387.0 ]--
r 47             to
--[ 2019.11.09.15.10.31.481.0 ]--
r 47             tot
--[ 2019.11.09.15.10.31.527.0 ]--
r 47             tota
--[ 2019.11.09.15.10.31.637.0 ]--
r 47             total
--[ 2019.11.09.15.10.31.872.0 ]--
r 47             totalC
--[ 2019.11.09.15.10.32.388.0 ]--
r 47             totalCo
--[ 2019.11.09.15.10.32.459.0 ]--
r 47             totalCos
--[ 2019.11.09.15.10.32.537.0 ]--
r 47             totalCost
--[ 2019.11.09.15.10.32.646.0 ]--
r 47             totalCost 
--[ 2019.11.09.15.10.32.772.0 ]--
r 47             totalCost +
--[ 2019.11.09.15.10.32.972.0 ]--
r 47             totalCost +=
--[ 2019.11.09.15.10.33.028.0 ]--
r 47             totalCost += 
--[ 2019.11.09.15.10.33.462.0 ]--
r 47             totalCost += p
--[ 2019.11.09.15.10.33.535.0 ]--
r 47             totalCost += pr
--[ 2019.11.09.15.10.33.607.0 ]--
r 47             totalCost += pre
--[ 2019.11.09.15.10.33.840.0 ]--
r 47             totalCost += prev
--[ 2019.11.09.15.10.34.440.0 ]--
r 47             totalCost += prev;
--[ 2019.11.09.15.10.40.391.0 ]--
r 48             totalCost += cost
--[ 2019.11.09.15.10.40.889.0 ]--
r 48             totalCost += cos
--[ 2019.11.09.15.10.40.933.0 ]--
r 48             totalCost += co
--[ 2019.11.09.15.10.40.980.0 ]--
r 48             totalCost += c
--[ 2019.11.09.15.10.40.980.1 ]--
r 48             totalCost += 
--[ 2019.11.09.15.10.41.027.0 ]--
r 48             totalCost +=
--[ 2019.11.09.15.10.41.043.0 ]--
r 48             totalCost +
--[ 2019.11.09.15.10.41.074.0 ]--
r 48             totalCost 
--[ 2019.11.09.15.10.41.121.0 ]--
r 48             totalCost
--[ 2019.11.09.15.10.41.152.0 ]--
r 48             totalCos
--[ 2019.11.09.15.10.41.183.0 ]--
r 48             totalCo
--[ 2019.11.09.15.10.41.215.0 ]--
r 48             totalC
--[ 2019.11.09.15.10.41.246.0 ]--
r 48             total
--[ 2019.11.09.15.10.41.450.0 ]--
r 48             tota
--[ 2019.11.09.15.10.41.634.0 ]--
r 48             tot
--[ 2019.11.09.15.10.41.806.0 ]--
r 48             to
--[ 2019.11.09.15.10.41.962.0 ]--
r 48             t
--[ 2019.11.09.15.10.42.118.0 ]--
r 48             
--[ 2019.11.09.15.10.42.822.0 ]--
r 48             f
--[ 2019.11.09.15.10.42.933.0 ]--
r 48             fl
--[ 2019.11.09.15.10.43.121.0 ]--
r 48             flo
--[ 2019.11.09.15.10.43.212.0 ]--
r 48             floa
--[ 2019.11.09.15.10.43.306.0 ]--
r 48             float
--[ 2019.11.09.15.10.43.337.0 ]--
r 48             float 
--[ 2019.11.09.15.10.43.477.0 ]--
r 48             float n
--[ 2019.11.09.15.10.43.555.0 ]--
r 48             float ne
--[ 2019.11.09.15.10.43.649.0 ]--
r 48             float new
--[ 2019.11.09.15.10.43.980.0 ]--
r 48             float newT
--[ 2019.11.09.15.10.44.125.0 ]--
r 48             float newTo
--[ 2019.11.09.15.10.44.188.0 ]--
r 48             float newTot
--[ 2019.11.09.15.10.44.297.0 ]--
r 48             float newTota
--[ 2019.11.09.15.10.44.344.0 ]--
r 48             float newTotal
--[ 2019.11.09.15.10.44.485.0 ]--
r 48             float newTotal 
--[ 2019.11.09.15.10.44.563.0 ]--
r 48             float newTotal =
--[ 2019.11.09.15.10.44.641.0 ]--
r 48             float newTotal = 
--[ 2019.11.09.15.10.47.364.0 ]--
r 48             float newTotal = t
--[ 2019.11.09.15.10.47.437.0 ]--
r 48             float newTotal = to
--[ 2019.11.09.15.10.47.547.0 ]--
r 48             float newTotal = tot
--[ 2019.11.09.15.10.47.593.0 ]--
r 48             float newTotal = tota
--[ 2019.11.09.15.10.47.656.0 ]--
r 48             float newTotal = total
--[ 2019.11.09.15.10.47.954.0 ]--
r 48             float newTotal = totalC
--[ 2019.11.09.15.10.48.073.0 ]--
r 48             float newTotal = totalCo
--[ 2019.11.09.15.10.48.225.0 ]--
r 48             float newTotal = totalCos
--[ 2019.11.09.15.10.48.299.0 ]--
r 48             float newTotal = totalCost
--[ 2019.11.09.15.10.48.389.0 ]--
r 48             float newTotal = totalCost 
--[ 2019.11.09.15.10.48.584.0 ]--
r 48             float newTotal = totalCost +
--[ 2019.11.09.15.10.48.763.0 ]--
r 48             float newTotal = totalCost +=
--[ 2019.11.09.15.10.48.819.0 ]--
r 48             float newTotal = totalCost += 
--[ 2019.11.09.15.10.49.101.0 ]--
r 48             float newTotal = totalCost +=
--[ 2019.11.09.15.10.49.265.0 ]--
r 48             float newTotal = totalCost +
--[ 2019.11.09.15.10.49.517.0 ]--
r 48             float newTotal = totalCost + 
--[ 2019.11.09.15.10.49.763.0 ]--
r 48             float newTotal = totalCost + p
--[ 2019.11.09.15.10.49.860.0 ]--
r 48             float newTotal = totalCost + pr
--[ 2019.11.09.15.10.49.922.0 ]--
r 48             float newTotal = totalCost + pre
--[ 2019.11.09.15.10.50.110.0 ]--
r 48             float newTotal = totalCost + prev
--[ 2019.11.09.15.10.50.141.0 ]--
r 48             float newTotal = totalCost + prev;
--[ 2019.11.09.15.10.51.033.0 ]--
r 48             float newTotal = totalCost + prev
--[ 2019.11.09.15.10.51.526.0 ]--
r 48             float newTotal = totalCost + pre
--[ 2019.11.09.15.10.51.727.0 ]--
r 48             float newTotal = totalCost + pr
--[ 2019.11.09.15.10.51.919.0 ]--
r 48             float newTotal = totalCost + p
--[ 2019.11.09.15.10.52.086.0 ]--
r 48             float newTotal = totalCost + 
--[ 2019.11.09.15.10.53.051.0 ]--
r 48             float newTotal = totalCost + c
--[ 2019.11.09.15.10.53.106.0 ]--
r 48             float newTotal = totalCost + co
--[ 2019.11.09.15.10.53.293.0 ]--
r 48             float newTotal = totalCost + cos
--[ 2019.11.09.15.10.53.356.0 ]--
r 48             float newTotal = totalCost + cost
--[ 2019.11.09.15.10.53.402.0 ]--
r 48             float newTotal = totalCost + cost;
--[ 2019.11.09.15.10.57.952.0 ]--
+ 47             
--[ 2019.11.09.15.10.58.324.0 ]--
r 47             float cost = terrain.computeTravelCost(loc, nextLoc);
--[ 2019.11.09.15.11.13.820.0 ]--
r 44 
--[ 2019.11.09.15.11.14.012.0 ]--
- 44
--[ 2019.11.09.15.11.19.223.0 ]--
r 53 
--[ 2019.11.09.15.11.19.483.0 ]--
- 53
--[ 2019.11.09.15.11.43.546.0 ]--
+ 44         
--[ 2019.11.09.15.11.44.107.0 ]--
r 44         totalCost += prev;
--[ 2019.11.09.15.11.46.378.0 ]--
r 48 
--[ 2019.11.09.15.11.46.517.0 ]--
- 48
--[ 2019.11.09.15.11.48.258.0 ]--
r 43 
--[ 2019.11.09.15.11.48.428.0 ]--
- 43
--[ 2019.11.09.15.12.28.120.0 ]--
+ 48             
--[ 2019.11.09.15.12.30.237.0 ]--
r 48             i
--[ 2019.11.09.15.12.30.341.0 ]--
r 48             if
--[ 2019.11.09.15.12.30.498.0 ]--
r 48             if 
--[ 2019.11.09.15.12.30.607.0 ]--
r 48             if ()
--[ 2019.11.09.15.12.32.514.0 ]--
r 48             if (n)
--[ 2019.11.09.15.12.32.612.0 ]--
r 48             if (ne)
--[ 2019.11.09.15.12.32.690.0 ]--
r 48             if (new)
--[ 2019.11.09.15.12.33.060.0 ]--
r 48             if (newT)
--[ 2019.11.09.15.12.33.527.0 ]--
r 48             if (newTo)
--[ 2019.11.09.15.12.33.607.0 ]--
r 48             if (newTot)
--[ 2019.11.09.15.12.33.693.0 ]--
r 48             if (newTota)
--[ 2019.11.09.15.12.33.780.0 ]--
r 48             if (newTotal)
--[ 2019.11.09.15.12.34.333.0 ]--
r 48             if (newTotal )
--[ 2019.11.09.15.12.34.503.0 ]--
r 48             if (newTotal >)
--[ 2019.11.09.15.12.34.581.0 ]--
r 48             if (newTotal > )
--[ 2019.11.09.15.12.34.737.0 ]--
r 48             if (newTotal > e)
--[ 2019.11.09.15.12.34.847.0 ]--
r 48             if (newTotal > en)
--[ 2019.11.09.15.12.34.956.0 ]--
r 48             if (newTotal > end)
--[ 2019.11.09.15.12.36.090.0 ]--
r 48             if (newTotal > end) 
--[ 2019.11.09.15.12.36.168.0 ]--
r 48             if (newTotal > end) {
--[ 2019.11.09.15.12.36.419.0 ]--
+ 49 
+ 50 }
--[ 2019.11.09.15.12.36.441.0 ]--
r 50             }
--[ 2019.11.09.15.12.36.458.0 ]--
r 49                 
--[ 2019.11.09.15.12.39.987.0 ]--
r 49                 p
--[ 2019.11.09.15.12.40.276.0 ]--
r 49                 pre
--[ 2019.11.09.15.12.40.653.0 ]--
r 49                 pr
--[ 2019.11.09.15.12.40.856.0 ]--
r 49                 p
--[ 2019.11.09.15.12.41.030.0 ]--
r 49                 
--[ 2019.11.09.15.12.41.421.0 ]--
- 49
--[ 2019.11.09.15.12.41.851.0 ]--
r 48             if (newTotal > end) 
--[ 2019.11.09.15.12.42.507.0 ]--
r 48             if (newTotal > end) p
--[ 2019.11.09.15.12.42.617.0 ]--
r 48             if (newTotal > end) pr
--[ 2019.11.09.15.12.42.680.0 ]--
r 48             if (newTotal > end) pre
--[ 2019.11.09.15.12.42.962.0 ]--
r 48             if (newTotal > end) prev
--[ 2019.11.09.15.12.43.219.0 ]--
r 48             if (newTotal > end) prev 
--[ 2019.11.09.15.12.43.405.0 ]--
r 48             if (newTotal > end) prev =
--[ 2019.11.09.15.12.47.155.0 ]--
r 48             if (newTotal > end) prev = 
--[ 2019.11.09.15.12.52.048.0 ]--
+ 44         
--[ 2019.11.09.15.12.52.508.0 ]--
r 44         o
--[ 2019.11.09.15.12.52.815.0 ]--
r 44         
--[ 2019.11.09.15.12.53.050.0 ]--
r 44         p
--[ 2019.11.09.15.12.53.170.0 ]--
r 44         pr
--[ 2019.11.09.15.12.53.263.0 ]--
r 44         pre
--[ 2019.11.09.15.12.53.467.0 ]--
r 44         prev
--[ 2019.11.09.15.12.53.570.0 ]--
r 44         prev 
--[ 2019.11.09.15.12.53.797.0 ]--
r 44         prev =
--[ 2019.11.09.15.12.53.906.0 ]--
r 44         prev = 
--[ 2019.11.09.15.12.54.048.0 ]--
r 44         prev = 0
--[ 2019.11.09.15.12.54.320.0 ]--
r 44         prev = 0.
--[ 2019.11.09.15.12.54.597.0 ]--
r 44         prev = 0.0
--[ 2019.11.09.15.12.54.726.0 ]--
r 44         prev = 0.0f
--[ 2019.11.09.15.12.54.867.0 ]--
r 44         prev = 0.0f;
--[ 2019.11.09.15.13.14.879.0 ]--
r 49             if (newTotal > end) prev = ()
--[ 2019.11.09.15.13.15.148.0 ]--
r 49             if (newTotal > end) prev = (t)
--[ 2019.11.09.15.13.15.931.0 ]--
r 49             if (newTotal > end) prev = (to)
--[ 2019.11.09.15.13.15.996.0 ]--
r 49             if (newTotal > end) prev = (tot)
--[ 2019.11.09.15.13.16.153.0 ]--
r 49             if (newTotal > end) prev = (tota)
--[ 2019.11.09.15.13.16.232.0 ]--
r 49             if (newTotal > end) prev = (total)
--[ 2019.11.09.15.13.16.598.0 ]--
r 49             if (newTotal > end) prev = (totalC)
--[ 2019.11.09.15.13.16.746.0 ]--
r 49             if (newTotal > end) prev = (totalCo)
--[ 2019.11.09.15.13.16.902.0 ]--
r 49             if (newTotal > end) prev = (totalCos)
--[ 2019.11.09.15.13.16.997.0 ]--
r 49             if (newTotal > end) prev = (totalCost)
--[ 2019.11.09.15.13.17.062.0 ]--
r 49             if (newTotal > end) prev = (totalCost )
--[ 2019.11.09.15.13.17.298.0 ]--
r 49             if (newTotal > end) prev = (totalCost +)
--[ 2019.11.09.15.13.17.380.0 ]--
r 49             if (newTotal > end) prev = (totalCost + )
--[ 2019.11.09.15.13.17.926.0 ]--
r 49             if (newTotal > end) prev = (totalCost + c)
--[ 2019.11.09.15.13.18.030.0 ]--
r 49             if (newTotal > end) prev = (totalCost + co)
--[ 2019.11.09.15.13.18.178.0 ]--
r 49             if (newTotal > end) prev = (totalCost + cos)
--[ 2019.11.09.15.13.18.305.0 ]--
r 49             if (newTotal > end) prev = (totalCost + cost)
--[ 2019.11.09.15.13.19.613.0 ]--
r 49             if (newTotal > end) prev = (totalCost + cos)
--[ 2019.11.09.15.13.20.118.0 ]--
r 49             if (newTotal > end) prev = (totalCost + co)
--[ 2019.11.09.15.13.20.177.0 ]--
r 49             if (newTotal > end) prev = (totalCost + c)
--[ 2019.11.09.15.13.20.224.0 ]--
r 49             if (newTotal > end) prev = (totalCost + )
--[ 2019.11.09.15.13.20.239.0 ]--
r 49             if (newTotal > end) prev = (totalCost +)
--[ 2019.11.09.15.13.20.270.0 ]--
r 49             if (newTotal > end) prev = (totalCost )
--[ 2019.11.09.15.13.20.286.0 ]--
r 49             if (newTotal > end) prev = (totalCost)
--[ 2019.11.09.15.13.20.302.0 ]--
r 49             if (newTotal > end) prev = (totalCos)
--[ 2019.11.09.15.13.20.333.0 ]--
r 49             if (newTotal > end) prev = (totalCo)
--[ 2019.11.09.15.13.20.364.0 ]--
r 49             if (newTotal > end) prev = (totalC)
--[ 2019.11.09.15.13.20.395.0 ]--
r 49             if (newTotal > end) prev = (total)
--[ 2019.11.09.15.13.20.442.0 ]--
r 49             if (newTotal > end) prev = (tota)
--[ 2019.11.09.15.13.20.474.0 ]--
r 49             if (newTotal > end) prev = (tot)
--[ 2019.11.09.15.13.20.694.0 ]--
r 49             if (newTotal > end) prev = (to)
--[ 2019.11.09.15.13.20.886.0 ]--
r 49             if (newTotal > end) prev = (t)
--[ 2019.11.09.15.13.21.058.0 ]--
r 49             if (newTotal > end) prev = ()
--[ 2019.11.09.15.13.21.278.0 ]--
r 49             if (newTotal > end) prev = 
--[ 2019.11.09.15.13.21.829.0 ]--
r 49             if (newTotal > end) prev = n
--[ 2019.11.09.15.13.21.911.0 ]--
r 49             if (newTotal > end) prev = ne
--[ 2019.11.09.15.13.22.004.0 ]--
r 49             if (newTotal > end) prev = new
--[ 2019.11.09.15.13.22.397.0 ]--
r 49             if (newTotal > end) prev = newT
--[ 2019.11.09.15.13.22.542.0 ]--
r 49             if (newTotal > end) prev = newTo
--[ 2019.11.09.15.13.22.640.0 ]--
r 49             if (newTotal > end) prev = newTot
--[ 2019.11.09.15.13.22.735.0 ]--
r 49             if (newTotal > end) prev = newTota
--[ 2019.11.09.15.13.22.847.0 ]--
r 49             if (newTotal > end) prev = newTotal
--[ 2019.11.09.15.13.23.223.0 ]--
r 49             if (newTotal > end) prev = newTotal 
--[ 2019.11.09.15.13.23.308.0 ]--
r 49             if (newTotal > end) prev = newTotal -
--[ 2019.11.09.15.13.23.401.0 ]--
r 49             if (newTotal > end) prev = newTotal - 
--[ 2019.11.09.15.13.23.543.0 ]--
r 49             if (newTotal > end) prev = newTotal - e
--[ 2019.11.09.15.13.23.665.0 ]--
r 49             if (newTotal > end) prev = newTotal - en
--[ 2019.11.09.15.13.23.744.0 ]--
r 49             if (newTotal > end) prev = newTotal - end
--[ 2019.11.09.15.13.24.379.0 ]--
r 49             if (newTotal > end) prev = newTotal - end;
--[ 2019.11.09.15.13.25.783.0 ]--
r 50             } 
--[ 2019.11.09.15.13.26.026.0 ]--
r 50             } e
--[ 2019.11.09.15.13.26.072.0 ]--
r 50             } el
--[ 2019.11.09.15.13.26.197.0 ]--
r 50             } els
--[ 2019.11.09.15.13.26.260.0 ]--
r 50             } else
--[ 2019.11.09.15.13.26.385.0 ]--
r 50             } else 
--[ 2019.11.09.15.13.26.589.0 ]--
r 50             } else {
--[ 2019.11.09.15.13.28.384.0 ]--
+ 55             
--[ 2019.11.09.15.13.29.201.0 ]--
r 55             }
--[ 2019.11.09.15.13.29.255.0 ]--
r 50             } else{
--[ 2019.11.09.15.13.29.255.1 ]--
+ 54             } else {
r 55                 nextLoc = null; break; }
--[ 2019.11.09.15.13.29.271.0 ]--
+ 55                 nextLoc = null;
r 56                 break; }
--[ 2019.11.09.15.13.29.287.0 ]--
+ 56                 break;
r 57             }
--[ 2019.11.09.15.13.29.302.0 ]--
r 58         }
--[ 2019.11.09.15.13.34.660.0 ]--
r 50             } else {
--[ 2019.11.09.15.13.37.417.0 ]--
r 58         
--[ 2019.11.09.15.13.37.799.0 ]--
- 58
--[ 2019.11.09.15.13.38.134.0 ]--
r 57             
--[ 2019.11.09.15.13.39.137.0 ]--
r 57             }
--[ 2019.11.09.15.13.43.663.0 ]--
+ 58             
--[ 2019.11.09.15.13.44.650.0 ]--
r 58             }
--[ 2019.11.09.15.13.44.722.0 ]--
r 50             } else{
--[ 2019.11.09.15.13.44.738.0 ]--
r 58         }
--[ 2019.11.09.15.13.47.711.0 ]--
r 58             }
--[ 2019.11.09.15.13.49.961.0 ]--
r 51                 loc = path.dequeue();
r 52                 if (!path.isEmpty()) {
r 53                     nextLoc = path.peek();
r 54                 } else {
r 55                     nextLoc = null;
r 56                     break;
r 57                 }
--[ 2019.11.09.15.13.51.179.0 ]--
r 50             } else {
--[ 2019.11.09.15.13.54.629.0 ]--
r 50             }else {
--[ 2019.11.09.15.13.54.767.0 ]--
r 50             else {
--[ 2019.11.09.15.14.06.687.0 ]--
- 52
r 52                 if (!path.isEmpty()) { nextLoc = path.peek();
--[ 2019.11.09.15.14.07.324.0 ]--
r 52                 if (!path.isEmpty()) {nextLoc = path.peek();
--[ 2019.11.09.15.14.07.606.0 ]--
r 52                 if (!path.isEmpty()) nextLoc = path.peek();
--[ 2019.11.09.15.14.10.177.0 ]--
r 53                  else {
--[ 2019.11.09.15.14.10.329.0 ]--
r 53                 else {
--[ 2019.11.09.15.14.38.296.0 ]--
+ 51                 
--[ 2019.11.09.15.14.38.661.0 ]--
r 51                 t
--[ 2019.11.09.15.14.38.847.0 ]--
r 51                 to
--[ 2019.11.09.15.14.38.883.0 ]--
r 51                 tot
--[ 2019.11.09.15.14.38.980.0 ]--
r 51                 tota
--[ 2019.11.09.15.14.39.151.0 ]--
r 51                 total
--[ 2019.11.09.15.14.39.418.0 ]--
r 51                 totalC
--[ 2019.11.09.15.14.39.481.0 ]--
r 51                 totalCo
--[ 2019.11.09.15.14.39.637.0 ]--
r 51                 totalCos
--[ 2019.11.09.15.14.39.715.0 ]--
r 51                 totalCost
--[ 2019.11.09.15.14.39.856.0 ]--
r 51                 totalCost 
--[ 2019.11.09.15.14.40.014.0 ]--
r 51                 totalCost +
--[ 2019.11.09.15.14.40.155.0 ]--
r 51                 totalCost +=
--[ 2019.11.09.15.14.40.233.0 ]--
r 51                 totalCost += 
--[ 2019.11.09.15.14.40.501.0 ]--
r 51                 totalCost += c
--[ 2019.11.09.15.14.40.594.0 ]--
r 51                 totalCost += co
--[ 2019.11.09.15.14.40.767.0 ]--
r 51                 totalCost += cos
--[ 2019.11.09.15.14.40.815.0 ]--
r 51                 totalCost += cost
--[ 2019.11.09.15.14.40.846.0 ]--
r 51                 totalCost += cost;
--[ 2019.11.09.15.14.44.771.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.15.15.11.313.0 ]--
r 49             if (newTotal > end) {prev = newTotal - end;
--[ 2019.11.09.15.15.11.532.0 ]--
r 49             if (newTotal > end) { prev = newTotal - end;
--[ 2019.11.09.15.15.12.315.0 ]--
r 49             if (newTotal > end) { prev = newTotal - end; 
--[ 2019.11.09.15.15.12.542.0 ]--
r 49             if (newTotal > end) { prev = newTotal - end; b
--[ 2019.11.09.15.15.12.902.0 ]--
r 49             if (newTotal > end) { prev = newTotal - end; br
--[ 2019.11.09.15.15.12.970.0 ]--
r 49             if (newTotal > end) { prev = newTotal - end; bre
--[ 2019.11.09.15.15.13.064.0 ]--
r 49             if (newTotal > end) { prev = newTotal - end; breka
--[ 2019.11.09.15.15.13.220.0 ]--
r 49             if (newTotal > end) { prev = newTotal - end; breka;
--[ 2019.11.09.15.15.13.768.0 ]--
r 49             if (newTotal > end) { prev = newTotal - end; breka
--[ 2019.11.09.15.15.13.956.0 ]--
r 49             if (newTotal > end) { prev = newTotal - end; brek
--[ 2019.11.09.15.15.14.099.0 ]--
r 49             if (newTotal > end) { prev = newTotal - end; bre
--[ 2019.11.09.15.15.14.396.0 ]--
r 49             if (newTotal > end) { prev = newTotal - end; brea
--[ 2019.11.09.15.15.14.542.0 ]--
r 49             if (newTotal > end) { prev = newTotal - end; break
--[ 2019.11.09.15.15.14.621.0 ]--
r 49             if (newTotal > end) { prev = newTotal - end; break;
--[ 2019.11.09.15.15.15.182.0 ]--
r 49             if (newTotal > end) { prev = newTotal - end; break; 
--[ 2019.11.09.15.15.15.389.0 ]--
r 49             if (newTotal > end) { prev = newTotal - end; break; }
--[ 2019.11.09.15.15.24.469.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.15.26.27.997.0 ]--
r 49             if (newTotal > end) { prev = e; break; }
--[ 2019.11.09.15.26.28.267.0 ]--
r 49             if (newTotal > end) { prev = end; break; }
--[ 2019.11.09.15.26.28.291.0 ]--
r 49             if (newTotal > end) { prev = end ; break; }
--[ 2019.11.09.15.26.28.351.0 ]--
r 49             if (newTotal > end) { prev = end -; break; }
--[ 2019.11.09.15.26.28.469.0 ]--
r 49             if (newTotal > end) { prev = end - ; break; }
--[ 2019.11.09.15.26.28.673.0 ]--
r 49             if (newTotal > end) { prev = end - t; break; }
--[ 2019.11.09.15.26.28.777.0 ]--
r 49             if (newTotal > end) { prev = end - to; break; }
--[ 2019.11.09.15.26.28.922.0 ]--
r 49             if (newTotal > end) { prev = end - tot; break; }
--[ 2019.11.09.15.26.29.033.0 ]--
r 49             if (newTotal > end) { prev = end - tota; break; }
--[ 2019.11.09.15.26.29.192.0 ]--
r 49             if (newTotal > end) { prev = end - total; break; }
--[ 2019.11.09.15.26.29.426.0 ]--
r 49             if (newTotal > end) { prev = end - totalC; break; }
--[ 2019.11.09.15.26.29.567.0 ]--
r 49             if (newTotal > end) { prev = end - totalCo; break; }
--[ 2019.11.09.15.26.29.661.0 ]--
r 49             if (newTotal > end) { prev = end - totalCos; break; }
--[ 2019.11.09.15.26.29.740.0 ]--
r 49             if (newTotal > end) { prev = end - totalCost; break; }
--[ 2019.11.09.15.26.37.467.0 ]--
r 49             if (t > end) { prev = end - totalCost; break; }
--[ 2019.11.09.15.26.37.540.0 ]--
r 49             if (to > end) { prev = end - totalCost; break; }
--[ 2019.11.09.15.26.37.684.0 ]--
r 49             if (tot > end) { prev = end - totalCost; break; }
--[ 2019.11.09.15.26.37.749.0 ]--
r 49             if (tota > end) { prev = end - totalCost; break; }
--[ 2019.11.09.15.26.37.854.0 ]--
r 49             if (total > end) { prev = end - totalCost; break; }
--[ 2019.11.09.15.26.38.077.0 ]--
r 49             if (totalC > end) { prev = end - totalCost; break; }
--[ 2019.11.09.15.26.38.306.0 ]--
r 49             if (totalCo > end) { prev = end - totalCost; break; }
--[ 2019.11.09.15.26.38.329.0 ]--
r 49             if (totalCos > end) { prev = end - totalCost; break; }
--[ 2019.11.09.15.26.38.416.0 ]--
r 49             if (totalCost > end) { prev = end - totalCost; break; }
--[ 2019.11.09.15.26.38.528.0 ]--
r 49             if (totalCost  > end) { prev = end - totalCost; break; }
--[ 2019.11.09.15.26.38.661.0 ]--
r 49             if (totalCost + > end) { prev = end - totalCost; break; }
--[ 2019.11.09.15.26.38.773.0 ]--
r 49             if (totalCost +  > end) { prev = end - totalCost; break; }
--[ 2019.11.09.15.26.38.930.0 ]--
r 49             if (totalCost + c > end) { prev = end - totalCost; break; }
--[ 2019.11.09.15.26.38.992.0 ]--
r 49             if (totalCost + co > end) { prev = end - totalCost; break; }
--[ 2019.11.09.15.26.39.180.0 ]--
r 49             if (totalCost + cos > end) { prev = end - totalCost; break; }
--[ 2019.11.09.15.26.39.306.0 ]--
r 49             if (totalCost + cost > end) { prev = end - totalCost; break; }
--[ 2019.11.09.15.26.42.199.0 ]--
r 48 
--[ 2019.11.09.15.26.42.333.0 ]--
- 48
--[ 2019.11.09.15.26.57.134.0 ]--
r 50                 totalCost += (cost;
--[ 2019.11.09.15.26.59.250.0 ]--
r 50                 totalCost += (cost ;
--[ 2019.11.09.15.26.59.313.0 ]--
r 50                 totalCost += (cost -;
--[ 2019.11.09.15.26.59.407.0 ]--
r 50                 totalCost += (cost - ;
--[ 2019.11.09.15.26.59.783.0 ]--
r 50                 totalCost += (cost - p;
--[ 2019.11.09.15.26.59.862.0 ]--
r 50                 totalCost += (cost - pr;
--[ 2019.11.09.15.26.59.924.0 ]--
r 50                 totalCost += (cost - pre;
--[ 2019.11.09.15.27.00.144.0 ]--
r 50                 totalCost += (cost - prev;
--[ 2019.11.09.15.27.00.286.0 ]--
r 50                 totalCost += (cost - prev);
--[ 2019.11.09.15.27.01.397.0 ]--
+ 51                 
--[ 2019.11.09.15.27.02.171.0 ]--
r 51                 p
--[ 2019.11.09.15.27.02.297.0 ]--
r 51                 pr
--[ 2019.11.09.15.27.02.391.0 ]--
r 51                 pre
--[ 2019.11.09.15.27.02.610.0 ]--
r 51                 prev
--[ 2019.11.09.15.27.02.699.0 ]--
r 51                 prev 
--[ 2019.11.09.15.27.02.777.0 ]--
r 51                 prev =
--[ 2019.11.09.15.27.02.917.0 ]--
r 51                 prev = 
--[ 2019.11.09.15.27.03.000.0 ]--
r 51                 prev = 0
--[ 2019.11.09.15.27.03.292.0 ]--
r 51                 prev = 0.
--[ 2019.11.09.15.27.03.514.0 ]--
r 51                 prev = 0.0
--[ 2019.11.09.15.27.03.628.0 ]--
r 51                 prev = 0.0f
--[ 2019.11.09.15.27.03.735.0 ]--
r 51                 prev = 0.0f;
--[ 2019.11.09.15.27.09.305.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.15.27.21.725.0 ]--
+ 60         
--[ 2019.11.09.15.27.22.132.0 ]--
r 60         S
--[ 2019.11.09.15.27.22.454.0 ]--
r 60         St
--[ 2019.11.09.15.27.22.787.0 ]--
r 60         Std
--[ 2019.11.09.15.27.23.026.0 ]--
r 60         Stdo
--[ 2019.11.09.15.27.23.151.0 ]--
r 60         Stdou
--[ 2019.11.09.15.27.23.229.0 ]--
r 60         Stdout
--[ 2019.11.09.15.27.23.370.0 ]--
r 60         Stdout.
--[ 2019.11.09.15.27.23.621.0 ]--
r 60         Stdout.p
--[ 2019.11.09.15.27.23.764.0 ]--
r 60         Stdout.pr
--[ 2019.11.09.15.27.23.827.0 ]--
r 60         Stdout.pri
--[ 2019.11.09.15.27.23.936.0 ]--
r 60         Stdout.prin
--[ 2019.11.09.15.27.24.139.0 ]--
r 60         Stdout.print
--[ 2019.11.09.15.27.24.186.0 ]--
r 60         Stdout.printl
--[ 2019.11.09.15.27.24.249.0 ]--
r 60         Stdout.println
--[ 2019.11.09.15.27.24.602.0 ]--
r 60         Stdout.printl
--[ 2019.11.09.15.27.25.134.0 ]--
r 60         Stdout.print
--[ 2019.11.09.15.27.25.164.0 ]--
r 60         Stdout.prin
--[ 2019.11.09.15.27.25.226.0 ]--
r 60         Stdout.pri
--[ 2019.11.09.15.27.25.273.0 ]--
r 60         Stdout.p
--[ 2019.11.09.15.27.25.289.0 ]--
r 60         Stdout.
--[ 2019.11.09.15.27.25.335.0 ]--
r 60         Stdout
--[ 2019.11.09.15.27.25.367.0 ]--
r 60         Stdou
--[ 2019.11.09.15.27.25.460.0 ]--
r 60         Stdo
--[ 2019.11.09.15.27.25.648.0 ]--
r 60         Std
--[ 2019.11.09.15.27.26.198.0 ]--
r 60         StdO
--[ 2019.11.09.15.27.26.417.0 ]--
r 60         StdOu
--[ 2019.11.09.15.27.26.502.0 ]--
r 60         StdOut
--[ 2019.11.09.15.27.26.612.0 ]--
r 60         StdOut.
--[ 2019.11.09.15.27.26.847.0 ]--
r 60         StdOut.p
--[ 2019.11.09.15.27.27.066.0 ]--
r 60         StdOut.pri
--[ 2019.11.09.15.27.27.209.0 ]--
r 60         StdOut.prin
--[ 2019.11.09.15.27.27.320.0 ]--
r 60         StdOut.print
--[ 2019.11.09.15.27.27.412.0 ]--
r 60         StdOut.printl
--[ 2019.11.09.15.27.27.506.0 ]--
r 60         StdOut.println
--[ 2019.11.09.15.27.27.694.0 ]--
r 60         StdOut.println()
--[ 2019.11.09.15.27.27.964.0 ]--
r 60         StdOut.println("")
--[ 2019.11.09.15.27.28.839.0 ]--
r 60         StdOut.println("l")
--[ 2019.11.09.15.27.28.970.0 ]--
r 60         StdOut.println("lo")
--[ 2019.11.09.15.27.29.032.0 ]--
r 60         StdOut.println("loc")
--[ 2019.11.09.15.27.29.173.0 ]--
r 60         StdOut.println("loc:")
--[ 2019.11.09.15.27.29.282.0 ]--
r 60         StdOut.println("loc: ")
--[ 2019.11.09.15.27.29.666.0 ]--
r 60         StdOut.println("loc: " )
--[ 2019.11.09.15.27.29.822.0 ]--
r 60         StdOut.println("loc: " +)
--[ 2019.11.09.15.27.29.962.0 ]--
r 60         StdOut.println("loc: " + )
--[ 2019.11.09.15.27.30.088.0 ]--
r 60         StdOut.println("loc: " + t)
--[ 2019.11.09.15.27.30.174.0 ]--
r 60         StdOut.println("loc: " + th)
--[ 2019.11.09.15.27.30.221.0 ]--
r 60         StdOut.println("loc: " + thi)
--[ 2019.11.09.15.27.30.315.0 ]--
r 60         StdOut.println("loc: " + this)
--[ 2019.11.09.15.27.30.628.0 ]--
r 60         StdOut.println("loc: " + thi)
--[ 2019.11.09.15.27.30.800.0 ]--
r 60         StdOut.println("loc: " + th)
--[ 2019.11.09.15.27.30.979.0 ]--
r 60         StdOut.println("loc: " + t)
--[ 2019.11.09.15.27.31.293.0 ]--
r 60         StdOut.println("loc: " + )
--[ 2019.11.09.15.27.31.517.0 ]--
r 60         StdOut.println("loc: " + g)
--[ 2019.11.09.15.27.31.687.0 ]--
r 60         StdOut.println("loc: " + ge)
--[ 2019.11.09.15.27.31.765.0 ]--
r 60         StdOut.println("loc: " + get)
--[ 2019.11.09.15.27.32.015.0 ]--
r 60         StdOut.println("loc: " + getL)
--[ 2019.11.09.15.27.32.174.0 ]--
r 60         StdOut.println("loc: " + getLo)
--[ 2019.11.09.15.27.32.224.0 ]--
r 60         StdOut.println("loc: " + getLoc)
--[ 2019.11.09.15.27.32.445.0 ]--
r 60         StdOut.println("loc: " + getLoca)
--[ 2019.11.09.15.27.32.554.0 ]--
r 60         StdOut.println("loc: " + getLocat)
--[ 2019.11.09.15.27.32.606.0 ]--
r 60         StdOut.println("loc: " + getLocati)
--[ 2019.11.09.15.27.32.653.0 ]--
r 60         StdOut.println("loc: " + getLocatio)
--[ 2019.11.09.15.27.32.700.0 ]--
r 60         StdOut.println("loc: " + getLocation)
--[ 2019.11.09.15.27.33.056.0 ]--
r 60         StdOut.println("loc: " + getLocation())
--[ 2019.11.09.15.27.33.541.0 ]--
r 60         StdOut.println("loc: " + getLocation());
--[ 2019.11.09.15.27.36.950.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.15.27.51.769.0 ]--
r 60 
--[ 2019.11.09.15.27.51.904.0 ]--
- 60
--[ 2019.11.09.15.28.18.744.0 ]--
+ 46         
--[ 2019.11.09.15.28.19.412.0 ]--
r 46         S
--[ 2019.11.09.15.28.19.632.0 ]--
r 46         St
--[ 2019.11.09.15.28.19.804.0 ]--
r 46         Std
--[ 2019.11.09.15.28.19.991.0 ]--
r 46         StdO
--[ 2019.11.09.15.28.20.196.0 ]--
r 46         StdOu
--[ 2019.11.09.15.28.20.280.0 ]--
r 46         StdOut
--[ 2019.11.09.15.28.20.420.0 ]--
r 46         StdOut.
--[ 2019.11.09.15.28.20.718.0 ]--
r 46         StdOut.p
--[ 2019.11.09.15.28.20.768.0 ]--
r 46         StdOut.pr
--[ 2019.11.09.15.28.20.862.0 ]--
r 46         StdOut.pri
--[ 2019.11.09.15.28.20.956.0 ]--
r 46         StdOut.prin
--[ 2019.11.09.15.28.21.049.0 ]--
r 46         StdOut.print
--[ 2019.11.09.15.28.21.143.0 ]--
r 46         StdOut.printl
--[ 2019.11.09.15.28.21.254.0 ]--
r 46         StdOut.println
--[ 2019.11.09.15.28.22.217.0 ]--
r 46         StdOut.println9
--[ 2019.11.09.15.28.22.550.0 ]--
r 46         StdOut.println9""
--[ 2019.11.09.15.28.22.866.0 ]--
r 46         StdOut.println9
--[ 2019.11.09.15.28.23.017.0 ]--
r 46         StdOut.println
--[ 2019.11.09.15.28.23.361.0 ]--
r 46         StdOut.println()
--[ 2019.11.09.15.28.23.943.0 ]--
r 46         StdOut.println("")
--[ 2019.11.09.15.28.24.309.0 ]--
r 46         StdOut.println("c")
--[ 2019.11.09.15.28.24.380.0 ]--
r 46         StdOut.println("co")
--[ 2019.11.09.15.28.24.539.0 ]--
r 46         StdOut.println("cos")
--[ 2019.11.09.15.28.24.680.0 ]--
r 46         StdOut.println("cost")
--[ 2019.11.09.15.28.24.852.0 ]--
r 46         StdOut.println("cost ")
--[ 2019.11.09.15.28.24.883.0 ]--
r 46         StdOut.println("cost a")
--[ 2019.11.09.15.28.25.134.0 ]--
r 46         StdOut.println("cost an")
--[ 2019.11.09.15.28.25.281.0 ]--
r 46         StdOut.println("cost and")
--[ 2019.11.09.15.28.25.437.0 ]--
r 46         StdOut.println("cost and ")
--[ 2019.11.09.15.28.25.515.0 ]--
r 46         StdOut.println("cost and e")
--[ 2019.11.09.15.28.25.640.0 ]--
r 46         StdOut.println("cost and en")
--[ 2019.11.09.15.28.25.718.0 ]--
r 46         StdOut.println("cost and end")
--[ 2019.11.09.15.28.25.923.0 ]--
r 46         StdOut.println("cost and end:")
--[ 2019.11.09.15.28.26.044.0 ]--
r 46         StdOut.println("cost and end: ")
--[ 2019.11.09.15.28.26.654.0 ]--
r 46         StdOut.println("cost and end: " )
--[ 2019.11.09.15.28.26.791.0 ]--
r 46         StdOut.println("cost and end: " +)
--[ 2019.11.09.15.28.26.932.0 ]--
r 46         StdOut.println("cost and end: " + )
--[ 2019.11.09.15.28.27.198.0 ]--
r 46         StdOut.println("cost and end: " + t)
--[ 2019.11.09.15.28.27.260.0 ]--
r 46         StdOut.println("cost and end: " + to)
--[ 2019.11.09.15.28.27.432.0 ]--
r 46         StdOut.println("cost and end: " + tot)
--[ 2019.11.09.15.28.27.479.0 ]--
r 46         StdOut.println("cost and end: " + tota)
--[ 2019.11.09.15.28.27.635.0 ]--
r 46         StdOut.println("cost and end: " + total)
--[ 2019.11.09.15.28.27.838.0 ]--
r 46         StdOut.println("cost and end: " + totalC)
--[ 2019.11.09.15.28.27.962.0 ]--
r 46         StdOut.println("cost and end: " + totalCo)
--[ 2019.11.09.15.28.28.106.0 ]--
r 46         StdOut.println("cost and end: " + totalCos)
--[ 2019.11.09.15.28.28.176.0 ]--
r 46         StdOut.println("cost and end: " + totalCost)
--[ 2019.11.09.15.28.28.346.0 ]--
r 46         StdOut.println("cost and end: " + totalCost )
--[ 2019.11.09.15.28.28.529.0 ]--
r 46         StdOut.println("cost and end: " + totalCost +)
--[ 2019.11.09.15.28.28.621.0 ]--
r 46         StdOut.println("cost and end: " + totalCost + )
--[ 2019.11.09.15.28.28.815.0 ]--
r 46         StdOut.println("cost and end: " + totalCost + '')
--[ 2019.11.09.15.28.29.077.0 ]--
r 46         StdOut.println("cost and end: " + totalCost + ' ')
--[ 2019.11.09.15.28.29.249.0 ]--
r 46         StdOut.println("cost and end: " + totalCost + ' ' )
--[ 2019.11.09.15.28.29.467.0 ]--
r 46         StdOut.println("cost and end: " + totalCost + ' ' +)
--[ 2019.11.09.15.28.29.561.0 ]--
r 46         StdOut.println("cost and end: " + totalCost + ' ' + )
--[ 2019.11.09.15.28.29.931.0 ]--
r 46         StdOut.println("cost and end: " + totalCost + ' ' + e)
--[ 2019.11.09.15.28.30.038.0 ]--
r 46         StdOut.println("cost and end: " + totalCost + ' ' + en)
--[ 2019.11.09.15.28.30.116.0 ]--
r 46         StdOut.println("cost and end: " + totalCost + ' ' + end)
--[ 2019.11.09.15.28.31.008.0 ]--
r 46         StdOut.println("cost and end: " + totalCost + ' ' + end);l
--[ 2019.11.09.15.28.31.812.0 ]--
r 46         StdOut.println("cost and end: " + totalCost + ' ' + end);
--[ 2019.11.09.15.28.35.142.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.15.28.59.778.0 ]--
+ 49             
--[ 2019.11.09.15.29.00.225.0 ]--
r 49             S
--[ 2019.11.09.15.29.00.437.0 ]--
r 49             St
--[ 2019.11.09.15.29.00.593.0 ]--
r 49             Std
--[ 2019.11.09.15.29.00.814.0 ]--
r 49             StdO
--[ 2019.11.09.15.29.01.013.0 ]--
r 49             StdOu
--[ 2019.11.09.15.29.01.169.0 ]--
r 49             StdOut
--[ 2019.11.09.15.29.01.234.0 ]--
r 49             StdOut.
--[ 2019.11.09.15.29.01.504.0 ]--
r 49             StdOut.p
--[ 2019.11.09.15.29.01.596.0 ]--
r 49             StdOut.pr
--[ 2019.11.09.15.29.01.721.0 ]--
r 49             StdOut.pri
--[ 2019.11.09.15.29.01.784.0 ]--
r 49             StdOut.prin
--[ 2019.11.09.15.29.01.877.0 ]--
r 49             StdOut.print
--[ 2019.11.09.15.29.01.971.0 ]--
r 49             StdOut.printl
--[ 2019.11.09.15.29.02.049.0 ]--
r 49             StdOut.println
--[ 2019.11.09.15.29.02.285.0 ]--
r 49             StdOut.println()
--[ 2019.11.09.15.29.02.698.0 ]--
r 49             StdOut.println("")
--[ 2019.11.09.15.29.03.739.0 ]--
r 49             StdOut.println("c")
--[ 2019.11.09.15.29.03.796.0 ]--
r 49             StdOut.println("co")
--[ 2019.11.09.15.29.03.902.0 ]--
r 49             StdOut.println("cos")
--[ 2019.11.09.15.29.04.074.0 ]--
r 49             StdOut.println("cost")
--[ 2019.11.09.15.29.04.286.0 ]--
r 49             StdOut.println("cost:")
--[ 2019.11.09.15.29.04.458.0 ]--
r 49             StdOut.println("cost: ")
--[ 2019.11.09.15.29.04.826.0 ]--
r 49             StdOut.println("cost: " )
--[ 2019.11.09.15.29.05.015.0 ]--
r 49             StdOut.println("cost: " +)
--[ 2019.11.09.15.29.05.134.0 ]--
r 49             StdOut.println("cost: " + )
--[ 2019.11.09.15.29.05.307.0 ]--
r 49             StdOut.println("cost: " + c)
--[ 2019.11.09.15.29.05.399.0 ]--
r 49             StdOut.println("cost: " + co)
--[ 2019.11.09.15.29.05.572.0 ]--
r 49             StdOut.println("cost: " + cos)
--[ 2019.11.09.15.29.06.015.0 ]--
r 49             StdOut.println("cost: " + co)
--[ 2019.11.09.15.29.06.196.0 ]--
r 49             StdOut.println("cost: " + c)
--[ 2019.11.09.15.29.06.336.0 ]--
r 49             StdOut.println("cost: " + )
--[ 2019.11.09.15.29.06.524.0 ]--
r 49             StdOut.println("cost: " + c)
--[ 2019.11.09.15.29.06.649.0 ]--
r 49             StdOut.println("cost: " + co)
--[ 2019.11.09.15.29.06.776.0 ]--
r 49             StdOut.println("cost: " + cos)
--[ 2019.11.09.15.29.06.857.0 ]--
r 49             StdOut.println("cost: " + cost)
--[ 2019.11.09.15.29.07.254.0 ]--
r 49             StdOut.println("cost: " + cost);
--[ 2019.11.09.15.29.10.689.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.15.30.06.557.0 ]--
+ 47         
--[ 2019.11.09.15.30.07.053.0 ]--
r 47         S
--[ 2019.11.09.15.30.07.277.0 ]--
r 47         St
--[ 2019.11.09.15.30.07.489.0 ]--
r 47         Std
--[ 2019.11.09.15.30.07.900.0 ]--
r 47         St
--[ 2019.11.09.15.30.08.056.0 ]--
r 47         S
--[ 2019.11.09.15.30.08.265.0 ]--
r 47         
--[ 2019.11.09.15.30.08.786.0 ]--
- 47
--[ 2019.11.09.15.30.11.688.0 ]--
r 44 
--[ 2019.11.09.15.30.11.839.0 ]--
- 44
--[ 2019.11.09.15.30.16.650.0 ]--
+ 46         
--[ 2019.11.09.15.30.16.932.0 ]--
r 46         S
--[ 2019.11.09.15.30.17.147.0 ]--
r 46         St
--[ 2019.11.09.15.30.17.402.0 ]--
r 46         Std
--[ 2019.11.09.15.30.17.511.0 ]--
r 46         StdO
--[ 2019.11.09.15.30.17.728.0 ]--
r 46         StdOu
--[ 2019.11.09.15.30.17.822.0 ]--
r 46         StdOut
--[ 2019.11.09.15.30.17.947.0 ]--
r 46         StdOut.
--[ 2019.11.09.15.30.18.199.0 ]--
r 46         StdOut.p
--[ 2019.11.09.15.30.18.289.0 ]--
r 46         StdOut.pr
--[ 2019.11.09.15.30.18.400.0 ]--
r 46         StdOut.pri
--[ 2019.11.09.15.30.18.498.0 ]--
r 46         StdOut.prin
--[ 2019.11.09.15.30.18.624.0 ]--
r 46         StdOut.print
--[ 2019.11.09.15.30.18.747.0 ]--
r 46         StdOut.printl
--[ 2019.11.09.15.30.18.801.0 ]--
r 46         StdOut.println
--[ 2019.11.09.15.30.19.033.0 ]--
r 46         StdOut.println()
--[ 2019.11.09.15.30.19.255.0 ]--
r 46         StdOut.println("")
--[ 2019.11.09.15.30.19.547.0 ]--
r 46         StdOut.println("p")
--[ 2019.11.09.15.30.19.642.0 ]--
r 46         StdOut.println("pr")
--[ 2019.11.09.15.30.19.742.0 ]--
r 46         StdOut.println("pre")
--[ 2019.11.09.15.30.19.945.0 ]--
r 46         StdOut.println("prev")
--[ 2019.11.09.15.30.20.164.0 ]--
r 46         StdOut.println("prev:")
--[ 2019.11.09.15.30.20.509.0 ]--
r 46         StdOut.println("prev: ")
--[ 2019.11.09.15.30.21.114.0 ]--
r 46         StdOut.println("prev: " )
--[ 2019.11.09.15.30.21.246.0 ]--
r 46         StdOut.println("prev: " +)
--[ 2019.11.09.15.30.21.371.0 ]--
r 46         StdOut.println("prev: " + )
--[ 2019.11.09.15.30.21.543.0 ]--
r 46         StdOut.println("prev: " + p)
--[ 2019.11.09.15.30.21.763.0 ]--
r 46         StdOut.println("prev: " + pr)
--[ 2019.11.09.15.30.21.825.0 ]--
r 46         StdOut.println("prev: " + pre)
--[ 2019.11.09.15.30.22.045.0 ]--
r 46         StdOut.println("prev: " + prev)
--[ 2019.11.09.15.30.24.107.0 ]--
r 46         StdOut.println("prev: " + prev);
--[ 2019.11.09.15.31.04.822.0 ]--
r 50             if (totalCost + (cost > end) { prev = end - totalCost; break; }
--[ 2019.11.09.15.31.06.944.0 ]--
r 50             if (totalCost + (cost  > end) { prev = end - totalCost; break; }
--[ 2019.11.09.15.31.07.050.0 ]--
r 50             if (totalCost + (cost - > end) { prev = end - totalCost; break; }
--[ 2019.11.09.15.31.07.123.0 ]--
r 50             if (totalCost + (cost -  > end) { prev = end - totalCost; break; }
--[ 2019.11.09.15.31.07.484.0 ]--
r 50             if (totalCost + (cost - p > end) { prev = end - totalCost; break; }
--[ 2019.11.09.15.31.07.548.0 ]--
r 50             if (totalCost + (cost - pr > end) { prev = end - totalCost; break; }
--[ 2019.11.09.15.31.07.677.0 ]--
r 50             if (totalCost + (cost - pre > end) { prev = end - totalCost; break; }
--[ 2019.11.09.15.31.07.842.0 ]--
r 50             if (totalCost + (cost - prev > end) { prev = end - totalCost; break; }
--[ 2019.11.09.15.31.08.015.0 ]--
r 50             if (totalCost + (cost - prev) > end) { prev = end - totalCost; break; }
--[ 2019.11.09.15.31.16.884.0 ]--
- 45
r 45 
--[ 2019.11.09.15.31.17.128.0 ]--
- 45
--[ 2019.11.09.15.31.20.190.0 ]--
r 47 
--[ 2019.11.09.15.31.20.352.0 ]--
- 47
--[ 2019.11.09.15.31.31.090.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.15.31.49.745.0 ]--
+ 47 
--[ 2019.11.09.15.31.50.124.0 ]--
r 47             StdOut.println("cost: " + cost);
--[ 2019.11.09.15.31.50.766.0 ]--
+ 45 
--[ 2019.11.09.15.31.51.080.0 ]--
+ 45         StdOut.println("cost and end: " + totalCost + ' ' + end);
r 46         StdOut.println("prev: " + prev);
--[ 2019.11.09.15.31.52.109.0 ]--
r 50             if (totalCost + (cost > end) { prev = end - totalCost; break; }
--[ 2019.11.09.15.31.53.058.0 ]--
r 50             if (totalCost + (cost - prev) > end) { prev = end - totalCost; break; }
--[ 2019.11.09.15.31.56.309.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.15.32.24.253.0 ]--
r 49             StdOut.println("cost: " + cost );
--[ 2019.11.09.15.32.24.489.0 ]--
r 49             StdOut.println("cost: " + cost - );
--[ 2019.11.09.15.32.24.623.0 ]--
r 49             StdOut.println("cost: " + cost - p);
--[ 2019.11.09.15.32.24.795.0 ]--
r 49             StdOut.println("cost: " + cost - pr);
--[ 2019.11.09.15.32.24.826.0 ]--
r 49             StdOut.println("cost: " + cost - pre);
--[ 2019.11.09.15.32.25.109.0 ]--
r 49             StdOut.println("cost: " + cost - prev);
--[ 2019.11.09.15.32.27.934.0 ]--
r 49             StdOut.println("cost: " + cost - pre);
--[ 2019.11.09.15.32.28.424.0 ]--
r 49             StdOut.println("cost: " + cost - pr);
--[ 2019.11.09.15.32.28.457.0 ]--
r 49             StdOut.println("cost: " + cost - p);
--[ 2019.11.09.15.32.28.489.0 ]--
r 49             StdOut.println("cost: " + cost - );
--[ 2019.11.09.15.32.28.521.0 ]--
r 49             StdOut.println("cost: " + cost -);
--[ 2019.11.09.15.32.28.556.0 ]--
r 49             StdOut.println("cost: " + cost );
--[ 2019.11.09.15.32.28.587.0 ]--
r 49             StdOut.println("cost: " + cost);
--[ 2019.11.09.15.32.28.621.0 ]--
r 49             StdOut.println("cost: " + cos);
--[ 2019.11.09.15.32.28.654.0 ]--
r 49             StdOut.println("cost: " + co);
--[ 2019.11.09.15.32.28.872.0 ]--
r 49             StdOut.println("cost: " + c);
--[ 2019.11.09.15.32.29.211.0 ]--
r 49             StdOut.println("cost: " + );
--[ 2019.11.09.15.32.29.705.0 ]--
r 49             StdOut.println("cost: " + ());
--[ 2019.11.09.15.32.29.908.0 ]--
r 49             StdOut.println("cost: " + (c));
--[ 2019.11.09.15.32.30.034.0 ]--
r 49             StdOut.println("cost: " + (co));
--[ 2019.11.09.15.32.30.409.0 ]--
r 49             StdOut.println("cost: " + (cos));
--[ 2019.11.09.15.32.30.452.0 ]--
r 49             StdOut.println("cost: " + (cost));
--[ 2019.11.09.15.32.30.672.0 ]--
r 49             StdOut.println("cost: " + (cost-));
--[ 2019.11.09.15.32.30.964.0 ]--
r 49             StdOut.println("cost: " + (cost-p));
--[ 2019.11.09.15.32.31.042.0 ]--
r 49             StdOut.println("cost: " + (cost-pr));
--[ 2019.11.09.15.32.31.120.0 ]--
r 49             StdOut.println("cost: " + (cost-pre));
--[ 2019.11.09.15.32.31.371.0 ]--
r 49             StdOut.println("cost: " + (cost-prev));
--[ 2019.11.09.15.32.33.655.0 ]--
+ 50             
--[ 2019.11.09.15.32.34.380.0 ]--
r 50             S
--[ 2019.11.09.15.32.34.679.0 ]--
r 50             St
--[ 2019.11.09.15.32.34.835.0 ]--
r 50             Std
--[ 2019.11.09.15.32.35.022.0 ]--
r 50             StdO
--[ 2019.11.09.15.32.35.220.0 ]--
r 50             StdOu
--[ 2019.11.09.15.32.35.299.0 ]--
r 50             StdOut
--[ 2019.11.09.15.32.35.414.0 ]--
r 50             StdOut.
--[ 2019.11.09.15.32.35.697.0 ]--
r 50             StdOut.p
--[ 2019.11.09.15.32.35.744.0 ]--
r 50             StdOut.pr
--[ 2019.11.09.15.32.35.884.0 ]--
r 50             StdOut.pri
--[ 2019.11.09.15.32.35.963.0 ]--
r 50             StdOut.prin
--[ 2019.11.09.15.32.36.072.0 ]--
r 50             StdOut.print
--[ 2019.11.09.15.32.36.150.0 ]--
r 50             StdOut.printl
--[ 2019.11.09.15.32.36.197.0 ]--
r 50             StdOut.println
--[ 2019.11.09.15.32.36.384.0 ]--
r 50             StdOut.println()
--[ 2019.11.09.15.32.36.605.0 ]--
r 50             StdOut.println("")
--[ 2019.11.09.15.32.36.831.0 ]--
r 50             StdOut.println("c")
--[ 2019.11.09.15.32.36.883.0 ]--
r 50             StdOut.println("ch")
--[ 2019.11.09.15.32.37.109.0 ]--
r 50             StdOut.println("che")
--[ 2019.11.09.15.32.37.379.0 ]--
r 50             StdOut.println("chec")
--[ 2019.11.09.15.32.37.490.0 ]--
r 50             StdOut.println("check")
--[ 2019.11.09.15.32.37.787.0 ]--
r 50             StdOut.println("check:")
--[ 2019.11.09.15.32.38.003.0 ]--
r 50             StdOut.println("check: ")
--[ 2019.11.09.15.32.38.384.0 ]--
r 50             StdOut.println("check: " )
--[ 2019.11.09.15.32.38.645.0 ]--
r 50             StdOut.println("check: " +)
--[ 2019.11.09.15.32.38.754.0 ]--
r 50             StdOut.println("check: " + )
--[ 2019.11.09.15.32.39.139.0 ]--
r 50             StdOut.println("check: " + t)
--[ 2019.11.09.15.32.39.248.0 ]--
r 50             StdOut.println("check: " + to)
--[ 2019.11.09.15.32.39.342.0 ]--
r 50             StdOut.println("check: " + tot)
--[ 2019.11.09.15.32.39.404.0 ]--
r 50             StdOut.println("check: " + tota)
--[ 2019.11.09.15.32.39.498.0 ]--
r 50             StdOut.println("check: " + total)
--[ 2019.11.09.15.32.39.796.0 ]--
r 50             StdOut.println("check: " + totalC)
--[ 2019.11.09.15.32.40.024.0 ]--
r 50             StdOut.println("check: " + totalCo)
--[ 2019.11.09.15.32.40.102.0 ]--
r 50             StdOut.println("check: " + totalCos)
--[ 2019.11.09.15.32.40.190.0 ]--
r 50             StdOut.println("check: " + totalCost)
--[ 2019.11.09.15.32.40.378.0 ]--
r 50             StdOut.println("check: " + totalCost )
--[ 2019.11.09.15.32.41.454.0 ]--
r 50             StdOut.println("check: " + totalCost +)
--[ 2019.11.09.15.32.41.551.0 ]--
r 50             StdOut.println("check: " + totalCost + )
--[ 2019.11.09.15.32.42.283.0 ]--
r 50             StdOut.println("check: " + totalCost + ())
--[ 2019.11.09.15.32.44.620.0 ]--
r 50             StdOut.println("check: " + totalCost + (c))
--[ 2019.11.09.15.32.44.886.0 ]--
r 50             StdOut.println("check: " + totalCost + (co))
--[ 2019.11.09.15.32.44.939.0 ]--
r 50             StdOut.println("check: " + totalCost + (cos))
--[ 2019.11.09.15.32.44.986.0 ]--
r 50             StdOut.println("check: " + totalCost + (cost))
--[ 2019.11.09.15.32.45.049.0 ]--
r 50             StdOut.println("check: " + totalCost + (cost-))
--[ 2019.11.09.15.32.45.331.0 ]--
r 50             StdOut.println("check: " + totalCost + (cost-p))
--[ 2019.11.09.15.32.45.363.0 ]--
r 50             StdOut.println("check: " + totalCost + (cost-pr))
--[ 2019.11.09.15.32.45.441.0 ]--
r 50             StdOut.println("check: " + totalCost + (cost-pre))
--[ 2019.11.09.15.32.45.677.0 ]--
r 50             StdOut.println("check: " + totalCost + (cost-prev))
--[ 2019.11.09.15.32.46.868.0 ]--
r 50             StdOut.println("check: " + totalCost + (cost-prev));
--[ 2019.11.09.15.32.50.333.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.15.33.38.887.0 ]--
r 50             StdOut.println("check: " + (totalCost + (cost-prev));
--[ 2019.11.09.15.33.41.363.0 ]--
r 50             StdOut.println("check: " + (totalCost + (cost-prev)));
--[ 2019.11.09.15.33.44.546.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.15.36.58.530.0 ]--
+ 49             
--[ 2019.11.09.15.36.58.815.0 ]--
r 49             S
--[ 2019.11.09.15.36.58.980.0 ]--
r 49             St
--[ 2019.11.09.15.36.59.217.0 ]--
r 49             Std
--[ 2019.11.09.15.36.59.447.0 ]--
r 49             StdO
--[ 2019.11.09.15.36.59.634.0 ]--
r 49             StdOu
--[ 2019.11.09.15.36.59.669.0 ]--
r 49             StdOut
--[ 2019.11.09.15.36.59.872.0 ]--
r 49             StdOut.
--[ 2019.11.09.15.37.00.111.0 ]--
r 49             StdOut.p
--[ 2019.11.09.15.37.00.174.0 ]--
r 49             StdOut.pr
--[ 2019.11.09.15.37.00.330.0 ]--
r 49             StdOut.pri
--[ 2019.11.09.15.37.00.408.0 ]--
r 49             StdOut.prin
--[ 2019.11.09.15.37.00.502.0 ]--
r 49             StdOut.print
--[ 2019.11.09.15.37.00.580.0 ]--
r 49             StdOut.printl
--[ 2019.11.09.15.37.00.658.0 ]--
r 49             StdOut.println
--[ 2019.11.09.15.37.00.861.0 ]--
r 49             StdOut.println()
--[ 2019.11.09.15.37.01.049.0 ]--
r 49             StdOut.println("")
--[ 2019.11.09.15.37.01.311.0 ]--
r 49             StdOut.println("r")
--[ 2019.11.09.15.37.01.399.0 ]--
r 49             StdOut.println("re")
--[ 2019.11.09.15.37.01.462.0 ]--
r 49             StdOut.println("rea")
--[ 2019.11.09.15.37.01.556.0 ]--
r 49             StdOut.println("real")
--[ 2019.11.09.15.37.01.618.0 ]--
r 49             StdOut.println("realc")
--[ 2019.11.09.15.37.01.743.0 ]--
r 49             StdOut.println("realco")
--[ 2019.11.09.15.37.01.852.0 ]--
r 49             StdOut.println("realcos")
--[ 2019.11.09.15.37.01.962.0 ]--
r 49             StdOut.println("realcost")
--[ 2019.11.09.15.37.02.197.0 ]--
r 49             StdOut.println("realcost:")
--[ 2019.11.09.15.37.02.383.0 ]--
r 49             StdOut.println("realcost: ")
--[ 2019.11.09.15.37.02.752.0 ]--
r 49             StdOut.println("realcost: " )
--[ 2019.11.09.15.37.03.007.0 ]--
r 49             StdOut.println("realcost: " +)
--[ 2019.11.09.15.37.03.142.0 ]--
r 49             StdOut.println("realcost: " + )
--[ 2019.11.09.15.37.03.340.0 ]--
r 49             StdOut.println("realcost: " + c)
--[ 2019.11.09.15.37.03.445.0 ]--
r 49             StdOut.println("realcost: " + co)
--[ 2019.11.09.15.37.03.558.0 ]--
r 49             StdOut.println("realcost: " + cos)
--[ 2019.11.09.15.37.03.627.0 ]--
r 49             StdOut.println("realcost: " + cost)
--[ 2019.11.09.15.37.04.019.0 ]--
r 49             StdOut.println("realcost: " + cost);
--[ 2019.11.09.15.37.06.973.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.15.37.58.390.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.15.38.24.820.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.15.42.48.065.0 ]--
r 52             if (totalCost + (cost - prev) > end) { prev = end - totalCost ; break; }
--[ 2019.11.09.15.42.48.349.0 ]--
r 52             if (totalCost + (cost - prev) > end) { prev = end - totalCost +; break; }
--[ 2019.11.09.15.42.48.374.0 ]--
r 52             if (totalCost + (cost - prev) > end) { prev = end - totalCost + ; break; }
--[ 2019.11.09.15.42.49.110.0 ]--
r 52             if (totalCost + (cost - prev) > end) { prev = end - totalCost + (); break; }
--[ 2019.11.09.15.42.49.324.0 ]--
r 52             if (totalCost + (cost - prev) > end) { prev = end - totalCost + (c); break; }
--[ 2019.11.09.15.42.49.463.0 ]--
r 52             if (totalCost + (cost - prev) > end) { prev = end - totalCost + (co); break; }
--[ 2019.11.09.15.42.49.589.0 ]--
r 52             if (totalCost + (cost - prev) > end) { prev = end - totalCost + (cos); break; }
--[ 2019.11.09.15.42.49.643.0 ]--
r 52             if (totalCost + (cost - prev) > end) { prev = end - totalCost + (cost); break; }
--[ 2019.11.09.15.42.49.799.0 ]--
r 52             if (totalCost + (cost - prev) > end) { prev = end - totalCost + (cost ); break; }
--[ 2019.11.09.15.42.50.066.0 ]--
r 52             if (totalCost + (cost - prev) > end) { prev = end - totalCost + (cost -); break; }
--[ 2019.11.09.15.42.50.130.0 ]--
r 52             if (totalCost + (cost - prev) > end) { prev = end - totalCost + (cost - ); break; }
--[ 2019.11.09.15.42.50.334.0 ]--
r 52             if (totalCost + (cost - prev) > end) { prev = end - totalCost + (cost - p); break; }
--[ 2019.11.09.15.42.50.411.0 ]--
r 52             if (totalCost + (cost - prev) > end) { prev = end - totalCost + (cost - pr); break; }
--[ 2019.11.09.15.42.50.520.0 ]--
r 52             if (totalCost + (cost - prev) > end) { prev = end - totalCost + (cost - pre); break; }
--[ 2019.11.09.15.42.50.676.0 ]--
r 52             if (totalCost + (cost - prev) > end) { prev = end - totalCost + (cost - prev); break; }
--[ 2019.11.09.15.42.58.947.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.15.43.12.912.0 ]--
- 49
- 49
r 49 
--[ 2019.11.09.15.43.13.415.0 ]--
- 49
--[ 2019.11.09.15.43.17.021.0 ]--
- 45
r 45 
--[ 2019.11.09.15.43.17.539.0 ]--
- 45
--[ 2019.11.09.15.43.20.843.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.15.43.43.194.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.09.15.43.43.917.0 ]--
r 48     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2019.11.09.15.43.44.031.0 ]--
r 48     private final static String emapFilename = emaps[11];        // change index to load a different elevation map
--[ 2019.11.09.15.43.47.282.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.15.46.47.440.0 ]--
r 48     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2019.11.09.15.46.47.580.0 ]--
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.09.15.46.52.032.0 ]--
r 48     private final static String emapFilename = emaps[3];        // change index to load a different elevation map
--[ 2019.11.09.15.46.55.221.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.15.48.16.352.0 ]--
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.09.15.48.21.098.0 ]--
r 48     private final static String emapFilename = emaps[2];        // change index to load a different elevation map
--[ 2019.11.09.15.48.24.637.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.15.49.53.016.0 ]--
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.09.15.49.53.707.0 ]--
r 48     private final static String emapFilename = emaps[0];        // change index to load a different elevation map
--[ 2019.11.09.15.49.59.983.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.15.50.18.163.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.15.54.09.937.0 ]--
:/src/Pathfinder.java
r 189         if (c != null) return c.getCost();
--[ 2019.11.09.15.54.10.430.0 ]--
r 189         if (c != null) return c.getCost(0);
--[ 2019.11.09.15.54.15.615.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.15.54.31.332.0 ]--
+ 21     
--[ 2019.11.09.15.54.32.237.0 ]--
- 21
--[ 2019.11.09.15.54.34.203.0 ]--
+ 12     
--[ 2019.11.09.15.54.35.484.0 ]--
r 12     p
--[ 2019.11.09.15.54.35.575.0 ]--
r 12     pr
--[ 2019.11.09.15.54.35.684.0 ]--
r 12     pri
--[ 2019.11.09.15.54.35.810.0 ]--
r 12     priv
--[ 2019.11.09.15.54.35.908.0 ]--
r 12     priva
--[ 2019.11.09.15.54.36.095.0 ]--
r 12     privat
--[ 2019.11.09.15.54.36.143.0 ]--
r 12     private
--[ 2019.11.09.15.54.36.202.0 ]--
r 12     private 
--[ 2019.11.09.15.54.36.374.0 ]--
r 12     private f
--[ 2019.11.09.15.54.36.437.0 ]--
r 12     private fl
--[ 2019.11.09.15.54.36.577.0 ]--
r 12     private flo
--[ 2019.11.09.15.54.36.671.0 ]--
r 12     private floa
--[ 2019.11.09.15.54.36.702.0 ]--
r 12     private float
--[ 2019.11.09.15.54.36.827.0 ]--
r 12     private float 
--[ 2019.11.09.15.54.37.010.0 ]--
r 12     private float p
--[ 2019.11.09.15.54.37.338.0 ]--
r 12     private float 
--[ 2019.11.09.15.54.37.686.0 ]--
r 12     private float t
--[ 2019.11.09.15.54.37.809.0 ]--
r 12     private float to
--[ 2019.11.09.15.54.38.062.0 ]--
r 12     private float t
--[ 2019.11.09.15.54.38.221.0 ]--
r 12     private float 
--[ 2019.11.09.15.54.38.369.0 ]--
r 12     private float t
--[ 2019.11.09.15.54.38.443.0 ]--
r 12     private float to
--[ 2019.11.09.15.54.38.585.0 ]--
r 12     private float tot
--[ 2019.11.09.15.54.38.714.0 ]--
r 12     private float tota
--[ 2019.11.09.15.54.39.095.0 ]--
r 12     private float total
--[ 2019.11.09.15.54.39.361.0 ]--
r 12     private float totalC
--[ 2019.11.09.15.54.39.478.0 ]--
r 12     private float totalCo
--[ 2019.11.09.15.54.39.634.0 ]--
r 12     private float totalCos
--[ 2019.11.09.15.54.39.681.0 ]--
r 12     private float totalCost
--[ 2019.11.09.15.54.39.753.0 ]--
r 12     private float totalCost;
--[ 2019.11.09.15.55.12.620.0 ]--
+ 83         
--[ 2019.11.09.15.55.13.620.0 ]--
r 83         t
--[ 2019.11.09.15.55.13.738.0 ]--
r 83         to
--[ 2019.11.09.15.55.13.816.0 ]--
r 83         tot
--[ 2019.11.09.15.55.13.878.0 ]--
r 83         tota
--[ 2019.11.09.15.55.13.972.0 ]--
r 83         total
--[ 2019.11.09.15.55.14.270.0 ]--
r 83         totalC
--[ 2019.11.09.15.55.14.489.0 ]--
r 83         totalCo
--[ 2019.11.09.15.55.14.681.0 ]--
r 83         totalCos
--[ 2019.11.09.15.55.14.744.0 ]--
r 83         totalCost
--[ 2019.11.09.15.55.14.838.0 ]--
r 83         totalCost 
--[ 2019.11.09.15.55.14.932.0 ]--
r 83         totalCost =
--[ 2019.11.09.15.55.15.009.0 ]--
r 83         totalCost = 
--[ 2019.11.09.15.55.15.182.0 ]--
r 83         totalCost = 0
--[ 2019.11.09.15.55.16.049.0 ]--
r 83         totalCost = 0/
--[ 2019.11.09.15.55.16.329.0 ]--
r 83         totalCost = 0/0
--[ 2019.11.09.15.55.16.424.0 ]--
r 83         totalCost = 0/0f
--[ 2019.11.09.15.55.16.707.0 ]--
r 83         totalCost = 0/0
--[ 2019.11.09.15.55.16.845.0 ]--
r 83         totalCost = 0/
--[ 2019.11.09.15.55.17.017.0 ]--
r 83         totalCost = 0
--[ 2019.11.09.15.55.17.487.0 ]--
r 83         totalCost = 0-
--[ 2019.11.09.15.55.17.589.0 ]--
r 83         totalCost = 0-f
--[ 2019.11.09.15.55.18.118.0 ]--
r 83         totalCost = 0-
--[ 2019.11.09.15.55.18.268.0 ]--
r 83         totalCost = 0
--[ 2019.11.09.15.55.18.441.0 ]--
r 83         totalCost = 0-
--[ 2019.11.09.15.55.18.918.0 ]--
r 83         totalCost = 0
--[ 2019.11.09.15.55.19.556.0 ]--
r 83         totalCost = 0.
--[ 2019.11.09.15.55.19.817.0 ]--
r 83         totalCost = 0.0
--[ 2019.11.09.15.55.19.982.0 ]--
r 83         totalCost = 0.0f
--[ 2019.11.09.15.55.20.094.0 ]--
r 83         totalCost = 0.0f;
--[ 2019.11.09.15.56.38.791.0 ]--
+ 60         
--[ 2019.11.09.15.56.39.262.0 ]--
+ 60         
--[ 2019.11.09.15.56.45.934.0 ]--
r 61         p
--[ 2019.11.09.15.56.45.992.0 ]--
r 61         pr
--[ 2019.11.09.15.56.46.117.0 ]--
r 61         pri
--[ 2019.11.09.15.56.46.210.0 ]--
r 61         priv
--[ 2019.11.09.15.56.46.304.0 ]--
r 61         priva
--[ 2019.11.09.15.56.46.492.0 ]--
r 61         privat
--[ 2019.11.09.15.56.46.525.0 ]--
r 61         private
--[ 2019.11.09.15.56.46.607.0 ]--
r 61         private 
--[ 2019.11.09.15.56.46.794.0 ]--
r 61         private v
--[ 2019.11.09.15.56.46.867.0 ]--
r 61         private vo
--[ 2019.11.09.15.56.46.914.0 ]--
r 61         private voi
--[ 2019.11.09.15.56.47.023.0 ]--
r 61         private void
--[ 2019.11.09.15.56.47.101.0 ]--
r 61         private void 
--[ 2019.11.09.15.56.47.273.0 ]--
r 61         private void c
--[ 2019.11.09.15.56.47.384.0 ]--
r 61         private void co
--[ 2019.11.09.15.56.47.431.0 ]--
r 61         private void com
--[ 2019.11.09.15.56.47.556.0 ]--
r 61         private void comp
--[ 2019.11.09.15.56.47.712.0 ]--
r 61         private void compu
--[ 2019.11.09.15.56.47.792.0 ]--
r 61         private void comput
--[ 2019.11.09.15.56.47.865.0 ]--
r 61         private void compute
--[ 2019.11.09.15.56.48.410.0 ]--
r 61         private void computeO
--[ 2019.11.09.15.56.48.579.0 ]--
r 61         private void computeOt
--[ 2019.11.09.15.56.48.641.0 ]--
r 61         private void computeOth
--[ 2019.11.09.15.56.48.733.0 ]--
r 61         private void computeOthe
--[ 2019.11.09.15.56.48.841.0 ]--
r 61         private void computeOther
--[ 2019.11.09.15.56.49.142.0 ]--
r 61         private void computeOtherC
--[ 2019.11.09.15.56.49.315.0 ]--
r 61         private void computeOtherCo
--[ 2019.11.09.15.56.49.440.0 ]--
r 61         private void computeOtherCos
--[ 2019.11.09.15.56.49.549.0 ]--
r 61         private void computeOtherCost
--[ 2019.11.09.15.56.49.816.0 ]--
r 61         private void computeOtherCost()
--[ 2019.11.09.15.56.50.175.0 ]--
r 61         private void computeOtherCost(f)
--[ 2019.11.09.15.56.50.286.0 ]--
r 61         private void computeOtherCost(fl)
--[ 2019.11.09.15.56.50.491.0 ]--
r 61         private void computeOtherCost(flo)
--[ 2019.11.09.15.56.50.694.0 ]--
r 61         private void computeOtherCost(fl)
--[ 2019.11.09.15.56.50.917.0 ]--
r 61         private void computeOtherCost(f)
--[ 2019.11.09.15.56.51.042.0 ]--
r 61         private void computeOtherCost()
--[ 2019.11.09.15.56.51.245.0 ]--
r 61         private void computeOtherCost
--[ 2019.11.09.15.56.51.699.0 ]--
r 61         private void computeOtherCos
--[ 2019.11.09.15.56.51.745.0 ]--
r 61         private void computeOtherCo
--[ 2019.11.09.15.56.51.777.0 ]--
r 61         private void computeOtherC
--[ 2019.11.09.15.56.51.808.0 ]--
r 61         private void computeOther
--[ 2019.11.09.15.56.51.839.0 ]--
r 61         private void computeOthe
--[ 2019.11.09.15.56.51.871.0 ]--
r 61         private void computeOth
--[ 2019.11.09.15.56.51.905.0 ]--
r 61         private void computeOt
--[ 2019.11.09.15.56.51.935.0 ]--
r 61         private void computeO
--[ 2019.11.09.15.56.51.972.0 ]--
r 61         private void compute
--[ 2019.11.09.15.56.52.004.0 ]--
r 61         private void comput
--[ 2019.11.09.15.56.52.041.0 ]--
r 61         private void compu
--[ 2019.11.09.15.56.52.069.0 ]--
r 61         private void comp
--[ 2019.11.09.15.56.52.103.0 ]--
r 61         private void com
--[ 2019.11.09.15.56.52.136.0 ]--
r 61         private void co
--[ 2019.11.09.15.56.52.398.0 ]--
r 61         private void c
--[ 2019.11.09.15.56.52.842.0 ]--
r 61         private void 
--[ 2019.11.09.15.56.54.751.0 ]--
r 61         private void
--[ 2019.11.09.15.56.54.958.0 ]--
r 61         private voi
--[ 2019.11.09.15.56.55.108.0 ]--
r 61         private vo
--[ 2019.11.09.15.56.55.297.0 ]--
r 61         private v
--[ 2019.11.09.15.56.55.476.0 ]--
r 61         private 
--[ 2019.11.09.15.56.55.968.0 ]--
r 61         private f
--[ 2019.11.09.15.56.56.062.0 ]--
r 61         private fl
--[ 2019.11.09.15.56.56.234.0 ]--
r 61         private flo
--[ 2019.11.09.15.56.56.344.0 ]--
r 61         private floa
--[ 2019.11.09.15.56.56.363.0 ]--
r 61         private float
--[ 2019.11.09.15.56.56.535.0 ]--
r 61         private float 
--[ 2019.11.09.15.56.58.074.0 ]--
r 61         private float g
--[ 2019.11.09.15.56.58.130.0 ]--
r 61         private float ge
--[ 2019.11.09.15.56.58.312.0 ]--
r 61         private float get
--[ 2019.11.09.15.56.58.591.0 ]--
r 61         private float getC
--[ 2019.11.09.15.56.58.722.0 ]--
r 61         private float getCo
--[ 2019.11.09.15.56.58.889.0 ]--
r 61         private float getCos
--[ 2019.11.09.15.56.59.156.0 ]--
r 61         private float getCost
--[ 2019.11.09.15.56.59.328.0 ]--
r 61         private float getCost()
--[ 2019.11.09.15.56.59.798.0 ]--
r 61         private float getCost(f)
--[ 2019.11.09.15.56.59.832.0 ]--
r 61         private float getCost(fl)
--[ 2019.11.09.15.56.59.973.0 ]--
r 61         private float getCost(flo)
--[ 2019.11.09.15.57.00.067.0 ]--
r 61         private float getCost(floa)
--[ 2019.11.09.15.57.00.161.0 ]--
r 61         private float getCost(float)
--[ 2019.11.09.15.57.00.365.0 ]--
r 61         private float getCost(float h)
--[ 2019.11.09.15.57.00.469.0 ]--
r 61         private float getCost(float he)
--[ 2019.11.09.15.57.00.563.0 ]--
r 61         private float getCost(float heu)
--[ 2019.11.09.15.57.00.672.0 ]--
r 61         private float getCost(float heur)
--[ 2019.11.09.15.57.00.782.0 ]--
r 61         private float getCost(float heuri)
--[ 2019.11.09.15.57.00.860.0 ]--
r 61         private float getCost(float heuris)
--[ 2019.11.09.15.57.00.922.0 ]--
r 61         private float getCost(float heurist)
--[ 2019.11.09.15.57.00.985.0 ]--
r 61         private float getCost(float heuristi)
--[ 2019.11.09.15.57.01.110.0 ]--
r 61         private float getCost(float heuristic)
--[ 2019.11.09.15.57.01.502.0 ]--
r 61         private float getCost(float heuristic) 
--[ 2019.11.09.15.57.01.682.0 ]--
r 61         private float getCost(float heuristic) {}
--[ 2019.11.09.15.57.01.902.0 ]--
+ 61         private float getCost(float heuristic) {
r 62         }
--[ 2019.11.09.15.57.01.938.0 ]--
+ 62             
--[ 2019.11.09.15.57.17.016.0 ]--
r 61         private float c(float heuristic) {
--[ 2019.11.09.15.57.17.210.0 ]--
r 61         private float com(float heuristic) {
--[ 2019.11.09.15.57.17.335.0 ]--
r 61         private float comp(float heuristic) {
--[ 2019.11.09.15.57.17.444.0 ]--
r 61         private float compu(float heuristic) {
--[ 2019.11.09.15.57.17.538.0 ]--
r 61         private float comput(float heuristic) {
--[ 2019.11.09.15.57.17.616.0 ]--
r 61         private float compute(float heuristic) {
--[ 2019.11.09.15.57.17.852.0 ]--
r 61         private float computeO(float heuristic) {
--[ 2019.11.09.15.57.18.000.0 ]--
r 61         private float computeOt(float heuristic) {
--[ 2019.11.09.15.57.18.064.0 ]--
r 61         private float computeOth(float heuristic) {
--[ 2019.11.09.15.57.18.183.0 ]--
r 61         private float computeOthe(float heuristic) {
--[ 2019.11.09.15.57.18.288.0 ]--
r 61         private float computeOther(float heuristic) {
--[ 2019.11.09.15.57.18.592.0 ]--
r 61         private float computeOtherC(float heuristic) {
--[ 2019.11.09.15.57.18.853.0 ]--
r 61         private float computeOtherCo(float heuristic) {
--[ 2019.11.09.15.57.18.971.0 ]--
r 61         private float computeOtherCos(float heuristic) {
--[ 2019.11.09.15.57.19.034.0 ]--
r 61         private float computeOtherCost(float heuristic) {
--[ 2019.11.09.15.58.04.419.0 ]--
r 61         private float c(float heuristic) {
--[ 2019.11.09.15.58.04.638.0 ]--
r 61         private float com(float heuristic) {
--[ 2019.11.09.15.58.04.685.0 ]--
r 61         private float comp(float heuristic) {
--[ 2019.11.09.15.58.04.779.0 ]--
r 61         private float compu(float heuristic) {
--[ 2019.11.09.15.58.04.857.0 ]--
r 61         private float comput(float heuristic) {
--[ 2019.11.09.15.58.04.982.0 ]--
r 61         private float compute(float heuristic) {
--[ 2019.11.09.15.58.05.499.0 ]--
r 61         private float computeF(float heuristic) {
--[ 2019.11.09.15.58.05.614.0 ]--
r 61         private float computeFl(float heuristic) {
--[ 2019.11.09.15.58.05.708.0 ]--
r 61         private float computeFla(float heuristic) {
--[ 2019.11.09.15.58.05.786.0 ]--
r 61         private float computeFlat(float heuristic) {
--[ 2019.11.09.15.58.06.098.0 ]--
r 61         private float computeFlatC(float heuristic) {
--[ 2019.11.09.15.58.06.254.0 ]--
r 61         private float computeFlatCo(float heuristic) {
--[ 2019.11.09.15.58.06.318.0 ]--
r 61         private float computeFlatCos(float heuristic) {
--[ 2019.11.09.15.58.06.437.0 ]--
r 61         private float computeFlatCost(float heuristic) {
--[ 2019.11.09.15.58.09.335.0 ]--
+ 36             
--[ 2019.11.09.15.58.09.845.0 ]--
r 36             c
--[ 2019.11.09.15.58.09.924.0 ]--
r 36             co
--[ 2019.11.09.15.58.10.034.0 ]--
r 36             com
--[ 2019.11.09.15.58.10.143.0 ]--
r 36             comp
--[ 2019.11.09.15.58.10.285.0 ]--
r 36             compu
--[ 2019.11.09.15.58.10.349.0 ]--
r 36             comput
--[ 2019.11.09.15.58.10.443.0 ]--
r 36             compute
--[ 2019.11.09.15.58.10.804.0 ]--
r 36             computeF
--[ 2019.11.09.15.58.10.948.0 ]--
r 36             computeFl
--[ 2019.11.09.15.58.11.073.0 ]--
r 36             computeFla
--[ 2019.11.09.15.58.11.135.0 ]--
r 36             computeFlat
--[ 2019.11.09.15.58.11.433.0 ]--
r 36             computeFlatC
--[ 2019.11.09.15.58.11.584.0 ]--
r 36             computeFlatCo
--[ 2019.11.09.15.58.11.662.0 ]--
r 36             computeFlatCos
--[ 2019.11.09.15.58.11.741.0 ]--
r 36             computeFlatCost
--[ 2019.11.09.15.58.12.008.0 ]--
r 36             computeFlatCost()
--[ 2019.11.09.15.58.12.154.0 ]--
r 36             computeFlatCost(h)
--[ 2019.11.09.15.58.12.577.0 ]--
r 36             computeFlatCost(h);
--[ 2019.11.09.15.58.14.570.0 ]--
+ 31         
--[ 2019.11.09.15.58.14.970.0 ]--
r 31         p
--[ 2019.11.09.15.58.15.039.0 ]--
r 31         pr
--[ 2019.11.09.15.58.15.149.0 ]--
r 31         pri
--[ 2019.11.09.15.58.15.289.0 ]--
r 31         priv
--[ 2019.11.09.15.58.15.367.0 ]--
r 31         priva
--[ 2019.11.09.15.58.15.492.0 ]--
r 31         privat
--[ 2019.11.09.15.58.15.570.0 ]--
r 31         private
--[ 2019.11.09.15.58.15.617.0 ]--
r 31         private 
--[ 2019.11.09.15.58.15.742.0 ]--
r 31         private f
--[ 2019.11.09.15.58.15.836.0 ]--
r 31         private fl
--[ 2019.11.09.15.58.16.118.0 ]--
r 31         private floa
--[ 2019.11.09.15.58.16.152.0 ]--
r 31         private float
--[ 2019.11.09.15.58.16.199.0 ]--
r 31         private float 
--[ 2019.11.09.15.58.16.403.0 ]--
r 31         private float f
--[ 2019.11.09.15.58.16.452.0 ]--
r 31         private float fl
--[ 2019.11.09.15.58.16.514.0 ]--
r 31         private float fla
--[ 2019.11.09.15.58.16.592.0 ]--
r 31         private float flat
--[ 2019.11.09.15.58.16.812.0 ]--
r 31         private float flatc
--[ 2019.11.09.15.58.16.859.0 ]--
r 31         private float flatco
--[ 2019.11.09.15.58.17.008.0 ]--
r 31         private float flatcos
--[ 2019.11.09.15.58.17.070.0 ]--
r 31         private float flatcost
--[ 2019.11.09.15.58.17.117.0 ]--
r 31         private float flatcost;
--[ 2019.11.09.15.58.23.310.0 ]--
+ 64             if (validateCoord(this.loc)) {
+ 65                 PFNode b = fromNode;
+ 66                 if (b == null)  this.cost = 0.0f;
+ 67                 else            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.computeDistance(loc, end);
r 68             }
--[ 2019.11.09.15.58.28.936.0 ]--
r 66                 if (b == null)  this.f = 0.0f;
--[ 2019.11.09.15.58.29.156.0 ]--
r 66                 if (b == null)  this.fla = 0.0f;
--[ 2019.11.09.15.58.29.187.0 ]--
r 66                 if (b == null)  this.flat = 0.0f;
--[ 2019.11.09.15.58.29.814.0 ]--
r 66                 if (b == null)  this.flatcost = 0.0f;
--[ 2019.11.09.15.58.32.542.0 ]--
r 67                 else            this.f = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.computeDistance(loc, end);
--[ 2019.11.09.15.58.32.594.0 ]--
r 67                 else            this.fl = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.computeDistance(loc, end);
--[ 2019.11.09.15.58.32.703.0 ]--
r 67                 else            this.fla = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.computeDistance(loc, end);
--[ 2019.11.09.15.58.32.781.0 ]--
r 67                 else            this.flat = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.computeDistance(loc, end);
--[ 2019.11.09.15.58.33.296.0 ]--
r 67                 else            this.flatcost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.computeDistance(loc, end);
--[ 2019.11.09.15.58.39.388.0 ]--
r 63         private float computeFlatCost() {
--[ 2019.11.09.15.58.43.031.0 ]--
+ 74         
--[ 2019.11.09.15.58.43.187.0 ]--
+ 74         
--[ 2019.11.09.15.58.44.012.0 ]--
r 75         p
--[ 2019.11.09.15.58.44.076.0 ]--
r 75         pu
--[ 2019.11.09.15.58.44.170.0 ]--
r 75         pub
--[ 2019.11.09.15.58.44.279.0 ]--
r 75         publ
--[ 2019.11.09.15.58.44.341.0 ]--
r 75         publi
--[ 2019.11.09.15.58.44.435.0 ]--
r 75         public
--[ 2019.11.09.15.58.44.591.0 ]--
r 75         public 
--[ 2019.11.09.15.58.44.685.0 ]--
r 75         public f
--[ 2019.11.09.15.58.44.732.0 ]--
r 75         public fl
--[ 2019.11.09.15.58.44.983.0 ]--
r 75         public flo
--[ 2019.11.09.15.58.45.033.0 ]--
r 75         public floa
--[ 2019.11.09.15.58.45.112.0 ]--
r 75         public float
--[ 2019.11.09.15.58.45.190.0 ]--
r 75         public float 
--[ 2019.11.09.15.58.45.330.0 ]--
r 75         public float g
--[ 2019.11.09.15.58.45.424.0 ]--
r 75         public float ge
--[ 2019.11.09.15.58.45.580.0 ]--
r 75         public float get
--[ 2019.11.09.15.58.45.997.0 ]--
r 75         public float getF
--[ 2019.11.09.15.58.46.126.0 ]--
r 75         public float getFl
--[ 2019.11.09.15.58.46.235.0 ]--
r 75         public float getFla
--[ 2019.11.09.15.58.46.314.0 ]--
r 75         public float getFlat
--[ 2019.11.09.15.58.46.627.0 ]--
r 75         public float getFlatC
--[ 2019.11.09.15.58.47.172.0 ]--
r 75         public float getFlat
--[ 2019.11.09.15.58.47.407.0 ]--
r 75         public float getFlatc
--[ 2019.11.09.15.58.47.496.0 ]--
r 75         public float getFlatco
--[ 2019.11.09.15.58.47.637.0 ]--
r 75         public float getFlatcos
--[ 2019.11.09.15.58.47.697.0 ]--
r 75         public float getFlatcost
--[ 2019.11.09.15.58.48.858.0 ]--
r 75         public float getFlatcost()
--[ 2019.11.09.15.58.49.145.0 ]--
r 75         public float getFlatcost(f)
--[ 2019.11.09.15.58.49.283.0 ]--
r 75         public float getFlatcost(fl)
--[ 2019.11.09.15.58.49.455.0 ]--
r 75         public float getFlatcost(flo)
--[ 2019.11.09.15.58.49.737.0 ]--
r 75         public float getFlatcost(float )
--[ 2019.11.09.15.58.49.762.0 ]--
r 75         public float getFlatcost(float h)
--[ 2019.11.09.15.58.49.872.0 ]--
r 75         public float getFlatcost(float he)
--[ 2019.11.09.15.58.49.965.0 ]--
r 75         public float getFlatcost(float heu)
--[ 2019.11.09.15.58.50.106.0 ]--
r 75         public float getFlatcost(float heur)
--[ 2019.11.09.15.58.50.280.0 ]--
r 75         public float getFlatcost(float heuri)
--[ 2019.11.09.15.58.50.378.0 ]--
r 75         public float getFlatcost(float heuris)
--[ 2019.11.09.15.58.50.503.0 ]--
r 75         public float getFlatcost(float heurist)
--[ 2019.11.09.15.58.50.581.0 ]--
r 75         public float getFlatcost(float heuristi)
--[ 2019.11.09.15.58.50.706.0 ]--
r 75         public float getFlatcost(float heuristic)
--[ 2019.11.09.15.58.51.130.0 ]--
r 75         public float getFlatcost(float heuristic) 
--[ 2019.11.09.15.58.51.482.0 ]--
r 75         public float getFlatcost(float heuristic)
--[ 2019.11.09.15.58.51.949.0 ]--
r 75         public float getFlatcost(float heuristic
--[ 2019.11.09.15.58.51.992.0 ]--
r 75         public float getFlatcost(float heuristi
--[ 2019.11.09.15.58.52.015.0 ]--
r 75         public float getFlatcost(float heurist
--[ 2019.11.09.15.58.52.038.0 ]--
r 75         public float getFlatcost(float heuris
--[ 2019.11.09.15.58.52.059.0 ]--
r 75         public float getFlatcost(float heuri
--[ 2019.11.09.15.58.52.094.0 ]--
r 75         public float getFlatcost(float heur
--[ 2019.11.09.15.58.52.129.0 ]--
r 75         public float getFlatcost(float heu
--[ 2019.11.09.15.58.52.159.0 ]--
r 75         public float getFlatcost(float he
--[ 2019.11.09.15.58.52.191.0 ]--
r 75         public float getFlatcost(float h
--[ 2019.11.09.15.58.52.228.0 ]--
r 75         public float getFlatcost(float 
--[ 2019.11.09.15.58.52.267.0 ]--
r 75         public float getFlatcost(float
--[ 2019.11.09.15.58.52.292.0 ]--
r 75         public float getFlatcost(floa
--[ 2019.11.09.15.58.52.324.0 ]--
r 75         public float getFlatcost(flo
--[ 2019.11.09.15.58.52.360.0 ]--
r 75         public float getFlatcost(fl
--[ 2019.11.09.15.58.52.743.0 ]--
r 75         public float getFlatcost(f
--[ 2019.11.09.15.58.52.933.0 ]--
r 75         public float getFlatcost(
--[ 2019.11.09.15.58.53.793.0 ]--
r 75         public float getFlatcost()
--[ 2019.11.09.15.58.53.967.0 ]--
r 75         public float getFlatcost() 
--[ 2019.11.09.15.58.54.688.0 ]--
r 75         public float getFlatcost() r
--[ 2019.11.09.15.58.54.991.0 ]--
r 75         public float getFlatcost() 
--[ 2019.11.09.15.58.55.350.0 ]--
r 75         public float getFlatcost() {}
--[ 2019.11.09.15.58.55.923.0 ]--
r 75         public float getFlatcost() { }
--[ 2019.11.09.15.58.56.473.0 ]--
r 75         public float getFlatcost() {  }
--[ 2019.11.09.15.58.57.639.0 ]--
r 75         public float getFlatcost() { r }
--[ 2019.11.09.15.58.57.759.0 ]--
r 75         public float getFlatcost() { re }
--[ 2019.11.09.15.58.57.885.0 ]--
r 75         public float getFlatcost() { ret }
--[ 2019.11.09.15.58.57.950.0 ]--
r 75         public float getFlatcost() { retu }
--[ 2019.11.09.15.58.58.108.0 ]--
r 75         public float getFlatcost() { retur }
--[ 2019.11.09.15.58.58.156.0 ]--
r 75         public float getFlatcost() { return }
--[ 2019.11.09.15.58.58.278.0 ]--
r 75         public float getFlatcost() { return  }
--[ 2019.11.09.15.58.59.633.0 ]--
r 75         public float getFlatcost() { return f }
--[ 2019.11.09.15.58.59.840.0 ]--
r 75         public float getFlatcost() { return fl }
--[ 2019.11.09.15.58.59.887.0 ]--
r 75         public float getFlatcost() { return fla }
--[ 2019.11.09.15.58.59.949.0 ]--
r 75         public float getFlatcost() { return flat }
--[ 2019.11.09.15.59.00.185.0 ]--
r 75         public float getFlatcost() { return flatco }
--[ 2019.11.09.15.59.00.437.0 ]--
r 75         public float getFlatcost() { return flatcos }
--[ 2019.11.09.15.59.00.510.0 ]--
r 75         public float getFlatcost() { return flatcost }
--[ 2019.11.09.15.59.01.324.0 ]--
r 75         public float getFlatcost() { return flatcost; }
--[ 2019.11.09.15.59.09.154.0 ]--
r 67                 else            this.flatcost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.09.15.59.15.376.0 ]--
r 63         private v computeFlatCost() {
--[ 2019.11.09.15.59.15.623.0 ]--
r 63         private void computeFlatCost() {
--[ 2019.11.09.15.59.24.304.0 ]--
r 37             computeFlatCost();
--[ 2019.11.09.15.59.42.896.0 ]--
r 37 
--[ 2019.11.09.15.59.43.147.0 ]--
- 37
--[ 2019.11.09.15.59.49.464.0 ]--
r 58                 else {           this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.computeDistance(loc, end);
--[ 2019.11.09.15.59.49.848.0 ]--
+ 58                 else {
+ 59            this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.computeDistance(loc, end);
r 60 }
--[ 2019.11.09.15.59.49.864.0 ]--
r 59                     this.cost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc) + heuristic*terrain.computeDistance(loc, end);
r 60                 }
--[ 2019.11.09.15.59.53.528.0 ]--
+ 60                     
--[ 2019.11.09.15.59.55.042.0 ]--
r 60                     t
--[ 2019.11.09.15.59.55.105.0 ]--
r 60                     th
--[ 2019.11.09.15.59.55.136.0 ]--
r 60                     thi
--[ 2019.11.09.15.59.55.245.0 ]--
r 60                     this
--[ 2019.11.09.15.59.55.354.0 ]--
r 60                     this.
--[ 2019.11.09.15.59.55.495.0 ]--
r 60                     this.f
--[ 2019.11.09.15.59.55.573.0 ]--
r 60                     this.fl
--[ 2019.11.09.15.59.55.731.0 ]--
r 60                     this.fla
--[ 2019.11.09.15.59.55.800.0 ]--
r 60                     this.flat
--[ 2019.11.09.15.59.55.988.0 ]--
r 60                     this.flatc
--[ 2019.11.09.15.59.56.068.0 ]--
r 60                     this.flatco
--[ 2019.11.09.15.59.56.208.0 ]--
r 60                     this.flatcos
--[ 2019.11.09.15.59.56.365.0 ]--
r 60                     this.flatcost
--[ 2019.11.09.15.59.56.427.0 ]--
r 60                     this.flatcost 
--[ 2019.11.09.15.59.56.725.0 ]--
r 60                     this.flatcost =
--[ 2019.11.09.15.59.56.910.0 ]--
r 60                     this.flatcost = 
--[ 2019.11.09.16.00.01.841.0 ]--
r 60                     this.flatcost = b.getCost(h) + terrain.computeTravelCost(b.getLoc(), loc)
--[ 2019.11.09.16.00.07.843.0 ]--
r 60                     this.flatcost = b.g(h) + terrain.computeTravelCost(b.getLoc(), loc)
--[ 2019.11.09.16.00.08.100.0 ]--
r 60                     this.flatcost = b.get(h) + terrain.computeTravelCost(b.getLoc(), loc)
--[ 2019.11.09.16.00.08.381.0 ]--
r 60                     this.flatcost = b.getF(h) + terrain.computeTravelCost(b.getLoc(), loc)
--[ 2019.11.09.16.00.08.446.0 ]--
r 60                     this.flatcost = b.getFl(h) + terrain.computeTravelCost(b.getLoc(), loc)
--[ 2019.11.09.16.00.08.622.0 ]--
r 60                     this.flatcost = b.getFla(h) + terrain.computeTravelCost(b.getLoc(), loc)
--[ 2019.11.09.16.00.08.649.0 ]--
r 60                     this.flatcost = b.getFlat(h) + terrain.computeTravelCost(b.getLoc(), loc)
--[ 2019.11.09.16.00.09.233.0 ]--
r 60                     this.flatcost = b.getFlatC(h) + terrain.computeTravelCost(b.getLoc(), loc)
--[ 2019.11.09.16.00.09.619.0 ]--
r 60                     this.flatcost = b.getFlatCo(h) + terrain.computeTravelCost(b.getLoc(), loc)
--[ 2019.11.09.16.00.09.775.0 ]--
r 60                     this.flatcost = b.getFlatCos(h) + terrain.computeTravelCost(b.getLoc(), loc)
--[ 2019.11.09.16.00.09.823.0 ]--
r 60                     this.flatcost = b.getFlatCost(h) + terrain.computeTravelCost(b.getLoc(), loc)
--[ 2019.11.09.16.00.10.137.0 ]--
r 60                     this.flatcost = b.getFlatCost((h) + terrain.computeTravelCost(b.getLoc(), loc)
--[ 2019.11.09.16.00.10.169.0 ]--
r 60                     this.flatcost = b.getFlatCost()(h) + terrain.computeTravelCost(b.getLoc(), loc)
--[ 2019.11.09.16.00.10.592.0 ]--
r 60                     this.flatcost = b.getFlatCost((h) + terrain.computeTravelCost(b.getLoc(), loc)
--[ 2019.11.09.16.00.10.786.0 ]--
r 60                     this.flatcost = b.getFlatCost(h) + terrain.computeTravelCost(b.getLoc(), loc)
--[ 2019.11.09.16.00.12.404.0 ]--
r 60                     this.flatcost = b.getFlatCost() + terrain.computeTravelCost(b.getLoc(), loc)
--[ 2019.11.09.16.00.15.554.0 ]--
r 77         public float getFlatost() { return flatcost; }
--[ 2019.11.09.16.00.15.695.0 ]--
r 77         public float getFlatCost() { return flatcost; }
--[ 2019.11.09.16.00.24.225.0 ]--
r 57                 if (b == null) { this.cost = 0.0f;
--[ 2019.11.09.16.00.25.755.0 ]--
r 57                 if (b == null) { this.cost = 0.0f; 
--[ 2019.11.09.16.00.26.087.0 ]--
r 57                 if (b == null) { this.cost = 0.0f; t
--[ 2019.11.09.16.00.26.194.0 ]--
r 57                 if (b == null) { this.cost = 0.0f; th
--[ 2019.11.09.16.00.26.257.0 ]--
r 57                 if (b == null) { this.cost = 0.0f; thi
--[ 2019.11.09.16.00.26.319.0 ]--
r 57                 if (b == null) { this.cost = 0.0f; this
--[ 2019.11.09.16.00.26.429.0 ]--
r 57                 if (b == null) { this.cost = 0.0f; this.
--[ 2019.11.09.16.00.26.632.0 ]--
r 57                 if (b == null) { this.cost = 0.0f; this.f
--[ 2019.11.09.16.00.26.678.0 ]--
r 57                 if (b == null) { this.cost = 0.0f; this.fl
--[ 2019.11.09.16.00.26.883.0 ]--
r 57                 if (b == null) { this.cost = 0.0f; this.fla
--[ 2019.11.09.16.00.26.948.0 ]--
r 57                 if (b == null) { this.cost = 0.0f; this.flat
--[ 2019.11.09.16.00.27.152.0 ]--
r 57                 if (b == null) { this.cost = 0.0f; this.flatc
--[ 2019.11.09.16.00.27.218.0 ]--
r 57                 if (b == null) { this.cost = 0.0f; this.flatco
--[ 2019.11.09.16.00.27.392.0 ]--
r 57                 if (b == null) { this.cost = 0.0f; this.flatcos
--[ 2019.11.09.16.00.27.462.0 ]--
r 57                 if (b == null) { this.cost = 0.0f; this.flatcost
--[ 2019.11.09.16.00.27.540.0 ]--
r 57                 if (b == null) { this.cost = 0.0f; this.flatcost 
--[ 2019.11.09.16.00.27.665.0 ]--
r 57                 if (b == null) { this.cost = 0.0f; this.flatcost =
--[ 2019.11.09.16.00.27.743.0 ]--
r 57                 if (b == null) { this.cost = 0.0f; this.flatcost = 
--[ 2019.11.09.16.00.27.892.0 ]--
r 57                 if (b == null) { this.cost = 0.0f; this.flatcost = 0
--[ 2019.11.09.16.00.28.175.0 ]--
r 57                 if (b == null) { this.cost = 0.0f; this.flatcost = 0.
--[ 2019.11.09.16.00.28.359.0 ]--
r 57                 if (b == null) { this.cost = 0.0f; this.flatcost = 0.0
--[ 2019.11.09.16.00.28.460.0 ]--
r 57                 if (b == null) { this.cost = 0.0f; this.flatcost = 0.0f
--[ 2019.11.09.16.00.28.577.0 ]--
r 57                 if (b == null) { this.cost = 0.0f; this.flatcost = 0.0f;
--[ 2019.11.09.16.00.29.254.0 ]--
r 57                 if (b == null) { this.cost = 0.0f; this.flatcost = 0.0f; 
--[ 2019.11.09.16.00.29.410.0 ]--
r 57                 if (b == null) { this.cost = 0.0f; this.flatcost = 0.0f; }
--[ 2019.11.09.16.00.33.469.0 ]--
+ 59                     
--[ 2019.11.09.16.00.34.152.0 ]--
r 59                     t
--[ 2019.11.09.16.00.34.251.0 ]--
r 59                     th
--[ 2019.11.09.16.00.34.345.0 ]--
r 59                     thi
--[ 2019.11.09.16.00.34.549.0 ]--
r 59                     this.
--[ 2019.11.09.16.00.34.681.0 ]--
r 59                     this.c
--[ 2019.11.09.16.00.34.759.0 ]--
r 59                     this.co
--[ 2019.11.09.16.00.34.912.0 ]--
r 59                     this.cos
--[ 2019.11.09.16.00.34.990.0 ]--
r 59                     this.cost
--[ 2019.11.09.16.00.35.162.0 ]--
r 59                     this.cost,
--[ 2019.11.09.16.00.35.242.0 ]--
r 59                     this.cost, 
--[ 2019.11.09.16.00.35.383.0 ]--
r 59                     this.cost, t
--[ 2019.11.09.16.00.35.445.0 ]--
r 59                     this.cost, th
--[ 2019.11.09.16.00.35.508.0 ]--
r 59                     this.cost, thi
--[ 2019.11.09.16.00.35.586.0 ]--
r 59                     this.cost, this
--[ 2019.11.09.16.00.35.742.0 ]--
r 59                     this.cost, this.
--[ 2019.11.09.16.00.35.867.0 ]--
r 59                     this.cost, this.f
--[ 2019.11.09.16.00.36.008.0 ]--
r 59                     this.cost, this.fl
--[ 2019.11.09.16.00.36.173.0 ]--
r 59                     this.cost, this.fla
--[ 2019.11.09.16.00.36.282.0 ]--
r 59                     this.cost, this.flat
--[ 2019.11.09.16.00.36.502.0 ]--
r 59                     this.cost, this.flatc
--[ 2019.11.09.16.00.36.845.0 ]--
r 59                     this.cost, this.flatco
--[ 2019.11.09.16.00.36.894.0 ]--
r 59                     this.cost, this.flatcos
--[ 2019.11.09.16.00.36.943.0 ]--
r 59                     this.cost, this.flatcost
--[ 2019.11.09.16.00.37.069.0 ]--
r 59                     this.cost, this.flatcost 
--[ 2019.11.09.16.00.37.169.0 ]--
r 59                     this.cost, this.flatcost =
--[ 2019.11.09.16.00.37.246.0 ]--
r 59                     this.cost, this.flatcost = 
--[ 2019.11.09.16.00.37.385.0 ]--
r 59                     this.cost, this.flatcost = 0
--[ 2019.11.09.16.00.37.607.0 ]--
r 59                     this.cost, this.flatcost = 0.
--[ 2019.11.09.16.00.37.842.0 ]--
r 59                     this.cost, this.flatcost = 0.0
--[ 2019.11.09.16.00.37.917.0 ]--
r 59                     this.cost, this.flatcost = 0.0f
--[ 2019.11.09.16.00.38.021.0 ]--
r 59                     this.cost, this.flatcost = 0.0f;
--[ 2019.11.09.16.00.42.414.0 ]--
r 59 
--[ 2019.11.09.16.00.42.523.0 ]--
- 59
--[ 2019.11.09.16.00.50.044.0 ]--
- 64
- 64
- 64
- 64
- 64
- 64
- 64
r 64 
--[ 2019.11.09.16.00.50.667.0 ]--
- 64
--[ 2019.11.09.16.00.59.977.0 ]--
r 60                     this.flatcost = b.getFlatCost() + terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.09.16.01.02.150.0 ]--
+ 59                     
--[ 2019.11.09.16.01.06.839.0 ]--
r 59                     n
--[ 2019.11.09.16.01.07.469.0 ]--
r 59                     ne
--[ 2019.11.09.16.01.07.677.0 ]--
r 59                     nex
--[ 2019.11.09.16.01.07.909.0 ]--
r 59                     next
--[ 2019.11.09.16.01.08.582.0 ]--
r 59                     nextC
--[ 2019.11.09.16.01.08.737.0 ]--
r 59                     nextCo
--[ 2019.11.09.16.01.08.840.0 ]--
r 59                     nextCos
--[ 2019.11.09.16.01.08.892.0 ]--
r 59                     nextCost
--[ 2019.11.09.16.01.09.096.0 ]--
r 59                     nextCost 
--[ 2019.11.09.16.01.09.227.0 ]--
r 59                     nextCost =
--[ 2019.11.09.16.01.09.336.0 ]--
r 59                     nextCost = 
--[ 2019.11.09.16.01.09.477.0 ]--
r 59                     nextCost = t
--[ 2019.11.09.16.01.09.586.0 ]--
r 59                     nextCost = te
--[ 2019.11.09.16.01.09.744.0 ]--
r 59                     nextCost = ter
--[ 2019.11.09.16.01.09.902.0 ]--
r 59                     nextCost = terr
--[ 2019.11.09.16.01.09.965.0 ]--
r 59                     nextCost = terra
--[ 2019.11.09.16.01.10.043.0 ]--
r 59                     nextCost = terrai
--[ 2019.11.09.16.01.10.105.0 ]--
r 59                     nextCost = terrain
--[ 2019.11.09.16.01.10.261.0 ]--
r 59                     nextCost = terrain.
--[ 2019.11.09.16.01.10.465.0 ]--
r 59                     nextCost = terrain.c
--[ 2019.11.09.16.01.10.543.0 ]--
r 59                     nextCost = terrain.co
--[ 2019.11.09.16.01.10.621.0 ]--
r 59                     nextCost = terrain.com
--[ 2019.11.09.16.01.10.793.0 ]--
r 59                     nextCost = terrain.comp
--[ 2019.11.09.16.01.10.871.0 ]--
r 59                     nextCost = terrain.compu
--[ 2019.11.09.16.01.10.918.0 ]--
r 59                     nextCost = terrain.comput
--[ 2019.11.09.16.01.11.011.0 ]--
r 59                     nextCost = terrain.compute
--[ 2019.11.09.16.01.11.310.0 ]--
r 59                     nextCost = terrain.computeT
--[ 2019.11.09.16.01.11.549.0 ]--
r 59                     nextCost = terrain.computeTr
--[ 2019.11.09.16.01.11.643.0 ]--
r 59                     nextCost = terrain.computeTra
--[ 2019.11.09.16.01.11.736.0 ]--
r 59                     nextCost = terrain.computeTrav
--[ 2019.11.09.16.01.11.845.0 ]--
r 59                     nextCost = terrain.computeTrave
--[ 2019.11.09.16.01.11.908.0 ]--
r 59                     nextCost = terrain.computeTravel
--[ 2019.11.09.16.01.12.426.0 ]--
r 59                     nextCost = terrain.computeTravelCost
--[ 2019.11.09.16.01.12.644.0 ]--
r 59                     nextCost = terrain.computeTravelCost()
--[ 2019.11.09.16.01.13.287.0 ]--
r 59                     nextCost = terrain.computeTravelCost(l)
--[ 2019.11.09.16.01.14.020.0 ]--
r 59                     nextCost = terrain.computeTravelCost()
--[ 2019.11.09.16.01.14.277.0 ]--
r 59                     nextCost = terrain.computeTravelCost(b)
--[ 2019.11.09.16.01.14.371.0 ]--
r 59                     nextCost = terrain.computeTravelCost(b.)
--[ 2019.11.09.16.01.14.635.0 ]--
r 59                     nextCost = terrain.computeTravelCost(b.g)
--[ 2019.11.09.16.01.14.712.0 ]--
r 59                     nextCost = terrain.computeTravelCost(b.ge)
--[ 2019.11.09.16.01.14.792.0 ]--
r 59                     nextCost = terrain.computeTravelCost(b.get)
--[ 2019.11.09.16.01.14.997.0 ]--
r 59                     nextCost = terrain.computeTravelCost(b.getL)
--[ 2019.11.09.16.01.15.150.0 ]--
r 59                     nextCost = terrain.computeTravelCost(b.getLo)
--[ 2019.11.09.16.01.15.212.0 ]--
r 59                     nextCost = terrain.computeTravelCost(b.getLoc)
--[ 2019.11.09.16.01.15.526.0 ]--
r 59                     nextCost = terrain.computeTravelCost(b.getLoc())
--[ 2019.11.09.16.01.15.804.0 ]--
r 59                     nextCost = terrain.computeTravelCost(b.getLoc(),)
--[ 2019.11.09.16.01.15.951.0 ]--
r 59                     nextCost = terrain.computeTravelCost(b.getLoc(), )
--[ 2019.11.09.16.01.16.045.0 ]--
r 59                     nextCost = terrain.computeTravelCost(b.getLoc(), l)
--[ 2019.11.09.16.01.16.264.0 ]--
r 59                     nextCost = terrain.computeTravelCost(b.getLoc(), lo)
--[ 2019.11.09.16.01.16.342.0 ]--
r 59                     nextCost = terrain.computeTravelCost(b.getLoc(), loc)
--[ 2019.11.09.16.01.16.734.0 ]--
r 59                     nextCost = terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.09.16.01.19.913.0 ]--
r 59                     fnextCost = terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.09.16.01.19.975.0 ]--
r 59                     flnextCost = terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.09.16.01.20.167.0 ]--
r 59                     flonextCost = terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.09.16.01.20.261.0 ]--
r 59                     floanextCost = terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.09.16.01.20.308.0 ]--
r 59                     floatnextCost = terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.09.16.01.20.401.0 ]--
r 59                     float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
--[ 2019.11.09.16.01.25.722.0 ]--
r 60                     this.cost = b.getCost(h) + n + heuristic*terrain.computeDistance(loc, end);
--[ 2019.11.09.16.01.25.917.0 ]--
r 60                     this.cost = b.getCost(h) + ne + heuristic*terrain.computeDistance(loc, end);
--[ 2019.11.09.16.01.25.948.0 ]--
r 60                     this.cost = b.getCost(h) + nex + heuristic*terrain.computeDistance(loc, end);
--[ 2019.11.09.16.01.26.231.0 ]--
r 60                     this.cost = b.getCost(h) + next + heuristic*terrain.computeDistance(loc, end);
--[ 2019.11.09.16.01.26.454.0 ]--
r 60                     this.cost = b.getCost(h) + nextC + heuristic*terrain.computeDistance(loc, end);
--[ 2019.11.09.16.01.26.626.0 ]--
r 60                     this.cost = b.getCost(h) + nextCo + heuristic*terrain.computeDistance(loc, end);
--[ 2019.11.09.16.01.26.750.0 ]--
r 60                     this.cost = b.getCost(h) + nextCos + heuristic*terrain.computeDistance(loc, end);
--[ 2019.11.09.16.01.26.828.0 ]--
r 60                     this.cost = b.getCost(h) + nextCost + heuristic*terrain.computeDistance(loc, end);
--[ 2019.11.09.16.01.31.494.0 ]--
r 61                     this.flatcost = b.getFlatCost() + n;
--[ 2019.11.09.16.01.31.556.0 ]--
r 61                     this.flatcost = b.getFlatCost() + ne;
--[ 2019.11.09.16.01.31.742.0 ]--
r 61                     this.flatcost = b.getFlatCost() + nex;
--[ 2019.11.09.16.01.31.930.0 ]--
r 61                     this.flatcost = b.getFlatCost() + next;
--[ 2019.11.09.16.01.32.222.0 ]--
r 61                     this.flatcost = b.getFlatCost() + nextc;
--[ 2019.11.09.16.01.32.914.0 ]--
r 61                     this.flatcost = b.getFlatCost() + next;
--[ 2019.11.09.16.01.33.180.0 ]--
r 61                     this.flatcost = b.getFlatCost() + nextC;
--[ 2019.11.09.16.01.33.406.0 ]--
r 61                     this.flatcost = b.getFlatCost() + nextCo;
--[ 2019.11.09.16.01.33.495.0 ]--
r 61                     this.flatcost = b.getFlatCost() + nextCos;
--[ 2019.11.09.16.01.33.564.0 ]--
r 61                     this.flatcost = b.getFlatCost() + nextCost;
--[ 2019.11.09.16.01.47.586.0 ]--
r 198         if (c != null) return c.g(0);
--[ 2019.11.09.16.01.47.781.0 ]--
r 198         if (c != null) return c.ge(0);
--[ 2019.11.09.16.01.47.812.0 ]--
r 198         if (c != null) return c.get(0);
--[ 2019.11.09.16.01.48.105.0 ]--
r 198         if (c != null) return c.getf(0);
--[ 2019.11.09.16.01.48.313.0 ]--
r 198         if (c != null) return c.getfl(0);
--[ 2019.11.09.16.01.48.381.0 ]--
r 198         if (c != null) return c.getfla(0);
--[ 2019.11.09.16.01.48.453.0 ]--
r 198         if (c != null) return c.getflat(0);
--[ 2019.11.09.16.01.48.782.0 ]--
r 198         if (c != null) return c.getflatC(0);
--[ 2019.11.09.16.01.48.966.0 ]--
r 198         if (c != null) return c.getflatCo(0);
--[ 2019.11.09.16.01.49.154.0 ]--
r 198         if (c != null) return c.getflatCost(0);
--[ 2019.11.09.16.01.51.028.0 ]--
r 198         if (c != null) return c.getflatCost();
--[ 2019.11.09.16.01.53.396.0 ]--
r 198         if (c != null) return c.getlatCost();
--[ 2019.11.09.16.01.53.567.0 ]--
r 198         if (c != null) return c.getFlatCost();
--[ 2019.11.09.16.01.55.724.0 ]--
r 198         if (c != null) return c.getFlatCostlatCost();
--[ 2019.11.09.16.01.55.755.0 ]--
r 198         if (c != null) return c.getFlatCost()latCost();
--[ 2019.11.09.16.01.57.974.0 ]--
r 198         if (c != null) return c.getFlatCost();
--[ 2019.11.09.16.02.07.930.0 ]--
r 69 
--[ 2019.11.09.16.02.09.609.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.16.05.12.931.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.16.07.16.819.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.09.16.07.18.232.0 ]--
r 48     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2019.11.09.16.07.21.508.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.16.08.50.096.0 ]--
r 158 
--[ 2019.11.09.16.08.50.370.0 ]--
- 158
--[ 2019.11.09.16.08.53.561.0 ]--
r 160 
--[ 2019.11.09.16.08.53.714.0 ]--
- 160
--[ 2019.11.09.16.09.23.349.0 ]--
:/src/Walker.java
+ 47             if (totalCost + (cost - prev) > end) { 
r 48                 prev = end - totalCost + (cost - prev); break; }
--[ 2019.11.09.16.09.25.928.0 ]--
+ 48                 prev = end - totalCost + (cost - prev); break; 
r 49             }
--[ 2019.11.09.16.09.27.031.0 ]--
- 49
r 49             } else {
--[ 2019.11.09.16.10.29.484.0 ]--
r 47             if (totalCost + (cost - prev) > end) {
r 48                 prev = end - totalCost + (cost - prev); break;
--[ 2019.11.09.16.10.29.756.0 ]--
DisposeComponent
--[ 2019.11.09.16.10.42.074.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.11.09.16.10.42.139.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml

--[ 2019.11.09.16.10.42.154.0 ]--
InitFile: /.cos265


--[ 2019.11.09.16.10.42.154.1 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.11.09.16.10.42.154.2 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.11.09.16.10.42.170.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private float totalCost;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;
        private float flatcost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        public Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) { this.cost = 0.0f; this.flatcost = 0.0f; }
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.getCost(h) + nextCost + heuristic*terrain.computeDistance(loc, end);
                    this.flatcost = b.getFlatCost() + nextCost;
                }
            }
        }

        public float getCost(float heuristic) {
            return cost;
        }

        public float getFlatCost() { return flatcost; }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        totalCost = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        Stopwatch stopwatch = new Stopwatch();
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            if (currentLoc.equals(getPathEnd())) {
                pathFound = true;
                endNode = currentNode;
                break;
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            atStart = false;
        }
        StdOut.println("stopwatch: " + stopwatch.elapsedTime());
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getFlatCost();
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        Stack<Coord> s = new Stack<>();
        PFNode c = endNode;
        while (c != null) {
            s.push(c.getLoc());
            c = c.fromNode;
        }
        return s;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2019.11.09.16.10.42.170.1 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float prev;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.prev = 0.0f;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        totalCost += prev;
        float end = totalCost + byTime;
        while (totalCost < end) {
            float cost = terrain.computeTravelCost(loc, nextLoc);
            if (totalCost + (cost - prev) > end) {
                prev = end - totalCost + (cost - prev); break;
            } else {
                totalCost += (cost - prev);
                prev = 0.0f;
                loc = path.dequeue();
                if (!path.isEmpty()) nextLoc = path.peek();
                else {
                    nextLoc = null;
                    break;
                }
            }
        }
    }

}

--[ 2019.11.09.16.10.42.170.2 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.11.09.16.10.42.185.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.11.09.16.10.42.185.1 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[1];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();
        int M = 0;

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.11.09.16.10.42.185.2 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.09.16.11.39.683.0 ]--
DisposeComponent
--[ 2019.11.09.19.36.24.869.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.11.09.19.36.25.087.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml

--[ 2019.11.09.19.36.25.103.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.09.19.36.25.119.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.11.09.19.36.25.134.0 ]--
InitFile: /.cos265


--[ 2019.11.09.19.36.25.150.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.11.09.19.36.25.165.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.11.09.19.36.25.197.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[1];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();
        int M = 0;

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.11.09.19.36.25.572.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.11.09.19.36.25.587.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float prev;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.prev = 0.0f;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        totalCost += prev;
        float end = totalCost + byTime;
        while (totalCost < end) {
            float cost = terrain.computeTravelCost(loc, nextLoc);
            if (totalCost + (cost - prev) > end) {
                prev = end - totalCost + (cost - prev); break;
            } else {
                totalCost += (cost - prev);
                prev = 0.0f;
                loc = path.dequeue();
                if (!path.isEmpty()) nextLoc = path.peek();
                else {
                    nextLoc = null;
                    break;
                }
            }
        }
    }

}

--[ 2019.11.09.19.36.25.650.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private float totalCost;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;
        private float flatcost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        public Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) { this.cost = 0.0f; this.flatcost = 0.0f; }
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.getCost(h) + nextCost + heuristic*terrain.computeDistance(loc, end);
                    this.flatcost = b.getFlatCost() + nextCost;
                }
            }
        }

        public float getCost(float heuristic) {
            return cost;
        }

        public float getFlatCost() { return flatcost; }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        totalCost = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        Stopwatch stopwatch = new Stopwatch();
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            if (currentLoc.equals(getPathEnd())) {
                pathFound = true;
                endNode = currentNode;
                break;
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            atStart = false;
        }
        StdOut.println("stopwatch: " + stopwatch.elapsedTime());
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getFlatCost();
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        Stack<Coord> s = new Stack<>();
        PFNode c = endNode;
        while (c != null) {
            s.push(c.getLoc());
            c = c.fromNode;
        }
        return s;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2019.11.09.19.36.32.707.0 ]--
UpdateTree (AD): 1 0
+ /P04_Pathfinding.zip

--[ 2019.11.09.19.38.34.556.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.19.39.09.325.0 ]--
:/src/Pathfinder.java
r 153 
--[ 2019.11.09.19.39.10.102.0 ]--
- 153
--[ 2019.11.09.19.39.21.078.0 ]--
r 182 
--[ 2019.11.09.19.39.21.739.0 ]--
- 182
--[ 2019.11.09.19.40.17.665.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.09.20.53.36.175.0 ]--
DisposeComponent
--[ 2019.11.10.22.26.23.514.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.11.10.22.26.23.859.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2019.11.10.22.26.23.878.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.10.22.26.23.902.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.11.10.22.26.23.920.0 ]--
InitFile: /.cos265


--[ 2019.11.10.22.26.23.938.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.11.10.22.26.23.959.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.11.10.22.26.23.993.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[1];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();
        int M = 0;

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.11.10.22.26.24.339.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.11.10.22.26.24.356.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float prev;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.prev = 0.0f;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        totalCost += prev;
        float end = totalCost + byTime;
        while (totalCost < end) {
            float cost = terrain.computeTravelCost(loc, nextLoc);
            if (totalCost + (cost - prev) > end) {
                prev = end - totalCost + (cost - prev); break;
            } else {
                totalCost += (cost - prev);
                prev = 0.0f;
                loc = path.dequeue();
                if (!path.isEmpty()) nextLoc = path.peek();
                else {
                    nextLoc = null;
                    break;
                }
            }
        }
    }

}

--[ 2019.11.10.22.26.24.374.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private float totalCost;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;
        private float flatcost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        public Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) { this.cost = 0.0f; this.flatcost = 0.0f; }
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.getCost(h) + nextCost + heuristic*terrain.computeDistance(loc, end);
                    this.flatcost = b.getFlatCost() + nextCost;
                }
            }
        }

        public float getCost(float heuristic) {
            return cost;
        }

        public float getFlatCost() { return flatcost; }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        totalCost = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            if (currentLoc.equals(getPathEnd())) {
                pathFound = true;
                endNode = currentNode;
                break;
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            atStart = false;
        }
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getFlatCost();
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        Stack<Coord> s = new Stack<>();
        PFNode c = endNode;
        while (c != null) {
            s.push(c.getLoc());
            c = c.fromNode;
        }
        return s;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2019.11.10.22.26.49.711.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.10.22.26.50.968.0 ]--
r 48     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2019.11.10.22.26.51.449.0 ]--
r 48     private final static String emapFilename = emaps[1-];        // change index to load a different elevation map
--[ 2019.11.10.22.26.53.326.0 ]--
r 48     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2019.11.10.22.26.53.758.0 ]--
r 48     private final static String emapFilename = emaps[10];        // change index to load a different elevation map
--[ 2019.11.10.22.27.02.246.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.10.22.29.10.430.0 ]--
r 56 
--[ 2019.11.10.22.29.11.316.0 ]--
- 56
--[ 2019.11.10.22.29.30.939.0 ]--
r 48     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2019.11.10.22.29.31.780.0 ]--
r 48     private final static String emapFilename = emaps[10];        // change index to load a different elevation map
--[ 2019.11.10.22.29.32.604.0 ]--
r 48     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2019.11.10.22.29.32.731.0 ]--
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.10.22.29.33.013.0 ]--
r 48     private final static String emapFilename = emaps[0];        // change index to load a different elevation map
--[ 2019.11.10.22.29.39.415.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.10.22.29.58.235.0 ]--
+ 56         
--[ 2019.11.10.22.29.58.417.0 ]--
r 56         i
--[ 2019.11.10.22.29.58.653.0 ]--
r 56         in
--[ 2019.11.10.22.29.58.759.0 ]--
r 56         int
--[ 2019.11.10.22.29.59.492.0 ]--
r 56         int 
--[ 2019.11.10.22.30.00.256.0 ]--
r 56         int M 
--[ 2019.11.10.22.30.00.339.0 ]--
r 56         int M =
--[ 2019.11.10.22.30.00.668.0 ]--
r 56         int M = 0
--[ 2019.11.10.22.30.00.806.0 ]--
r 56         int M = 0;
--[ 2019.11.10.22.30.12.085.0 ]--
+ 160                     
--[ 2019.11.10.22.30.12.943.0 ]--
r 160                     Std
--[ 2019.11.10.22.30.13.079.0 ]--
r 160                     StdO
--[ 2019.11.10.22.30.13.282.0 ]--
r 160                     StdOu
--[ 2019.11.10.22.30.13.461.0 ]--
r 160                     StdOut
--[ 2019.11.10.22.30.13.561.0 ]--
r 160                     StdOut.
--[ 2019.11.10.22.30.13.760.0 ]--
r 160                     StdOut.p
--[ 2019.11.10.22.30.13.863.0 ]--
r 160                     StdOut.pr
--[ 2019.11.10.22.30.13.963.0 ]--
r 160                     StdOut.pri
--[ 2019.11.10.22.30.14.061.0 ]--
r 160                     StdOut.prin
--[ 2019.11.10.22.30.14.144.0 ]--
r 160                     StdOut.print
--[ 2019.11.10.22.30.14.263.0 ]--
r 160                     StdOut.printl
--[ 2019.11.10.22.30.14.361.0 ]--
r 160                     StdOut.println
--[ 2019.11.10.22.30.14.695.0 ]--
r 160                     StdOut.println()
--[ 2019.11.10.22.30.14.833.0 ]--
r 160                     StdOut.println("")
--[ 2019.11.10.22.30.15.331.0 ]--
r 160                     StdOut.println()
--[ 2019.11.10.22.30.16.573.0 ]--
r 160                     StdOut.println(+)
--[ 2019.11.10.22.30.16.703.0 ]--
r 160                     StdOut.println(++)
--[ 2019.11.10.22.30.17.022.0 ]--
r 160                     StdOut.println(++M)
--[ 2019.11.10.22.30.17.579.0 ]--
r 160                     StdOut.println(++M);
--[ 2019.11.10.22.30.19.456.0 ]--
+ 158                     
--[ 2019.11.10.22.30.20.089.0 ]--
r 158                     M
--[ 2019.11.10.22.30.20.424.0 ]--
r 158                     M 
--[ 2019.11.10.22.30.20.541.0 ]--
r 158                     M =
--[ 2019.11.10.22.30.20.612.0 ]--
r 158                     M = 
--[ 2019.11.10.22.30.20.961.0 ]--
r 158                     M = 0
--[ 2019.11.10.22.30.21.155.0 ]--
r 158                     M = 0;
--[ 2019.11.10.22.30.27.895.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.10.22.31.56.198.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.10.22.34.07.109.0 ]--
:/src/Pathfinder.java
r 174                     } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getFCost(h)) {
--[ 2019.11.10.22.34.07.902.0 ]--
r 174                     } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getFltaCost(h)) {
--[ 2019.11.10.22.34.08.888.0 ]--
r 174                     } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getFltCost(h)) {
--[ 2019.11.10.22.34.09.071.0 ]--
r 174                     } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getFlCost(h)) {
--[ 2019.11.10.22.34.09.234.0 ]--
r 174                     } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getFlaCost(h)) {
--[ 2019.11.10.22.34.09.319.0 ]--
r 174                     } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getFlatCost(h)) {
--[ 2019.11.10.22.34.11.894.0 ]--
r 174                     } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getFlatCost()) {
--[ 2019.11.10.22.34.14.147.0 ]--
r 174                     } else if (c.getFCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getFlatCost()) {
--[ 2019.11.10.22.34.14.464.0 ]--
r 174                     } else if (c.getFlCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getFlatCost()) {
--[ 2019.11.10.22.34.14.548.0 ]--
r 174                     } else if (c.getFlaCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getFlatCost()) {
--[ 2019.11.10.22.34.14.647.0 ]--
r 174                     } else if (c.getFlatCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getFlatCost()) {
--[ 2019.11.10.22.34.17.503.0 ]--
r 174                     } else if (c.getFlatCost() < board[c.getLoc().getI()][c.getLoc().getJ()].getFlatCost()) {
--[ 2019.11.10.22.34.29.571.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.10.22.34.52.608.0 ]--
r 174                     } else if (c.getFlatCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getFlatCost()) {
--[ 2019.11.10.22.34.53.384.0 ]--
r 174                     } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getFlatCost()) {
--[ 2019.11.10.22.34.54.161.0 ]--
r 174                     } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getFlatCost(h)) {
--[ 2019.11.10.22.34.55.421.0 ]--
r 174                     } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getFlCost(h)) {
--[ 2019.11.10.22.34.55.995.0 ]--
r 174                     } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getFltaCost(h)) {
--[ 2019.11.10.22.34.56.412.0 ]--
r 174                     } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
--[ 2019.11.10.22.37.06.685.0 ]--
DisposeComponent
--[ 2019.11.10.23.31.46.730.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.11.10.23.31.46.833.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml

--[ 2019.11.10.23.31.46.845.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.10.23.31.46.853.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.11.10.23.31.46.866.0 ]--
InitFile: /.cos265


--[ 2019.11.10.23.31.46.873.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.11.10.23.31.46.884.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.11.10.23.31.46.895.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[0];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();
        int M = 0;

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                    M = 0;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                    StdOut.println(++M);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.11.10.23.31.46.909.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.11.10.23.31.46.919.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float prev;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.prev = 0.0f;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        totalCost += prev;
        float end = totalCost + byTime;
        while (totalCost < end) {
            float cost = terrain.computeTravelCost(loc, nextLoc);
            if (totalCost + (cost - prev) > end) {
                prev = end - totalCost + (cost - prev); break;
            } else {
                totalCost += (cost - prev);
                prev = 0.0f;
                loc = path.dequeue();
                if (!path.isEmpty()) nextLoc = path.peek();
                else {
                    nextLoc = null;
                    break;
                }
            }
        }
    }

}

--[ 2019.11.10.23.31.46.937.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private float totalCost;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;
        private float flatcost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        public Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) { this.cost = 0.0f; this.flatcost = 0.0f; }
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.getCost(h) + nextCost + heuristic*terrain.computeDistance(loc, end);
                    this.flatcost = b.getFlatCost() + nextCost;
                }
            }
        }

        public float getCost(float heuristic) {
            return cost;
        }

        public float getFlatCost() { return flatcost; }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        totalCost = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            if (currentLoc.equals(getPathEnd())) {
                pathFound = true;
                endNode = currentNode;
                break;
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            atStart = false;
        }
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getFlatCost();
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        Stack<Coord> s = new Stack<>();
        PFNode c = endNode;
        while (c != null) {
            s.push(c.getLoc());
            c = c.fromNode;
        }
        return s;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2019.11.10.23.31.55.163.0 ]--
UpdateTree (AD): 1 0
+ /P04_Pathfinding.zip

--[ 2019.11.10.23.42.33.075.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.10.23.42.33.961.0 ]--
r 48     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2019.11.10.23.42.34.052.0 ]--
r 48     private final static String emapFilename = emaps[12];        // change index to load a different elevation map
--[ 2019.11.10.23.42.39.878.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.10.23.47.07.196.0 ]--
:/src/Walker.java
+ 45         
--[ 2019.11.10.23.47.10.459.0 ]--
r 45         S
--[ 2019.11.10.23.47.10.738.0 ]--
r 45         St
--[ 2019.11.10.23.47.10.906.0 ]--
r 45         Std
--[ 2019.11.10.23.47.11.161.0 ]--
r 45         StdO
--[ 2019.11.10.23.47.11.278.0 ]--
r 45         StdOu
--[ 2019.11.10.23.47.11.419.0 ]--
r 45         StdOut
--[ 2019.11.10.23.47.11.498.0 ]--
r 45         StdOut.
--[ 2019.11.10.23.47.11.729.0 ]--
r 45         StdOut.p
--[ 2019.11.10.23.47.11.838.0 ]--
r 45         StdOut.pr
--[ 2019.11.10.23.47.11.924.0 ]--
r 45         StdOut.pri
--[ 2019.11.10.23.47.12.017.0 ]--
r 45         StdOut.prin
--[ 2019.11.10.23.47.12.114.0 ]--
r 45         StdOut.print
--[ 2019.11.10.23.47.12.176.0 ]--
r 45         StdOut.printl
--[ 2019.11.10.23.47.12.260.0 ]--
r 45         StdOut.println
--[ 2019.11.10.23.47.12.440.0 ]--
r 45         StdOut.println()
--[ 2019.11.10.23.47.12.646.0 ]--
r 45         StdOut.println("")
--[ 2019.11.10.23.47.12.858.0 ]--
r 45         StdOut.println("t")
--[ 2019.11.10.23.47.12.992.0 ]--
r 45         StdOut.println("to")
--[ 2019.11.10.23.47.13.054.0 ]--
r 45         StdOut.println("tot")
--[ 2019.11.10.23.47.13.143.0 ]--
r 45         StdOut.println("tota")
--[ 2019.11.10.23.47.13.224.0 ]--
r 45         StdOut.println("total")
--[ 2019.11.10.23.47.13.323.0 ]--
r 45         StdOut.println("total ")
--[ 2019.11.10.23.47.13.441.0 ]--
r 45         StdOut.println("total c")
--[ 2019.11.10.23.47.13.536.0 ]--
r 45         StdOut.println("total co")
--[ 2019.11.10.23.47.13.631.0 ]--
r 45         StdOut.println("total cos")
--[ 2019.11.10.23.47.13.732.0 ]--
r 45         StdOut.println("total cost")
--[ 2019.11.10.23.47.13.827.0 ]--
r 45         StdOut.println("total cost ")
--[ 2019.11.10.23.47.13.968.0 ]--
r 45         StdOut.println("total cost t")
--[ 2019.11.10.23.47.14.073.0 ]--
r 45         StdOut.println("total cost th")
--[ 2019.11.10.23.47.14.180.0 ]--
r 45         StdOut.println("total cost this")
--[ 2019.11.10.23.47.14.254.0 ]--
r 45         StdOut.println("total cost this ")
--[ 2019.11.10.23.47.14.372.0 ]--
r 45         StdOut.println("total cost this r")
--[ 2019.11.10.23.47.14.452.0 ]--
r 45         StdOut.println("total cost this ru")
--[ 2019.11.10.23.47.14.634.0 ]--
r 45         StdOut.println("total cost this run")
--[ 2019.11.10.23.47.14.991.0 ]--
r 45         StdOut.println("total cost this run:")
--[ 2019.11.10.23.47.15.168.0 ]--
r 45         StdOut.println("total cost this run: ")
--[ 2019.11.10.23.47.15.553.0 ]--
r 45         StdOut.println("total cost this run: " )
--[ 2019.11.10.23.47.15.770.0 ]--
r 45         StdOut.println("total cost this run: " +)
--[ 2019.11.10.23.47.15.874.0 ]--
r 45         StdOut.println("total cost this run: " + )
--[ 2019.11.10.23.47.16.189.0 ]--
r 45         StdOut.println("total cost this run: " + t)
--[ 2019.11.10.23.47.16.275.0 ]--
r 45         StdOut.println("total cost this run: " + to)
--[ 2019.11.10.23.47.16.376.0 ]--
r 45         StdOut.println("total cost this run: " + tot)
--[ 2019.11.10.23.47.16.447.0 ]--
r 45         StdOut.println("total cost this run: " + tota)
--[ 2019.11.10.23.47.16.553.0 ]--
r 45         StdOut.println("total cost this run: " + total)
--[ 2019.11.10.23.47.16.649.0 ]--
r 45         StdOut.println("total cost this run: " + totalc)
--[ 2019.11.10.23.47.17.027.0 ]--
r 45         StdOut.println("total cost this run: " + total)
--[ 2019.11.10.23.47.17.193.0 ]--
r 45         StdOut.println("total cost this run: " + totalC)
--[ 2019.11.10.23.47.17.315.0 ]--
r 45         StdOut.println("total cost this run: " + totalCo)
--[ 2019.11.10.23.47.17.421.0 ]--
r 45         StdOut.println("total cost this run: " + totalCos)
--[ 2019.11.10.23.47.17.503.0 ]--
r 45         StdOut.println("total cost this run: " + totalCost)
--[ 2019.11.10.23.47.17.886.0 ]--
r 45         StdOut.println("total cost this run: " + totalCost);
--[ 2019.11.10.23.47.22.719.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.10.23.47.51.129.0 ]--
+ 46         
--[ 2019.11.10.23.47.51.654.0 ]--
r 46         S
--[ 2019.11.10.23.47.51.866.0 ]--
r 46         St
--[ 2019.11.10.23.47.52.077.0 ]--
r 46         Std
--[ 2019.11.10.23.47.52.269.0 ]--
r 46         StdO
--[ 2019.11.10.23.47.52.454.0 ]--
r 46         StdOu
--[ 2019.11.10.23.47.52.543.0 ]--
r 46         StdOut
--[ 2019.11.10.23.47.52.661.0 ]--
r 46         StdOut.
--[ 2019.11.10.23.47.52.887.0 ]--
r 46         StdOut.p
--[ 2019.11.10.23.47.52.995.0 ]--
r 46         StdOut.pr
--[ 2019.11.10.23.47.53.109.0 ]--
r 46         StdOut.pri
--[ 2019.11.10.23.47.53.228.0 ]--
r 46         StdOut.prin
--[ 2019.11.10.23.47.53.290.0 ]--
r 46         StdOut.print
--[ 2019.11.10.23.47.53.706.0 ]--
r 46         StdOut.printl
--[ 2019.11.10.23.47.53.820.0 ]--
r 46         StdOut.println
--[ 2019.11.10.23.47.54.030.0 ]--
r 46         StdOut.println()
--[ 2019.11.10.23.47.54.230.0 ]--
r 46         StdOut.println("")
--[ 2019.11.10.23.47.54.477.0 ]--
r 46         StdOut.println("b")
--[ 2019.11.10.23.47.54.576.0 ]--
r 46         StdOut.println("by")
--[ 2019.11.10.23.47.54.859.0 ]--
r 46         StdOut.println("byT")
--[ 2019.11.10.23.47.54.962.0 ]--
r 46         StdOut.println("byTi")
--[ 2019.11.10.23.47.55.020.0 ]--
r 46         StdOut.println("byTim")
--[ 2019.11.10.23.47.55.114.0 ]--
r 46         StdOut.println("byTime")
--[ 2019.11.10.23.47.55.265.0 ]--
r 46         StdOut.println("byTime:")
--[ 2019.11.10.23.47.55.390.0 ]--
r 46         StdOut.println("byTime: ")
--[ 2019.11.10.23.47.55.928.0 ]--
r 46         StdOut.println("byTime: " )
--[ 2019.11.10.23.47.56.089.0 ]--
r 46         StdOut.println("byTime: " +)
--[ 2019.11.10.23.47.56.163.0 ]--
r 46         StdOut.println("byTime: " + )
--[ 2019.11.10.23.47.56.368.0 ]--
r 46         StdOut.println("byTime: " + b)
--[ 2019.11.10.23.47.56.499.0 ]--
r 46         StdOut.println("byTime: " + by)
--[ 2019.11.10.23.47.56.766.0 ]--
r 46         StdOut.println("byTime: " + byT)
--[ 2019.11.10.23.47.56.912.0 ]--
r 46         StdOut.println("byTime: " + byTi)
--[ 2019.11.10.23.47.56.977.0 ]--
r 46         StdOut.println("byTime: " + byTim)
--[ 2019.11.10.23.47.57.064.0 ]--
r 46         StdOut.println("byTime: " + byTime)
--[ 2019.11.10.23.47.57.395.0 ]--
r 46         StdOut.println("byTime: " + byTime);
--[ 2019.11.10.23.48.02.460.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.10.23.48.29.157.0 ]--
+ 48             
--[ 2019.11.10.23.48.29.760.0 ]--
r 48             S
--[ 2019.11.10.23.48.29.982.0 ]--
r 48             St
--[ 2019.11.10.23.48.30.163.0 ]--
r 48             Std
--[ 2019.11.10.23.48.30.366.0 ]--
r 48             StdO
--[ 2019.11.10.23.48.30.559.0 ]--
r 48             StdOu
--[ 2019.11.10.23.48.30.690.0 ]--
r 48             StdOut
--[ 2019.11.10.23.48.30.777.0 ]--
r 48             StdOut.
--[ 2019.11.10.23.48.31.040.0 ]--
r 48             StdOut.p
--[ 2019.11.10.23.48.31.158.0 ]--
r 48             StdOut.pr
--[ 2019.11.10.23.48.31.222.0 ]--
r 48             StdOut.pri
--[ 2019.11.10.23.48.31.351.0 ]--
r 48             StdOut.prin
--[ 2019.11.10.23.48.31.495.0 ]--
r 48             StdOut.print
--[ 2019.11.10.23.48.31.574.0 ]--
r 48             StdOut.printl
--[ 2019.11.10.23.48.31.648.0 ]--
r 48             StdOut.println
--[ 2019.11.10.23.48.31.835.0 ]--
r 48             StdOut.println()
--[ 2019.11.10.23.48.32.045.0 ]--
r 48             StdOut.println("")
--[ 2019.11.10.23.48.32.241.0 ]--
r 48             StdOut.println("s")
--[ 2019.11.10.23.48.32.339.0 ]--
r 48             StdOut.println("st")
--[ 2019.11.10.23.48.32.444.0 ]--
r 48             StdOut.println("sta")
--[ 2019.11.10.23.48.32.553.0 ]--
r 48             StdOut.println("star")
--[ 2019.11.10.23.48.32.778.0 ]--
r 48             StdOut.println("start")
--[ 2019.11.10.23.48.32.842.0 ]--
r 48             StdOut.println("starti")
--[ 2019.11.10.23.48.32.918.0 ]--
r 48             StdOut.println("startin")
--[ 2019.11.10.23.48.33.005.0 ]--
r 48             StdOut.println("starting")
--[ 2019.11.10.23.48.33.074.0 ]--
r 48             StdOut.println("starting ")
--[ 2019.11.10.23.48.33.165.0 ]--
r 48             StdOut.println("starting l")
--[ 2019.11.10.23.48.33.319.0 ]--
r 48             StdOut.println("starting ll")
--[ 2019.11.10.23.48.33.729.0 ]--
r 48             StdOut.println("starting l")
--[ 2019.11.10.23.48.33.950.0 ]--
r 48             StdOut.println("starting lo")
--[ 2019.11.10.23.48.34.116.0 ]--
r 48             StdOut.println("starting loo")
--[ 2019.11.10.23.48.34.215.0 ]--
r 48             StdOut.println("starting loop")
--[ 2019.11.10.23.48.34.571.0 ]--
r 48             StdOut.println("starting loop!")
--[ 2019.11.10.23.48.36.075.0 ]--
r 48             StdOut.println("starting loop! ")
--[ 2019.11.10.23.48.36.233.0 ]--
r 48             StdOut.println("starting loop! -")
--[ 2019.11.10.23.48.36.707.0 ]--
r 48             StdOut.println("starting loop! --")
--[ 2019.11.10.23.48.36.756.0 ]--
r 48             StdOut.println("starting loop! ---")
--[ 2019.11.10.23.48.36.800.0 ]--
r 48             StdOut.println("starting loop! ----")
--[ 2019.11.10.23.48.36.833.0 ]--
r 48             StdOut.println("starting loop! -----")
--[ 2019.11.10.23.48.36.861.0 ]--
r 48             StdOut.println("starting loop! ------")
--[ 2019.11.10.23.48.36.897.0 ]--
r 48             StdOut.println("starting loop! -------")
--[ 2019.11.10.23.48.36.929.0 ]--
r 48             StdOut.println("starting loop! --------")
--[ 2019.11.10.23.48.36.963.0 ]--
r 48             StdOut.println("starting loop! ---------")
--[ 2019.11.10.23.48.36.994.0 ]--
r 48             StdOut.println("starting loop! ----------")
--[ 2019.11.10.23.48.37.024.0 ]--
r 48             StdOut.println("starting loop! -----------")
--[ 2019.11.10.23.48.37.057.0 ]--
r 48             StdOut.println("starting loop! ------------")
--[ 2019.11.10.23.48.37.125.0 ]--
r 48             StdOut.println("starting loop! --------------")
--[ 2019.11.10.23.48.37.157.0 ]--
r 48             StdOut.println("starting loop! ---------------")
--[ 2019.11.10.23.48.38.249.0 ]--
r 48             StdOut.println("starting loop! ---------------");
--[ 2019.11.10.23.48.41.522.0 ]--
+ 50             
--[ 2019.11.10.23.48.41.761.0 ]--
r 50             S
--[ 2019.11.10.23.48.41.971.0 ]--
r 50             St
--[ 2019.11.10.23.48.42.152.0 ]--
r 50             Std
--[ 2019.11.10.23.48.42.320.0 ]--
r 50             StdO
--[ 2019.11.10.23.48.42.506.0 ]--
r 50             StdOu
--[ 2019.11.10.23.48.42.605.0 ]--
r 50             StdOut
--[ 2019.11.10.23.48.42.726.0 ]--
r 50             StdOut.
--[ 2019.11.10.23.48.42.935.0 ]--
r 50             StdOut.p
--[ 2019.11.10.23.48.43.066.0 ]--
r 50             StdOut.pr
--[ 2019.11.10.23.48.43.148.0 ]--
r 50             StdOut.pri
--[ 2019.11.10.23.48.43.256.0 ]--
r 50             StdOut.prin
--[ 2019.11.10.23.48.43.366.0 ]--
r 50             StdOut.print
--[ 2019.11.10.23.48.43.436.0 ]--
r 50             StdOut.printl
--[ 2019.11.10.23.48.43.502.0 ]--
r 50             StdOut.println
--[ 2019.11.10.23.48.43.688.0 ]--
r 50             StdOut.println()
--[ 2019.11.10.23.48.43.880.0 ]--
r 50             StdOut.println("")
--[ 2019.11.10.23.48.46.513.0 ]--
r 50             StdOut.println("c")
--[ 2019.11.10.23.48.46.608.0 ]--
r 50             StdOut.println("co")
--[ 2019.11.10.23.48.46.831.0 ]--
r 50             StdOut.println("cos")
--[ 2019.11.10.23.48.46.953.0 ]--
r 50             StdOut.println("cost")
--[ 2019.11.10.23.48.47.217.0 ]--
r 50             StdOut.println("cost:")
--[ 2019.11.10.23.48.47.304.0 ]--
r 50             StdOut.println("cost: ")
--[ 2019.11.10.23.48.47.919.0 ]--
r 50             StdOut.println("cost: " )
--[ 2019.11.10.23.48.48.098.0 ]--
r 50             StdOut.println("cost: " +)
--[ 2019.11.10.23.48.48.156.0 ]--
r 50             StdOut.println("cost: " + )
--[ 2019.11.10.23.48.48.328.0 ]--
r 50             StdOut.println("cost: " + c)
--[ 2019.11.10.23.48.48.750.0 ]--
r 50             StdOut.println("cost: " + cost)
--[ 2019.11.10.23.48.49.084.0 ]--
r 50             StdOut.println("cost: " + cost);
--[ 2019.11.10.23.48.49.288.0 ]--
+ 51             
--[ 2019.11.10.23.48.49.716.0 ]--
r 51             t
--[ 2019.11.10.23.48.49.864.0 ]--
r 51             to
--[ 2019.11.10.23.48.50.116.0 ]--
r 51             t
--[ 2019.11.10.23.48.50.251.0 ]--
r 51             
--[ 2019.11.10.23.48.50.399.0 ]--
r 51             S
--[ 2019.11.10.23.48.50.597.0 ]--
r 51             St
--[ 2019.11.10.23.48.50.754.0 ]--
r 51             Std
--[ 2019.11.10.23.48.50.906.0 ]--
r 51             StdO
--[ 2019.11.10.23.48.51.072.0 ]--
r 51             StdOu
--[ 2019.11.10.23.48.51.181.0 ]--
r 51             StdOut
--[ 2019.11.10.23.48.51.282.0 ]--
r 51             StdOut.
--[ 2019.11.10.23.48.51.489.0 ]--
r 51             StdOut.p
--[ 2019.11.10.23.48.51.649.0 ]--
r 51             StdOut.pi
--[ 2019.11.10.23.48.51.681.0 ]--
r 51             StdOut.pir
--[ 2019.11.10.23.48.51.847.0 ]--
r 51             StdOut.pirn
--[ 2019.11.10.23.48.52.049.0 ]--
r 51             StdOut.pirnt
--[ 2019.11.10.23.48.52.339.0 ]--
r 51             StdOut.pirn
--[ 2019.11.10.23.48.52.616.0 ]--
r 51             StdOut.pir
--[ 2019.11.10.23.48.52.670.0 ]--
r 51             StdOut.pi
--[ 2019.11.10.23.48.52.790.0 ]--
r 51             StdOut.p
--[ 2019.11.10.23.48.53.473.0 ]--
r 51             StdOut.pr
--[ 2019.11.10.23.48.53.603.0 ]--
r 51             StdOut.pri
--[ 2019.11.10.23.48.53.668.0 ]--
r 51             StdOut.prin
--[ 2019.11.10.23.48.53.749.0 ]--
r 51             StdOut.print
--[ 2019.11.10.23.48.53.846.0 ]--
r 51             StdOut.printl
--[ 2019.11.10.23.48.53.896.0 ]--
r 51             StdOut.println
--[ 2019.11.10.23.48.54.079.0 ]--
r 51             StdOut.println()
--[ 2019.11.10.23.48.54.263.0 ]--
r 51             StdOut.println("")
--[ 2019.11.10.23.48.54.993.0 ]--
r 51             StdOut.println("p")
--[ 2019.11.10.23.48.55.056.0 ]--
r 51             StdOut.println("pr")
--[ 2019.11.10.23.48.55.133.0 ]--
r 51             StdOut.println("pre")
--[ 2019.11.10.23.48.55.328.0 ]--
r 51             StdOut.println("prev")
--[ 2019.11.10.23.48.55.498.0 ]--
r 51             StdOut.println("prev:")
--[ 2019.11.10.23.48.55.713.0 ]--
r 51             StdOut.println("prev: ")
--[ 2019.11.10.23.48.56.033.0 ]--
r 51             StdOut.println("prev: " )
--[ 2019.11.10.23.48.56.237.0 ]--
r 51             StdOut.println("prev: " +)
--[ 2019.11.10.23.48.56.341.0 ]--
r 51             StdOut.println("prev: " + )
--[ 2019.11.10.23.48.56.506.0 ]--
r 51             StdOut.println("prev: " + p)
--[ 2019.11.10.23.48.56.616.0 ]--
r 51             StdOut.println("prev: " + pr)
--[ 2019.11.10.23.48.56.690.0 ]--
r 51             StdOut.println("prev: " + pre)
--[ 2019.11.10.23.48.56.866.0 ]--
r 51             StdOut.println("prev: " + prev)
--[ 2019.11.10.23.48.57.227.0 ]--
r 51             StdOut.println("prev: " + prev);
--[ 2019.11.10.23.49.02.379.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.00.01.38.155.0 ]--
+ 47         
--[ 2019.11.11.00.01.38.793.0 ]--
r 47         A
--[ 2019.11.11.00.01.39.046.0 ]--
r 47         Ar
--[ 2019.11.11.00.01.39.211.0 ]--
r 47         Ars
--[ 2019.11.11.00.01.39.403.0 ]--
r 47         ArsO
--[ 2019.11.11.00.01.39.581.0 ]--
r 47         ArsOu
--[ 2019.11.11.00.01.39.848.0 ]--
r 47         ArsO
--[ 2019.11.11.00.01.40.037.0 ]--
r 47         Ars
--[ 2019.11.11.00.01.40.209.0 ]--
r 47         Ar
--[ 2019.11.11.00.01.40.371.0 ]--
r 47         A
--[ 2019.11.11.00.01.40.511.0 ]--
r 47         
--[ 2019.11.11.00.01.40.838.0 ]--
r 47         S
--[ 2019.11.11.00.01.41.039.0 ]--
r 47         St
--[ 2019.11.11.00.01.41.258.0 ]--
r 47         Std
--[ 2019.11.11.00.01.41.422.0 ]--
r 47         StdO
--[ 2019.11.11.00.01.41.626.0 ]--
r 47         StdOu
--[ 2019.11.11.00.01.41.724.0 ]--
r 47         StdOut
--[ 2019.11.11.00.01.41.829.0 ]--
r 47         StdOut.
--[ 2019.11.11.00.01.42.060.0 ]--
r 47         StdOut.p
--[ 2019.11.11.00.01.42.186.0 ]--
r 47         StdOut.pr
--[ 2019.11.11.00.01.42.277.0 ]--
r 47         StdOut.pri
--[ 2019.11.11.00.01.42.382.0 ]--
r 47         StdOut.prin
--[ 2019.11.11.00.01.42.469.0 ]--
r 47         StdOut.print
--[ 2019.11.11.00.01.42.577.0 ]--
r 47         StdOut.printl
--[ 2019.11.11.00.01.42.643.0 ]--
r 47         StdOut.println
--[ 2019.11.11.00.01.42.847.0 ]--
r 47         StdOut.println()
--[ 2019.11.11.00.01.43.414.0 ]--
r 47         StdOut.println("")
--[ 2019.11.11.00.01.43.575.0 ]--
r 47         StdOut.println("e")
--[ 2019.11.11.00.01.43.662.0 ]--
r 47         StdOut.println("en")
--[ 2019.11.11.00.01.43.786.0 ]--
r 47         StdOut.println("end")
--[ 2019.11.11.00.01.43.943.0 ]--
r 47         StdOut.println("end:")
--[ 2019.11.11.00.01.44.030.0 ]--
r 47         StdOut.println("end: ")
--[ 2019.11.11.00.01.44.380.0 ]--
r 47         StdOut.println("end: " )
--[ 2019.11.11.00.01.44.568.0 ]--
r 47         StdOut.println("end: " +)
--[ 2019.11.11.00.01.44.650.0 ]--
r 47         StdOut.println("end: " + )
--[ 2019.11.11.00.01.44.970.0 ]--
r 47         StdOut.println("end: " + e)
--[ 2019.11.11.00.01.45.092.0 ]--
r 47         StdOut.println("end: " + en)
--[ 2019.11.11.00.01.45.193.0 ]--
r 47         StdOut.println("end: " + end)
--[ 2019.11.11.00.01.45.564.0 ]--
r 47         StdOut.println("end: " + end);
--[ 2019.11.11.00.01.52.517.0 ]--
+ 53             
--[ 2019.11.11.00.01.53.158.0 ]--
r 53             S
--[ 2019.11.11.00.01.53.378.0 ]--
r 53             St
--[ 2019.11.11.00.01.53.558.0 ]--
r 53             Std
--[ 2019.11.11.00.01.53.718.0 ]--
r 53             StdO
--[ 2019.11.11.00.01.53.911.0 ]--
r 53             StdOu
--[ 2019.11.11.00.01.54.002.0 ]--
r 53             StdOut
--[ 2019.11.11.00.01.54.114.0 ]--
r 53             StdOut.
--[ 2019.11.11.00.01.54.338.0 ]--
r 53             StdOut.p
--[ 2019.11.11.00.01.54.469.0 ]--
r 53             StdOut.pr
--[ 2019.11.11.00.01.54.541.0 ]--
r 53             StdOut.pri
--[ 2019.11.11.00.01.54.653.0 ]--
r 53             StdOut.prin
--[ 2019.11.11.00.01.54.750.0 ]--
r 53             StdOut.print
--[ 2019.11.11.00.01.54.837.0 ]--
r 53             StdOut.printl
--[ 2019.11.11.00.01.54.904.0 ]--
r 53             StdOut.println
--[ 2019.11.11.00.01.55.101.0 ]--
r 53             StdOut.println()
--[ 2019.11.11.00.01.55.300.0 ]--
r 53             StdOut.println("")
--[ 2019.11.11.00.01.55.519.0 ]--
r 53             StdOut.println("c")
--[ 2019.11.11.00.01.55.589.0 ]--
r 53             StdOut.println("cu")
--[ 2019.11.11.00.01.55.750.0 ]--
r 53             StdOut.println("cur")
--[ 2019.11.11.00.01.55.944.0 ]--
r 53             StdOut.println("curr")
--[ 2019.11.11.00.01.56.003.0 ]--
r 53             StdOut.println("curre")
--[ 2019.11.11.00.01.56.097.0 ]--
r 53             StdOut.println("curren")
--[ 2019.11.11.00.01.56.248.0 ]--
r 53             StdOut.println("current")
--[ 2019.11.11.00.01.56.359.0 ]--
r 53             StdOut.println("current ")
--[ 2019.11.11.00.01.56.502.0 ]--
r 53             StdOut.println("current t")
--[ 2019.11.11.00.01.56.708.0 ]--
r 53             StdOut.println("current tc")
--[ 2019.11.11.00.01.56.997.0 ]--
r 53             StdOut.println("current tc:")
--[ 2019.11.11.00.01.57.195.0 ]--
r 53             StdOut.println("current tc: ")
--[ 2019.11.11.00.01.57.931.0 ]--
r 53             StdOut.println("current tc: " )
--[ 2019.11.11.00.01.58.100.0 ]--
r 53             StdOut.println("current tc: " +)
--[ 2019.11.11.00.01.58.206.0 ]--
r 53             StdOut.println("current tc: " + )
--[ 2019.11.11.00.01.58.431.0 ]--
r 53             StdOut.println("current tc: " + t)
--[ 2019.11.11.00.01.58.550.0 ]--
r 53             StdOut.println("current tc: " + to)
--[ 2019.11.11.00.01.58.662.0 ]--
r 53             StdOut.println("current tc: " + tot)
--[ 2019.11.11.00.01.58.720.0 ]--
r 53             StdOut.println("current tc: " + tota)
--[ 2019.11.11.00.01.58.798.0 ]--
r 53             StdOut.println("current tc: " + total)
--[ 2019.11.11.00.01.59.041.0 ]--
r 53             StdOut.println("current tc: " + totalC)
--[ 2019.11.11.00.01.59.150.0 ]--
r 53             StdOut.println("current tc: " + totalCo)
--[ 2019.11.11.00.01.59.327.0 ]--
r 53             StdOut.println("current tc: " + totalCos)
--[ 2019.11.11.00.01.59.404.0 ]--
r 53             StdOut.println("current tc: " + totalCost)
--[ 2019.11.11.00.02.00.126.0 ]--
r 53             StdOut.println("current tc: " + totalCost);
--[ 2019.11.11.00.02.02.299.0 ]--
+ 54             
--[ 2019.11.11.00.02.02.782.0 ]--
r 54             S
--[ 2019.11.11.00.02.03.199.0 ]--
r 54             Std
--[ 2019.11.11.00.02.03.356.0 ]--
r 54             StdO
--[ 2019.11.11.00.02.03.582.0 ]--
r 54             StdOu
--[ 2019.11.11.00.02.03.686.0 ]--
r 54             StdOut
--[ 2019.11.11.00.02.03.785.0 ]--
r 54             StdOut.
--[ 2019.11.11.00.02.04.091.0 ]--
r 54             StdOut.p
--[ 2019.11.11.00.02.04.178.0 ]--
r 54             StdOut.pr
--[ 2019.11.11.00.02.04.292.0 ]--
r 54             StdOut.pri
--[ 2019.11.11.00.02.04.377.0 ]--
r 54             StdOut.prin
--[ 2019.11.11.00.02.04.473.0 ]--
r 54             StdOut.print
--[ 2019.11.11.00.02.04.584.0 ]--
r 54             StdOut.printl
--[ 2019.11.11.00.02.04.630.0 ]--
r 54             StdOut.println
--[ 2019.11.11.00.02.04.816.0 ]--
r 54             StdOut.println()
--[ 2019.11.11.00.02.05.012.0 ]--
r 54             StdOut.println("")
--[ 2019.11.11.00.02.07.528.0 ]--
r 54             StdOut.println("v")
--[ 2019.11.11.00.02.07.633.0 ]--
r 54             StdOut.println("va")
--[ 2019.11.11.00.02.07.755.0 ]--
r 54             StdOut.println("val")
--[ 2019.11.11.00.02.07.882.0 ]--
r 54             StdOut.println("vals")
--[ 2019.11.11.00.02.08.051.0 ]--
r 54             StdOut.println("vals:")
--[ 2019.11.11.00.02.08.829.0 ]--
r 54             StdOut.println("vals: ")
--[ 2019.11.11.00.02.09.338.0 ]--
r 54             StdOut.println("vals: " )
--[ 2019.11.11.00.02.09.519.0 ]--
r 54             StdOut.println("vals: " +)
--[ 2019.11.11.00.02.09.668.0 ]--
r 54             StdOut.println("vals: " + )
--[ 2019.11.11.00.02.10.812.0 ]--
r 54             StdOut.println("vals: " +)
--[ 2019.11.11.00.02.11.170.0 ]--
r 54             StdOut.println("vals: " )
--[ 2019.11.11.00.02.11.333.0 ]--
r 54             StdOut.println("vals: ")
--[ 2019.11.11.00.02.12.180.0 ]--
r 54             StdOut.println("vals: ");
--[ 2019.11.11.00.02.12.700.0 ]--
+ 55             
--[ 2019.11.11.00.02.13.046.0 ]--
r 55             S
--[ 2019.11.11.00.02.13.872.0 ]--
r 55             StdOu
--[ 2019.11.11.00.02.13.940.0 ]--
r 55             StdOut
--[ 2019.11.11.00.02.14.039.0 ]--
r 55             StdOut.
--[ 2019.11.11.00.02.14.223.0 ]--
r 55             StdOut.p
--[ 2019.11.11.00.02.14.369.0 ]--
r 55             StdOut.pr
--[ 2019.11.11.00.02.14.423.0 ]--
r 55             StdOut.pri
--[ 2019.11.11.00.02.15.392.0 ]--
r 55             StdOut.prin
--[ 2019.11.11.00.02.15.489.0 ]--
r 55             StdOut.print
--[ 2019.11.11.00.02.15.613.0 ]--
r 55             StdOut.printl
--[ 2019.11.11.00.02.15.698.0 ]--
r 55             StdOut.println
--[ 2019.11.11.00.02.15.965.0 ]--
r 55             StdOut.println()
--[ 2019.11.11.00.02.17.911.0 ]--
r 55             StdOut.println(t)
--[ 2019.11.11.00.02.18.026.0 ]--
r 55             StdOut.println(to)
--[ 2019.11.11.00.02.18.111.0 ]--
r 55             StdOut.println(tot)
--[ 2019.11.11.00.02.18.185.0 ]--
r 55             StdOut.println(tota)
--[ 2019.11.11.00.02.18.274.0 ]--
r 55             StdOut.println(total)
--[ 2019.11.11.00.02.18.573.0 ]--
r 55             StdOut.println(totalC)
--[ 2019.11.11.00.02.18.702.0 ]--
r 55             StdOut.println(totalCo)
--[ 2019.11.11.00.02.18.854.0 ]--
r 55             StdOut.println(totalCos)
--[ 2019.11.11.00.02.18.957.0 ]--
r 55             StdOut.println(totalCost)
--[ 2019.11.11.00.02.19.044.0 ]--
r 55             StdOut.println(totalCost )
--[ 2019.11.11.00.02.19.234.0 ]--
r 55             StdOut.println(totalCost +)
--[ 2019.11.11.00.02.19.341.0 ]--
r 55             StdOut.println(totalCost + )
--[ 2019.11.11.00.02.19.628.0 ]--
r 55             StdOut.println(totalCost + ())
--[ 2019.11.11.00.02.19.802.0 ]--
r 55             StdOut.println(totalCost + (c))
--[ 2019.11.11.00.02.19.892.0 ]--
r 55             StdOut.println(totalCost + (co))
--[ 2019.11.11.00.02.20.033.0 ]--
r 55             StdOut.println(totalCost + (cos))
--[ 2019.11.11.00.02.20.163.0 ]--
r 55             StdOut.println(totalCost + (cost))
--[ 2019.11.11.00.02.20.235.0 ]--
r 55             StdOut.println(totalCost + (cost ))
--[ 2019.11.11.00.02.20.267.0 ]--
r 55             StdOut.println(totalCost + (cost -))
--[ 2019.11.11.00.02.20.404.0 ]--
r 55             StdOut.println(totalCost + (cost - ))
--[ 2019.11.11.00.02.20.521.0 ]--
r 55             StdOut.println(totalCost + (cost - p))
--[ 2019.11.11.00.02.20.621.0 ]--
r 55             StdOut.println(totalCost + (cost - pr))
--[ 2019.11.11.00.02.20.697.0 ]--
r 55             StdOut.println(totalCost + (cost - pre))
--[ 2019.11.11.00.02.20.886.0 ]--
r 55             StdOut.println(totalCost + (cost - prev))
--[ 2019.11.11.00.02.21.648.0 ]--
r 55             StdOut.println(totalCost + (cost - prev));
--[ 2019.11.11.00.02.24.454.0 ]--
r 54             StdOut.printl("vals: ");
--[ 2019.11.11.00.02.24.915.0 ]--
r 54             StdOut.print("vals: ");
--[ 2019.11.11.00.02.30.039.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.00.03.26.095.0 ]--
+ 57                 
--[ 2019.11.11.00.03.26.337.0 ]--
r 57                 S
--[ 2019.11.11.00.03.26.539.0 ]--
r 57                 St
--[ 2019.11.11.00.03.26.716.0 ]--
r 57                 Std
--[ 2019.11.11.00.03.26.925.0 ]--
r 57                 StdO
--[ 2019.11.11.00.03.27.105.0 ]--
r 57                 StdOu
--[ 2019.11.11.00.03.27.182.0 ]--
r 57                 StdOut
--[ 2019.11.11.00.03.27.324.0 ]--
r 57                 StdOut.
--[ 2019.11.11.00.03.27.552.0 ]--
r 57                 StdOut.p
--[ 2019.11.11.00.03.27.654.0 ]--
r 57                 StdOut.pr
--[ 2019.11.11.00.03.27.781.0 ]--
r 57                 StdOut.pri
--[ 2019.11.11.00.03.27.873.0 ]--
r 57                 StdOut.prin
--[ 2019.11.11.00.03.28.025.0 ]--
r 57                 StdOut.print
--[ 2019.11.11.00.03.28.086.0 ]--
r 57                 StdOut.printl
--[ 2019.11.11.00.03.28.139.0 ]--
r 57                 StdOut.println
--[ 2019.11.11.00.03.28.332.0 ]--
r 57                 StdOut.println()
--[ 2019.11.11.00.03.28.551.0 ]--
r 57                 StdOut.println("")
--[ 2019.11.11.00.03.28.882.0 ]--
r 57                 StdOut.println("e")
--[ 2019.11.11.00.03.28.991.0 ]--
r 57                 StdOut.println("en")
--[ 2019.11.11.00.03.29.093.0 ]--
r 57                 StdOut.println("end")
--[ 2019.11.11.00.03.29.267.0 ]--
r 57                 StdOut.println("end:")
--[ 2019.11.11.00.03.29.656.0 ]--
r 57                 StdOut.println("end: ")
--[ 2019.11.11.00.03.29.819.0 ]--
r 57                 StdOut.println("end: " )
--[ 2019.11.11.00.03.30.039.0 ]--
r 57                 StdOut.println("end: " +)
--[ 2019.11.11.00.03.30.115.0 ]--
r 57                 StdOut.println("end: " + )
--[ 2019.11.11.00.03.30.291.0 ]--
r 57                 StdOut.println("end: " + e)
--[ 2019.11.11.00.03.30.399.0 ]--
r 57                 StdOut.println("end: " + en)
--[ 2019.11.11.00.03.30.484.0 ]--
r 57                 StdOut.println("end: " + end)
--[ 2019.11.11.00.03.30.845.0 ]--
r 57                 StdOut.println("end: " + end);
--[ 2019.11.11.00.03.31.050.0 ]--
+ 58                 
--[ 2019.11.11.00.03.31.554.0 ]--
r 58                 S
--[ 2019.11.11.00.03.31.745.0 ]--
r 58                 St
--[ 2019.11.11.00.03.31.941.0 ]--
r 58                 Std
--[ 2019.11.11.00.03.32.146.0 ]--
r 58                 StdO
--[ 2019.11.11.00.03.32.554.0 ]--
r 58                 StdOut
--[ 2019.11.11.00.03.32.607.0 ]--
r 58                 StdOut.
--[ 2019.11.11.00.03.32.800.0 ]--
r 58                 StdOut.p
--[ 2019.11.11.00.03.32.929.0 ]--
r 58                 StdOut.pr
--[ 2019.11.11.00.03.33.024.0 ]--
r 58                 StdOut.pri
--[ 2019.11.11.00.03.33.148.0 ]--
r 58                 StdOut.prin
--[ 2019.11.11.00.03.33.270.0 ]--
r 58                 StdOut.print
--[ 2019.11.11.00.03.33.356.0 ]--
r 58                 StdOut.printl
--[ 2019.11.11.00.03.33.426.0 ]--
r 58                 StdOut.println
--[ 2019.11.11.00.03.33.618.0 ]--
r 58                 StdOut.println()
--[ 2019.11.11.00.03.33.856.0 ]--
r 58                 StdOut.println("")
--[ 2019.11.11.00.03.34.358.0 ]--
r 58                 StdOut.println()
--[ 2019.11.11.00.03.34.918.0 ]--
r 58                 StdOut.printl
--[ 2019.11.11.00.03.34.957.0 ]--
r 58                 StdOut.print
--[ 2019.11.11.00.03.34.986.0 ]--
r 58                 StdOut.prin
--[ 2019.11.11.00.03.35.016.0 ]--
r 58                 StdOut.pri
--[ 2019.11.11.00.03.35.072.0 ]--
r 58                 StdOut.p
--[ 2019.11.11.00.03.35.102.0 ]--
r 58                 StdOut.
--[ 2019.11.11.00.03.35.132.0 ]--
r 58                 StdOut
--[ 2019.11.11.00.03.35.290.0 ]--
r 58                 StdOu
--[ 2019.11.11.00.03.35.496.0 ]--
r 58                 StdO
--[ 2019.11.11.00.03.35.675.0 ]--
r 58                 Std
--[ 2019.11.11.00.03.35.854.0 ]--
r 58                 St
--[ 2019.11.11.00.03.36.097.0 ]--
r 58                 S
--[ 2019.11.11.00.03.36.421.0 ]--
r 58                 
--[ 2019.11.11.00.03.36.853.0 ]--
- 58
--[ 2019.11.11.00.03.42.951.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.00.06.05.787.0 ]--
r 58                 prev = end - totalCost ; break;
--[ 2019.11.11.00.06.05.925.0 ]--
r 58                 prev = end - totalCost; break;
--[ 2019.11.11.00.06.10.304.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.00.06.50.078.0 ]--
r 56             if (totalCost + (cost - prev > end) {
--[ 2019.11.11.00.06.50.593.0 ]--
r 56             if (totalCost + (cost - pre > end) {
--[ 2019.11.11.00.06.50.629.0 ]--
r 56             if (totalCost + (cost - pr > end) {
--[ 2019.11.11.00.06.50.658.0 ]--
r 56             if (totalCost + (cost - p > end) {
--[ 2019.11.11.00.06.50.689.0 ]--
r 56             if (totalCost + (cost -  > end) {
--[ 2019.11.11.00.06.50.720.0 ]--
r 56             if (totalCost + (cost - > end) {
--[ 2019.11.11.00.06.50.755.0 ]--
r 56             if (totalCost + (cost  > end) {
--[ 2019.11.11.00.06.50.789.0 ]--
r 56             if (totalCost + (cost > end) {
--[ 2019.11.11.00.06.50.823.0 ]--
r 56             if (totalCost + (cos > end) {
--[ 2019.11.11.00.06.50.853.0 ]--
r 56             if (totalCost + (co > end) {
--[ 2019.11.11.00.06.50.882.0 ]--
r 56             if (totalCost + (c > end) {
--[ 2019.11.11.00.06.51.032.0 ]--
r 56             if (totalCost + ( > end) {
--[ 2019.11.11.00.06.51.213.0 ]--
r 56             if (totalCost +  > end) {
--[ 2019.11.11.00.06.51.747.0 ]--
r 56             if (totalCost + > end) {
--[ 2019.11.11.00.06.51.912.0 ]--
r 56             if (totalCost  > end) {
--[ 2019.11.11.00.06.52.281.0 ]--
r 56             if (totalCost > end) {
--[ 2019.11.11.00.06.56.834.0 ]--
r 56             if (totalCost + (cost - prev) > end) {
--[ 2019.11.11.00.07.46.059.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.00.10.23.279.0 ]--
+ 15     
--[ 2019.11.11.00.10.23.655.0 ]--
r 15     fl
--[ 2019.11.11.00.10.23.722.0 ]--
r 15     flo
--[ 2019.11.11.00.10.23.797.0 ]--
r 15     floa
--[ 2019.11.11.00.10.23.939.0 ]--
r 15     float
--[ 2019.11.11.00.10.23.984.0 ]--
r 15     float 
--[ 2019.11.11.00.10.24.019.0 ]--
r 15     float p
--[ 2019.11.11.00.10.24.145.0 ]--
r 15     float pr
--[ 2019.11.11.00.10.24.241.0 ]--
r 15     float pro
--[ 2019.11.11.00.10.24.349.0 ]--
r 15     float prog
--[ 2019.11.11.00.10.24.556.0 ]--
r 15     float progr
--[ 2019.11.11.00.10.24.648.0 ]--
r 15     float progre
--[ 2019.11.11.00.10.24.744.0 ]--
r 15     float progres
--[ 2019.11.11.00.10.24.920.0 ]--
r 15     float progress
--[ 2019.11.11.00.10.24.998.0 ]--
r 15     float progress;
--[ 2019.11.11.00.10.27.237.0 ]--
+ 29         
--[ 2019.11.11.00.10.27.578.0 ]--
r 29         t
--[ 2019.11.11.00.10.27.682.0 ]--
r 29         th
--[ 2019.11.11.00.10.27.744.0 ]--
r 29         thi
--[ 2019.11.11.00.10.27.808.0 ]--
r 29         this
--[ 2019.11.11.00.10.27.926.0 ]--
r 29         this.
--[ 2019.11.11.00.10.28.175.0 ]--
r 29         this.p
--[ 2019.11.11.00.10.28.233.0 ]--
r 29         this.pr
--[ 2019.11.11.00.10.28.340.0 ]--
r 29         this.pro
--[ 2019.11.11.00.10.28.441.0 ]--
r 29         this.prog
--[ 2019.11.11.00.10.28.655.0 ]--
r 29         this.progr
--[ 2019.11.11.00.10.28.744.0 ]--
r 29         this.progre
--[ 2019.11.11.00.10.28.820.0 ]--
r 29         this.progres
--[ 2019.11.11.00.10.28.996.0 ]--
r 29         this.progress
--[ 2019.11.11.00.10.29.079.0 ]--
r 29         this.progress 
--[ 2019.11.11.00.10.29.199.0 ]--
r 29         this.progress =
--[ 2019.11.11.00.10.29.288.0 ]--
r 29         this.progress = 
--[ 2019.11.11.00.10.29.390.0 ]--
r 29         this.progress = 0
--[ 2019.11.11.00.10.29.625.0 ]--
r 29         this.progress = 0.
--[ 2019.11.11.00.10.29.842.0 ]--
r 29         this.progress = 0.0
--[ 2019.11.11.00.10.29.909.0 ]--
r 29         this.progress = 0.0f
--[ 2019.11.11.00.10.30.030.0 ]--
r 29         this.progress = 0.0f;
--[ 2019.11.11.00.10.33.089.0 ]--
+ 64                 
--[ 2019.11.11.00.10.33.373.0 ]--
r 64                 p
--[ 2019.11.11.00.10.33.736.0 ]--
r 64                 prog
--[ 2019.11.11.00.10.33.859.0 ]--
r 64                 progr
--[ 2019.11.11.00.10.33.944.0 ]--
r 64                 progre
--[ 2019.11.11.00.10.34.009.0 ]--
r 64                 progres
--[ 2019.11.11.00.10.34.204.0 ]--
r 64                 progress
--[ 2019.11.11.00.10.34.302.0 ]--
r 64                 progress 
--[ 2019.11.11.00.10.34.403.0 ]--
r 64                 progress =
--[ 2019.11.11.00.10.34.509.0 ]--
r 64                 progress = 
--[ 2019.11.11.00.10.35.396.0 ]--
r 64                 progress = 0
--[ 2019.11.11.00.10.35.625.0 ]--
r 64                 progress = 0.
--[ 2019.11.11.00.10.35.878.0 ]--
r 64                 progress = 0.0
--[ 2019.11.11.00.10.35.970.0 ]--
r 64                 progress = 0.0f
--[ 2019.11.11.00.10.36.074.0 ]--
r 64                 progress = 0.0f;
--[ 2019.11.11.00.11.44.548.0 ]--
+ 60                 
--[ 2019.11.11.00.11.44.964.0 ]--
r 60                 p
--[ 2019.11.11.00.11.45.095.0 ]--
r 60                 pr
--[ 2019.11.11.00.11.45.192.0 ]--
r 60                 pro
--[ 2019.11.11.00.11.45.336.0 ]--
r 60                 prog
--[ 2019.11.11.00.11.45.562.0 ]--
r 60                 progr
--[ 2019.11.11.00.11.45.656.0 ]--
r 60                 progre
--[ 2019.11.11.00.11.45.710.0 ]--
r 60                 progres
--[ 2019.11.11.00.11.45.899.0 ]--
r 60                 progress
--[ 2019.11.11.00.11.46.029.0 ]--
r 60                 progress 
--[ 2019.11.11.00.11.46.210.0 ]--
r 60                 progress +
--[ 2019.11.11.00.11.46.399.0 ]--
r 60                 progress +=
--[ 2019.11.11.00.11.46.488.0 ]--
r 60                 progress += 
--[ 2019.11.11.00.11.46.988.0 ]--
r 60                 progress += p
--[ 2019.11.11.00.11.47.105.0 ]--
r 60                 progress += pr
--[ 2019.11.11.00.11.47.196.0 ]--
r 60                 progress += pre
--[ 2019.11.11.00.11.47.398.0 ]--
r 60                 progress += prev
--[ 2019.11.11.00.11.47.456.0 ]--
r 60                 progress += prev;
--[ 2019.11.11.00.11.47.785.0 ]--
r 60                 progress += prev
--[ 2019.11.11.00.11.48.288.0 ]--
r 60                 progress += pre
--[ 2019.11.11.00.11.48.323.0 ]--
r 60                 progress += pr
--[ 2019.11.11.00.11.48.353.0 ]--
r 60                 progress += p
--[ 2019.11.11.00.11.48.386.0 ]--
r 60                 progress += 
--[ 2019.11.11.00.11.48.434.0 ]--
r 60                 progress +=
--[ 2019.11.11.00.11.48.465.0 ]--
r 60                 progress +
--[ 2019.11.11.00.11.48.517.0 ]--
r 60                 progress 
--[ 2019.11.11.00.11.48.565.0 ]--
r 60                 progress
--[ 2019.11.11.00.11.48.595.0 ]--
r 60                 progres
--[ 2019.11.11.00.11.48.740.0 ]--
r 60                 progre
--[ 2019.11.11.00.11.48.937.0 ]--
r 60                 progr
--[ 2019.11.11.00.11.49.108.0 ]--
r 60                 prog
--[ 2019.11.11.00.11.49.262.0 ]--
r 60                 pro
--[ 2019.11.11.00.11.49.453.0 ]--
r 60                 pr
--[ 2019.11.11.00.11.49.629.0 ]--
r 60                 p
--[ 2019.11.11.00.11.49.818.0 ]--
r 60                 
--[ 2019.11.11.00.11.50.174.0 ]--
- 60
--[ 2019.11.11.00.11.52.414.0 ]--
+ 60                 prev = end - totalCost; 
r 61                 break;
--[ 2019.11.11.00.11.52.760.0 ]--
r 61                 pbreak;
--[ 2019.11.11.00.11.52.807.0 ]--
r 61                 prbreak;
--[ 2019.11.11.00.11.52.920.0 ]--
r 61                 probreak;
--[ 2019.11.11.00.11.53.012.0 ]--
r 61                 progbreak;
--[ 2019.11.11.00.11.53.233.0 ]--
r 61                 progrbreak;
--[ 2019.11.11.00.11.53.325.0 ]--
r 61                 progrebreak;
--[ 2019.11.11.00.11.53.389.0 ]--
r 61                 progresbreak;
--[ 2019.11.11.00.11.53.561.0 ]--
r 61                 progressbreak;
--[ 2019.11.11.00.11.53.646.0 ]--
r 61                 progress break;
--[ 2019.11.11.00.11.53.805.0 ]--
r 61                 progress +break;
--[ 2019.11.11.00.11.53.960.0 ]--
r 61                 progress +=break;
--[ 2019.11.11.00.11.54.004.0 ]--
r 61                 progress += break;
--[ 2019.11.11.00.11.54.193.0 ]--
r 61                 progress += pbreak;
--[ 2019.11.11.00.11.54.299.0 ]--
r 61                 progress += prbreak;
--[ 2019.11.11.00.11.54.385.0 ]--
r 61                 progress += prebreak;
--[ 2019.11.11.00.11.54.569.0 ]--
r 61                 progress += prevbreak;
--[ 2019.11.11.00.11.54.930.0 ]--
+ 61                 progress += prev;
r 62                 break;
--[ 2019.11.11.00.12.13.018.0 ]--
r 58             if (totalCost + ((cost - prev)) > end) {
--[ 2019.11.11.00.12.13.786.0 ]--
r 58             if (totalCost + (c) > end) {
--[ 2019.11.11.00.12.13.921.0 ]--
r 58             if (totalCost + (co) > end) {
--[ 2019.11.11.00.12.14.055.0 ]--
r 58             if (totalCost + (cos) > end) {
--[ 2019.11.11.00.12.14.146.0 ]--
r 58             if (totalCost + (cost) > end) {
--[ 2019.11.11.00.12.14.443.0 ]--
r 58             if (totalCost + (cost-) > end) {
--[ 2019.11.11.00.12.14.776.0 ]--
r 58             if (totalCost + (cost-p) > end) {
--[ 2019.11.11.00.12.14.860.0 ]--
r 58             if (totalCost + (cost-pr) > end) {
--[ 2019.11.11.00.12.14.959.0 ]--
r 58             if (totalCost + (cost-pro) > end) {
--[ 2019.11.11.00.12.15.058.0 ]--
r 58             if (totalCost + (cost-prog) > end) {
--[ 2019.11.11.00.12.15.313.0 ]--
r 58             if (totalCost + (cost-progr) > end) {
--[ 2019.11.11.00.12.15.392.0 ]--
r 58             if (totalCost + (cost-progre) > end) {
--[ 2019.11.11.00.12.15.491.0 ]--
r 58             if (totalCost + (cost-progres) > end) {
--[ 2019.11.11.00.12.15.642.0 ]--
r 58             if (totalCost + (cost-progress) > end) {
--[ 2019.11.11.00.12.17.919.0 ]--
r 60                 prev = end - totalCost;
--[ 2019.11.11.00.12.20.063.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.00.12.42.661.0 ]--
r 59                 /StdOut.println("end: " + end);
--[ 2019.11.11.00.12.42.843.0 ]--
r 59                 //StdOut.println("end: " + end);
--[ 2019.11.11.00.12.46.466.0 ]--
r 53             /StdOut.println("cost: " + cost);
--[ 2019.11.11.00.12.46.683.0 ]--
r 53             /*StdOut.println("cost: " + cost);
--[ 2019.11.11.00.12.48.872.0 ]--
r 57             StdOut.println(totalCost + (cost - prev));*
--[ 2019.11.11.00.12.49.236.0 ]--
r 57             StdOut.println(totalCost + (cost - prev));*/
--[ 2019.11.11.00.12.52.637.0 ]--
r 47         /StdOut.println("total cost this run: " + totalCost);
--[ 2019.11.11.00.12.52.869.0 ]--
r 47         /*StdOut.println("total cost this run: " + totalCost);
--[ 2019.11.11.00.12.54.775.0 ]--
r 49         *StdOut.println("end: " + end);
--[ 2019.11.11.00.12.55.131.0 ]--
r 49         */StdOut.println("end: " + end);
--[ 2019.11.11.00.12.55.881.0 ]--
r 49         *StdOut.println("end: " + end);
--[ 2019.11.11.00.12.56.158.0 ]--
r 49         StdOut.println("end: " + end);
--[ 2019.11.11.00.12.57.602.0 ]--
r 49         StdOut.println("end: " + end);*
--[ 2019.11.11.00.12.57.863.0 ]--
r 49         StdOut.println("end: " + end);*/
--[ 2019.11.11.00.13.03.835.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.00.13.10.439.0 ]--
r 51             /StdOut.println("starting loop! ---------------");
--[ 2019.11.11.00.13.10.580.0 ]--
r 51             //StdOut.println("starting loop! ---------------");
--[ 2019.11.11.00.13.15.150.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.00.14.33.489.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 48     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2019.11.11.00.14.33.876.0 ]--
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.11.00.14.34.560.0 ]--
r 48     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2019.11.11.00.14.34.714.0 ]--
r 48     private final static String emapFilename = emaps[10];        // change index to load a different elevation map
--[ 2019.11.11.00.14.38.966.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.00.20.00.059.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.00.23.37.347.0 ]--
:/src/Walker.java
r 64                 totalCost += (cost - p);
--[ 2019.11.11.00.23.37.453.0 ]--
r 64                 totalCost += (cost - pr);
--[ 2019.11.11.00.23.37.547.0 ]--
r 64                 totalCost += (cost - pro);
--[ 2019.11.11.00.23.37.673.0 ]--
r 64                 totalCost += (cost - prog);
--[ 2019.11.11.00.23.37.956.0 ]--
r 64                 totalCost += (cost - progr);
--[ 2019.11.11.00.23.38.059.0 ]--
r 64                 totalCost += (cost - progre);
--[ 2019.11.11.00.23.38.136.0 ]--
r 64                 totalCost += (cost - progres);
--[ 2019.11.11.00.23.38.335.0 ]--
r 64                 totalCost += (cost - progress);
--[ 2019.11.11.00.23.43.444.0 ]--
+ 61                 
--[ 2019.11.11.00.23.44.261.0 ]--
r 61                 t
--[ 2019.11.11.00.23.44.395.0 ]--
r 61                 to
--[ 2019.11.11.00.23.44.475.0 ]--
r 61                 tot
--[ 2019.11.11.00.23.44.554.0 ]--
r 61                 tota
--[ 2019.11.11.00.23.44.624.0 ]--
r 61                 total
--[ 2019.11.11.00.23.44.761.0 ]--
r 61                 totalc
--[ 2019.11.11.00.23.45.020.0 ]--
r 61                 totalcS
--[ 2019.11.11.00.23.45.464.0 ]--
r 61                 totalc
--[ 2019.11.11.00.23.45.674.0 ]--
r 61                 total
--[ 2019.11.11.00.23.45.915.0 ]--
r 61                 totalC
--[ 2019.11.11.00.23.46.090.0 ]--
r 61                 totalCo
--[ 2019.11.11.00.23.46.228.0 ]--
r 61                 totalCos
--[ 2019.11.11.00.23.46.313.0 ]--
r 61                 totalCost
--[ 2019.11.11.00.23.46.391.0 ]--
r 61                 totalCost 
--[ 2019.11.11.00.23.46.588.0 ]--
r 61                 totalCost +
--[ 2019.11.11.00.23.47.046.0 ]--
r 61                 totalCost += 
--[ 2019.11.11.00.23.55.234.0 ]--
r 60                 fprev = end - totalCost;
--[ 2019.11.11.00.23.55.332.0 ]--
r 60                 flprev = end - totalCost;
--[ 2019.11.11.00.23.55.490.0 ]--
r 60                 floprev = end - totalCost;
--[ 2019.11.11.00.23.55.694.0 ]--
r 60                 floatprev = end - totalCost;
--[ 2019.11.11.00.23.55.725.0 ]--
r 60                 float prev = end - totalCost;
--[ 2019.11.11.00.23.58.219.0 ]--
r 61                 totalCost += p
--[ 2019.11.11.00.23.58.561.0 ]--
r 61                 totalCost += pre
--[ 2019.11.11.00.23.58.594.0 ]--
r 61                 totalCost += prev
--[ 2019.11.11.00.23.58.637.0 ]--
r 61                 totalCost += prev;
--[ 2019.11.11.00.24.00.607.0 ]--
r 45 
--[ 2019.11.11.00.24.00.794.0 ]--
- 45
--[ 2019.11.11.00.24.03.316.0 ]--
r 14 
--[ 2019.11.11.00.24.03.483.0 ]--
- 14
--[ 2019.11.11.00.24.05.064.0 ]--
r 27 
--[ 2019.11.11.00.24.05.232.0 ]--
- 27
--[ 2019.11.11.00.24.10.951.0 ]--
r 63 
--[ 2019.11.11.00.24.11.361.0 ]--
- 63
--[ 2019.11.11.00.24.43.042.0 ]--
r 55             if (totalCost + (cost -progress) > end) {
--[ 2019.11.11.00.24.43.886.0 ]--
r 55             if (totalCost + (cost - progress) > end) {
--[ 2019.11.11.00.24.47.334.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.00.26.09.021.0 ]--
r 44         /StdOut.println("total cost this run: " + totalCost);
--[ 2019.11.11.00.26.09.189.0 ]--
r 44         StdOut.println("total cost this run: " + totalCost);
--[ 2019.11.11.00.26.10.786.0 ]--
r 48             /StdOut.println("starting loop! ---------------");
--[ 2019.11.11.00.26.10.973.0 ]--
r 48             StdOut.println("starting loop! ---------------");
--[ 2019.11.11.00.26.11.926.0 ]--
r 46         StdOut.println("end: " + end);*
--[ 2019.11.11.00.26.12.097.0 ]--
r 46         StdOut.println("end: " + end);
--[ 2019.11.11.00.26.13.236.0 ]--
r 50             /StdOut.println("cost: " + cost);
--[ 2019.11.11.00.26.13.404.0 ]--
r 50             StdOut.println("cost: " + cost);
--[ 2019.11.11.00.26.14.990.0 ]--
r 54             StdOut.println(totalCost + (cost - prev));*
--[ 2019.11.11.00.26.15.174.0 ]--
r 54             StdOut.println(totalCost + (cost - prev));
--[ 2019.11.11.00.26.21.639.0 ]--
r 54             StdOut.println(totalCost + (cost - p));
--[ 2019.11.11.00.26.21.980.0 ]--
r 54             StdOut.println(totalCost + (cost - prog));
--[ 2019.11.11.00.26.22.166.0 ]--
r 54             StdOut.println(totalCost + (cost - progr));
--[ 2019.11.11.00.26.22.259.0 ]--
r 54             StdOut.println(totalCost + (cost - progre));
--[ 2019.11.11.00.26.22.354.0 ]--
r 54             StdOut.println(totalCost + (cost - progres));
--[ 2019.11.11.00.26.22.552.0 ]--
r 54             StdOut.println(totalCost + (cost - progress));
--[ 2019.11.11.00.26.24.581.0 ]--
r 51             StdOut.println("p: " + prev);
--[ 2019.11.11.00.26.24.682.0 ]--
r 51             StdOut.println("pr: " + prev);
--[ 2019.11.11.00.26.24.784.0 ]--
r 51             StdOut.println("pro: " + prev);
--[ 2019.11.11.00.26.24.938.0 ]--
r 51             StdOut.println("prog: " + prev);
--[ 2019.11.11.00.26.25.134.0 ]--
r 51             StdOut.println("progr: " + prev);
--[ 2019.11.11.00.26.25.228.0 ]--
r 51             StdOut.println("progre: " + prev);
--[ 2019.11.11.00.26.25.330.0 ]--
r 51             StdOut.println("progres: " + prev);
--[ 2019.11.11.00.26.25.529.0 ]--
r 51             StdOut.println("progress: " + prev);
--[ 2019.11.11.00.26.27.223.0 ]--
r 51             StdOut.println("progress: " + p);
--[ 2019.11.11.00.26.27.326.0 ]--
r 51             StdOut.println("progress: " + pr);
--[ 2019.11.11.00.26.27.419.0 ]--
r 51             StdOut.println("progress: " + pro);
--[ 2019.11.11.00.26.27.555.0 ]--
r 51             StdOut.println("progress: " + prog);
--[ 2019.11.11.00.26.27.765.0 ]--
r 51             StdOut.println("progress: " + progr);
--[ 2019.11.11.00.26.27.858.0 ]--
r 51             StdOut.println("progress: " + progre);
--[ 2019.11.11.00.26.27.948.0 ]--
r 51             StdOut.println("progress: " + progres);
--[ 2019.11.11.00.26.28.151.0 ]--
r 51             StdOut.println("progress: " + progress);
--[ 2019.11.11.00.26.36.904.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.00.31.23.282.0 ]--
+ 67                     
--[ 2019.11.11.00.31.23.786.0 ]--
r 67                     S
--[ 2019.11.11.00.31.24.005.0 ]--
r 67                     St
--[ 2019.11.11.00.31.24.221.0 ]--
r 67                     Std
--[ 2019.11.11.00.31.24.404.0 ]--
r 67                     StdO
--[ 2019.11.11.00.31.24.597.0 ]--
r 67                     StdOu
--[ 2019.11.11.00.31.24.683.0 ]--
r 67                     StdOut
--[ 2019.11.11.00.31.24.776.0 ]--
r 67                     StdOut.
--[ 2019.11.11.00.31.25.035.0 ]--
r 67                     StdOut.p
--[ 2019.11.11.00.31.25.145.0 ]--
r 67                     StdOut.pr
--[ 2019.11.11.00.31.25.221.0 ]--
r 67                     StdOut.pri
--[ 2019.11.11.00.31.25.355.0 ]--
r 67                     StdOut.prin
--[ 2019.11.11.00.31.25.473.0 ]--
r 67                     StdOut.print
--[ 2019.11.11.00.31.25.565.0 ]--
r 67                     StdOut.printl
--[ 2019.11.11.00.31.25.641.0 ]--
r 67                     StdOut.println
--[ 2019.11.11.00.31.25.840.0 ]--
r 67                     StdOut.println()
--[ 2019.11.11.00.31.26.039.0 ]--
r 67                     StdOut.println("")
--[ 2019.11.11.00.31.26.433.0 ]--
r 67                     StdOut.println("E")
--[ 2019.11.11.00.31.26.526.0 ]--
r 67                     StdOut.println("EM")
--[ 2019.11.11.00.31.26.640.0 ]--
r 67                     StdOut.println("EMP")
--[ 2019.11.11.00.31.26.724.0 ]--
r 67                     StdOut.println("EMPT")
--[ 2019.11.11.00.31.26.839.0 ]--
r 67                     StdOut.println("EMPTY")
--[ 2019.11.11.00.31.27.147.0 ]--
r 67                     StdOut.println("EMPTY!")
--[ 2019.11.11.00.31.28.242.0 ]--
r 67                     StdOut.println("EMPTY!");
--[ 2019.11.11.00.31.32.904.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.00.32.57.803.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 161                     StdOut.println(+M);
--[ 2019.11.11.00.32.58.384.0 ]--
r 161                     StdOut.println(M);
--[ 2019.11.11.00.32.59.910.0 ]--
r 161                     StdOut.println(M+);
--[ 2019.11.11.00.33.00.082.0 ]--
r 161                     StdOut.println(M++);
--[ 2019.11.11.00.33.04.679.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.00.33.54.452.0 ]--
r 56         int M = ;
--[ 2019.11.11.00.33.54.538.0 ]--
r 56         int M = 1;
--[ 2019.11.11.00.34.00.073.0 ]--
r 158                     M = ;
--[ 2019.11.11.00.34.00.167.0 ]--
r 158                     M = 1;
--[ 2019.11.11.00.34.04.134.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.00.35.05.254.0 ]--
r 158                     M = ;
--[ 2019.11.11.00.35.05.578.0 ]--
r 158                     M = 0;
--[ 2019.11.11.00.35.09.954.0 ]--
r 56         int M = ;
--[ 2019.11.11.00.35.10.020.0 ]--
r 56         int M = 0;
--[ 2019.11.11.00.35.15.005.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.00.37.17.548.0 ]--
+ 157                     
--[ 2019.11.11.00.37.17.911.0 ]--
r 157                     S
--[ 2019.11.11.00.37.18.081.0 ]--
r 157                     St
--[ 2019.11.11.00.37.18.275.0 ]--
r 157                     Std
--[ 2019.11.11.00.37.18.450.0 ]--
r 157                     StdO
--[ 2019.11.11.00.37.18.632.0 ]--
r 157                     StdOu
--[ 2019.11.11.00.37.18.746.0 ]--
r 157                     StdOut
--[ 2019.11.11.00.37.18.860.0 ]--
r 157                     StdOut.
--[ 2019.11.11.00.37.19.068.0 ]--
r 157                     StdOut.p
--[ 2019.11.11.00.37.19.212.0 ]--
r 157                     StdOut.pr
--[ 2019.11.11.00.37.19.290.0 ]--
r 157                     StdOut.pri
--[ 2019.11.11.00.37.19.429.0 ]--
r 157                     StdOut.prin
--[ 2019.11.11.00.37.19.515.0 ]--
r 157                     StdOut.print
--[ 2019.11.11.00.37.19.604.0 ]--
r 157                     StdOut.printl
--[ 2019.11.11.00.37.19.659.0 ]--
r 157                     StdOut.println
--[ 2019.11.11.00.37.19.865.0 ]--
r 157                     StdOut.println()
--[ 2019.11.11.00.37.20.076.0 ]--
r 157                     StdOut.println("")
--[ 2019.11.11.00.37.20.568.0 ]--
r 157                     StdOut.println("f")
--[ 2019.11.11.00.37.20.640.0 ]--
r 157                     StdOut.println("fi")
--[ 2019.11.11.00.37.20.693.0 ]--
r 157                     StdOut.println("fin")
--[ 2019.11.11.00.37.20.770.0 ]--
r 157                     StdOut.println("fina")
--[ 2019.11.11.00.37.20.866.0 ]--
r 157                     StdOut.println("final")
--[ 2019.11.11.00.37.21.144.0 ]--
r 157                     StdOut.println("final:")
--[ 2019.11.11.00.37.21.250.0 ]--
r 157                     StdOut.println("final: ")
--[ 2019.11.11.00.37.21.819.0 ]--
r 157                     StdOut.println("final: " )
--[ 2019.11.11.00.37.21.993.0 ]--
r 157                     StdOut.println("final: " +)
--[ 2019.11.11.00.37.22.099.0 ]--
r 157                     StdOut.println("final: " + )
--[ 2019.11.11.00.37.22.595.0 ]--
r 157                     StdOut.println("final: " + M)
--[ 2019.11.11.00.37.23.331.0 ]--
r 157                     StdOut.println("final: " + M);
--[ 2019.11.11.00.37.27.595.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.00.41.42.187.0 ]--
:/src/Walker.java
+ 15     
--[ 2019.11.11.00.41.42.518.0 ]--
r 15     i
--[ 2019.11.11.00.41.42.605.0 ]--
r 15     in
--[ 2019.11.11.00.41.42.642.0 ]--
r 15     int
--[ 2019.11.11.00.41.42.703.0 ]--
r 15     int 
--[ 2019.11.11.00.41.42.892.0 ]--
r 15     int c
--[ 2019.11.11.00.41.42.980.0 ]--
r 15     int ca
--[ 2019.11.11.00.41.43.140.0 ]--
r 15     int call
--[ 2019.11.11.00.41.43.216.0 ]--
r 15     int calls
--[ 2019.11.11.00.41.43.275.0 ]--
r 15     int calls;
--[ 2019.11.11.00.41.45.783.0 ]--
+ 44         
--[ 2019.11.11.00.41.45.963.0 ]--
r 44         c
--[ 2019.11.11.00.41.46.053.0 ]--
r 44         ca
--[ 2019.11.11.00.41.46.161.0 ]--
r 44         cal
--[ 2019.11.11.00.41.46.315.0 ]--
r 44         call
--[ 2019.11.11.00.41.46.402.0 ]--
r 44         calls
--[ 2019.11.11.00.41.46.643.0 ]--
r 44         calls+
--[ 2019.11.11.00.41.46.770.0 ]--
r 44         calls++
--[ 2019.11.11.00.41.47.734.0 ]--
r 44         calls++;
--[ 2019.11.11.00.42.03.084.0 ]--
+ 67                 
--[ 2019.11.11.00.42.03.684.0 ]--
r 67                 i
--[ 2019.11.11.00.42.03.820.0 ]--
r 67                 if
--[ 2019.11.11.00.42.03.899.0 ]--
r 67                 if 
--[ 2019.11.11.00.42.04.098.0 ]--
r 67                 if ()
--[ 2019.11.11.00.42.04.370.0 ]--
r 67                 if (c)
--[ 2019.11.11.00.42.04.478.0 ]--
r 67                 if (ca)
--[ 2019.11.11.00.42.04.556.0 ]--
r 67                 if (cal)
--[ 2019.11.11.00.42.04.688.0 ]--
r 67                 if (call)
--[ 2019.11.11.00.42.04.784.0 ]--
r 67                 if (calls)
--[ 2019.11.11.00.42.04.857.0 ]--
r 67                 if (calls )
--[ 2019.11.11.00.42.04.980.0 ]--
r 67                 if (calls =)
--[ 2019.11.11.00.42.05.140.0 ]--
r 67                 if (calls ==)
--[ 2019.11.11.00.42.05.255.0 ]--
r 67                 if (calls == )
--[ 2019.11.11.00.42.05.435.0 ]--
r 67                 if (calls == 1)
--[ 2019.11.11.00.42.05.526.0 ]--
r 67                 if (calls == 10)
--[ 2019.11.11.00.42.05.664.0 ]--
r 67                 if (calls == 100)
--[ 2019.11.11.00.42.06.526.0 ]--
r 67                 if (calls == 100) 
--[ 2019.11.11.00.42.06.707.0 ]--
r 67                 if (calls == 100) {
--[ 2019.11.11.00.42.06.991.0 ]--
+ 68 
+ 69 }
--[ 2019.11.11.00.42.07.062.0 ]--
r 69                 }
--[ 2019.11.11.00.42.07.092.0 ]--
r 68                     
--[ 2019.11.11.00.42.11.984.0 ]--
r 68                     w
--[ 2019.11.11.00.42.12.094.0 ]--
r 68                     wh
--[ 2019.11.11.00.42.12.137.0 ]--
r 68                     whi
--[ 2019.11.11.00.42.12.329.0 ]--
r 68                     whil
--[ 2019.11.11.00.42.12.427.0 ]--
r 68                     while
--[ 2019.11.11.00.42.12.534.0 ]--
r 68                     while 
--[ 2019.11.11.00.42.13.004.0 ]--
r 68                     while ()
--[ 2019.11.11.00.42.14.792.0 ]--
r 68                     while (!)
--[ 2019.11.11.00.42.15.252.0 ]--
r 68                     while (!p)
--[ 2019.11.11.00.42.15.402.0 ]--
r 68                     while (!pa)
--[ 2019.11.11.00.42.15.517.0 ]--
r 68                     while (!pat)
--[ 2019.11.11.00.42.15.550.0 ]--
r 68                     while (!path)
--[ 2019.11.11.00.42.15.751.0 ]--
r 68                     while (!path.)
--[ 2019.11.11.00.42.15.958.0 ]--
r 68                     while (!path.i)
--[ 2019.11.11.00.42.16.054.0 ]--
r 68                     while (!path.is)
--[ 2019.11.11.00.42.16.483.0 ]--
r 68                     while (!path.isE)
--[ 2019.11.11.00.42.16.637.0 ]--
r 68                     while (!path.isEm)
--[ 2019.11.11.00.42.16.761.0 ]--
r 68                     while (!path.isEmp)
--[ 2019.11.11.00.42.16.842.0 ]--
r 68                     while (!path.isEmpt)
--[ 2019.11.11.00.42.16.963.0 ]--
r 68                     while (!path.isEmpty)
--[ 2019.11.11.00.42.17.319.0 ]--
r 68                     while (!path.isEmpty())
--[ 2019.11.11.00.42.18.128.0 ]--
r 68                     while (!path.isEmpty()) 
--[ 2019.11.11.00.42.18.317.0 ]--
r 68                     while (!path.isEmpty()) {
--[ 2019.11.11.00.42.18.556.0 ]--
+ 69 
+ 70 }
--[ 2019.11.11.00.42.18.598.0 ]--
r 70                     }
--[ 2019.11.11.00.42.18.628.0 ]--
r 69                         
--[ 2019.11.11.00.42.24.307.0 ]--
r 69                         l
--[ 2019.11.11.00.42.24.539.0 ]--
r 69                         lo
--[ 2019.11.11.00.42.24.637.0 ]--
r 69                         loc
--[ 2019.11.11.00.42.24.754.0 ]--
r 69                         loc 
--[ 2019.11.11.00.42.24.900.0 ]--
r 69                         loc =
--[ 2019.11.11.00.42.25.235.0 ]--
r 69                         loc = 
--[ 2019.11.11.00.42.25.264.0 ]--
r 69                         loc = p
--[ 2019.11.11.00.42.25.398.0 ]--
r 69                         loc = pa
--[ 2019.11.11.00.42.25.478.0 ]--
r 69                         loc = pat
--[ 2019.11.11.00.42.25.545.0 ]--
r 69                         loc = path
--[ 2019.11.11.00.42.25.790.0 ]--
r 69                         loc = path.
--[ 2019.11.11.00.42.25.946.0 ]--
r 69                         loc = path.d
--[ 2019.11.11.00.42.26.136.0 ]--
r 69                         loc = path.de
--[ 2019.11.11.00.42.26.267.0 ]--
r 69                         loc = path.deq
--[ 2019.11.11.00.42.26.381.0 ]--
r 69                         loc = path.dequ
--[ 2019.11.11.00.42.26.461.0 ]--
r 69                         loc = path.deque
--[ 2019.11.11.00.42.26.559.0 ]--
r 69                         loc = path.dequeu
--[ 2019.11.11.00.42.26.636.0 ]--
r 69                         loc = path.dequeue
--[ 2019.11.11.00.42.26.950.0 ]--
r 69                         loc = path.dequeue()
--[ 2019.11.11.00.42.27.297.0 ]--
r 69                         loc = path.dequeue();
--[ 2019.11.11.00.42.28.519.0 ]--
+ 71                     
--[ 2019.11.11.00.42.29.083.0 ]--
r 71                     n
--[ 2019.11.11.00.42.29.187.0 ]--
r 71                     ne
--[ 2019.11.11.00.42.29.372.0 ]--
r 71                     nex
--[ 2019.11.11.00.42.29.568.0 ]--
r 71                     next
--[ 2019.11.11.00.42.29.788.0 ]--
r 71                     nextL
--[ 2019.11.11.00.42.29.948.0 ]--
r 71                     nextLo
--[ 2019.11.11.00.42.29.992.0 ]--
r 71                     nextLoc
--[ 2019.11.11.00.42.30.079.0 ]--
r 71                     nextLoc 
--[ 2019.11.11.00.42.30.291.0 ]--
r 71                     nextLoc=
--[ 2019.11.11.00.42.30.334.0 ]--
r 71                     nextLoc= 
--[ 2019.11.11.00.42.30.982.0 ]--
r 71                     nextLoc=
--[ 2019.11.11.00.42.31.141.0 ]--
r 71                     nextLoc
--[ 2019.11.11.00.42.31.341.0 ]--
r 71                     nextLoc 
--[ 2019.11.11.00.42.31.449.0 ]--
r 71                     nextLoc =
--[ 2019.11.11.00.42.31.571.0 ]--
r 71                     nextLoc = 
--[ 2019.11.11.00.42.31.756.0 ]--
r 71                     nextLoc = p
--[ 2019.11.11.00.42.31.885.0 ]--
r 71                     nextLoc = pa
--[ 2019.11.11.00.42.32.343.0 ]--
r 71                     nextLoc = pat
--[ 2019.11.11.00.42.32.397.0 ]--
r 71                     nextLoc = path
--[ 2019.11.11.00.42.32.587.0 ]--
r 71                     nextLoc = path.
--[ 2019.11.11.00.42.32.818.0 ]--
r 71                     nextLoc = path.p
--[ 2019.11.11.00.42.32.925.0 ]--
r 71                     nextLoc = path.pe
--[ 2019.11.11.00.42.33.101.0 ]--
r 71                     nextLoc = path.pee
--[ 2019.11.11.00.42.33.164.0 ]--
r 71                     nextLoc = path.peek
--[ 2019.11.11.00.42.34.705.0 ]--
r 71                     nextLoc = path.peek()
--[ 2019.11.11.00.42.34.978.0 ]--
r 71                     nextLoc = path.peek();
--[ 2019.11.11.00.42.36.276.0 ]--
r 71                     nextLoc = path.peek()
--[ 2019.11.11.00.42.36.816.0 ]--
r 71                     nextLoc = path.peek(
--[ 2019.11.11.00.42.37.069.0 ]--
r 71                     nextLoc = path.peek
--[ 2019.11.11.00.42.37.569.0 ]--
r 71                     nextLoc = path.pee
--[ 2019.11.11.00.42.37.621.0 ]--
r 71                     nextLoc = path.pe
--[ 2019.11.11.00.42.37.645.0 ]--
r 71                     nextLoc = path.p
--[ 2019.11.11.00.42.37.683.0 ]--
r 71                     nextLoc = path.
--[ 2019.11.11.00.42.37.709.0 ]--
r 71                     nextLoc = path
--[ 2019.11.11.00.42.37.749.0 ]--
r 71                     nextLoc = pat
--[ 2019.11.11.00.42.37.780.0 ]--
r 71                     nextLoc = pa
--[ 2019.11.11.00.42.37.949.0 ]--
r 71                     nextLoc = p
--[ 2019.11.11.00.42.38.139.0 ]--
r 71                     nextLoc = 
--[ 2019.11.11.00.42.38.573.0 ]--
r 71                     nextLoc = n
--[ 2019.11.11.00.42.38.800.0 ]--
r 71                     nextLoc = nu
--[ 2019.11.11.00.42.39.228.0 ]--
r 71                     nextLoc = nul
--[ 2019.11.11.00.42.39.374.0 ]--
r 71                     nextLoc = null
--[ 2019.11.11.00.42.39.465.0 ]--
r 71                     nextLoc = null;
--[ 2019.11.11.00.42.42.411.0 ]--
+ 72                     
--[ 2019.11.11.00.42.42.826.0 ]--
r 72                     b
--[ 2019.11.11.00.42.43.173.0 ]--
r 72                     br
--[ 2019.11.11.00.42.43.248.0 ]--
r 72                     bre
--[ 2019.11.11.00.42.43.340.0 ]--
r 72                     brea
--[ 2019.11.11.00.42.43.381.0 ]--
r 72                     break
--[ 2019.11.11.00.42.43.514.0 ]--
r 72                     break;
--[ 2019.11.11.00.42.59.419.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.00.43.32.304.0 ]--
+ 82         
--[ 2019.11.11.00.43.32.869.0 ]--
r 82         S
--[ 2019.11.11.00.43.33.082.0 ]--
r 82         St
--[ 2019.11.11.00.43.33.296.0 ]--
r 82         Std
--[ 2019.11.11.00.43.33.497.0 ]--
r 82         StdO
--[ 2019.11.11.00.43.33.672.0 ]--
r 82         StdOu
--[ 2019.11.11.00.43.33.786.0 ]--
r 82         StdOut
--[ 2019.11.11.00.43.33.886.0 ]--
r 82         StdOut.
--[ 2019.11.11.00.43.34.165.0 ]--
r 82         StdOut.p
--[ 2019.11.11.00.43.34.282.0 ]--
r 82         StdOut.pr
--[ 2019.11.11.00.43.34.385.0 ]--
r 82         StdOut.pri
--[ 2019.11.11.00.43.34.513.0 ]--
r 82         StdOut.prin
--[ 2019.11.11.00.43.34.682.0 ]--
r 82         StdOut.print
--[ 2019.11.11.00.43.34.822.0 ]--
r 82         StdOut.printl
--[ 2019.11.11.00.43.34.907.0 ]--
r 82         StdOut.println
--[ 2019.11.11.00.43.35.137.0 ]--
r 82         StdOut.println()
--[ 2019.11.11.00.43.35.350.0 ]--
r 82         StdOut.println("")
--[ 2019.11.11.00.43.35.567.0 ]--
r 82         StdOut.println("c")
--[ 2019.11.11.00.43.35.639.0 ]--
r 82         StdOut.println("ca")
--[ 2019.11.11.00.43.35.729.0 ]--
r 82         StdOut.println("cal")
--[ 2019.11.11.00.43.35.876.0 ]--
r 82         StdOut.println("call")
--[ 2019.11.11.00.43.35.974.0 ]--
r 82         StdOut.println("call ")
--[ 2019.11.11.00.43.36.081.0 ]--
r 82         StdOut.println("call n")
--[ 2019.11.11.00.43.36.281.0 ]--
r 82         StdOut.println("call nu")
--[ 2019.11.11.00.43.36.453.0 ]--
r 82         StdOut.println("call num")
--[ 2019.11.11.00.43.36.521.0 ]--
r 82         StdOut.println("call numb")
--[ 2019.11.11.00.43.36.747.0 ]--
r 82         StdOut.println("call numbe")
--[ 2019.11.11.00.43.36.823.0 ]--
r 82         StdOut.println("call number")
--[ 2019.11.11.00.43.37.012.0 ]--
r 82         StdOut.println("call number:")
--[ 2019.11.11.00.43.37.281.0 ]--
r 82         StdOut.println("call number: ")
--[ 2019.11.11.00.43.37.901.0 ]--
r 82         StdOut.println("call number: " )
--[ 2019.11.11.00.43.38.326.0 ]--
r 82         StdOut.println("call number: " _)
--[ 2019.11.11.00.43.38.439.0 ]--
r 82         StdOut.println("call number: " _ )
--[ 2019.11.11.00.43.38.669.0 ]--
r 82         StdOut.println("call number: " _ c)
--[ 2019.11.11.00.43.38.928.0 ]--
r 82         StdOut.println("call number: " _ )
--[ 2019.11.11.00.43.39.082.0 ]--
r 82         StdOut.println("call number: " _)
--[ 2019.11.11.00.43.39.244.0 ]--
r 82         StdOut.println("call number: " )
--[ 2019.11.11.00.43.39.516.0 ]--
r 82         StdOut.println("call number: " +)
--[ 2019.11.11.00.43.39.745.0 ]--
r 82         StdOut.println("call number: " + )
--[ 2019.11.11.00.43.39.924.0 ]--
r 82         StdOut.println("call number: " + c)
--[ 2019.11.11.00.43.40.083.0 ]--
r 82         StdOut.println("call number: " + ca)
--[ 2019.11.11.00.43.40.184.0 ]--
r 82         StdOut.println("call number: " + cal)
--[ 2019.11.11.00.43.40.322.0 ]--
r 82         StdOut.println("call number: " + call)
--[ 2019.11.11.00.43.40.410.0 ]--
r 82         StdOut.println("call number: " + calls)
--[ 2019.11.11.00.43.40.970.0 ]--
r 82         StdOut.println("call number: " + calls);
--[ 2019.11.11.00.43.45.181.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 159 
--[ 2019.11.11.00.43.45.521.0 ]--
- 159
--[ 2019.11.11.00.43.46.776.0 ]--
r 157 
--[ 2019.11.11.00.43.46.954.0 ]--
- 157
--[ 2019.11.11.00.43.48.709.0 ]--
r 160 
--[ 2019.11.11.00.43.48.898.0 ]--
- 160
--[ 2019.11.11.00.43.53.245.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.00.44.37.476.0 ]--
:/src/Walker.java
- 46
- 46
r 46 
--[ 2019.11.11.00.44.37.793.0 ]--
- 46
--[ 2019.11.11.00.44.42.180.0 ]--
- 49
- 49
- 49
r 49 
--[ 2019.11.11.00.44.42.483.0 ]--
- 49
--[ 2019.11.11.00.44.45.571.0 ]--
r 47 
--[ 2019.11.11.00.44.45.948.0 ]--
- 47
--[ 2019.11.11.00.44.48.661.0 ]--
r 48 
--[ 2019.11.11.00.44.48.842.0 ]--
- 48
--[ 2019.11.11.00.44.51.514.0 ]--
r 49 
--[ 2019.11.11.00.44.51.655.0 ]--
- 49
--[ 2019.11.11.00.45.03.678.0 ]--
+ 52                 
--[ 2019.11.11.00.45.04.241.0 ]--
r 52                 i
--[ 2019.11.11.00.45.04.374.0 ]--
r 52                 if
--[ 2019.11.11.00.45.04.450.0 ]--
r 52                 if 
--[ 2019.11.11.00.45.04.642.0 ]--
r 52                 if ()
--[ 2019.11.11.00.45.04.824.0 ]--
r 52                 if (c)
--[ 2019.11.11.00.45.04.967.0 ]--
r 52                 if (ca)
--[ 2019.11.11.00.45.05.023.0 ]--
r 52                 if (cal)
--[ 2019.11.11.00.45.05.168.0 ]--
r 52                 if (call)
--[ 2019.11.11.00.45.05.251.0 ]--
r 52                 if (calls)
--[ 2019.11.11.00.45.05.336.0 ]--
r 52                 if (calls )
--[ 2019.11.11.00.45.05.446.0 ]--
r 52                 if (calls =)
--[ 2019.11.11.00.45.05.602.0 ]--
r 52                 if (calls ==)
--[ 2019.11.11.00.45.05.630.0 ]--
r 52                 if (calls == )
--[ 2019.11.11.00.45.05.873.0 ]--
r 52                 if (calls == 1)
--[ 2019.11.11.00.45.05.984.0 ]--
r 52                 if (calls == 10)
--[ 2019.11.11.00.45.06.138.0 ]--
r 52                 if (calls == 100)
--[ 2019.11.11.00.45.06.873.0 ]--
r 52                 if (calls == 100
--[ 2019.11.11.00.45.07.373.0 ]--
r 52                 if (calls == 10
--[ 2019.11.11.00.45.07.406.0 ]--
r 52                 if (calls == 1
--[ 2019.11.11.00.45.07.439.0 ]--
r 52                 if (calls == 
--[ 2019.11.11.00.45.07.485.0 ]--
r 52                 if (calls ==
--[ 2019.11.11.00.45.07.513.0 ]--
r 52                 if (calls =
--[ 2019.11.11.00.45.07.541.0 ]--
r 52                 if (calls 
--[ 2019.11.11.00.45.07.578.0 ]--
r 52                 if (calls
--[ 2019.11.11.00.45.07.609.0 ]--
r 52                 if (call
--[ 2019.11.11.00.45.07.639.0 ]--
r 52                 if (cal
--[ 2019.11.11.00.45.07.683.0 ]--
r 52                 if (ca
--[ 2019.11.11.00.45.07.713.0 ]--
r 52                 if (c
--[ 2019.11.11.00.45.07.745.0 ]--
r 52                 if (
--[ 2019.11.11.00.45.07.780.0 ]--
r 52                 if 
--[ 2019.11.11.00.45.07.817.0 ]--
r 52                 if
--[ 2019.11.11.00.45.08.019.0 ]--
r 52                 i
--[ 2019.11.11.00.45.08.180.0 ]--
r 52                 
--[ 2019.11.11.00.45.08.430.0 ]--
- 52
--[ 2019.11.11.00.45.14.203.0 ]--
+ 48             
--[ 2019.11.11.00.45.14.548.0 ]--
+ 48             if (calls == 100) {
+ 49                     while (!path.isEmpty()) {
+ 50                         loc = path.dequeue();
+ 51                     }
+ 52                     nextLoc = null;
+ 53                     break;
r 54                 }
--[ 2019.11.11.00.45.14.606.0 ]--
r 49                 while (!path.isEmpty()) {
r 50                     loc = path.dequeue();
r 51                 }
r 52                 nextLoc = null;
r 53                 break;
r 54             }
--[ 2019.11.11.00.45.18.236.0 ]--
- 64
- 64
- 64
- 64
- 64
- 64
r 64 
--[ 2019.11.11.00.45.18.456.0 ]--
- 64
--[ 2019.11.11.00.45.33.786.0 ]--
r 66 
--[ 2019.11.11.00.45.34.179.0 ]--
- 66
--[ 2019.11.11.00.45.36.941.0 ]--
r 71 
--[ 2019.11.11.00.45.37.130.0 ]--
- 71
--[ 2019.11.11.00.45.48.804.0 ]--
+ 29         
--[ 2019.11.11.00.45.49.201.0 ]--
r 29         t
--[ 2019.11.11.00.45.49.386.0 ]--
r 29         th
--[ 2019.11.11.00.45.49.466.0 ]--
r 29         thi
--[ 2019.11.11.00.45.49.564.0 ]--
r 29         this
--[ 2019.11.11.00.45.49.727.0 ]--
r 29         this.
--[ 2019.11.11.00.45.49.865.0 ]--
r 29         this.c
--[ 2019.11.11.00.45.49.981.0 ]--
r 29         this.ca
--[ 2019.11.11.00.45.50.075.0 ]--
r 29         this.cal
--[ 2019.11.11.00.45.50.209.0 ]--
r 29         this.call
--[ 2019.11.11.00.45.50.288.0 ]--
r 29         this.calls
--[ 2019.11.11.00.45.50.384.0 ]--
r 29         this.calls 
--[ 2019.11.11.00.45.50.512.0 ]--
r 29         this.calls =
--[ 2019.11.11.00.45.50.616.0 ]--
r 29         this.calls = 
--[ 2019.11.11.00.45.50.711.0 ]--
r 29         this.calls = 0
--[ 2019.11.11.00.45.50.920.0 ]--
r 29         this.calls = 0;
--[ 2019.11.11.00.46.10.919.0 ]--
+ 47         
--[ 2019.11.11.00.46.11.249.0 ]--
+ 47         if (calls == 100) {
+ 48                 while (!path.isEmpty()) {
+ 49                     loc = path.dequeue();
+ 50                 }
+ 51                 nextLoc = null;
+ 52                 break;
r 53             }
--[ 2019.11.11.00.46.11.294.0 ]--
r 48             while (!path.isEmpty()) {
r 49                 loc = path.dequeue();
r 50             }
r 51             nextLoc = null;
r 52             break;
r 53         }
--[ 2019.11.11.00.46.14.209.0 ]--
- 56
- 56
- 56
- 56
- 56
- 56
r 56 
--[ 2019.11.11.00.46.14.673.0 ]--
- 56
--[ 2019.11.11.00.46.16.546.0 ]--
r 52 
--[ 2019.11.11.00.46.16.964.0 ]--
- 52
--[ 2019.11.11.00.46.18.528.0 ]--
r 52         } 
--[ 2019.11.11.00.46.18.679.0 ]--
r 52         } e
--[ 2019.11.11.00.46.18.798.0 ]--
r 52         } el
--[ 2019.11.11.00.46.18.896.0 ]--
r 52         } els
--[ 2019.11.11.00.46.18.949.0 ]--
r 52         } else
--[ 2019.11.11.00.46.19.032.0 ]--
r 52         } else 
--[ 2019.11.11.00.46.19.259.0 ]--
r 52         } else {
--[ 2019.11.11.00.46.23.369.0 ]--
+ 71         
--[ 2019.11.11.00.46.24.149.0 ]--
r 71         }
--[ 2019.11.11.00.46.24.208.0 ]--
r 53             while (totalCost < end) {
--[ 2019.11.11.00.46.24.233.0 ]--
r 54                 float cost = terrain.computeTravelCost(loc, nextLoc);
--[ 2019.11.11.00.46.24.253.0 ]--
r 55                 if (totalCost + (cost - progress) > end) {
--[ 2019.11.11.00.46.24.275.0 ]--
r 56                     float prev = end - totalCost;
--[ 2019.11.11.00.46.24.296.0 ]--
r 57                     totalCost += prev;
--[ 2019.11.11.00.46.24.316.0 ]--
r 58                     progress += prev;
--[ 2019.11.11.00.46.24.338.0 ]--
r 59                     break;
--[ 2019.11.11.00.46.24.361.0 ]--
r 60                 } else {
--[ 2019.11.11.00.46.24.388.0 ]--
r 61                     totalCost += (cost - progress);
--[ 2019.11.11.00.46.24.409.0 ]--
r 62                     progress = 0.0f;
--[ 2019.11.11.00.46.24.430.0 ]--
r 63                     loc = path.dequeue();
--[ 2019.11.11.00.46.24.451.0 ]--
r 64                     if (!path.isEmpty()) nextLoc = path.peek();
--[ 2019.11.11.00.46.24.473.0 ]--
r 65                     else {
--[ 2019.11.11.00.46.24.494.0 ]--
r 66                         nextLoc = null;
--[ 2019.11.11.00.46.24.516.0 ]--
r 67                         break;
--[ 2019.11.11.00.46.24.539.0 ]--
r 68                     }
--[ 2019.11.11.00.46.24.560.0 ]--
r 69                 }
--[ 2019.11.11.00.46.24.581.0 ]--
r 70             }
--[ 2019.11.11.00.50.01.050.0 ]--
:/src/Pathfinder.java
+ 205         
--[ 2019.11.11.00.50.01.385.0 ]--
r 205         /
--[ 2019.11.11.00.50.01.529.0 ]--
r 205         /*
--[ 2019.11.11.00.50.03.872.0 ]--
+ 213         
+ 214          */
--[ 2019.11.11.00.50.04.158.0 ]--
r 213         *
--[ 2019.11.11.00.50.04.424.0 ]--
r 213         */
--[ 2019.11.11.00.50.06.309.0 ]--
r 214          /
--[ 2019.11.11.00.50.06.564.0 ]--
r 214         /
--[ 2019.11.11.00.50.07.631.0 ]--
r 214         
--[ 2019.11.11.00.50.09.154.0 ]--
r 214 
--[ 2019.11.11.00.50.09.471.0 ]--
- 214
--[ 2019.11.11.00.50.10.071.0 ]--
+ 214         
--[ 2019.11.11.00.50.17.272.0 ]--
r 214         p
--[ 2019.11.11.00.50.17.626.0 ]--
r 214         pub
--[ 2019.11.11.00.50.17.661.0 ]--
r 214         publ
--[ 2019.11.11.00.50.17.761.0 ]--
r 214         publi
--[ 2019.11.11.00.50.17.881.0 ]--
r 214         public
--[ 2019.11.11.00.50.17.989.0 ]--
r 214         public 
--[ 2019.11.11.00.50.18.114.0 ]--
r 214         public b
--[ 2019.11.11.00.50.18.212.0 ]--
r 214         public bo
--[ 2019.11.11.00.50.18.370.0 ]--
r 214         public boo
--[ 2019.11.11.00.50.18.567.0 ]--
r 214         public bool
--[ 2019.11.11.00.50.18.647.0 ]--
r 214         public boole
--[ 2019.11.11.00.50.18.739.0 ]--
r 214         public boolea
--[ 2019.11.11.00.50.18.800.0 ]--
r 214         public boolean
--[ 2019.11.11.00.50.18.886.0 ]--
r 214         public boolean 
--[ 2019.11.11.00.50.19.062.0 ]--
r 214         public boolean h
--[ 2019.11.11.00.50.19.184.0 ]--
r 214         public boolean ha
--[ 2019.11.11.00.50.19.213.0 ]--
r 214         public boolean has
--[ 2019.11.11.00.50.19.488.0 ]--
r 214         public boolean hasN
--[ 2019.11.11.00.50.19.597.0 ]--
r 214         public boolean hasNe
--[ 2019.11.11.00.50.19.848.0 ]--
r 214         public boolean hasNex
--[ 2019.11.11.00.50.20.061.0 ]--
r 214         public boolean hasNext
--[ 2019.11.11.00.50.21.148.0 ]--
r 214         public boolean hasNext()
--[ 2019.11.11.00.50.21.757.0 ]--
r 214         public boolean hasNext() 
--[ 2019.11.11.00.50.21.995.0 ]--
r 214         public boolean hasNext() {
--[ 2019.11.11.00.50.22.895.0 ]--
r 214         public boolean hasNext() { 
--[ 2019.11.11.00.50.23.128.0 ]--
r 214         public boolean hasNext() { }
--[ 2019.11.11.00.50.24.090.0 ]--
r 214         public boolean hasNext() {  }
--[ 2019.11.11.00.50.24.918.0 ]--
r 214         public boolean hasNext() { r }
--[ 2019.11.11.00.50.25.023.0 ]--
r 214         public boolean hasNext() { re }
--[ 2019.11.11.00.50.25.168.0 ]--
r 214         public boolean hasNext() { ret }
--[ 2019.11.11.00.50.25.246.0 ]--
r 214         public boolean hasNext() { retu }
--[ 2019.11.11.00.50.25.382.0 ]--
r 214         public boolean hasNext() { retur }
--[ 2019.11.11.00.50.25.439.0 ]--
r 214         public boolean hasNext() { return }
--[ 2019.11.11.00.50.25.609.0 ]--
r 214         public boolean hasNext() { return  }
--[ 2019.11.11.00.50.27.890.0 ]--
r 214         public boolean hasNext() { return i }
--[ 2019.11.11.00.50.28.218.0 ]--
r 214         public boolean hasNext() { return i  }
--[ 2019.11.11.00.50.28.365.0 ]--
r 214         public boolean hasNext() { return i < }
--[ 2019.11.11.00.50.28.438.0 ]--
r 214         public boolean hasNext() { return i <  }
--[ 2019.11.11.00.50.28.731.0 ]--
r 214         public boolean hasNext() { return i < }
--[ 2019.11.11.00.50.28.940.0 ]--
r 214         public boolean hasNext() { return i  }
--[ 2019.11.11.00.50.29.114.0 ]--
r 214         public boolean hasNext() { return i }
--[ 2019.11.11.00.50.29.287.0 ]--
r 214         public boolean hasNext() { return  }
--[ 2019.11.11.00.50.33.800.0 ]--
+ 214         
--[ 2019.11.11.00.50.34.781.0 ]--
r 214         p
--[ 2019.11.11.00.50.34.909.0 ]--
r 214         pr
--[ 2019.11.11.00.50.34.983.0 ]--
r 214         pri
--[ 2019.11.11.00.50.35.142.0 ]--
r 214         priv
--[ 2019.11.11.00.50.35.272.0 ]--
r 214         priva
--[ 2019.11.11.00.50.35.378.0 ]--
r 214         privat
--[ 2019.11.11.00.50.35.465.0 ]--
r 214         private
--[ 2019.11.11.00.50.35.613.0 ]--
r 214         private 
--[ 2019.11.11.00.50.36.741.0 ]--
r 214         private P
--[ 2019.11.11.00.50.36.867.0 ]--
r 214         private PF
--[ 2019.11.11.00.50.37.051.0 ]--
r 214         private PFn
--[ 2019.11.11.00.50.37.757.0 ]--
r 214         private PF
--[ 2019.11.11.00.50.38.061.0 ]--
r 214         private PFN
--[ 2019.11.11.00.50.38.440.0 ]--
r 214         private PFNod
--[ 2019.11.11.00.50.38.525.0 ]--
r 214         private PFNode
--[ 2019.11.11.00.50.38.643.0 ]--
r 214         private PFNode 
--[ 2019.11.11.00.50.38.763.0 ]--
r 214         private PFNode c
--[ 2019.11.11.00.50.38.924.0 ]--
r 214         private PFNode c 
--[ 2019.11.11.00.50.39.039.0 ]--
r 214         private PFNode c =
--[ 2019.11.11.00.50.39.145.0 ]--
r 214         private PFNode c = 
--[ 2019.11.11.00.50.39.357.0 ]--
r 214         private PFNode c = e
--[ 2019.11.11.00.50.39.481.0 ]--
r 214         private PFNode c = en
--[ 2019.11.11.00.50.39.569.0 ]--
r 214         private PFNode c = end
--[ 2019.11.11.00.50.39.746.0 ]--
r 214         private PFNode c = endN
--[ 2019.11.11.00.50.39.898.0 ]--
r 214         private PFNode c = endNo
--[ 2019.11.11.00.50.39.993.0 ]--
r 214         private PFNode c = endNod
--[ 2019.11.11.00.50.40.170.0 ]--
r 214         private PFNode c = endNode
--[ 2019.11.11.00.50.40.252.0 ]--
r 214         private PFNode c = endNode;
--[ 2019.11.11.00.50.40.554.0 ]--
+ 215         
--[ 2019.11.11.00.50.45.563.0 ]--
r 214          PFNode c = endNode;
--[ 2019.11.11.00.50.46.007.0 ]--
r 214         PFNode c = endNode;
--[ 2019.11.11.00.50.57.723.0 ]--
r 216         public boolean hasNext() { return  c}
--[ 2019.11.11.00.50.58.056.0 ]--
r 216         public boolean hasNext() { return  c }
--[ 2019.11.11.00.50.58.302.0 ]--
r 216         public boolean hasNext() { return  c =}
--[ 2019.11.11.00.50.58.551.0 ]--
r 216         public boolean hasNext() { return  c ==}
--[ 2019.11.11.00.50.58.661.0 ]--
r 216         public boolean hasNext() { return  c == }
--[ 2019.11.11.00.50.58.805.0 ]--
r 216         public boolean hasNext() { return  c == n}
--[ 2019.11.11.00.50.59.065.0 ]--
r 216         public boolean hasNext() { return  c == nu}
--[ 2019.11.11.00.50.59.263.0 ]--
r 216         public boolean hasNext() { return  c == nul}
--[ 2019.11.11.00.50.59.418.0 ]--
r 216         public boolean hasNext() { return  c == null}
--[ 2019.11.11.00.50.59.727.0 ]--
r 216         public boolean hasNext() { return  c == null }
--[ 2019.11.11.00.51.01.093.0 ]--
+ 217         
--[ 2019.11.11.00.51.01.689.0 ]--
+ 217         
--[ 2019.11.11.00.51.04.024.0 ]--
r 218         p
--[ 2019.11.11.00.51.04.138.0 ]--
r 218         pu
--[ 2019.11.11.00.51.04.336.0 ]--
r 218         pub
--[ 2019.11.11.00.51.04.374.0 ]--
r 218         publ
--[ 2019.11.11.00.51.04.476.0 ]--
r 218         publi
--[ 2019.11.11.00.51.04.631.0 ]--
r 218         public
--[ 2019.11.11.00.51.04.744.0 ]--
r 218         public 
--[ 2019.11.11.00.51.06.015.0 ]--
r 218         public P
--[ 2019.11.11.00.51.06.197.0 ]--
r 218         public PF
--[ 2019.11.11.00.51.06.353.0 ]--
r 218         public PFN
--[ 2019.11.11.00.51.06.632.0 ]--
r 218         public PFNo
--[ 2019.11.11.00.51.06.753.0 ]--
r 218         public PFNod
--[ 2019.11.11.00.51.06.989.0 ]--
r 218         public PFNode
--[ 2019.11.11.00.51.07.114.0 ]--
r 218         public PFNode 
--[ 2019.11.11.00.51.07.313.0 ]--
r 218         public PFNode n
--[ 2019.11.11.00.51.07.414.0 ]--
r 218         public PFNode ne
--[ 2019.11.11.00.51.07.602.0 ]--
r 218         public PFNode nex
--[ 2019.11.11.00.51.07.957.0 ]--
r 218         public PFNode next
--[ 2019.11.11.00.51.08.298.0 ]--
r 218         public PFNode next()
--[ 2019.11.11.00.51.08.568.0 ]--
r 218         public PFNode next() 
--[ 2019.11.11.00.51.08.748.0 ]--
r 218         public PFNode next() {
--[ 2019.11.11.00.51.09.558.0 ]--
r 218         public PFNode next() { 
--[ 2019.11.11.00.51.09.752.0 ]--
r 218         public PFNode next() {  
--[ 2019.11.11.00.51.09.987.0 ]--
r 218         public PFNode next() {  }
--[ 2019.11.11.00.51.11.013.0 ]--
r 218         public PFNode next() { r }
--[ 2019.11.11.00.51.11.121.0 ]--
r 218         public PFNode next() { re }
--[ 2019.11.11.00.51.11.286.0 ]--
r 218         public PFNode next() { ret }
--[ 2019.11.11.00.51.11.366.0 ]--
r 218         public PFNode next() { retu }
--[ 2019.11.11.00.51.11.487.0 ]--
r 218         public PFNode next() { retur }
--[ 2019.11.11.00.51.11.556.0 ]--
r 218         public PFNode next() { return }
--[ 2019.11.11.00.51.11.678.0 ]--
r 218         public PFNode next() { return  }
--[ 2019.11.11.00.51.16.202.0 ]--
r 218         public PFNode next() { return c }
--[ 2019.11.11.00.51.16.321.0 ]--
r 218         public PFNode next() { return c; }
--[ 2019.11.11.00.51.16.672.0 ]--
r 218         public PFNode next() { return c }
--[ 2019.11.11.00.51.17.172.0 ]--
r 218         public PFNode next() { return  }
--[ 2019.11.11.00.51.17.207.0 ]--
r 218         public PFNode next() { return }
--[ 2019.11.11.00.51.17.237.0 ]--
r 218         public PFNode next() { retur }
--[ 2019.11.11.00.51.17.271.0 ]--
r 218         public PFNode next() { retu }
--[ 2019.11.11.00.51.17.425.0 ]--
r 218         public PFNode next() { ret }
--[ 2019.11.11.00.51.17.644.0 ]--
r 218         public PFNode next() { re }
--[ 2019.11.11.00.51.17.828.0 ]--
r 218         public PFNode next() { r }
--[ 2019.11.11.00.51.18.020.0 ]--
r 218         public PFNode next() {  }
--[ 2019.11.11.00.51.18.392.0 ]--
r 218         public PFNode next() { r }
--[ 2019.11.11.00.51.18.484.0 ]--
r 218         public PFNode next() { re }
--[ 2019.11.11.00.51.18.642.0 ]--
r 218         public PFNode next() { ret }
--[ 2019.11.11.00.51.18.735.0 ]--
r 218         public PFNode next() { retu }
--[ 2019.11.11.00.51.18.857.0 ]--
r 218         public PFNode next() { retur }
--[ 2019.11.11.00.51.18.949.0 ]--
r 218         public PFNode next() { return }
--[ 2019.11.11.00.51.19.014.0 ]--
r 218         public PFNode next() { return  }
--[ 2019.11.11.00.51.19.186.0 ]--
r 218         public PFNode next() { return c }
--[ 2019.11.11.00.51.19.244.0 ]--
r 218         public PFNode next() { return c. }
--[ 2019.11.11.00.51.20.133.0 ]--
r 218         public PFNode next() { return c }
--[ 2019.11.11.00.51.20.294.0 ]--
r 218         public PFNode next() { return  }
--[ 2019.11.11.00.51.22.322.0 ]--
r 218         public PFNode next() { return c }
--[ 2019.11.11.00.51.22.412.0 ]--
r 218         public PFNode next() { return c; }
--[ 2019.11.11.00.51.22.746.0 ]--
r 218         public PFNode next() { return c }
--[ 2019.11.11.00.51.23.246.0 ]--
r 218         public PFNode next() { return  }
--[ 2019.11.11.00.51.23.281.0 ]--
r 218         public PFNode next() { return }
--[ 2019.11.11.00.51.23.311.0 ]--
r 218         public PFNode next() { retur }
--[ 2019.11.11.00.51.23.344.0 ]--
r 218         public PFNode next() { retu }
--[ 2019.11.11.00.51.23.491.0 ]--
r 218         public PFNode next() { ret }
--[ 2019.11.11.00.51.23.691.0 ]--
r 218         public PFNode next() { re }
--[ 2019.11.11.00.51.23.862.0 ]--
r 218         public PFNode next() { r }
--[ 2019.11.11.00.51.24.116.0 ]--
r 218         public PFNode next() {  }
--[ 2019.11.11.00.51.24.636.0 ]--
+ 218         public PFNode next() { 
r 219          }
--[ 2019.11.11.00.51.24.666.0 ]--
r 219         }
--[ 2019.11.11.00.51.24.698.0 ]--
+ 219             
--[ 2019.11.11.00.51.26.311.0 ]--
r 219             P
--[ 2019.11.11.00.51.26.432.0 ]--
r 219             PF
--[ 2019.11.11.00.51.26.664.0 ]--
r 219             PFN
--[ 2019.11.11.00.51.26.945.0 ]--
r 219             PFNo
--[ 2019.11.11.00.51.27.049.0 ]--
r 219             PFNod
--[ 2019.11.11.00.51.27.218.0 ]--
r 219             PFNode
--[ 2019.11.11.00.51.27.303.0 ]--
r 219             PFNode 
--[ 2019.11.11.00.51.27.428.0 ]--
r 219             PFNode a
--[ 2019.11.11.00.51.27.577.0 ]--
r 219             PFNode a 
--[ 2019.11.11.00.51.27.842.0 ]--
r 219             PFNode a
--[ 2019.11.11.00.51.28.019.0 ]--
r 219             PFNode 
--[ 2019.11.11.00.51.29.087.0 ]--
r 219             PFNode d
--[ 2019.11.11.00.51.29.375.0 ]--
r 219             PFNode d 
--[ 2019.11.11.00.51.29.406.0 ]--
r 219             PFNode d =
--[ 2019.11.11.00.51.29.495.0 ]--
r 219             PFNode d = 
--[ 2019.11.11.00.51.31.057.0 ]--
r 219             PFNode d = c
--[ 2019.11.11.00.51.31.159.0 ]--
r 219             PFNode d = c;
--[ 2019.11.11.00.51.31.417.0 ]--
+ 220             
--[ 2019.11.11.00.51.32.925.0 ]--
r 220             c
--[ 2019.11.11.00.51.33.142.0 ]--
r 220             c 
--[ 2019.11.11.00.51.33.285.0 ]--
r 220             c =
--[ 2019.11.11.00.51.33.345.0 ]--
r 220             c = 
--[ 2019.11.11.00.51.34.983.0 ]--
r 220             c = c
--[ 2019.11.11.00.51.35.140.0 ]--
r 220             c = c.
--[ 2019.11.11.00.51.36.298.0 ]--
r 220             c = c.f
--[ 2019.11.11.00.51.36.543.0 ]--
r 220             c = c.fr
--[ 2019.11.11.00.51.36.635.0 ]--
r 220             c = c.fro
--[ 2019.11.11.00.51.36.725.0 ]--
r 220             c = c.from
--[ 2019.11.11.00.51.36.912.0 ]--
r 220             c = c.fromNode
--[ 2019.11.11.00.51.37.320.0 ]--
r 220             c = c.fromNode;
--[ 2019.11.11.00.51.37.549.0 ]--
+ 221             
--[ 2019.11.11.00.51.38.043.0 ]--
r 221             r
--[ 2019.11.11.00.51.38.159.0 ]--
r 221             re
--[ 2019.11.11.00.51.38.302.0 ]--
r 221             ret
--[ 2019.11.11.00.51.38.401.0 ]--
r 221             retu
--[ 2019.11.11.00.51.38.499.0 ]--
r 221             retur
--[ 2019.11.11.00.51.38.564.0 ]--
r 221             return
--[ 2019.11.11.00.51.38.729.0 ]--
r 221             return 
--[ 2019.11.11.00.51.39.070.0 ]--
r 221             return d
--[ 2019.11.11.00.51.39.113.0 ]--
r 221             return d;
--[ 2019.11.11.00.51.45.078.0 ]--
r 222         };
--[ 2019.11.11.00.51.55.436.0 ]--
- 215
- 215
- 216
- 216
- 216
- 216
r 216 
--[ 2019.11.11.00.51.55.870.0 ]--
- 216
--[ 2019.11.11.00.54.00.565.0 ]--
r 214         r
--[ 2019.11.11.00.54.00.891.0 ]--
r 214         ret
--[ 2019.11.11.00.54.00.927.0 ]--
r 214         retu
--[ 2019.11.11.00.54.01.048.0 ]--
r 214         retur
--[ 2019.11.11.00.54.01.163.0 ]--
r 214         return
--[ 2019.11.11.00.54.01.218.0 ]--
r 214         return 
--[ 2019.11.11.00.54.01.365.0 ]--
r 214         return n
--[ 2019.11.11.00.54.01.437.0 ]--
r 214         return ne
--[ 2019.11.11.00.54.01.535.0 ]--
r 214         return new
--[ 2019.11.11.00.54.01.609.0 ]--
r 214         return new 
--[ 2019.11.11.00.54.01.874.0 ]--
r 214         return new I
--[ 2019.11.11.00.54.01.954.0 ]--
r 214         return new It
--[ 2019.11.11.00.54.02.143.0 ]--
r 214         return new Ite
--[ 2019.11.11.00.54.02.220.0 ]--
r 214         return new Iter
--[ 2019.11.11.00.54.02.388.0 ]--
r 214         return new Itera
--[ 2019.11.11.00.54.02.553.0 ]--
r 214         return new Iterab
--[ 2019.11.11.00.54.02.696.0 ]--
r 214         return new Iterabl
--[ 2019.11.11.00.54.02.783.0 ]--
r 214         return new Iterable
--[ 2019.11.11.00.54.03.118.0 ]--
r 214         return new Iterable<>
--[ 2019.11.11.00.54.04.059.0 ]--
r 214         return new Iterable<P>
--[ 2019.11.11.00.54.04.125.0 ]--
r 214         return new Iterable<PF>
--[ 2019.11.11.00.54.04.285.0 ]--
r 214         return new Iterable<PFN>
--[ 2019.11.11.00.54.04.505.0 ]--
r 214         return new Iterable<PFNo>
--[ 2019.11.11.00.54.04.613.0 ]--
r 214         return new Iterable<PFNod>
--[ 2019.11.11.00.54.04.811.0 ]--
r 214         return new Iterable<PFNode>
--[ 2019.11.11.00.54.05.408.0 ]--
r 214         return new Iterable<PFNode
--[ 2019.11.11.00.54.05.594.0 ]--
r 214         return new Iterable<PFNod
--[ 2019.11.11.00.54.05.762.0 ]--
r 214         return new Iterable<PFNo
--[ 2019.11.11.00.54.05.930.0 ]--
r 214         return new Iterable<PFN
--[ 2019.11.11.00.54.06.108.0 ]--
r 214         return new Iterable<PF
--[ 2019.11.11.00.54.06.264.0 ]--
r 214         return new Iterable<P
--[ 2019.11.11.00.54.06.453.0 ]--
r 214         return new Iterable<
--[ 2019.11.11.00.54.06.806.0 ]--
r 214         return new Iterable<C
--[ 2019.11.11.00.54.06.943.0 ]--
r 214         return new Iterable<Co
--[ 2019.11.11.00.54.07.106.0 ]--
r 214         return new Iterable<Coo
--[ 2019.11.11.00.54.07.176.0 ]--
r 214         return new Iterable<Coor
--[ 2019.11.11.00.54.07.366.0 ]--
r 214         return new Iterable<Coord
--[ 2019.11.11.00.54.07.523.0 ]--
r 214         return new Iterable<Coord>
--[ 2019.11.11.00.54.09.985.0 ]--
r 214         return new Iterable<Coord>()
--[ 2019.11.11.00.54.11.608.0 ]--
+ 215         
--[ 2019.11.11.00.54.11.937.0 ]--
r 215                 
--[ 2019.11.11.00.54.12.884.0 ]--
r 215                 {}
--[ 2019.11.11.00.54.12.917.0 ]--
r 215         {}
--[ 2019.11.11.00.54.13.618.0 ]--
+ 215         {
r 216         }
--[ 2019.11.11.00.54.13.654.0 ]--
+ 216             
--[ 2019.11.11.00.54.15.625.0 ]--
r 217         };
--[ 2019.11.11.00.54.17.921.0 ]--
r 217         }
--[ 2019.11.11.00.54.21.229.0 ]--
r 217         };
--[ 2019.11.11.00.54.37.277.0 ]--
r 216             p
--[ 2019.11.11.00.54.37.665.0 ]--
r 216             publ
--[ 2019.11.11.00.54.37.707.0 ]--
r 216             publi
--[ 2019.11.11.00.54.37.755.0 ]--
r 216             public
--[ 2019.11.11.00.54.37.884.0 ]--
r 216             public 
--[ 2019.11.11.00.54.38.087.0 ]--
r 216             public I
--[ 2019.11.11.00.54.38.263.0 ]--
r 216             public It
--[ 2019.11.11.00.54.38.396.0 ]--
r 216             public Ite
--[ 2019.11.11.00.54.38.507.0 ]--
r 216             public Iter
--[ 2019.11.11.00.54.38.672.0 ]--
r 216             public Itera
--[ 2019.11.11.00.54.38.799.0 ]--
r 216             public Iterat
--[ 2019.11.11.00.54.38.863.0 ]--
r 216             public Iterato
--[ 2019.11.11.00.54.39.017.0 ]--
r 216             public Iterator
--[ 2019.11.11.00.54.39.318.0 ]--
r 216             public Iterator<>
--[ 2019.11.11.00.54.41.397.0 ]--
r 216             public Iterator<C>
--[ 2019.11.11.00.54.41.653.0 ]--
r 216             public Iterator<Co>
--[ 2019.11.11.00.54.41.810.0 ]--
r 216             public Iterator<Coo>
--[ 2019.11.11.00.54.41.886.0 ]--
r 216             public Iterator<Coor>
--[ 2019.11.11.00.54.42.090.0 ]--
r 216             public Iterator<Coord>
--[ 2019.11.11.00.54.42.376.0 ]--
r 216             public Iterator<Coord> 
--[ 2019.11.11.00.54.42.521.0 ]--
r 216             public Iterator<Coord> i
--[ 2019.11.11.00.54.42.856.0 ]--
r 216             public Iterator<Coord> ite
--[ 2019.11.11.00.54.42.908.0 ]--
r 216             public Iterator<Coord> iter
--[ 2019.11.11.00.54.43.027.0 ]--
r 216             public Iterator<Coord> itera
--[ 2019.11.11.00.54.43.132.0 ]--
r 216             public Iterator<Coord> iterat
--[ 2019.11.11.00.54.43.206.0 ]--
r 216             public Iterator<Coord> iterato
--[ 2019.11.11.00.54.43.341.0 ]--
r 216             public Iterator<Coord> iterator
--[ 2019.11.11.00.54.43.634.0 ]--
r 216             public Iterator<Coord> iterator()
--[ 2019.11.11.00.54.45.782.0 ]--
+ 217             
--[ 2019.11.11.00.54.45.810.0 ]--
r 217                 
--[ 2019.11.11.00.54.46.131.0 ]--
r 217                 {}
--[ 2019.11.11.00.54.46.167.0 ]--
r 217             {}
--[ 2019.11.11.00.54.46.389.0 ]--
+ 217             {
r 218             }
--[ 2019.11.11.00.54.46.430.0 ]--
+ 218                 
--[ 2019.11.11.00.55.08.435.0 ]--
- 214
- 214
- 214
- 214
- 214
- 214
r 214 
--[ 2019.11.11.00.55.08.831.0 ]--
- 214
--[ 2019.11.11.00.55.13.937.0 ]--
r 213         *
--[ 2019.11.11.00.55.14.146.0 ]--
r 213         
--[ 2019.11.11.00.55.14.594.0 ]--
r 213        
--[ 2019.11.11.00.55.15.031.0 ]--
r 213       
--[ 2019.11.11.00.55.15.432.0 ]--
r 213      
--[ 2019.11.11.00.55.15.930.0 ]--
r 213     
--[ 2019.11.11.00.55.15.963.0 ]--
r 213    
--[ 2019.11.11.00.55.16.226.0 ]--
r 213   
--[ 2019.11.11.00.55.16.431.0 ]--
r 213  
--[ 2019.11.11.00.55.16.605.0 ]--
r 213 
--[ 2019.11.11.00.55.16.925.0 ]--
- 213
--[ 2019.11.11.00.55.17.837.0 ]--
r 213        
--[ 2019.11.11.00.55.18.229.0 ]--
r 213       
--[ 2019.11.11.00.55.18.455.0 ]--
r 213      
--[ 2019.11.11.00.55.18.632.0 ]--
r 213     
--[ 2019.11.11.00.55.18.881.0 ]--
r 213    
--[ 2019.11.11.00.55.18.983.0 ]--
r 213   
--[ 2019.11.11.00.55.19.144.0 ]--
r 213  
--[ 2019.11.11.00.55.19.329.0 ]--
r 213 
--[ 2019.11.11.00.55.19.672.0 ]--
- 213
--[ 2019.11.11.00.55.21.453.0 ]--
r 205         /
--[ 2019.11.11.00.55.21.693.0 ]--
r 205         
--[ 2019.11.11.00.55.21.930.0 ]--
- 205
--[ 2019.11.11.01.00.19.979.0 ]--
DisposeComponent
--[ 2019.11.11.09.54.13.279.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.11.11.09.54.13.592.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2019.11.11.09.54.13.632.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.11.09.54.13.654.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.11.11.09.54.13.671.0 ]--
InitFile: /.cos265


--[ 2019.11.11.09.54.13.692.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.11.11.09.54.13.719.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.11.11.09.54.13.736.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[10];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();
        int M = 0;

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.11.11.09.54.14.081.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.11.11.09.54.14.109.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float progress;
    int calls;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.progress = 0.0f;
        this.calls = 0;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        calls++;
        float end = totalCost + byTime;
        if (calls == 100) {
            while (!path.isEmpty()) {
                loc = path.dequeue();
            }
            nextLoc = null;
        } else {
            while (totalCost < end) {
                float cost = terrain.computeTravelCost(loc, nextLoc);
                if (totalCost + (cost - progress) > end) {
                    float prev = end - totalCost;
                    totalCost += prev;
                    progress += prev;
                    break;
                } else {
                    totalCost += (cost - progress);
                    progress = 0.0f;
                    loc = path.dequeue();
                    if (!path.isEmpty()) nextLoc = path.peek();
                    else {
                        nextLoc = null;
                        break;
                    }
                }
            }
        }
    }

}

--[ 2019.11.11.09.54.14.128.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private float totalCost;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;
        private float flatcost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        public Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) { this.cost = 0.0f; this.flatcost = 0.0f; }
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.getCost(h) + nextCost + heuristic*terrain.computeDistance(loc, end);
                    this.flatcost = b.getFlatCost() + nextCost;
                }
            }
        }

        public float getCost(float heuristic) {
            return cost;
        }

        public float getFlatCost() { return flatcost; }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        totalCost = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            if (currentLoc.equals(getPathEnd())) {
                pathFound = true;
                endNode = currentNode;
                break;
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            atStart = false;
        }
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getFlatCost();
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        Stack<Coord> s = new Stack<>();
        PFNode c = endNode;
        while (c != null) {
            s.push(c.getLoc());
            c = c.fromNode;
        }
        return s;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2019.11.11.09.57.19.185.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.11.09.57.21.151.0 ]--
r 48     private final static String emapFilename = emaps[0];        // change index to load a different elevation map
--[ 2019.11.11.09.57.32.724.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.10.22.24.563.0 ]--
:/src/Pathfinder.java
+ 170                     
--[ 2019.11.11.10.22.27.888.0 ]--
r 170                     StdOut.println("")
--[ 2019.11.11.10.22.30.414.0 ]--
r 170                     StdOut.println("C")
--[ 2019.11.11.10.22.30.711.0 ]--
r 170                     StdOut.println("Co")
--[ 2019.11.11.10.22.31.016.0 ]--
r 170                     StdOut.println("Coor")
--[ 2019.11.11.10.22.31.328.0 ]--
r 170                     StdOut.println("Coord:")
--[ 2019.11.11.10.22.31.892.0 ]--
r 170                     StdOut.println("Coord: ")
--[ 2019.11.11.10.22.32.549.0 ]--
r 170                     StdOut.println("Coord:")
--[ 2019.11.11.10.22.33.061.0 ]--
r 170                     StdOut.println("Coord")
--[ 2019.11.11.10.22.33.133.0 ]--
r 170                     StdOut.println("Co")
--[ 2019.11.11.10.22.33.431.0 ]--
r 170                     StdOut.pr
--[ 2019.11.11.10.22.34.289.0 ]--
r 170                     St
--[ 2019.11.11.10.22.34.444.0 ]--
r 170                     S
--[ 2019.11.11.10.22.35.057.0 ]--
r 170                     
--[ 2019.11.11.10.22.44.831.0 ]--
- 170
--[ 2019.11.11.10.22.46.705.0 ]--
+ 171                         
--[ 2019.11.11.10.22.48.058.0 ]--
r 171                         St
--[ 2019.11.11.10.22.49.108.0 ]--
r 171                         StdOut.
--[ 2019.11.11.10.22.49.816.0 ]--
r 171                         StdOut.prin
--[ 2019.11.11.10.22.50.114.0 ]--
r 171                         StdOut.println
--[ 2019.11.11.10.22.50.457.0 ]--
r 171                         StdOut.println()
--[ 2019.11.11.10.22.50.939.0 ]--
r 171                         StdOut.println("")
--[ 2019.11.11.10.22.53.935.0 ]--
r 171                         StdOut.println("C")
--[ 2019.11.11.10.22.54.633.0 ]--
r 171                         StdOut.println("Curr")
--[ 2019.11.11.10.22.54.742.0 ]--
r 171                         StdOut.println("Curre")
--[ 2019.11.11.10.22.54.876.0 ]--
r 171                         StdOut.println("Curren")
--[ 2019.11.11.10.22.54.959.0 ]--
r 171                         StdOut.println("Current")
--[ 2019.11.11.10.22.55.120.0 ]--
r 171                         StdOut.println("Current ")
--[ 2019.11.11.10.22.55.235.0 ]--
r 171                         StdOut.println("Current l")
--[ 2019.11.11.10.22.55.392.0 ]--
r 171                         StdOut.println("Current lo")
--[ 2019.11.11.10.22.55.486.0 ]--
r 171                         StdOut.println("Current loc")
--[ 2019.11.11.10.22.55.673.0 ]--
r 171                         StdOut.println("Current loc:")
--[ 2019.11.11.10.22.57.841.0 ]--
r 171                         StdOut.println("Current loc: ")
--[ 2019.11.11.10.22.58.958.0 ]--
r 171                         StdOut.println("Current loc: " )
--[ 2019.11.11.10.22.59.174.0 ]--
r 171                         StdOut.println("Current loc: " +)
--[ 2019.11.11.10.22.59.305.0 ]--
r 171                         StdOut.println("Current loc: " + )
--[ 2019.11.11.10.23.01.114.0 ]--
r 171                         StdOut.println("Current loc: " + c)
--[ 2019.11.11.10.23.01.415.0 ]--
r 171                         StdOut.println("Current loc: " + c.)
--[ 2019.11.11.10.23.01.999.0 ]--
r 171                         StdOut.println("Current loc: " + c)
--[ 2019.11.11.10.23.02.149.0 ]--
r 171                         StdOut.println("Current loc: " + )
--[ 2019.11.11.10.23.03.012.0 ]--
r 171                         StdOut.println("Current loc: " + c)
--[ 2019.11.11.10.23.03.227.0 ]--
r 171                         StdOut.println("Current loc: " + c.)
--[ 2019.11.11.10.23.03.434.0 ]--
r 171                         StdOut.println("Current loc: " + c.ge)
--[ 2019.11.11.10.23.03.608.0 ]--
r 171                         StdOut.println("Current loc: " + c.get)
--[ 2019.11.11.10.23.03.868.0 ]--
r 171                         StdOut.println("Current loc: " + c.getL)
--[ 2019.11.11.10.23.05.419.0 ]--
r 171                         StdOut.println("Current loc: " + c.getLoc())
--[ 2019.11.11.10.23.06.286.0 ]--
r 171                         StdOut.println("Current loc: " + c.getLoc() )
--[ 2019.11.11.10.23.06.770.0 ]--
r 171                         StdOut.println("Current loc: " + c.getLoc() + )
--[ 2019.11.11.10.23.07.692.0 ]--
r 171                         StdOut.println("Current loc: " + c.getLoc() + "")
--[ 2019.11.11.10.23.07.944.0 ]--
r 171                         StdOut.println("Current loc: " + c.getLoc() + " ")
--[ 2019.11.11.10.23.08.388.0 ]--
r 171                         StdOut.println("Current loc: " + c.getLoc() + " c")
--[ 2019.11.11.10.23.08.473.0 ]--
r 171                         StdOut.println("Current loc: " + c.getLoc() + " co")
--[ 2019.11.11.10.23.08.582.0 ]--
r 171                         StdOut.println("Current loc: " + c.getLoc() + " cos")
--[ 2019.11.11.10.23.08.777.0 ]--
r 171                         StdOut.println("Current loc: " + c.getLoc() + " cost")
--[ 2019.11.11.10.23.09.024.0 ]--
r 171                         StdOut.println("Current loc: " + c.getLoc() + " cost:")
--[ 2019.11.11.10.23.09.239.0 ]--
r 171                         StdOut.println("Current loc: " + c.getLoc() + " cost: ")
--[ 2019.11.11.10.23.09.960.0 ]--
r 171                         StdOut.println("Current loc: " + c.getLoc() + " cost: " )
--[ 2019.11.11.10.23.10.328.0 ]--
r 171                         StdOut.println("Current loc: " + c.getLoc() + " cost: " +)
--[ 2019.11.11.10.23.10.472.0 ]--
r 171                         StdOut.println("Current loc: " + c.getLoc() + " cost: " + )
--[ 2019.11.11.10.23.11.218.0 ]--
r 171                         StdOut.println("Current loc: " + c.getLoc() + " cost: " + c)
--[ 2019.11.11.10.23.11.868.0 ]--
r 171                         StdOut.println("Current loc: " + c.getLoc() + " cost: " + c.ge)
--[ 2019.11.11.10.23.12.067.0 ]--
r 171                         StdOut.println("Current loc: " + c.getLoc() + " cost: " + c.get)
--[ 2019.11.11.10.23.12.505.0 ]--
r 171                         StdOut.println("Current loc: " + c.getLoc() + " cost: " + c.getC)
--[ 2019.11.11.10.23.12.705.0 ]--
r 171                         StdOut.println("Current loc: " + c.getLoc() + " cost: " + c.getCo)
--[ 2019.11.11.10.23.12.820.0 ]--
r 171                         StdOut.println("Current loc: " + c.getLoc() + " cost: " + c.getCos)
--[ 2019.11.11.10.23.12.924.0 ]--
r 171                         StdOut.println("Current loc: " + c.getLoc() + " cost: " + c.getCost)
--[ 2019.11.11.10.23.13.352.0 ]--
r 171                         StdOut.println("Current loc: " + c.getLoc() + " cost: " + c.getCost())
--[ 2019.11.11.10.23.13.555.0 ]--
r 171                         StdOut.println("Current loc: " + c.getLoc() + " cost: " + c.getCost(h))
--[ 2019.11.11.10.23.14.639.0 ]--
r 171                         StdOut.println("Current loc: " + c.getLoc() + " cost: " + c.getCost(h));
--[ 2019.11.11.10.23.20.825.0 ]--
+ 176                         
--[ 2019.11.11.10.23.22.396.0 ]--
r 176                         StdOut.println("Current loc: " + c.getLoc() + " cost: " + c.getCost(h));
--[ 2019.11.11.10.23.33.147.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.10.24.19.811.0 ]--
r 171                         StdOut.println("S loc: " + c.getLoc() + " cost: " + c.getCost(h));
--[ 2019.11.11.10.24.20.363.0 ]--
r 171                         StdOut.println("Se loc: " + c.getLoc() + " cost: " + c.getCost(h));
--[ 2019.11.11.10.24.20.493.0 ]--
r 171                         StdOut.println("Sea loc: " + c.getLoc() + " cost: " + c.getCost(h));
--[ 2019.11.11.10.24.20.604.0 ]--
r 171                         StdOut.println("Sear loc: " + c.getLoc() + " cost: " + c.getCost(h));
--[ 2019.11.11.10.24.20.889.0 ]--
r 171                         StdOut.println("Searc loc: " + c.getLoc() + " cost: " + c.getCost(h));
--[ 2019.11.11.10.24.22.435.0 ]--
r 171                         StdOut.println("Searching loc: " + c.getLoc() + " cost: " + c.getCost(h));
--[ 2019.11.11.10.24.23.019.0 ]--
r 171                         StdOut.println("Searchingloc: " + c.getLoc() + " cost: " + c.getCost(h));
--[ 2019.11.11.10.24.23.212.0 ]--
r 171                         StdOut.println("Searchingoc: " + c.getLoc() + " cost: " + c.getCost(h));
--[ 2019.11.11.10.24.23.442.0 ]--
r 171                         StdOut.println("Searchingc: " + c.getLoc() + " cost: " + c.getCost(h));
--[ 2019.11.11.10.24.24.193.0 ]--
r 171                         StdOut.println("Searching: " + c.getLoc() + " cost: " + c.getCost(h));
--[ 2019.11.11.10.24.26.172.0 ]--
r 176                         StdOut.println("S loc: " + c.getLoc() + " cost: " + c.getCost(h));
--[ 2019.11.11.10.24.26.421.0 ]--
r 176                         StdOut.println("Se loc: " + c.getLoc() + " cost: " + c.getCost(h));
--[ 2019.11.11.10.24.26.530.0 ]--
r 176                         StdOut.println("Sea loc: " + c.getLoc() + " cost: " + c.getCost(h));
--[ 2019.11.11.10.24.26.633.0 ]--
r 176                         StdOut.println("Sear loc: " + c.getLoc() + " cost: " + c.getCost(h));
--[ 2019.11.11.10.24.26.809.0 ]--
r 176                         StdOut.println("Searc loc: " + c.getLoc() + " cost: " + c.getCost(h));
--[ 2019.11.11.10.24.27.014.0 ]--
r 176                         StdOut.println("Searchi loc: " + c.getLoc() + " cost: " + c.getCost(h));
--[ 2019.11.11.10.24.27.217.0 ]--
r 176                         StdOut.println("Searching loc: " + c.getLoc() + " cost: " + c.getCost(h));
--[ 2019.11.11.10.24.27.681.0 ]--
r 176                         StdOut.println("Searchingloc: " + c.getLoc() + " cost: " + c.getCost(h));
--[ 2019.11.11.10.24.27.907.0 ]--
r 176                         StdOut.println("Searchingoc: " + c.getLoc() + " cost: " + c.getCost(h));
--[ 2019.11.11.10.24.28.129.0 ]--
r 176                         StdOut.println("Searchingc: " + c.getLoc() + " cost: " + c.getCost(h));
--[ 2019.11.11.10.24.28.328.0 ]--
r 176                         StdOut.println("Searching: " + c.getLoc() + " cost: " + c.getCost(h));
--[ 2019.11.11.10.24.34.824.0 ]--
+ 168             
--[ 2019.11.11.10.24.36.164.0 ]--
r 168             StdOu
--[ 2019.11.11.10.24.36.263.0 ]--
r 168             StdOut
--[ 2019.11.11.10.24.36.364.0 ]--
r 168             StdOut.
--[ 2019.11.11.10.24.36.596.0 ]--
r 168             StdOut.p
--[ 2019.11.11.10.24.36.714.0 ]--
r 168             StdOut.pr
--[ 2019.11.11.10.24.36.797.0 ]--
r 168             StdOut.pri
--[ 2019.11.11.10.24.36.882.0 ]--
r 168             StdOut.prin
--[ 2019.11.11.10.24.36.996.0 ]--
r 168             StdOut.print
--[ 2019.11.11.10.24.37.147.0 ]--
r 168             StdOut.println
--[ 2019.11.11.10.24.37.381.0 ]--
r 168             StdOut.println()
--[ 2019.11.11.10.24.37.603.0 ]--
r 168             StdOut.println("")
--[ 2019.11.11.10.24.38.205.0 ]--
r 168             StdOut.println("c")
--[ 2019.11.11.10.24.38.625.0 ]--
r 168             StdOut.println("")
--[ 2019.11.11.10.24.38.936.0 ]--
r 168             StdOut.println("C")
--[ 2019.11.11.10.24.39.148.0 ]--
r 168             StdOut.println("Cu")
--[ 2019.11.11.10.24.39.345.0 ]--
r 168             StdOut.println("Cur")
--[ 2019.11.11.10.24.39.542.0 ]--
r 168             StdOut.println("Curr")
--[ 2019.11.11.10.24.39.613.0 ]--
r 168             StdOut.println("Curre")
--[ 2019.11.11.10.24.39.717.0 ]--
r 168             StdOut.println("Curren")
--[ 2019.11.11.10.24.39.790.0 ]--
r 168             StdOut.println("Current")
--[ 2019.11.11.10.24.39.921.0 ]--
r 168             StdOut.println("Current ")
--[ 2019.11.11.10.24.39.985.0 ]--
r 168             StdOut.println("Current l")
--[ 2019.11.11.10.24.40.181.0 ]--
r 168             StdOut.println("Current lo")
--[ 2019.11.11.10.24.40.248.0 ]--
r 168             StdOut.println("Current loc")
--[ 2019.11.11.10.24.40.498.0 ]--
r 168             StdOut.println("Current loc:")
--[ 2019.11.11.10.24.40.780.0 ]--
r 168             StdOut.println("Current loc: ")
--[ 2019.11.11.10.24.41.209.0 ]--
r 168             StdOut.println("Current loc: " )
--[ 2019.11.11.10.24.41.468.0 ]--
r 168             StdOut.println("Current loc: " +)
--[ 2019.11.11.10.24.41.566.0 ]--
r 168             StdOut.println("Current loc: " + )
--[ 2019.11.11.10.24.52.339.0 ]--
r 168             StdOut.println("Current loc: " + c)
--[ 2019.11.11.10.24.53.699.0 ]--
r 168             StdOut.println("Current loc: " + currentN)
--[ 2019.11.11.10.24.53.776.0 ]--
r 168             StdOut.println("Current loc: " + currentNo)
--[ 2019.11.11.10.24.53.904.0 ]--
r 168             StdOut.println("Current loc: " + currentNod)
--[ 2019.11.11.10.24.53.994.0 ]--
r 168             StdOut.println("Current loc: " + currentNode)
--[ 2019.11.11.10.24.54.065.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.)
--[ 2019.11.11.10.24.54.227.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.g)
--[ 2019.11.11.10.24.54.316.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.ge)
--[ 2019.11.11.10.24.54.461.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.get)
--[ 2019.11.11.10.24.54.847.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getL)
--[ 2019.11.11.10.24.54.998.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLo)
--[ 2019.11.11.10.24.55.083.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLoc)
--[ 2019.11.11.10.24.55.514.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLoc())
--[ 2019.11.11.10.24.56.483.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLoc() )
--[ 2019.11.11.10.24.56.671.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLoc() +)
--[ 2019.11.11.10.24.56.815.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLoc() + )
--[ 2019.11.11.10.24.57.229.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLoc() + "")
--[ 2019.11.11.10.24.57.381.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLoc() + " ")
--[ 2019.11.11.10.24.58.065.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLoc() + " c")
--[ 2019.11.11.10.24.58.188.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLoc() + " co")
--[ 2019.11.11.10.24.58.302.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLoc() + " cos")
--[ 2019.11.11.10.24.58.443.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLoc() + " cost")
--[ 2019.11.11.10.24.58.732.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLoc() + " cost:")
--[ 2019.11.11.10.24.58.921.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLoc() + " cost: ")
--[ 2019.11.11.10.24.59.438.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLoc() + " cost: " )
--[ 2019.11.11.10.24.59.588.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLoc() + " cost: " +)
--[ 2019.11.11.10.24.59.711.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLoc() + " cost: " + )
--[ 2019.11.11.10.25.00.878.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLoc() + " cost: " + c)
--[ 2019.11.11.10.25.01.065.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLoc() + " cost: " + cu)
--[ 2019.11.11.10.25.01.172.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLoc() + " cost: " + cur)
--[ 2019.11.11.10.25.01.386.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLoc() + " cost: " + curr)
--[ 2019.11.11.10.25.01.476.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLoc() + " cost: " + curre)
--[ 2019.11.11.10.25.01.589.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLoc() + " cost: " + curren)
--[ 2019.11.11.10.25.01.688.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLoc() + " cost: " + current)
--[ 2019.11.11.10.25.01.849.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLoc() + " cost: " + currentN)
--[ 2019.11.11.10.25.02.006.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLoc() + " cost: " + currentNo)
--[ 2019.11.11.10.25.02.124.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLoc() + " cost: " + currentNod)
--[ 2019.11.11.10.25.02.289.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLoc() + " cost: " + currentNode)
--[ 2019.11.11.10.25.02.350.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLoc() + " cost: " + currentNode.)
--[ 2019.11.11.10.25.03.707.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLoc() + " cost: " + currentNode.getCost)
--[ 2019.11.11.10.25.03.985.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLoc() + " cost: " + currentNode.getCost())
--[ 2019.11.11.10.25.04.250.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLoc() + " cost: " + currentNode.getCost(h))
--[ 2019.11.11.10.25.05.078.0 ]--
r 168             StdOut.println("Current loc: " + currentNode.getLoc() + " cost: " + currentNode.getCost(h));
--[ 2019.11.11.10.25.15.622.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.10.25.58.656.0 ]--
+ 153         
--[ 2019.11.11.10.26.03.002.0 ]--
r 153         boolean found = false;
--[ 2019.11.11.10.26.40.441.0 ]--
+ 172                     
--[ 2019.11.11.10.26.42.000.0 ]--
r 172                     if 
--[ 2019.11.11.10.26.42.832.0 ]--
r 172                     if ()
--[ 2019.11.11.10.26.43.156.0 ]--
r 172                     if (c)
--[ 2019.11.11.10.26.43.538.0 ]--
r 172                     if (c.g)
--[ 2019.11.11.10.26.43.635.0 ]--
r 172                     if (c.ge)
--[ 2019.11.11.10.26.43.747.0 ]--
r 172                     if (c.get)
--[ 2019.11.11.10.26.44.020.0 ]--
r 172                     if (c.getL)
--[ 2019.11.11.10.26.44.168.0 ]--
r 172                     if (c.getLo)
--[ 2019.11.11.10.26.44.271.0 ]--
r 172                     if (c.getLoc)
--[ 2019.11.11.10.26.44.551.0 ]--
r 172                     if (c.getLoc())
--[ 2019.11.11.10.26.48.532.0 ]--
r 172                     if (c.getLoc().)
--[ 2019.11.11.10.26.48.732.0 ]--
r 172                     if (c.getLoc().e)
--[ 2019.11.11.10.26.49.016.0 ]--
r 172                     if (c.getLoc().eq)
--[ 2019.11.11.10.26.49.101.0 ]--
r 172                     if (c.getLoc().equ)
--[ 2019.11.11.10.26.49.251.0 ]--
r 172                     if (c.getLoc().equa)
--[ 2019.11.11.10.26.49.450.0 ]--
r 172                     if (c.getLoc().equal)
--[ 2019.11.11.10.26.49.615.0 ]--
r 172                     if (c.getLoc().equals)
--[ 2019.11.11.10.26.49.902.0 ]--
r 172                     if (c.getLoc().equals())
--[ 2019.11.11.10.26.50.297.0 ]--
r 172                     if (c.getLoc().equals(g))
--[ 2019.11.11.10.26.50.368.0 ]--
r 172                     if (c.getLoc().equals(ge))
--[ 2019.11.11.10.26.50.576.0 ]--
r 172                     if (c.getLoc().equals(get))
--[ 2019.11.11.10.26.52.239.0 ]--
r 172                     if (c.getLoc().equals(getPathEnd))
--[ 2019.11.11.10.26.52.438.0 ]--
r 172                     if (c.getLoc().equals(getPathEnd()))
--[ 2019.11.11.10.26.53.638.0 ]--
r 172                     if (c.getLoc().equals(getPathEnd())) 
--[ 2019.11.11.10.26.53.788.0 ]--
r 172                     if (c.getLoc().equals(getPathEnd())) {
--[ 2019.11.11.10.26.54.007.0 ]--
+ 173 
+ 174 }
--[ 2019.11.11.10.26.54.229.0 ]--
r 174                     }
--[ 2019.11.11.10.26.54.302.0 ]--
r 173                         
--[ 2019.11.11.10.26.56.103.0 ]--
r 173                         f
--[ 2019.11.11.10.26.56.274.0 ]--
r 173                         fo
--[ 2019.11.11.10.26.56.368.0 ]--
r 173                         fou
--[ 2019.11.11.10.26.56.508.0 ]--
r 173                         foun
--[ 2019.11.11.10.26.56.639.0 ]--
r 173                         found
--[ 2019.11.11.10.26.56.805.0 ]--
r 173                         found =
--[ 2019.11.11.10.26.56.927.0 ]--
r 173                         found = 
--[ 2019.11.11.10.26.57.375.0 ]--
r 173                         found = t
--[ 2019.11.11.10.26.57.614.0 ]--
r 173                         found = tr
--[ 2019.11.11.10.26.57.745.0 ]--
r 173                         found = tru
--[ 2019.11.11.10.26.57.856.0 ]--
r 173                         found = true
--[ 2019.11.11.10.26.57.940.0 ]--
r 173                         found = true;
--[ 2019.11.11.10.26.58.112.0 ]--
+ 174                         
--[ 2019.11.11.10.26.59.454.0 ]--
r 174                         b
--[ 2019.11.11.10.26.59.704.0 ]--
r 174                         br
--[ 2019.11.11.10.26.59.787.0 ]--
r 174                         bre
--[ 2019.11.11.10.26.59.863.0 ]--
r 174                         brea
--[ 2019.11.11.10.26.59.971.0 ]--
r 174                         break
--[ 2019.11.11.10.27.00.102.0 ]--
r 174                         break;
--[ 2019.11.11.10.27.04.338.0 ]--
+ 188             
--[ 2019.11.11.10.27.08.202.0 ]--
r 188             i
--[ 2019.11.11.10.27.08.348.0 ]--
r 188             if
--[ 2019.11.11.10.27.08.490.0 ]--
r 188             if 
--[ 2019.11.11.10.27.08.615.0 ]--
r 188             if ()
--[ 2019.11.11.10.27.08.830.0 ]--
r 188             if (f)
--[ 2019.11.11.10.27.08.953.0 ]--
r 188             if (fou)
--[ 2019.11.11.10.27.09.197.0 ]--
r 188             if (foun)
--[ 2019.11.11.10.27.09.334.0 ]--
r 188             if (found)
--[ 2019.11.11.10.27.09.807.0 ]--
r 188             if (found) 
--[ 2019.11.11.10.27.10.013.0 ]--
r 188             if (found) {
--[ 2019.11.11.10.27.10.201.0 ]--
+ 189 
+ 190 }
--[ 2019.11.11.10.27.10.383.0 ]--
r 190             }
--[ 2019.11.11.10.27.10.464.0 ]--
r 189                 
--[ 2019.11.11.10.27.13.028.0 ]--
r 189                 p
--[ 2019.11.11.10.27.13.183.0 ]--
r 189                 pa
--[ 2019.11.11.10.27.13.352.0 ]--
r 189                 path
--[ 2019.11.11.10.27.13.554.0 ]--
r 189                 pathF
--[ 2019.11.11.10.27.13.732.0 ]--
r 189                 pathFo
--[ 2019.11.11.10.27.13.813.0 ]--
r 189                 pathFou
--[ 2019.11.11.10.27.14.031.0 ]--
r 189                 pathFoun
--[ 2019.11.11.10.27.14.164.0 ]--
r 189                 pathFound
--[ 2019.11.11.10.27.14.230.0 ]--
r 189                 pathFound 
--[ 2019.11.11.10.27.14.315.0 ]--
r 189                 pathFound =
--[ 2019.11.11.10.27.14.397.0 ]--
r 189                 pathFound = 
--[ 2019.11.11.10.27.14.581.0 ]--
r 189                 pathFound = t
--[ 2019.11.11.10.27.15.961.0 ]--
+ 189                 pathFound = true;
r 190                 
--[ 2019.11.11.10.27.19.033.0 ]--
r 190                 e
--[ 2019.11.11.10.27.19.197.0 ]--
r 190                 en
--[ 2019.11.11.10.27.19.316.0 ]--
r 190                 end
--[ 2019.11.11.10.27.19.531.0 ]--
r 190                 endN
--[ 2019.11.11.10.27.19.655.0 ]--
r 190                 endNo
--[ 2019.11.11.10.27.19.763.0 ]--
r 190                 endNod
--[ 2019.11.11.10.27.19.852.0 ]--
r 190                 endNode
--[ 2019.11.11.10.27.20.418.0 ]--
r 190                 endNode 
--[ 2019.11.11.10.27.20.479.0 ]--
r 190                 endNode =
--[ 2019.11.11.10.27.20.584.0 ]--
r 190                 endNode = 
--[ 2019.11.11.10.27.20.757.0 ]--
r 190                 endNode = c
--[ 2019.11.11.10.27.20.885.0 ]--
r 190                 endNode = cu
--[ 2019.11.11.10.27.21.070.0 ]--
r 190                 endNode = cur
--[ 2019.11.11.10.27.21.219.0 ]--
r 190                 endNode = curr
--[ 2019.11.11.10.27.21.352.0 ]--
r 190                 endNode = curre
--[ 2019.11.11.10.27.21.487.0 ]--
r 190                 endNode = current
--[ 2019.11.11.10.27.21.773.0 ]--
r 190                 endNode = currentN
--[ 2019.11.11.10.27.21.970.0 ]--
r 190                 endNode = currentNo
--[ 2019.11.11.10.27.22.055.0 ]--
r 190                 endNode = currentNod
--[ 2019.11.11.10.27.22.188.0 ]--
r 190                 endNode = currentNode
--[ 2019.11.11.10.27.22.255.0 ]--
r 190                 endNode = currentNode;
--[ 2019.11.11.10.27.22.587.0 ]--
+ 191                 
--[ 2019.11.11.10.27.22.815.0 ]--
r 191                 b
--[ 2019.11.11.10.27.23.068.0 ]--
r 191                 br
--[ 2019.11.11.10.27.23.157.0 ]--
r 191                 bre
--[ 2019.11.11.10.27.23.286.0 ]--
r 191                 break
--[ 2019.11.11.10.27.23.365.0 ]--
r 191                 break;
--[ 2019.11.11.10.27.40.629.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.10.28.08.343.0 ]--
+ 173                         
--[ 2019.11.11.10.28.08.744.0 ]--
r 173                         c
--[ 2019.11.11.10.28.09.010.0 ]--
r 173                         cu
--[ 2019.11.11.10.28.09.210.0 ]--
r 173                         cur
--[ 2019.11.11.10.28.09.512.0 ]--
r 173                         curren
--[ 2019.11.11.10.28.10.776.0 ]--
r 173                         currentNode = 
--[ 2019.11.11.10.28.10.962.0 ]--
r 173                         currentNode = c
--[ 2019.11.11.10.28.11.290.0 ]--
r 173                         currentNode = c;
--[ 2019.11.11.10.28.20.734.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.10.28.39.793.0 ]--
+ 191                 
--[ 2019.11.11.10.28.40.174.0 ]--
r 191                 S
--[ 2019.11.11.10.28.40.424.0 ]--
r 191                 St
--[ 2019.11.11.10.28.40.607.0 ]--
r 191                 Std
--[ 2019.11.11.10.28.40.786.0 ]--
r 191                 StdO
--[ 2019.11.11.10.28.40.974.0 ]--
r 191                 StdOu
--[ 2019.11.11.10.28.42.525.0 ]--
r 191                 StdOut.println()
--[ 2019.11.11.10.28.42.635.0 ]--
r 191                 StdOut.println("")
--[ 2019.11.11.10.28.42.993.0 ]--
r 191                 StdOut.println("f")
--[ 2019.11.11.10.28.43.059.0 ]--
r 191                 StdOut.println("fo")
--[ 2019.11.11.10.28.43.131.0 ]--
r 191                 StdOut.println("fou")
--[ 2019.11.11.10.28.43.315.0 ]--
r 191                 StdOut.println("foun")
--[ 2019.11.11.10.28.43.500.0 ]--
r 191                 StdOut.println("found ")
--[ 2019.11.11.10.28.43.648.0 ]--
r 191                 StdOut.println("found a")
--[ 2019.11.11.10.28.43.893.0 ]--
r 191                 StdOut.println("found at")
--[ 2019.11.11.10.28.43.999.0 ]--
r 191                 StdOut.println("found at:")
--[ 2019.11.11.10.28.44.213.0 ]--
r 191                 StdOut.println("found at: ")
--[ 2019.11.11.10.28.44.611.0 ]--
r 191                 StdOut.println("found at: " )
--[ 2019.11.11.10.28.44.765.0 ]--
r 191                 StdOut.println("found at: " +)
--[ 2019.11.11.10.28.44.912.0 ]--
r 191                 StdOut.println("found at: " + )
--[ 2019.11.11.10.28.47.432.0 ]--
r 191                 StdOut.println("found at: " + c)
--[ 2019.11.11.10.28.48.127.0 ]--
r 191                 StdOut.println("found at: " + cu)
--[ 2019.11.11.10.28.48.430.0 ]--
r 191                 StdOut.println("found at: " + cur)
--[ 2019.11.11.10.28.48.932.0 ]--
r 191                 StdOut.println("found at: " + curre)
--[ 2019.11.11.10.28.49.529.0 ]--
r 191                 StdOut.println("found at: " + curren)
--[ 2019.11.11.10.28.49.644.0 ]--
r 191                 StdOut.println("found at: " + current)
--[ 2019.11.11.10.28.49.872.0 ]--
r 191                 StdOut.println("found at: " + currentN)
--[ 2019.11.11.10.28.50.165.0 ]--
r 191                 StdOut.println("found at: " + currentNod)
--[ 2019.11.11.10.28.50.332.0 ]--
r 191                 StdOut.println("found at: " + currentNode)
--[ 2019.11.11.10.28.50.398.0 ]--
r 191                 StdOut.println("found at: " + currentNode.)
--[ 2019.11.11.10.28.50.592.0 ]--
r 191                 StdOut.println("found at: " + currentNode.g)
--[ 2019.11.11.10.28.50.714.0 ]--
r 191                 StdOut.println("found at: " + currentNode.ge)
--[ 2019.11.11.10.28.50.816.0 ]--
r 191                 StdOut.println("found at: " + currentNode.get)
--[ 2019.11.11.10.28.51.066.0 ]--
r 191                 StdOut.println("found at: " + currentNode.getL)
--[ 2019.11.11.10.28.53.244.0 ]--
r 191                 StdOut.println("found at: " + currentNode.getLoc())
--[ 2019.11.11.10.28.54.337.0 ]--
r 191                 StdOut.println("found at: " + currentNode.getLoc());
--[ 2019.11.11.10.29.03.649.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.10.29.40.211.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.11.10.29.42.214.0 ]--
r 48     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2019.11.11.10.29.43.711.0 ]--
r 48     private final static String emapFilename = emaps[10];        // change index to load a different elevation map
--[ 2019.11.11.10.29.50.392.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.10.30.50.573.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.10.33.14.946.0 ]--
:/src/Pathfinder.java
r 60                     this.cost = b.g(h) + nextCost + heuristic*terrain.computeDistance(loc, end);
--[ 2019.11.11.10.33.15.016.0 ]--
r 60                     this.cost = b.ge(h) + nextCost + heuristic*terrain.computeDistance(loc, end);
--[ 2019.11.11.10.33.15.164.0 ]--
r 60                     this.cost = b.get(h) + nextCost + heuristic*terrain.computeDistance(loc, end);
--[ 2019.11.11.10.33.15.546.0 ]--
r 60                     this.cost = b.getF(h) + nextCost + heuristic*terrain.computeDistance(loc, end);
--[ 2019.11.11.10.33.15.780.0 ]--
r 60                     this.cost = b.getFl(h) + nextCost + heuristic*terrain.computeDistance(loc, end);
--[ 2019.11.11.10.33.15.928.0 ]--
r 60                     this.cost = b.getFla(h) + nextCost + heuristic*terrain.computeDistance(loc, end);
--[ 2019.11.11.10.33.16.031.0 ]--
r 60                     this.cost = b.getFlat(h) + nextCost + heuristic*terrain.computeDistance(loc, end);
--[ 2019.11.11.10.33.17.270.0 ]--
r 60                     this.cost = b.getFlatCost(h) + nextCost + heuristic*terrain.computeDistance(loc, end);
--[ 2019.11.11.10.33.18.769.0 ]--
r 60                     this.cost = b.getFlatCost() + nextCost + heuristic*terrain.computeDistance(loc, end);
--[ 2019.11.11.10.33.32.260.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.10.34.31.410.0 ]--
r 178 
--[ 2019.11.11.10.34.31.798.0 ]--
- 178
--[ 2019.11.11.10.34.37.543.0 ]--
r 182                         
--[ 2019.11.11.10.34.38.099.0 ]--
- 182
--[ 2019.11.11.10.34.41.266.0 ]--
r 169             
--[ 2019.11.11.10.34.41.621.0 ]--
- 169
--[ 2019.11.11.10.34.54.653.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.10.35.11.201.0 ]--
r 188 
--[ 2019.11.11.10.35.11.594.0 ]--
- 188
--[ 2019.11.11.10.39.08.236.0 ]--
r 90 
--[ 2019.11.11.10.39.09.984.0 ]--
- 90
--[ 2019.11.11.10.39.14.162.0 ]--
r 12 
--[ 2019.11.11.10.39.14.313.0 ]--
- 12
--[ 2019.11.11.10.39.28.313.0 ]--
+ 214         
--[ 2019.11.11.10.39.29.493.0 ]--
r 214         /*
--[ 2019.11.11.10.39.31.019.0 ]--
+ 222         
+ 223          */
--[ 2019.11.11.10.39.33.673.0 ]--
+ 224          
--[ 2019.11.11.10.39.33.754.0 ]--
r 224         
--[ 2019.11.11.10.41.14.086.0 ]--
r 222 
--[ 2019.11.11.10.42.27.046.0 ]--
+ 21     
--[ 2019.11.11.10.42.28.345.0 ]--
r 21     private 
--[ 2019.11.11.10.42.28.623.0 ]--
r 21     private S
--[ 2019.11.11.10.42.28.826.0 ]--
r 21     private St
--[ 2019.11.11.10.42.28.935.0 ]--
r 21     private Sta
--[ 2019.11.11.10.42.29.269.0 ]--
r 21     private Stack
--[ 2019.11.11.10.42.29.488.0 ]--
r 21     private Stack<>
--[ 2019.11.11.10.42.29.889.0 ]--
r 21     private Stack<C>
--[ 2019.11.11.10.42.30.078.0 ]--
r 21     private Stack<Co>
--[ 2019.11.11.10.42.30.216.0 ]--
r 21     private Stack<Coo>
--[ 2019.11.11.10.42.30.312.0 ]--
r 21     private Stack<Coor>
--[ 2019.11.11.10.42.30.552.0 ]--
r 21     private Stack<Coord>
--[ 2019.11.11.10.42.30.810.0 ]--
r 21     private Stack<Coord> 
--[ 2019.11.11.10.42.32.869.0 ]--
r 21     private Stack<Coord> s
--[ 2019.11.11.10.42.33.001.0 ]--
r 21     private Stack<Coord> so
--[ 2019.11.11.10.42.33.146.0 ]--
r 21     private Stack<Coord> sol
--[ 2019.11.11.10.42.33.585.0 ]--
r 21     private Stack<Coord> so
--[ 2019.11.11.10.42.33.770.0 ]--
r 21     private Stack<Coord> s
--[ 2019.11.11.10.42.33.948.0 ]--
r 21     private Stack<Coord> 
--[ 2019.11.11.10.42.34.633.0 ]--
r 21     private Stack<Coord> p
--[ 2019.11.11.10.42.34.774.0 ]--
r 21     private Stack<Coord> pa
--[ 2019.11.11.10.42.34.881.0 ]--
r 21     private Stack<Coord> pat
--[ 2019.11.11.10.42.34.954.0 ]--
r 21     private Stack<Coord> path
--[ 2019.11.11.10.42.35.173.0 ]--
r 21     private Stack<Coord> path;
--[ 2019.11.11.10.42.43.731.0 ]--
+ 188                 
--[ 2019.11.11.10.42.47.083.0 ]--
r 188                 P
--[ 2019.11.11.10.42.47.262.0 ]--
r 188                 PF
--[ 2019.11.11.10.42.47.349.0 ]--
r 188                 PFN
--[ 2019.11.11.10.42.47.689.0 ]--
r 188                 PFNo
--[ 2019.11.11.10.42.47.831.0 ]--
r 188                 PFNod
--[ 2019.11.11.10.42.47.979.0 ]--
r 188                 PFNode
--[ 2019.11.11.10.42.48.084.0 ]--
r 188                 PFNode 
--[ 2019.11.11.10.42.48.216.0 ]--
r 188                 PFNode c
--[ 2019.11.11.10.42.48.331.0 ]--
r 188                 PFNode c 
--[ 2019.11.11.10.42.48.467.0 ]--
r 188                 PFNode c =
--[ 2019.11.11.10.42.48.559.0 ]--
r 188                 PFNode c = 
--[ 2019.11.11.10.42.48.734.0 ]--
r 188                 PFNode c = e
--[ 2019.11.11.10.42.48.838.0 ]--
r 188                 PFNode c = en
--[ 2019.11.11.10.42.48.921.0 ]--
r 188                 PFNode c = end
--[ 2019.11.11.10.42.49.100.0 ]--
r 188                 PFNode c = endn
--[ 2019.11.11.10.42.49.502.0 ]--
r 188                 PFNode c = end
--[ 2019.11.11.10.42.49.770.0 ]--
r 188                 PFNode c = endN
--[ 2019.11.11.10.42.49.937.0 ]--
r 188                 PFNode c = endNo
--[ 2019.11.11.10.42.50.035.0 ]--
r 188                 PFNode c = endNod
--[ 2019.11.11.10.42.50.192.0 ]--
r 188                 PFNode c = endNode
--[ 2019.11.11.10.42.50.277.0 ]--
r 188                 PFNode c = endNode;
--[ 2019.11.11.10.42.50.436.0 ]--
+ 189                 
--[ 2019.11.11.10.42.57.291.0 ]--
r 189                 S
--[ 2019.11.11.10.42.58.623.0 ]--
r 189                 Sta
--[ 2019.11.11.10.43.00.849.0 ]--
r 189                 Stac
--[ 2019.11.11.10.43.01.007.0 ]--
r 189                 Stack
--[ 2019.11.11.10.43.01.719.0 ]--
r 189                 Stack<>
--[ 2019.11.11.10.43.03.007.0 ]--
r 189                 Stack<C>
--[ 2019.11.11.10.43.03.349.0 ]--
r 189                 Stack<Co>
--[ 2019.11.11.10.43.03.499.0 ]--
r 189                 Stack<Coo>
--[ 2019.11.11.10.43.03.610.0 ]--
r 189                 Stack<Coor>
--[ 2019.11.11.10.43.03.877.0 ]--
r 189                 Stack<Coord>
--[ 2019.11.11.10.43.04.277.0 ]--
r 189                 Stack<Coord
--[ 2019.11.11.10.43.04.763.0 ]--
r 189                 Stack<Coor
--[ 2019.11.11.10.43.04.831.0 ]--
r 189                 Stack<Coo
--[ 2019.11.11.10.43.04.885.0 ]--
r 189                 Stack<C
--[ 2019.11.11.10.43.04.937.0 ]--
r 189                 Stack<
--[ 2019.11.11.10.43.05.008.0 ]--
r 189                 Stack
--[ 2019.11.11.10.43.05.068.0 ]--
r 189                 St
--[ 2019.11.11.10.43.05.171.0 ]--
r 189                 S
--[ 2019.11.11.10.43.05.393.0 ]--
r 189                 
--[ 2019.11.11.10.43.05.765.0 ]--
r 189                 s
--[ 2019.11.11.10.43.05.864.0 ]--
r 189                 so
--[ 2019.11.11.10.43.06.095.0 ]--
r 189                 sol
--[ 2019.11.11.10.43.07.072.0 ]--
r 189                 so
--[ 2019.11.11.10.43.07.261.0 ]--
r 189                 s
--[ 2019.11.11.10.43.07.409.0 ]--
r 189                 
--[ 2019.11.11.10.43.09.085.0 ]--
r 189                 path
--[ 2019.11.11.10.43.10.741.0 ]--
r 189                 path 
--[ 2019.11.11.10.43.10.984.0 ]--
r 189                 path = 
--[ 2019.11.11.10.43.11.132.0 ]--
r 189                 path = n
--[ 2019.11.11.10.43.11.236.0 ]--
r 189                 path = ne
--[ 2019.11.11.10.43.11.410.0 ]--
r 189                 path = new
--[ 2019.11.11.10.43.11.561.0 ]--
r 189                 path = new 
--[ 2019.11.11.10.43.11.847.0 ]--
r 189                 path = new S
--[ 2019.11.11.10.43.12.047.0 ]--
r 189                 path = new St
--[ 2019.11.11.10.43.12.115.0 ]--
r 189                 path = new Sta
--[ 2019.11.11.10.43.12.320.0 ]--
r 189                 path = new Stac
--[ 2019.11.11.10.43.12.427.0 ]--
r 189                 path = new Stack
--[ 2019.11.11.10.43.13.603.0 ]--
r 189                 path = new Stack<>
--[ 2019.11.11.10.43.15.048.0 ]--
r 189                 path = new Stack<>()
--[ 2019.11.11.10.43.15.395.0 ]--
r 189                 path = new Stack<>();
--[ 2019.11.11.10.43.15.697.0 ]--
+ 190                 
--[ 2019.11.11.10.43.16.643.0 ]--
r 190                 w
--[ 2019.11.11.10.43.16.733.0 ]--
r 190                 wh
--[ 2019.11.11.10.43.16.783.0 ]--
r 190                 whi
--[ 2019.11.11.10.43.16.998.0 ]--
r 190                 whil
--[ 2019.11.11.10.43.17.139.0 ]--
r 190                 while
--[ 2019.11.11.10.43.17.220.0 ]--
r 190                 while 
--[ 2019.11.11.10.43.17.430.0 ]--
r 190                 while ()
--[ 2019.11.11.10.43.17.633.0 ]--
r 190                 while (c)
--[ 2019.11.11.10.43.17.983.0 ]--
r 190                 while (c )
--[ 2019.11.11.10.43.18.735.0 ]--
r 190                 while (c != )
--[ 2019.11.11.10.43.19.117.0 ]--
r 190                 while (c != nu)
--[ 2019.11.11.10.43.19.217.0 ]--
r 190                 while (c != nul)
--[ 2019.11.11.10.43.19.385.0 ]--
r 190                 while (c != null)
--[ 2019.11.11.10.43.19.825.0 ]--
r 190                 while (c != null) 
--[ 2019.11.11.10.43.20.003.0 ]--
r 190                 while (c != null) {
--[ 2019.11.11.10.43.20.226.0 ]--
+ 191 
+ 192 }
--[ 2019.11.11.10.43.20.394.0 ]--
r 192                 }
--[ 2019.11.11.10.43.20.454.0 ]--
r 191                     
--[ 2019.11.11.10.43.22.874.0 ]--
r 191                     p
--[ 2019.11.11.10.43.23.003.0 ]--
r 191                     pa
--[ 2019.11.11.10.43.23.105.0 ]--
r 191                     pat
--[ 2019.11.11.10.43.23.184.0 ]--
r 191                     path
--[ 2019.11.11.10.43.23.424.0 ]--
r 191                     path.
--[ 2019.11.11.10.43.23.680.0 ]--
r 191                     path.p
--[ 2019.11.11.10.43.23.799.0 ]--
r 191                     path.pu
--[ 2019.11.11.10.43.23.953.0 ]--
r 191                     path.pus
--[ 2019.11.11.10.43.24.050.0 ]--
r 191                     path.push
--[ 2019.11.11.10.43.26.239.0 ]--
r 191                     path.push()
--[ 2019.11.11.10.43.27.551.0 ]--
r 191                     path.push(c)
--[ 2019.11.11.10.43.28.110.0 ]--
r 191                     path.push(c);
--[ 2019.11.11.10.43.29.507.0 ]--
+ 192                     
--[ 2019.11.11.10.43.30.075.0 ]--
r 192                     c
--[ 2019.11.11.10.43.30.360.0 ]--
r 192                     c 
--[ 2019.11.11.10.43.30.527.0 ]--
r 192                     c =
--[ 2019.11.11.10.43.30.661.0 ]--
r 192                     c = 
--[ 2019.11.11.10.43.31.084.0 ]--
r 192                     c = c
--[ 2019.11.11.10.43.31.218.0 ]--
r 192                     c = c.
--[ 2019.11.11.10.43.31.799.0 ]--
r 192                     c = c.f
--[ 2019.11.11.10.43.32.028.0 ]--
r 192                     c = c.fr
--[ 2019.11.11.10.43.32.161.0 ]--
r 192                     c = c.fro
--[ 2019.11.11.10.43.32.229.0 ]--
r 192                     c = c.from
--[ 2019.11.11.10.43.32.499.0 ]--
r 192                     c = c.fromN
--[ 2019.11.11.10.43.32.667.0 ]--
r 192                     c = c.fromNo
--[ 2019.11.11.10.43.32.751.0 ]--
r 192                     c = c.fromNod
--[ 2019.11.11.10.43.32.961.0 ]--
r 192                     c = c.fromNode
--[ 2019.11.11.10.43.33.071.0 ]--
r 192                     c = c.fromNode;
--[ 2019.11.11.10.43.37.237.0 ]--
r 191                     path.push(c.);
--[ 2019.11.11.10.43.37.355.0 ]--
r 191                     path.push(c.g);
--[ 2019.11.11.10.43.37.455.0 ]--
r 191                     path.push(c.gj);
--[ 2019.11.11.10.43.37.514.0 ]--
r 191                     path.push(c.gje);
--[ 2019.11.11.10.43.37.616.0 ]--
r 191                     path.push(c.gjet);
--[ 2019.11.11.10.43.38.147.0 ]--
r 191                     path.push(c.gje);
--[ 2019.11.11.10.43.38.666.0 ]--
r 191                     path.push(c.gj);
--[ 2019.11.11.10.43.39.264.0 ]--
r 191                     path.push(c.g);
--[ 2019.11.11.10.43.39.518.0 ]--
r 191                     path.push(c.ge);
--[ 2019.11.11.10.43.39.605.0 ]--
r 191                     path.push(c.get);
--[ 2019.11.11.10.43.39.981.0 ]--
r 191                     path.push(c.getL);
--[ 2019.11.11.10.43.40.187.0 ]--
r 191                     path.push(c.getLo);
--[ 2019.11.11.10.43.40.309.0 ]--
r 191                     path.push(c.getLoc);
--[ 2019.11.11.10.43.40.562.0 ]--
r 191                     path.push(c.getLoc());
--[ 2019.11.11.10.43.45.724.0 ]--
r 231         r
--[ 2019.11.11.10.43.45.850.0 ]--
r 231         re
--[ 2019.11.11.10.43.45.987.0 ]--
r 231         ret
--[ 2019.11.11.10.43.46.112.0 ]--
r 231         retu
--[ 2019.11.11.10.43.46.218.0 ]--
r 231         retur
--[ 2019.11.11.10.43.46.310.0 ]--
r 231         return
--[ 2019.11.11.10.43.46.478.0 ]--
r 231         return 
--[ 2019.11.11.10.43.46.760.0 ]--
r 231         return p
--[ 2019.11.11.10.43.46.841.0 ]--
r 231         return pa
--[ 2019.11.11.10.43.46.930.0 ]--
r 231         return pat
--[ 2019.11.11.10.43.47.031.0 ]--
r 231         return path
--[ 2019.11.11.10.43.47.577.0 ]--
r 231         return path;
--[ 2019.11.11.10.43.55.028.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.10.44.44.665.0 ]--
- 221
- 221
- 221
- 221
- 221
- 221
- 221
- 221
- 222
--[ 2019.11.11.10.44.45.972.0 ]--
- 221
--[ 2019.11.11.10.45.06.605.0 ]--
- 163
- 163
- 163
- 163
r 163 
--[ 2019.11.11.10.45.08.290.0 ]--
- 163
--[ 2019.11.11.10.47.46.726.0 ]--
DisposeComponent
--[ 2019.11.11.12.00.12.316.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.11.11.12.00.12.502.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2019.11.11.12.00.12.520.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.11.12.00.12.537.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.11.11.12.00.12.556.0 ]--
InitFile: /.cos265


--[ 2019.11.11.12.00.12.572.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.11.11.12.00.12.592.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.11.11.12.00.12.620.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[10];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();
        int M = 0;

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.11.11.12.00.13.005.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.11.11.12.00.13.020.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float progress;
    int calls;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.progress = 0.0f;
        this.calls = 0;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        calls++;
        float end = totalCost + byTime;
        if (calls == 100) {
            while (!path.isEmpty()) {
                loc = path.dequeue();
            }
            nextLoc = null;
        } else {
            while (totalCost < end) {
                float cost = terrain.computeTravelCost(loc, nextLoc);
                if (totalCost + (cost - progress) > end) {
                    float prev = end - totalCost;
                    totalCost += prev;
                    progress += prev;
                    break;
                } else {
                    totalCost += (cost - progress);
                    progress = 0.0f;
                    loc = path.dequeue();
                    if (!path.isEmpty()) nextLoc = path.peek();
                    else {
                        nextLoc = null;
                        break;
                    }
                }
            }
        }
    }

}

--[ 2019.11.11.12.00.13.038.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> path;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;
        private float flatcost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        public Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) { this.cost = 0.0f; this.flatcost = 0.0f; }
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.getFlatCost() + nextCost + heuristic*terrain.computeDistance(loc, end);
                    this.flatcost = b.getFlatCost() + nextCost;
                }
            }
        }

        public float getCost(float heuristic) {
            return cost;
        }

        public float getFlatCost() { return flatcost; }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        boolean found = false;
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (c.getLoc().equals(getPathEnd())) {
                        currentNode = c;
                        found = true;
                        break;
                    }
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            if (found) {
                pathFound = true;
                endNode = currentNode;
                PFNode c = endNode;
                path = new Stack<>();
                while (c != null) {
                    path.push(c.getLoc());
                    c = c.fromNode;
                }
                break;
            }
            atStart = false;
        }
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getFlatCost();
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2019.11.11.13.12.04.104.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.13.13.27.568.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.11.13.13.31.004.0 ]--
r 48     private final static String emapFilename = emaps[0];        // change index to load a different elevation map
--[ 2019.11.11.13.13.40.821.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.13.15.20.312.0 ]--
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.11.13.15.20.443.0 ]--
r 48     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2019.11.11.13.15.27.502.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.13.28.30.141.0 ]--
UpdateTree (AD): 0 1
- /src/algs4.jar

--[ 2019.11.11.13.28.30.235.0 ]--
UpdateTree (AD): 1 0
+ /src/algs4.jar

--[ 2019.11.11.13.30.24.792.0 ]--
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.11.13.30.26.153.0 ]--
r 48     private final static String emapFilename = emaps[9];        // change index to load a different elevation map
--[ 2019.11.11.13.30.34.278.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.13.33.50.672.0 ]--
r 56 
--[ 2019.11.11.13.33.51.890.0 ]--
- 56
--[ 2019.11.11.13.34.07.164.0 ]--
:/src/Pathfinder.java
+ 130         
--[ 2019.11.11.13.34.09.163.0 ]--
r 130         path = new 
--[ 2019.11.11.13.34.09.831.0 ]--
r 130         path = new S
--[ 2019.11.11.13.34.10.149.0 ]--
r 130         path = new St
--[ 2019.11.11.13.34.10.220.0 ]--
r 130         path = new Sta
--[ 2019.11.11.13.34.10.433.0 ]--
r 130         path = new Stac
--[ 2019.11.11.13.34.10.545.0 ]--
r 130         path = new Stack
--[ 2019.11.11.13.34.11.109.0 ]--
r 130         path = new StackM
--[ 2019.11.11.13.34.12.027.0 ]--
r 130         path = new Stack
--[ 2019.11.11.13.34.12.619.0 ]--
r 130         path = new Stack<>
--[ 2019.11.11.13.34.13.049.0 ]--
r 130         path = new Stack<>()
--[ 2019.11.11.13.34.13.392.0 ]--
r 130         path = new Stack<>():
--[ 2019.11.11.13.34.14.229.0 ]--
r 130         path = new Stack<>()
--[ 2019.11.11.13.34.14.332.0 ]--
r 130         path = new Stack<>();
--[ 2019.11.11.13.34.23.680.0 ]--
r 130         path = new Stack<>()
--[ 2019.11.11.13.34.27.431.0 ]--
r 130         path = new St
--[ 2019.11.11.13.34.28.263.0 ]--
r 130         path = new S
--[ 2019.11.11.13.34.28.748.0 ]--
r 130         path = new 
--[ 2019.11.11.13.34.29.109.0 ]--
r 130         path = new
--[ 2019.11.11.13.34.29.257.0 ]--
r 130         path = ne
--[ 2019.11.11.13.34.29.325.0 ]--
r 130         path = n
--[ 2019.11.11.13.34.29.896.0 ]--
r 130         path = nu
--[ 2019.11.11.13.34.30.114.0 ]--
r 130         path = nul
--[ 2019.11.11.13.34.30.366.0 ]--
r 130         path = null
--[ 2019.11.11.13.34.30.746.0 ]--
r 130         path = null;
--[ 2019.11.11.13.34.50.435.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.11.13.34.51.521.0 ]--
r 48     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2019.11.11.13.34.51.640.0 ]--
r 48     private final static String emapFilename = emaps[10];        // change index to load a different elevation map
--[ 2019.11.11.13.35.00.211.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.13.37.25.501.0 ]--
r 48     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2019.11.11.13.37.25.789.0 ]--
r 48     private final static String emapFilename = emaps[11];        // change index to load a different elevation map
--[ 2019.11.11.13.37.32.437.0 ]--
UpdateTree (AD): 0 1
- /out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class

--[ 2019.11.11.13.37.32.563.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
+ /out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class

--[ 2019.11.11.13.37.32.629.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
+ /out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class

--[ 2019.11.11.13.37.32.691.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
+ /out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class

--[ 2019.11.11.13.37.32.948.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
+ /out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class

--[ 2019.11.11.13.37.33.010.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
+ /out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class

--[ 2019.11.11.13.37.33.376.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
+ /out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class

--[ 2019.11.11.13.37.33.432.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
+ /out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class

--[ 2019.11.11.13.37.33.571.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
+ /out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class

--[ 2019.11.11.13.37.33.627.0 ]--
UpdateTree (AD): 1 1
- /out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
+ /out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class

--[ 2019.11.11.13.37.34.687.0 ]--
UpdateTree (AD): 1 0
+ /out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class

--[ 2019.11.11.13.37.34.758.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.13.46.31.020.0 ]--
DisposeComponent
--[ 2019.11.11.15.52.03.472.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.11.11.15.52.03.753.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2019.11.11.15.52.03.769.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.11.15.52.03.785.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.11.11.15.52.03.800.0 ]--
InitFile: /.cos265


--[ 2019.11.11.15.52.03.816.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.11.11.15.52.03.831.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.11.11.15.52.03.863.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[11];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.11.11.15.52.04.217.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.11.11.15.52.04.233.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float progress;
    int calls;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.progress = 0.0f;
        this.calls = 0;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        calls++;
        float end = totalCost + byTime;
        if (calls == 100) {
            while (!path.isEmpty()) {
                loc = path.dequeue();
            }
            nextLoc = null;
        } else {
            while (totalCost < end) {
                float cost = terrain.computeTravelCost(loc, nextLoc);
                if (totalCost + (cost - progress) > end) {
                    float prev = end - totalCost;
                    totalCost += prev;
                    progress += prev;
                    break;
                } else {
                    totalCost += (cost - progress);
                    progress = 0.0f;
                    loc = path.dequeue();
                    if (!path.isEmpty()) nextLoc = path.peek();
                    else {
                        nextLoc = null;
                        break;
                    }
                }
            }
        }
    }

}

--[ 2019.11.11.15.52.04.248.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> path;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;
        private float flatcost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        public Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) { this.cost = 0.0f; this.flatcost = 0.0f; }
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.getFlatCost() + nextCost + heuristic*terrain.computeDistance(loc, end);
                    this.flatcost = b.getFlatCost() + nextCost;
                }
            }
        }

        public float getCost(float heuristic) {
            return cost;
        }

        public float getFlatCost() { return flatcost; }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
        path = null;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        boolean found = false;
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (c.getLoc().equals(getPathEnd())) {
                        currentNode = c;
                        found = true;
                        break;
                    }
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            if (found) {
                pathFound = true;
                endNode = currentNode;
                PFNode c = endNode;
                path = new Stack<>();
                while (c != null) {
                    path.push(c.getLoc());
                    c = c.fromNode;
                }
                break;
            }
            atStart = false;
        }
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getFlatCost();
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2019.11.11.15.54.00.041.0 ]--
:/src/Walker.java
r 47         //if (calls == 100) {
--[ 2019.11.11.15.54.03.018.0 ]--
r 47         /if (calls == 100) {
--[ 2019.11.11.15.54.04.364.0 ]--
r 47         /*if (calls == 100) {
--[ 2019.11.11.15.54.06.554.0 ]--
r 52         }* else {
--[ 2019.11.11.15.54.06.974.0 ]--
r 52         }*/ else {
--[ 2019.11.11.15.54.09.415.0 ]--
r 52         }* else {
--[ 2019.11.11.15.54.09.553.0 ]--
r 52         } else {
--[ 2019.11.11.15.54.11.854.0 ]--
r 52         } else {*
--[ 2019.11.11.15.54.12.219.0 ]--
r 52         } else {*/
--[ 2019.11.11.15.54.20.374.0 ]--
r 70             /}
--[ 2019.11.11.15.54.21.094.0 ]--
r 70             //}
--[ 2019.11.11.15.54.28.450.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.15.54.36.196.0 ]--
+ 54                 
--[ 2019.11.11.15.54.36.566.0 ]--
r 54                 S
--[ 2019.11.11.15.54.36.959.0 ]--
r 54                 
--[ 2019.11.11.15.54.37.269.0 ]--
- 54
--[ 2019.11.11.15.54.39.084.0 ]--
+ 47         
--[ 2019.11.11.15.54.39.438.0 ]--
r 47         S
--[ 2019.11.11.15.54.39.651.0 ]--
r 47         St
--[ 2019.11.11.15.54.39.839.0 ]--
r 47         Std
--[ 2019.11.11.15.54.40.190.0 ]--
r 47         StdO
--[ 2019.11.11.15.54.40.365.0 ]--
r 47         StdOu
--[ 2019.11.11.15.54.40.469.0 ]--
r 47         StdOut
--[ 2019.11.11.15.54.40.685.0 ]--
r 47         StdOut.
--[ 2019.11.11.15.54.41.033.0 ]--
r 47         StdOut.pr
--[ 2019.11.11.15.54.41.094.0 ]--
r 47         StdOut.pri
--[ 2019.11.11.15.54.41.215.0 ]--
r 47         StdOut.prin
--[ 2019.11.11.15.54.41.313.0 ]--
r 47         StdOut.print
--[ 2019.11.11.15.54.41.395.0 ]--
r 47         StdOut.printl
--[ 2019.11.11.15.54.41.439.0 ]--
r 47         StdOut.println
--[ 2019.11.11.15.54.41.694.0 ]--
r 47         StdOut.println()
--[ 2019.11.11.15.54.41.887.0 ]--
r 47         StdOut.println("")
--[ 2019.11.11.15.54.42.232.0 ]--
r 47         StdOut.println("c")
--[ 2019.11.11.15.54.42.312.0 ]--
r 47         StdOut.println("ca")
--[ 2019.11.11.15.54.42.402.0 ]--
r 47         StdOut.println("cal")
--[ 2019.11.11.15.54.42.590.0 ]--
r 47         StdOut.println("call")
--[ 2019.11.11.15.54.42.640.0 ]--
r 47         StdOut.println("calls")
--[ 2019.11.11.15.54.42.795.0 ]--
r 47         StdOut.println("calls:")
--[ 2019.11.11.15.54.42.969.0 ]--
r 47         StdOut.println("calls: ")
--[ 2019.11.11.15.54.43.344.0 ]--
r 47         StdOut.println("calls: " )
--[ 2019.11.11.15.54.43.522.0 ]--
r 47         StdOut.println("calls: " +)
--[ 2019.11.11.15.54.43.600.0 ]--
r 47         StdOut.println("calls: " + )
--[ 2019.11.11.15.54.43.779.0 ]--
r 47         StdOut.println("calls: " + c)
--[ 2019.11.11.15.54.44.137.0 ]--
r 47         StdOut.println("calls: " + cal)
--[ 2019.11.11.15.54.44.196.0 ]--
r 47         StdOut.println("calls: " + calls)
--[ 2019.11.11.15.54.44.678.0 ]--
r 47         StdOut.println("calls: " + calls);
--[ 2019.11.11.15.55.30.559.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.15.56.55.473.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 48     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2019.11.11.15.56.57.004.0 ]--
r 48     private final static String emapFilename = emaps[10];        // change index to load a different elevation map
--[ 2019.11.11.15.57.02.739.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.16.12.37.779.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.16.15.29.936.0 ]--
:/src/Walker.java
+ 60                     
--[ 2019.11.11.16.15.30.694.0 ]--
r 60                     S
--[ 2019.11.11.16.15.30.743.0 ]--
r 60                     St
--[ 2019.11.11.16.15.30.854.0 ]--
r 60                     Std
--[ 2019.11.11.16.15.31.087.0 ]--
r 60                     StdO
--[ 2019.11.11.16.15.31.265.0 ]--
r 60                     StdOu
--[ 2019.11.11.16.15.31.366.0 ]--
r 60                     StdOut
--[ 2019.11.11.16.15.31.523.0 ]--
r 60                     StdOut.
--[ 2019.11.11.16.15.31.739.0 ]--
r 60                     StdOut.p
--[ 2019.11.11.16.15.31.852.0 ]--
r 60                     StdOut.pr
--[ 2019.11.11.16.15.31.930.0 ]--
r 60                     StdOut.pri
--[ 2019.11.11.16.15.32.114.0 ]--
r 60                     StdOut.prin
--[ 2019.11.11.16.15.32.190.0 ]--
r 60                     StdOut.print
--[ 2019.11.11.16.15.32.318.0 ]--
r 60                     StdOut.printl
--[ 2019.11.11.16.15.32.381.0 ]--
r 60                     StdOut.println
--[ 2019.11.11.16.15.32.491.0 ]--
r 60                     StdOut.println()
--[ 2019.11.11.16.15.33.045.0 ]--
r 60                     StdOut.println("")
--[ 2019.11.11.16.15.34.116.0 ]--
r 60                     StdOut.println("t")
--[ 2019.11.11.16.15.34.272.0 ]--
r 60                     StdOut.println("tr")
--[ 2019.11.11.16.15.34.391.0 ]--
r 60                     StdOut.println("tra")
--[ 2019.11.11.16.15.34.585.0 ]--
r 60                     StdOut.println("trav")
--[ 2019.11.11.16.15.34.775.0 ]--
r 60                     StdOut.println("trave")
--[ 2019.11.11.16.15.34.839.0 ]--
r 60                     StdOut.println("traver")
--[ 2019.11.11.16.15.34.978.0 ]--
r 60                     StdOut.println("travers")
--[ 2019.11.11.16.15.35.107.0 ]--
r 60                     StdOut.println("traverse")
--[ 2019.11.11.16.15.35.233.0 ]--
r 60                     StdOut.println("traversed")
--[ 2019.11.11.16.15.35.473.0 ]--
r 60                     StdOut.println("traversed:")
--[ 2019.11.11.16.15.35.555.0 ]--
r 60                     StdOut.println("traversed: ")
--[ 2019.11.11.16.15.36.100.0 ]--
r 60                     StdOut.println("traversed: " )
--[ 2019.11.11.16.15.36.305.0 ]--
r 60                     StdOut.println("traversed: " +)
--[ 2019.11.11.16.15.36.398.0 ]--
r 60                     StdOut.println("traversed: " + )
--[ 2019.11.11.16.15.36.790.0 ]--
r 60                     StdOut.println("traversed: " + t)
--[ 2019.11.11.16.15.36.931.0 ]--
r 60                     StdOut.println("traversed: " + to)
--[ 2019.11.11.16.15.36.996.0 ]--
r 60                     StdOut.println("traversed: " + tot)
--[ 2019.11.11.16.15.37.112.0 ]--
r 60                     StdOut.println("traversed: " + tota)
--[ 2019.11.11.16.15.37.225.0 ]--
r 60                     StdOut.println("traversed: " + total)
--[ 2019.11.11.16.15.37.443.0 ]--
r 60                     StdOut.println("traversed: " + totalC)
--[ 2019.11.11.16.15.37.571.0 ]--
r 60                     StdOut.println("traversed: " + totalCo)
--[ 2019.11.11.16.15.37.745.0 ]--
r 60                     StdOut.println("traversed: " + totalCos)
--[ 2019.11.11.16.15.37.859.0 ]--
r 60                     StdOut.println("traversed: " + totalCost)
--[ 2019.11.11.16.15.38.532.0 ]--
r 60                     StdOut.println("traversed: " + totalCost);
--[ 2019.11.11.16.15.38.725.0 ]--
+ 61                     
--[ 2019.11.11.16.15.39.470.0 ]--
r 61                     S
--[ 2019.11.11.16.15.39.631.0 ]--
r 61                     St
--[ 2019.11.11.16.15.39.878.0 ]--
r 61                     Std
--[ 2019.11.11.16.15.40.089.0 ]--
r 61                     StdO
--[ 2019.11.11.16.15.40.913.0 ]--
r 61                     StdOut.pr
--[ 2019.11.11.16.15.40.982.0 ]--
r 61                     StdOut.pri
--[ 2019.11.11.16.15.41.074.0 ]--
r 61                     StdOut.prin
--[ 2019.11.11.16.15.41.160.0 ]--
r 61                     StdOut.print
--[ 2019.11.11.16.15.41.215.0 ]--
r 61                     StdOut.printl
--[ 2019.11.11.16.15.41.396.0 ]--
r 61                     StdOut.println
--[ 2019.11.11.16.15.41.511.0 ]--
r 61                     StdOut.println()
--[ 2019.11.11.16.15.41.738.0 ]--
r 61                     StdOut.println("")
--[ 2019.11.11.16.15.45.525.0 ]--
r 61                     StdOut.println("c")
--[ 2019.11.11.16.15.45.605.0 ]--
r 61                     StdOut.println("cu")
--[ 2019.11.11.16.15.45.744.0 ]--
r 61                     StdOut.println("cur")
--[ 2019.11.11.16.15.45.903.0 ]--
r 61                     StdOut.println("curr")
--[ 2019.11.11.16.15.46.000.0 ]--
r 61                     StdOut.println("curre")
--[ 2019.11.11.16.15.46.100.0 ]--
r 61                     StdOut.println("curren")
--[ 2019.11.11.16.15.46.184.0 ]--
r 61                     StdOut.println("current")
--[ 2019.11.11.16.15.46.298.0 ]--
r 61                     StdOut.println("current ")
--[ 2019.11.11.16.15.46.397.0 ]--
r 61                     StdOut.println("current e")
--[ 2019.11.11.16.15.46.476.0 ]--
r 61                     StdOut.println("current en")
--[ 2019.11.11.16.15.46.619.0 ]--
r 61                     StdOut.println("current end")
--[ 2019.11.11.16.15.46.858.0 ]--
r 61                     StdOut.println("current end:")
--[ 2019.11.11.16.15.47.017.0 ]--
r 61                     StdOut.println("current end: ")
--[ 2019.11.11.16.15.47.388.0 ]--
r 61                     StdOut.println("current end: " )
--[ 2019.11.11.16.15.47.530.0 ]--
r 61                     StdOut.println("current end: " +)
--[ 2019.11.11.16.15.47.661.0 ]--
r 61                     StdOut.println("current end: " + )
--[ 2019.11.11.16.15.48.496.0 ]--
r 61                     StdOut.println("current end: " + e)
--[ 2019.11.11.16.15.48.592.0 ]--
r 61                     StdOut.println("current end: " + en)
--[ 2019.11.11.16.15.48.675.0 ]--
r 61                     StdOut.println("current end: " + end)
--[ 2019.11.11.16.15.49.159.0 ]--
r 61                     StdOut.println("current end: " + end);
--[ 2019.11.11.16.15.54.499.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.16.17.09.659.0 ]--
r 61                     StdOut.println("current end: " + (end));
--[ 2019.11.11.16.17.09.811.0 ]--
r 61                     StdOut.println("current end: " + (c));
--[ 2019.11.11.16.17.09.913.0 ]--
r 61                     StdOut.println("current end: " + (co));
--[ 2019.11.11.16.17.10.011.0 ]--
r 61                     StdOut.println("current end: " + (cos));
--[ 2019.11.11.16.17.10.147.0 ]--
r 61                     StdOut.println("current end: " + (cost));
--[ 2019.11.11.16.17.10.297.0 ]--
r 61                     StdOut.println("current end: " + (cost ));
--[ 2019.11.11.16.17.10.405.0 ]--
r 61                     StdOut.println("current end: " + (cost -));
--[ 2019.11.11.16.17.10.484.0 ]--
r 61                     StdOut.println("current end: " + (cost - ));
--[ 2019.11.11.16.17.10.619.0 ]--
r 61                     StdOut.println("current end: " + (cost - p));
--[ 2019.11.11.16.17.10.774.0 ]--
r 61                     StdOut.println("current end: " + (cost - pr));
--[ 2019.11.11.16.17.11.676.0 ]--
r 61                     StdOut.println("current end: " + (cost - progres));
--[ 2019.11.11.16.17.11.729.0 ]--
r 61                     StdOut.println("current end: " + (cost - progress));
--[ 2019.11.11.16.17.19.052.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.16.17.24.122.0 ]--
+ 58                     
--[ 2019.11.11.16.17.24.404.0 ]--
r 58                     S
--[ 2019.11.11.16.17.24.540.0 ]--
r 58                     St
--[ 2019.11.11.16.17.24.787.0 ]--
r 58                     Std
--[ 2019.11.11.16.17.24.971.0 ]--
r 58                     StdO
--[ 2019.11.11.16.17.25.158.0 ]--
r 58                     StdOu
--[ 2019.11.11.16.17.25.773.0 ]--
r 58                     StdOut.pr
--[ 2019.11.11.16.17.25.826.0 ]--
r 58                     StdOut.pri
--[ 2019.11.11.16.17.25.999.0 ]--
r 58                     StdOut.prin
--[ 2019.11.11.16.17.26.067.0 ]--
r 58                     StdOut.print
--[ 2019.11.11.16.17.26.158.0 ]--
r 58                     StdOut.printl
--[ 2019.11.11.16.17.26.287.0 ]--
r 58                     StdOut.println
--[ 2019.11.11.16.17.26.408.0 ]--
r 58                     StdOut.println()
--[ 2019.11.11.16.17.26.618.0 ]--
r 58                     StdOut.println("")
--[ 2019.11.11.16.17.26.805.0 ]--
r 58                     StdOut.println("c")
--[ 2019.11.11.16.17.26.878.0 ]--
r 58                     StdOut.println("cu")
--[ 2019.11.11.16.17.27.110.0 ]--
r 58                     StdOut.println("cut")
--[ 2019.11.11.16.17.27.220.0 ]--
r 58                     StdOut.println("cuto")
--[ 2019.11.11.16.17.27.374.0 ]--
r 58                     StdOut.println("cutof")
--[ 2019.11.11.16.17.27.463.0 ]--
r 58                     StdOut.println("cutoff")
--[ 2019.11.11.16.17.27.780.0 ]--
r 58                     StdOut.println("cutoff:")
--[ 2019.11.11.16.17.28.134.0 ]--
r 58                     StdOut.println("cutoff: ")
--[ 2019.11.11.16.17.28.734.0 ]--
r 58                     StdOut.println("cutoff: " )
--[ 2019.11.11.16.17.28.871.0 ]--
r 58                     StdOut.println("cutoff: " +)
--[ 2019.11.11.16.17.29.004.0 ]--
r 58                     StdOut.println("cutoff: " + )
--[ 2019.11.11.16.17.30.407.0 ]--
r 58                     StdOut.println("cutoff: " + ())
--[ 2019.11.11.16.17.30.611.0 ]--
r 58                     StdOut.println("cutoff: " + (t))
--[ 2019.11.11.16.17.30.733.0 ]--
r 58                     StdOut.println("cutoff: " + (to))
--[ 2019.11.11.16.17.30.833.0 ]--
r 58                     StdOut.println("cutoff: " + (tot))
--[ 2019.11.11.16.17.30.879.0 ]--
r 58                     StdOut.println("cutoff: " + (tota))
--[ 2019.11.11.16.17.30.978.0 ]--
r 58                     StdOut.println("cutoff: " + (total))
--[ 2019.11.11.16.17.31.232.0 ]--
r 58                     StdOut.println("cutoff: " + (totalC))
--[ 2019.11.11.16.17.31.419.0 ]--
r 58                     StdOut.println("cutoff: " + (totalCo))
--[ 2019.11.11.16.17.31.552.0 ]--
r 58                     StdOut.println("cutoff: " + (totalCos))
--[ 2019.11.11.16.17.31.621.0 ]--
r 58                     StdOut.println("cutoff: " + (totalCost))
--[ 2019.11.11.16.17.31.733.0 ]--
r 58                     StdOut.println("cutoff: " + (totalCost ))
--[ 2019.11.11.16.17.32.012.0 ]--
r 58                     StdOut.println("cutoff: " + (totalCost +))
--[ 2019.11.11.16.17.32.937.0 ]--
r 58                     StdOut.println("cutoff: " + (totalCost + ))
--[ 2019.11.11.16.17.33.145.0 ]--
r 58                     StdOut.println("cutoff: " + (totalCost + ()))
--[ 2019.11.11.16.17.33.703.0 ]--
r 58                     StdOut.println("cutoff: " + (totalCost + (c)))
--[ 2019.11.11.16.17.33.967.0 ]--
r 58                     StdOut.println("cutoff: " + (totalCost + (co)))
--[ 2019.11.11.16.17.34.086.0 ]--
r 58                     StdOut.println("cutoff: " + (totalCost + (cos)))
--[ 2019.11.11.16.17.34.191.0 ]--
r 58                     StdOut.println("cutoff: " + (totalCost + (cost)))
--[ 2019.11.11.16.17.34.323.0 ]--
r 58                     StdOut.println("cutoff: " + (totalCost + (cost )))
--[ 2019.11.11.16.17.34.399.0 ]--
r 58                     StdOut.println("cutoff: " + (totalCost + (cost -)))
--[ 2019.11.11.16.17.34.496.0 ]--
r 58                     StdOut.println("cutoff: " + (totalCost + (cost - )))
--[ 2019.11.11.16.17.34.609.0 ]--
r 58                     StdOut.println("cutoff: " + (totalCost + (cost - p)))
--[ 2019.11.11.16.17.34.695.0 ]--
r 58                     StdOut.println("cutoff: " + (totalCost + (cost - pr)))
--[ 2019.11.11.16.17.34.800.0 ]--
r 58                     StdOut.println("cutoff: " + (totalCost + (cost - pro)))
--[ 2019.11.11.16.17.34.946.0 ]--
r 58                     StdOut.println("cutoff: " + (totalCost + (cost - prog)))
--[ 2019.11.11.16.17.35.157.0 ]--
r 58                     StdOut.println("cutoff: " + (totalCost + (cost - progr)))
--[ 2019.11.11.16.17.35.749.0 ]--
r 58                     StdOut.println("cutoff: " + (totalCost + (cost - progress)))
--[ 2019.11.11.16.17.36.256.0 ]--
r 58                     StdOut.println("cutoff: " + (totalCost + (cost - progress))):
--[ 2019.11.11.16.17.36.976.0 ]--
r 58                     StdOut.println("cutoff: " + (totalCost + (cost - progress)))
--[ 2019.11.11.16.17.37.617.0 ]--
r 58                     StdOut.println("cutoff: " + (totalCost + (cost - progress)));
--[ 2019.11.11.16.17.42.988.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.16.36.38.302.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.16.36.46.179.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 48     private final static String emapFilename = emaps[0];        // change index to load a different elevation map
--[ 2019.11.11.16.36.51.520.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.16.37.48.244.0 ]--
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.11.16.37.49.930.0 ]--
r 48     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2019.11.11.16.37.50.375.0 ]--
r 48     private final static String emapFilename = emaps[10];        // change index to load a different elevation map
--[ 2019.11.11.16.37.56.022.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.16.39.17.289.0 ]--
:/src/Pathfinder.java
r 67             return cost ;
--[ 2019.11.11.16.39.18.058.0 ]--
r 67             return cost + ;
--[ 2019.11.11.16.39.18.383.0 ]--
r 67             return cost + h;
--[ 2019.11.11.16.39.18.483.0 ]--
r 67             return cost + he;
--[ 2019.11.11.16.39.18.607.0 ]--
r 67             return cost + heu;
--[ 2019.11.11.16.39.18.717.0 ]--
r 67             return cost + heur;
--[ 2019.11.11.16.39.18.845.0 ]--
r 67             return cost + heuri;
--[ 2019.11.11.16.39.18.915.0 ]--
r 67             return cost + heuris;
--[ 2019.11.11.16.39.19.030.0 ]--
r 67             return cost + heurist;
--[ 2019.11.11.16.39.19.160.0 ]--
r 67             return cost + heuristi;
--[ 2019.11.11.16.39.19.301.0 ]--
r 67             return cost + heuristic;
--[ 2019.11.11.16.39.19.517.0 ]--
r 67             return cost + heuristic*;
--[ 2019.11.11.16.39.19.739.0 ]--
r 67             return cost + heuristic*t;
--[ 2019.11.11.16.39.19.820.0 ]--
r 67             return cost + heuristic*te;
--[ 2019.11.11.16.39.19.994.0 ]--
r 67             return cost + heuristic*ter;
--[ 2019.11.11.16.39.20.148.0 ]--
r 67             return cost + heuristic*terr;
--[ 2019.11.11.16.39.20.517.0 ]--
r 67             return cost + heuristic*terrain.;
--[ 2019.11.11.16.39.20.690.0 ]--
r 67             return cost + heuristic*terrain.c;
--[ 2019.11.11.16.39.20.753.0 ]--
r 67             return cost + heuristic*terrain.co;
--[ 2019.11.11.16.39.20.893.0 ]--
r 67             return cost + heuristic*terrain.com;
--[ 2019.11.11.16.39.21.016.0 ]--
r 67             return cost + heuristic*terrain.comp;
--[ 2019.11.11.16.39.21.168.0 ]--
r 67             return cost + heuristic*terrain.compu;
--[ 2019.11.11.16.39.21.252.0 ]--
r 67             return cost + heuristic*terrain.comput;
--[ 2019.11.11.16.39.21.313.0 ]--
r 67             return cost + heuristic*terrain.compute;
--[ 2019.11.11.16.39.21.575.0 ]--
r 67             return cost + heuristic*terrain.computeD;
--[ 2019.11.11.16.39.21.721.0 ]--
r 67             return cost + heuristic*terrain.computeDi;
--[ 2019.11.11.16.39.21.798.0 ]--
r 67             return cost + heuristic*terrain.computeDis;
--[ 2019.11.11.16.39.21.921.0 ]--
r 67             return cost + heuristic*terrain.computeDist;
--[ 2019.11.11.16.39.22.012.0 ]--
r 67             return cost + heuristic*terrain.computeDista;
--[ 2019.11.11.16.39.22.121.0 ]--
r 67             return cost + heuristic*terrain.computeDistan;
--[ 2019.11.11.16.39.22.227.0 ]--
r 67             return cost + heuristic*terrain.computeDistanc;
--[ 2019.11.11.16.39.22.451.0 ]--
r 67             return cost + heuristic*terrain.computeDistance;
--[ 2019.11.11.16.39.22.782.0 ]--
r 67             return cost + heuristic*terrain.computeDistance();
--[ 2019.11.11.16.39.23.579.0 ]--
r 67             return cost + heuristic*terrain.computeDistance(l);
--[ 2019.11.11.16.39.23.756.0 ]--
r 67             return cost + heuristic*terrain.computeDistance(lo);
--[ 2019.11.11.16.39.23.864.0 ]--
r 67             return cost + heuristic*terrain.computeDistance(loc);
--[ 2019.11.11.16.39.23.958.0 ]--
r 67             return cost + heuristic*terrain.computeDistance(loc,);
--[ 2019.11.11.16.39.24.079.0 ]--
r 67             return cost + heuristic*terrain.computeDistance(loc, );
--[ 2019.11.11.16.39.24.189.0 ]--
r 67             return cost + heuristic*terrain.computeDistance(loc, e);
--[ 2019.11.11.16.39.24.297.0 ]--
r 67             return cost + heuristic*terrain.computeDistance(loc, en);
--[ 2019.11.11.16.39.24.430.0 ]--
r 67             return cost + heuristic*terrain.computeDistance(loc, end);
--[ 2019.11.11.16.39.46.852.0 ]--
r 60                     this.cost = b.c() + nextCost + heuristic*terrain.computeDistance(loc, end);
--[ 2019.11.11.16.39.47.595.0 ]--
r 60                     this.cost = b.cost() + nextCost + heuristic*terrain.computeDistance(loc, end);
--[ 2019.11.11.16.39.48.070.0 ]--
r 60                     this.cost = b.cost) + nextCost + heuristic*terrain.computeDistance(loc, end);
--[ 2019.11.11.16.39.48.205.0 ]--
r 60                     this.cost = b.cost + nextCost + heuristic*terrain.computeDistance(loc, end);
--[ 2019.11.11.16.39.59.099.0 ]--
r 60                     this.cost = b.cost + nextCost;
--[ 2019.11.11.16.41.28.945.0 ]--
r 61 
--[ 2019.11.11.16.41.29.772.0 ]--
- 61
--[ 2019.11.11.16.41.41.829.0 ]--
r 207         if (c != null) return c.g();
--[ 2019.11.11.16.41.42.599.0 ]--
r 207         if (c != null) return c.getCo();
--[ 2019.11.11.16.41.42.667.0 ]--
r 207         if (c != null) return c.getCos();
--[ 2019.11.11.16.41.42.818.0 ]--
r 207         if (c != null) return c.getCost();
--[ 2019.11.11.16.41.43.773.0 ]--
r 207         if (c != null) return c.getCost(0);
--[ 2019.11.11.16.42.05.861.0 ]--
r 69 
--[ 2019.11.11.16.42.06.712.0 ]--
- 68
r 68         
--[ 2019.11.11.16.42.09.021.0 ]--
- 68
--[ 2019.11.11.16.42.22.488.0 ]--
r 31 
--[ 2019.11.11.16.42.23.303.0 ]--
- 31
--[ 2019.11.11.16.42.33.957.0 ]--
UpdateTree (AD): 0 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class

--[ 2019.11.11.16.42.33.974.0 ]--
CompilationStatus (AEW): 0 1 0
[Ljava.lang.String;@2d0683b6
--[ 2019.11.11.16.42.38.488.0 ]--
r 56                 if (b == null) { this.cost = 0.0f; his.flatcost = 0.0f; }
--[ 2019.11.11.16.42.38.868.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.38.951.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.39.010.0 ]--
r 56                 if (b == null) { this.cost = 0.0f; is.flatcost = 0.0f; }
--[ 2019.11.11.16.42.39.035.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.39.072.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.40.858.0 ]--
r 56                 if (b == null) { this.cost = 0.0f; s.flatcost = 0.0f; }
--[ 2019.11.11.16.42.40.899.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.40.944.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.41.065.0 ]--
r 56                 if (b == null) { this.cost = 0.0f; .flatcost = 0.0f; }
--[ 2019.11.11.16.42.41.109.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.41.166.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.41.204.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.41.232.0 ]--
r 56                 if (b == null) { this.cost = 0.0f; flatcost = 0.0f; }
--[ 2019.11.11.16.42.41.255.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.41.283.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.41.384.0 ]--
r 56                 if (b == null) { this.cost = 0.0f; latcost = 0.0f; }
--[ 2019.11.11.16.42.41.400.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.41.437.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.41.579.0 ]--
r 56                 if (b == null) { this.cost = 0.0f; atcost = 0.0f; }
--[ 2019.11.11.16.42.41.607.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.41.658.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.41.728.0 ]--
r 56                 if (b == null) { this.cost = 0.0f; tcost = 0.0f; }
--[ 2019.11.11.16.42.41.754.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.41.787.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.41.923.0 ]--
r 56                 if (b == null) { this.cost = 0.0f; cost = 0.0f; }
--[ 2019.11.11.16.42.41.953.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.41.983.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.42.084.0 ]--
r 56                 if (b == null) { this.cost = 0.0f; ost = 0.0f; }
--[ 2019.11.11.16.42.42.113.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.42.138.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.42.251.0 ]--
r 56                 if (b == null) { this.cost = 0.0f; st = 0.0f; }
--[ 2019.11.11.16.42.42.284.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.42.306.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.42.418.0 ]--
r 56                 if (b == null) { this.cost = 0.0f; t = 0.0f; }
--[ 2019.11.11.16.42.42.455.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.42.487.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.42.599.0 ]--
r 56                 if (b == null) { this.cost = 0.0f;  = 0.0f; }
--[ 2019.11.11.16.42.42.631.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.42.653.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.42.683.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.42.718.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.42.736.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.42.777.0 ]--
r 56                 if (b == null) { this.cost = 0.0f; = 0.0f; }
--[ 2019.11.11.16.42.42.818.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.42.865.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.42.930.0 ]--
r 56                 if (b == null) { this.cost = 0.0f;  0.0f; }
--[ 2019.11.11.16.42.42.952.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.42.981.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.43.012.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.43.037.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.43.097.0 ]--
r 56                 if (b == null) { this.cost = 0.0f; 0.0f; }
--[ 2019.11.11.16.42.43.122.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.43.154.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.43.433.0 ]--
r 56                 if (b == null) { this.cost = 0.0f; .0f; }
--[ 2019.11.11.16.42.43.457.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.43.481.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.43.684.0 ]--
r 56                 if (b == null) { this.cost = 0.0f; 0f; }
--[ 2019.11.11.16.42.43.718.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.43.751.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.43.893.0 ]--
r 56                 if (b == null) { this.cost = 0.0f; f; }
--[ 2019.11.11.16.42.44.107.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.44.145.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.44.227.0 ]--
r 56                 if (b == null) { this.cost = 0.0f; ; }
--[ 2019.11.11.16.42.44.259.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.44.286.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.44.330.0 ]--
r 56                 if (b == null) { this.cost = 0.0f;  }
--[ 2019.11.11.16.42.44.346.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.44.375.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.44.419.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.44.442.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.44.716.0 ]--
r 56                 if (b == null) { this.cost = 0.0f; }
--[ 2019.11.11.16.42.44.747.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.44.793.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.45.196.0 ]--
r 56                 if (b == null) { this.cost = 0.0f; 
--[ 2019.11.11.16.42.45.222.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.45.265.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.45.752.0 ]--
r 56                 if (b == null) { this.cost = 0.0f;
--[ 2019.11.11.16.42.45.820.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.45.856.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.48.310.0 ]--
r 56                 if (b == null)  this.cost = 0.0f;
--[ 2019.11.11.16.42.48.335.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.48.357.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.48.700.0 ]--
r 56                 if (b == null) this.cost = 0.0f;
--[ 2019.11.11.16.42.49.058.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.42.49.339.0 ]--
UpdateTree (AD): 2 2
- /out/production/P04_Pathfinding/Pathfinder$PFNode.class
- /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.43.03.350.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 48     private final static String emapFilename = emaps[0];        // change index to load a different elevation map
--[ 2019.11.11.16.43.10.724.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.16.43.43.166.0 ]--
:/src/Walker.java
- 47
- 47
- 47
- 47
- 47
- 47
r 47 
--[ 2019.11.11.16.43.43.905.0 ]--
UpdateTree (AD): 2 0
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class

--[ 2019.11.11.16.43.44.010.0 ]--
- 47
--[ 2019.11.11.16.43.51.110.0 ]--
r 47         while (totalCost < end) {
r 48             float cost = terrain.computeTravelCost(loc, nextLoc);
r 49             if (totalCost + (cost - progress) > end) {
r 50                 float prev = end - totalCost;
r 51                 StdOut.println("cutoff: " + (totalCost + (cost - progress)));
r 52                 totalCost += prev;
r 53                 progress += prev;
r 54                 StdOut.println("traversed: " + totalCost);
r 55                 StdOut.println("current end: " + (cost - progress));
r 56                 break;
r 57             } else {
r 58                 totalCost += (cost - progress);
r 59                 progress = 0.0f;
r 60                 loc = path.dequeue();
r 61                 if (!path.isEmpty()) nextLoc = path.peek();
r 62                 else {
r 63                     nextLoc = null;
r 64                     break;
r 65                 }
r 66             }
r 67         //}
--[ 2019.11.11.16.43.54.861.0 ]--
r 67         //
--[ 2019.11.11.16.43.55.647.0 ]--
r 67         
--[ 2019.11.11.16.43.56.119.0 ]--
- 67
--[ 2019.11.11.16.44.01.449.0 ]--
- 54
r 54 
--[ 2019.11.11.16.44.01.826.0 ]--
- 54
--[ 2019.11.11.16.44.06.085.0 ]--
r 51 
--[ 2019.11.11.16.44.07.147.0 ]--
- 51
--[ 2019.11.11.16.46.31.555.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.16.49.01.232.0 ]--
DisposeComponent
--[ 2019.11.11.16.49.26.285.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.11.11.16.49.26.615.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2019.11.11.16.49.26.631.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.11.16.49.26.647.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.11.11.16.49.26.663.0 ]--
InitFile: /.cos265


--[ 2019.11.11.16.49.26.685.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.11.11.16.49.26.705.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.11.11.16.49.26.725.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[0];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.11.11.16.49.27.075.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.11.11.16.49.27.094.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float progress;
    int calls;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.progress = 0.0f;
        this.calls = 0;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        calls++;
        float end = totalCost + byTime;
        while (totalCost < end) {
            float cost = terrain.computeTravelCost(loc, nextLoc);
            if (totalCost + (cost - progress) > end) {
                float prev = end - totalCost;
                totalCost += prev;
                progress += prev;
                break;
            } else {
                totalCost += (cost - progress);
                progress = 0.0f;
                loc = path.dequeue();
                if (!path.isEmpty()) nextLoc = path.peek();
                else {
                    nextLoc = null;
                    break;
                }
            }
        }
    }

}

--[ 2019.11.11.16.49.27.111.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> path;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        public Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) this.cost = 0.0f;
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.cost + nextCost;
                }
            }
        }

        public float getCost(float heuristic) {
            return cost + heuristic*terrain.computeDistance(loc, end);
        }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
        path = null;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        boolean found = false;
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (c.getLoc().equals(getPathEnd())) {
                        currentNode = c;
                        found = true;
                        break;
                    }
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            if (found) {
                pathFound = true;
                endNode = currentNode;
                PFNode c = endNode;
                path = new Stack<>();
                while (c != null) {
                    path.push(c.getLoc());
                    c = c.fromNode;
                }
                break;
            }
            atStart = false;
        }
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(0);
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2019.11.11.16.51.45.335.0 ]--
DisposeComponent
--[ 2019.11.11.19.37.38.057.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.11.11.19.37.38.245.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2019.11.11.19.37.38.261.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.11.19.37.38.276.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.11.11.19.37.38.299.0 ]--
InitFile: /.cos265


--[ 2019.11.11.19.37.38.316.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.11.11.19.37.38.334.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.11.11.19.37.38.352.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[0];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.11.11.19.37.38.738.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.11.11.19.37.38.758.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float progress;
    int calls;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.progress = 0.0f;
        this.calls = 0;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        calls++;
        float end = totalCost + byTime;
        while (totalCost < end) {
            float cost = terrain.computeTravelCost(loc, nextLoc);
            if (totalCost + (cost - progress) > end) {
                float prev = end - totalCost;
                totalCost += prev;
                progress += prev;
                break;
            } else {
                totalCost += (cost - progress);
                progress = 0.0f;
                loc = path.dequeue();
                if (!path.isEmpty()) nextLoc = path.peek();
                else {
                    nextLoc = null;
                    break;
                }
            }
        }
    }

}

--[ 2019.11.11.19.37.38.788.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> path;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        public Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) this.cost = 0.0f;
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.cost + nextCost;
                }
            }
        }

        public float getCost(float heuristic) {
            return cost + heuristic*terrain.computeDistance(loc, end);
        }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
        path = null;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        boolean found = false;
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (c.getLoc().equals(getPathEnd())) {
                        currentNode = c;
                        found = true;
                        break;
                    }
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            if (found) {
                pathFound = true;
                endNode = currentNode;
                PFNode c = endNode;
                path = new Stack<>();
                while (c != null) {
                    path.push(c.getLoc());
                    c = c.fromNode;
                }
                break;
            }
            atStart = false;
        }
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(0);
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2019.11.11.21.02.12.491.0 ]--
DisposeComponent
--[ 2019.11.11.21.38.26.593.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.11.11.21.38.26.718.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2019.11.11.21.38.26.734.0 ]--
InitFile: /.cos265


--[ 2019.11.11.21.38.26.734.1 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.11.11.21.38.26.734.2 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.11.11.21.38.26.734.3 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> path;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        public Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) this.cost = 0.0f;
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.cost + nextCost;
                }
            }
        }

        public float getCost(float heuristic) {
            return cost + heuristic*terrain.computeDistance(loc, end);
        }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
        path = null;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        boolean found = false;
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (c.getLoc().equals(getPathEnd())) {
                        currentNode = c;
                        found = true;
                        break;
                    }
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            if (found) {
                pathFound = true;
                endNode = currentNode;
                PFNode c = endNode;
                path = new Stack<>();
                while (c != null) {
                    path.push(c.getLoc());
                    c = c.fromNode;
                }
                break;
            }
            atStart = false;
        }
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(0);
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2019.11.11.21.38.26.749.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float progress;
    int calls;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.progress = 0.0f;
        this.calls = 0;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        calls++;
        float end = totalCost + byTime;
        while (totalCost < end) {
            float cost = terrain.computeTravelCost(loc, nextLoc);
            if (totalCost + (cost - progress) > end) {
                float prev = end - totalCost;
                totalCost += prev;
                progress += prev;
                break;
            } else {
                totalCost += (cost - progress);
                progress = 0.0f;
                loc = path.dequeue();
                if (!path.isEmpty()) nextLoc = path.peek();
                else {
                    nextLoc = null;
                    break;
                }
            }
        }
    }

}

--[ 2019.11.11.21.38.26.749.1 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.11.11.21.38.26.749.2 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.11.11.21.38.26.765.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[0];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.11.11.21.38.26.765.1 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.11.21.59.39.283.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.22.08.31.496.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.11.22.08.32.052.0 ]--
r 48     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2019.11.11.22.08.32.178.0 ]--
r 48     private final static String emapFilename = emaps[11];        // change index to load a different elevation map
--[ 2019.11.11.22.08.36.515.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.22.43.32.522.0 ]--
DisposeComponent
--[ 2019.11.11.23.13.14.104.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.11.11.23.13.14.950.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2019.11.11.23.13.15.067.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.11.23.13.15.165.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.11.11.23.13.15.756.0 ]--
InitFile: /.cos265


--[ 2019.11.11.23.13.15.887.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.11.11.23.13.16.148.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.11.11.23.13.16.235.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[11];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.11.11.23.13.16.328.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.11.11.23.13.16.440.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float progress;
    int calls;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.progress = 0.0f;
        this.calls = 0;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        calls++;
        float end = totalCost + byTime;
        while (totalCost < end) {
            float cost = terrain.computeTravelCost(loc, nextLoc);
            if (totalCost + (cost - progress) > end) {
                float prev = end - totalCost;
                totalCost += prev;
                progress += prev;
                break;
            } else {
                totalCost += (cost - progress);
                progress = 0.0f;
                loc = path.dequeue();
                if (!path.isEmpty()) nextLoc = path.peek();
                else {
                    nextLoc = null;
                    break;
                }
            }
        }
    }

}

--[ 2019.11.11.23.13.16.569.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> path;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        public Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) this.cost = 0.0f;
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.cost + nextCost;
                }
            }
        }

        public float getCost(float heuristic) {
            return cost + heuristic*terrain.computeDistance(loc, end);
        }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
        path = null;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        boolean found = false;
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (c.getLoc().equals(getPathEnd())) {
                        currentNode = c;
                        found = true;
                        break;
                    }
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            if (found) {
                pathFound = true;
                endNode = currentNode;
                PFNode c = endNode;
                path = new Stack<>();
                while (c != null) {
                    path.push(c.getLoc());
                    c = c.fromNode;
                }
                break;
            }
            atStart = false;
        }
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(0);
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2019.11.11.23.22.13.310.0 ]--
DisposeComponent
--[ 2019.11.12.10.07.39.056.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.11.12.10.07.39.228.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2019.11.12.10.07.39.228.1 ]--
InitFile: /.cos265


--[ 2019.11.12.10.07.39.228.2 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.11.12.10.07.39.228.3 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.11.12.10.07.39.243.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> path;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        public Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) this.cost = 0.0f;
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.cost + nextCost;
                }
            }
        }

        public float getCost(float heuristic) {
            return cost + heuristic*terrain.computeDistance(loc, end);
        }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
        path = null;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        boolean found = false;
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (c.getLoc().equals(getPathEnd())) {
                        currentNode = c;
                        found = true;
                        break;
                    }
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            if (found) {
                pathFound = true;
                endNode = currentNode;
                PFNode c = endNode;
                path = new Stack<>();
                while (c != null) {
                    path.push(c.getLoc());
                    c = c.fromNode;
                }
                break;
            }
            atStart = false;
        }
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(0);
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2019.11.12.10.07.39.243.1 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float progress;
    int calls;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.progress = 0.0f;
        this.calls = 0;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        calls++;
        float end = totalCost + byTime;
        while (totalCost < end) {
            float cost = terrain.computeTravelCost(loc, nextLoc);
            if (totalCost + (cost - progress) > end) {
                float prev = end - totalCost;
                totalCost += prev;
                progress += prev;
                break;
            } else {
                totalCost += (cost - progress);
                progress = 0.0f;
                loc = path.dequeue();
                if (!path.isEmpty()) nextLoc = path.peek();
                else {
                    nextLoc = null;
                    break;
                }
            }
        }
    }

}

--[ 2019.11.12.10.07.39.243.2 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.11.12.10.07.39.243.3 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.11.12.10.07.39.243.4 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[11];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.11.12.10.07.39.259.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.12.10.07.53.626.0 ]--
DisposeComponent
--[ 2019.11.12.12.24.05.254.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.11.12.12.24.05.740.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2019.11.12.12.24.05.772.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.12.12.24.05.815.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.11.12.12.24.05.844.0 ]--
InitFile: /.cos265


--[ 2019.11.12.12.24.05.876.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.11.12.12.24.05.917.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.11.12.12.24.05.961.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[11];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.11.12.12.24.05.990.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.11.12.12.24.06.025.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float progress;
    int calls;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.progress = 0.0f;
        this.calls = 0;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        calls++;
        float end = totalCost + byTime;
        while (totalCost < end) {
            float cost = terrain.computeTravelCost(loc, nextLoc);
            if (totalCost + (cost - progress) > end) {
                float prev = end - totalCost;
                totalCost += prev;
                progress += prev;
                break;
            } else {
                totalCost += (cost - progress);
                progress = 0.0f;
                loc = path.dequeue();
                if (!path.isEmpty()) nextLoc = path.peek();
                else {
                    nextLoc = null;
                    break;
                }
            }
        }
    }

}

--[ 2019.11.12.12.24.06.061.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> path;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        public Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) this.cost = 0.0f;
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.cost + nextCost;
                }
            }
        }

        public float getCost(float heuristic) {
            return cost + heuristic*terrain.computeDistance(loc, end);
        }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
        path = null;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        boolean found = false;
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (c.getLoc().equals(getPathEnd())) {
                        currentNode = c;
                        found = true;
                        break;
                    }
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            if (found) {
                pathFound = true;
                endNode = currentNode;
                PFNode c = endNode;
                path = new Stack<>();
                while (c != null) {
                    path.push(c.getLoc());
                    c = c.fromNode;
                }
                break;
            }
            atStart = false;
        }
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(0);
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2019.11.12.12.24.30.310.0 ]--
DisposeComponent
--[ 2020.09.16.14.38.07.235.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2020.09.16.14.38.07.476.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2020.09.16.14.38.07.498.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2020.09.16.14.38.07.517.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2020.09.16.14.38.07.535.0 ]--
InitFile: /.cos265


--[ 2020.09.16.14.38.07.555.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2020.09.16.14.38.07.575.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2020.09.16.14.38.07.604.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[11];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2020.09.16.14.38.07.623.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2020.09.16.14.38.07.641.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float progress;
    int calls;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.progress = 0.0f;
        this.calls = 0;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        calls++;
        float end = totalCost + byTime;
        while (totalCost < end) {
            float cost = terrain.computeTravelCost(loc, nextLoc);
            if (totalCost + (cost - progress) > end) {
                float prev = end - totalCost;
                totalCost += prev;
                progress += prev;
                break;
            } else {
                totalCost += (cost - progress);
                progress = 0.0f;
                loc = path.dequeue();
                if (!path.isEmpty()) nextLoc = path.peek();
                else {
                    nextLoc = null;
                    break;
                }
            }
        }
    }

}

--[ 2020.09.16.14.38.07.661.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> path;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        public Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) this.cost = 0.0f;
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.cost + nextCost;
                }
            }
        }

        public float getCost(float heuristic) {
            return cost + heuristic*terrain.computeDistance(loc, end);
        }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
        path = null;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        boolean found = false;
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (c.getLoc().equals(getPathEnd())) {
                        currentNode = c;
                        found = true;
                        break;
                    }
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            if (found) {
                pathFound = true;
                endNode = currentNode;
                PFNode c = endNode;
                path = new Stack<>();
                while (c != null) {
                    path.push(c.getLoc());
                    c = c.fromNode;
                }
                break;
            }
            atStart = false;
        }
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(0);
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2020.09.16.14.41.25.570.0 ]--
DisposeComponent
--[ 2020.09.16.14.52.38.599.0 ]--
DisposeComponent
--[ 2020.09.16.14.52.42.225.0 ]--
DisposeComponent
--[ 2020.10.05.19.30.33.785.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2020.10.05.19.30.34.041.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2020.10.05.19.30.34.045.0 ]--
InitFile: /.cos265


--[ 2020.10.05.19.30.34.048.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2020.10.05.19.30.34.054.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2020.10.05.19.30.34.058.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> path;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        public Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) this.cost = 0.0f;
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.cost + nextCost;
                }
            }
        }

        public float getCost(float heuristic) {
            return cost + heuristic*terrain.computeDistance(loc, end);
        }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
        path = null;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        boolean found = false;
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (c.getLoc().equals(getPathEnd())) {
                        currentNode = c;
                        found = true;
                        break;
                    }
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            if (found) {
                pathFound = true;
                endNode = currentNode;
                PFNode c = endNode;
                path = new Stack<>();
                while (c != null) {
                    path.push(c.getLoc());
                    c = c.fromNode;
                }
                break;
            }
            atStart = false;
        }
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(0);
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2020.10.05.19.30.34.062.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float progress;
    int calls;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.progress = 0.0f;
        this.calls = 0;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        calls++;
        float end = totalCost + byTime;
        while (totalCost < end) {
            float cost = terrain.computeTravelCost(loc, nextLoc);
            if (totalCost + (cost - progress) > end) {
                float prev = end - totalCost;
                totalCost += prev;
                progress += prev;
                break;
            } else {
                totalCost += (cost - progress);
                progress = 0.0f;
                loc = path.dequeue();
                if (!path.isEmpty()) nextLoc = path.peek();
                else {
                    nextLoc = null;
                    break;
                }
            }
        }
    }

}

--[ 2020.10.05.19.30.34.066.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2020.10.05.19.30.34.070.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2020.10.05.19.30.34.073.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[11];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2020.10.05.19.30.34.077.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2020.10.05.19.30.42.337.0 ]--
UpdateTree (AD): 1 0
+ /.idea/.gitignore

--[ 2020.10.05.19.30.53.741.0 ]--
UpdateTree (AD): 66 0
+ /out/production/P04_Pathfinding/.donotlog
+ /out/production/P04_Pathfinding/algs4.jar
+ /out/production/P04_Pathfinding/stdlib.jar
+ /out/production/P04_Pathfinding/Coord.class
+ /out/production/P04_Pathfinding/png2emap.py
+ /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/ramp.png.emap
+ /out/production/P04_Pathfinding/Terrain.class
+ /out/production/P04_Pathfinding/ramp2.png.emap
+ /out/production/P04_Pathfinding/ramp3.png.emap
+ /out/production/P04_Pathfinding/mazeAB.png.emap
+ /out/production/P04_Pathfinding/usa128.png.emap
+ /out/production/P04_Pathfinding/usa256.png.emap
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/usa1024.png.emap
+ /out/production/P04_Pathfinding/writeupTest.emap
+ /out/production/P04_Pathfinding/maze32_0.png.emap
+ /out/production/P04_Pathfinding/maze32_1.png.emap
+ /out/production/P04_Pathfinding/maze232_0.png.emap
+ /out/production/P04_Pathfinding/maze320_0.png.emap
+ /out/production/P04_Pathfinding/mazeBrain.png.emap
+ /out/production/P04_Pathfinding/elevationTests.emap
+ /out/production/P04_Pathfinding/TerrainEditor.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/PathfinderVisualizer.class
+ /out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
+ /src/algs4.jar
+ /src/Coord.java
+ /src/stdlib.jar
+ /src/Walker.java
+ /src/Terrain.java
+ /src/Pathfinder.java
+ /src/TerrainEditor.java
+ /src/PathfinderVisualizer.java
+ /src/InteractivePathfinderVisualizer.java
+ /.log/history.log
+ /.idea/copyright/profiles_settings.xml
+ /.idea/libraries/algs4.xml
+ /.idea/libraries/stdlib.xml
+ /.idea/.name
+ /.idea/misc.xml
+ /.idea/.gitignore
+ /.idea/modules.xml
+ /.idea/compiler.xml
+ /.idea/workspace.xml
+ /.idea/uiDesigner.xml
+ /heightmaps/.donotlog
+ /heightmaps/png2emap.py
+ /heightmaps/ramp.png.emap
+ /heightmaps/ramp2.png.emap
+ /heightmaps/ramp3.png.emap
+ /heightmaps/mazeAB.png.emap
+ /heightmaps/usa128.png.emap
+ /heightmaps/usa256.png.emap
+ /heightmaps/usa1024.png.emap
+ /heightmaps/writeupTest.emap
+ /heightmaps/maze32_0.png.emap
+ /heightmaps/maze32_1.png.emap
+ /heightmaps/maze232_0.png.emap
+ /heightmaps/maze320_0.png.emap
+ /heightmaps/mazeBrain.png.emap
+ /heightmaps/elevationTests.emap
+ /.cos265
+ /readme.html
+ /P04_Pathfinding.iml
+ /P04_Pathfinding.zip

--[ 2020.10.05.19.30.53.746.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2020.10.05.19.30.53.751.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float progress;
    int calls;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.progress = 0.0f;
        this.calls = 0;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        calls++;
        float end = totalCost + byTime;
        while (totalCost < end) {
            float cost = terrain.computeTravelCost(loc, nextLoc);
            if (totalCost + (cost - progress) > end) {
                float prev = end - totalCost;
                totalCost += prev;
                progress += prev;
                break;
            } else {
                totalCost += (cost - progress);
                progress = 0.0f;
                loc = path.dequeue();
                if (!path.isEmpty()) nextLoc = path.peek();
                else {
                    nextLoc = null;
                    break;
                }
            }
        }
    }

}

--[ 2020.10.05.19.30.53.755.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2020.10.05.19.30.53.760.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> path;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        public Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) this.cost = 0.0f;
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.cost + nextCost;
                }
            }
        }

        public float getCost(float heuristic) {
            return cost + heuristic*terrain.computeDistance(loc, end);
        }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
        path = null;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        boolean found = false;
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (c.getLoc().equals(getPathEnd())) {
                        currentNode = c;
                        found = true;
                        break;
                    }
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            if (found) {
                pathFound = true;
                endNode = currentNode;
                PFNode c = endNode;
                path = new Stack<>();
                while (c != null) {
                    path.push(c.getLoc());
                    c = c.fromNode;
                }
                break;
            }
            atStart = false;
        }
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(0);
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2020.10.05.19.30.53.764.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2020.10.05.19.30.53.768.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2020.10.05.19.30.53.772.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[11];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2020.10.05.19.30.53.776.0 ]--
InitFile: /.cos265


--[ 2020.10.05.19.30.53.782.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2020.10.05.19.31.00.030.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.10.05.19.33.01.514.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 48     private final static String emapFilename = emaps[0];        // change index to load a different elevation map
--[ 2020.10.05.19.33.06.016.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.10.05.19.34.13.933.0 ]--
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2020.10.05.19.34.15.413.0 ]--
r 48     private final static String emapFilename = emaps[4];        // change index to load a different elevation map
--[ 2020.10.05.19.34.19.913.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.10.05.19.34.52.535.0 ]--
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2020.10.05.19.34.53.783.0 ]--
r 48     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2020.10.05.19.34.54.037.0 ]--
r 48     private final static String emapFilename = emaps[13];        // change index to load a different elevation map
--[ 2020.10.05.19.34.58.443.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.10.05.19.35.05.964.0 ]--
r 48     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2020.10.05.19.35.07.485.0 ]--
r 48     private final static String emapFilename = emaps[12];        // change index to load a different elevation map
--[ 2020.10.05.19.35.11.663.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.10.05.19.35.31.537.0 ]--
r 48     private final static String emapFilename = emaps[9];        // change index to load a different elevation map
--[ 2020.10.05.19.35.35.669.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.10.05.19.41.18.176.0 ]--
DisposeComponent
--[ 2020.10.05.19.41.20.641.0 ]--
DisposeComponent
--[ 2020.10.14.14.37.19.668.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2020.10.14.14.37.20.031.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2020.10.14.14.37.20.047.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2020.10.14.14.37.20.071.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2020.10.14.14.37.20.099.0 ]--
InitFile: /.cos265


--[ 2020.10.14.14.37.20.117.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2020.10.14.14.37.20.138.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2020.10.14.14.37.20.172.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[9];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2020.10.14.14.37.20.204.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2020.10.14.14.37.20.231.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float progress;
    int calls;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.progress = 0.0f;
        this.calls = 0;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        calls++;
        float end = totalCost + byTime;
        while (totalCost < end) {
            float cost = terrain.computeTravelCost(loc, nextLoc);
            if (totalCost + (cost - progress) > end) {
                float prev = end - totalCost;
                totalCost += prev;
                progress += prev;
                break;
            } else {
                totalCost += (cost - progress);
                progress = 0.0f;
                loc = path.dequeue();
                if (!path.isEmpty()) nextLoc = path.peek();
                else {
                    nextLoc = null;
                    break;
                }
            }
        }
    }

}

--[ 2020.10.14.14.37.20.267.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> path;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        public Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) this.cost = 0.0f;
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.cost + nextCost;
                }
            }
        }

        public float getCost(float heuristic) {
            return cost + heuristic*terrain.computeDistance(loc, end);
        }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
        path = null;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        boolean found = false;
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (c.getLoc().equals(getPathEnd())) {
                        currentNode = c;
                        found = true;
                        break;
                    }
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            if (found) {
                pathFound = true;
                endNode = currentNode;
                PFNode c = endNode;
                path = new Stack<>();
                while (c != null) {
                    path.push(c.getLoc());
                    c = c.fromNode;
                }
                break;
            }
            atStart = false;
        }
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(0);
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2020.10.14.14.43.49.799.0 ]--
DisposeComponent
--[ 2020.10.20.14.35.43.760.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2020.10.20.14.35.44.008.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2020.10.20.14.35.44.022.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2020.10.20.14.35.44.037.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2020.10.20.14.35.44.058.0 ]--
InitFile: /.cos265


--[ 2020.10.20.14.35.44.072.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2020.10.20.14.35.44.091.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2020.10.20.14.35.44.106.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[9];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2020.10.20.14.35.44.121.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2020.10.20.14.35.44.140.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float progress;
    int calls;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.progress = 0.0f;
        this.calls = 0;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        calls++;
        float end = totalCost + byTime;
        while (totalCost < end) {
            float cost = terrain.computeTravelCost(loc, nextLoc);
            if (totalCost + (cost - progress) > end) {
                float prev = end - totalCost;
                totalCost += prev;
                progress += prev;
                break;
            } else {
                totalCost += (cost - progress);
                progress = 0.0f;
                loc = path.dequeue();
                if (!path.isEmpty()) nextLoc = path.peek();
                else {
                    nextLoc = null;
                    break;
                }
            }
        }
    }

}

--[ 2020.10.20.14.35.44.155.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> path;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        public Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) this.cost = 0.0f;
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.cost + nextCost;
                }
            }
        }

        public float getCost(float heuristic) {
            return cost + heuristic*terrain.computeDistance(loc, end);
        }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
        path = null;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        boolean found = false;
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (c.getLoc().equals(getPathEnd())) {
                        currentNode = c;
                        found = true;
                        break;
                    }
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            if (found) {
                pathFound = true;
                endNode = currentNode;
                PFNode c = endNode;
                path = new Stack<>();
                while (c != null) {
                    path.push(c.getLoc());
                    c = c.fromNode;
                }
                break;
            }
            atStart = false;
        }
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(0);
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2020.10.20.14.55.33.680.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.10.20.14.55.46.790.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.10.20.15.05.32.999.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.10.20.15.53.22.567.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 48     private final static String emapFilename = emaps[0];        // change index to load a different elevation map
--[ 2020.10.20.15.53.28.085.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.10.20.16.07.23.045.0 ]--
:/src/Pathfinder.java
r 49         p Coord getLoc() {
--[ 2020.10.20.16.07.23.128.0 ]--
r 49         pr Coord getLoc() {
--[ 2020.10.20.16.07.23.215.0 ]--
r 49         pri Coord getLoc() {
--[ 2020.10.20.16.07.23.560.0 ]--
r 49         privat Coord getLoc() {
--[ 2020.10.20.16.07.24.306.0 ]--
r 49         private Coord getLoc() {
--[ 2020.10.20.16.07.43.585.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.10.20.16.10.57.086.0 ]--
DisposeComponent
--[ 2020.10.20.16.29.25.275.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2020.10.20.16.29.25.478.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2020.10.20.16.29.25.495.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2020.10.20.16.29.25.509.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2020.10.20.16.29.25.527.0 ]--
InitFile: /.cos265


--[ 2020.10.20.16.29.25.546.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2020.10.20.16.29.25.562.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2020.10.20.16.29.25.578.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[0];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2020.10.20.16.29.25.594.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2020.10.20.16.29.25.612.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float progress;
    int calls;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.progress = 0.0f;
        this.calls = 0;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        calls++;
        float end = totalCost + byTime;
        while (totalCost < end) {
            float cost = terrain.computeTravelCost(loc, nextLoc);
            if (totalCost + (cost - progress) > end) {
                float prev = end - totalCost;
                totalCost += prev;
                progress += prev;
                break;
            } else {
                totalCost += (cost - progress);
                progress = 0.0f;
                loc = path.dequeue();
                if (!path.isEmpty()) nextLoc = path.peek();
                else {
                    nextLoc = null;
                    break;
                }
            }
        }
    }

}

--[ 2020.10.20.16.29.25.627.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> path;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        private Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) this.cost = 0.0f;
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.cost + nextCost;
                }
            }
        }

        public float getCost(float heuristic) {
            return cost + heuristic*terrain.computeDistance(loc, end);
        }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
        path = null;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        boolean found = false;
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (c.getLoc().equals(getPathEnd())) {
                        currentNode = c;
                        found = true;
                        break;
                    }
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            if (found) {
                pathFound = true;
                endNode = currentNode;
                PFNode c = endNode;
                path = new Stack<>();
                while (c != null) {
                    path.push(c.getLoc());
                    c = c.fromNode;
                }
                break;
            }
            atStart = false;
        }
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(0);
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2020.10.20.16.55.27.502.0 ]--
DisposeComponent
--[ 2020.10.21.13.58.01.903.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2020.10.21.13.58.02.139.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2020.10.21.13.58.02.156.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2020.10.21.13.58.02.172.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2020.10.21.13.58.02.189.0 ]--
InitFile: /.cos265


--[ 2020.10.21.13.58.02.205.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2020.10.21.13.58.02.220.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2020.10.21.13.58.02.237.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[0];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2020.10.21.13.58.02.254.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2020.10.21.13.58.02.270.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float progress;
    int calls;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.progress = 0.0f;
        this.calls = 0;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        calls++;
        float end = totalCost + byTime;
        while (totalCost < end) {
            float cost = terrain.computeTravelCost(loc, nextLoc);
            if (totalCost + (cost - progress) > end) {
                float prev = end - totalCost;
                totalCost += prev;
                progress += prev;
                break;
            } else {
                totalCost += (cost - progress);
                progress = 0.0f;
                loc = path.dequeue();
                if (!path.isEmpty()) nextLoc = path.peek();
                else {
                    nextLoc = null;
                    break;
                }
            }
        }
    }

}

--[ 2020.10.21.13.58.02.288.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> path;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        private Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) this.cost = 0.0f;
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.cost + nextCost;
                }
            }
        }

        public float getCost(float heuristic) {
            return cost + heuristic*terrain.computeDistance(loc, end);
        }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
        path = null;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        boolean found = false;
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (c.getLoc().equals(getPathEnd())) {
                        currentNode = c;
                        found = true;
                        break;
                    }
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            if (found) {
                pathFound = true;
                endNode = currentNode;
                PFNode c = endNode;
                path = new Stack<>();
                while (c != null) {
                    path.push(c.getLoc());
                    c = c.fromNode;
                }
                break;
            }
            atStart = false;
        }
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(0);
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2020.10.21.13.58.34.290.0 ]--
DisposeComponent
--[ 2020.10.27.16.12.29.460.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2020.10.27.16.12.29.570.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2020.10.27.16.12.29.570.1 ]--
InitFile: /.cos265


--[ 2020.10.27.16.12.29.570.2 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2020.10.27.16.12.29.585.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2020.10.27.16.12.29.585.1 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> path;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        private Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) this.cost = 0.0f;
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.cost + nextCost;
                }
            }
        }

        public float getCost(float heuristic) {
            return cost + heuristic*terrain.computeDistance(loc, end);
        }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
        path = null;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        boolean found = false;
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (c.getLoc().equals(getPathEnd())) {
                        currentNode = c;
                        found = true;
                        break;
                    }
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            if (found) {
                pathFound = true;
                endNode = currentNode;
                PFNode c = endNode;
                path = new Stack<>();
                while (c != null) {
                    path.push(c.getLoc());
                    c = c.fromNode;
                }
                break;
            }
            atStart = false;
        }
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(0);
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2020.10.27.16.12.29.585.2 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float progress;
    int calls;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.progress = 0.0f;
        this.calls = 0;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        calls++;
        float end = totalCost + byTime;
        while (totalCost < end) {
            float cost = terrain.computeTravelCost(loc, nextLoc);
            if (totalCost + (cost - progress) > end) {
                float prev = end - totalCost;
                totalCost += prev;
                progress += prev;
                break;
            } else {
                totalCost += (cost - progress);
                progress = 0.0f;
                loc = path.dequeue();
                if (!path.isEmpty()) nextLoc = path.peek();
                else {
                    nextLoc = null;
                    break;
                }
            }
        }
    }

}

--[ 2020.10.27.16.12.29.601.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2020.10.27.16.12.29.601.1 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2020.10.27.16.12.29.601.2 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[9];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2020.10.27.16.12.29.617.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2020.10.27.16.58.24.751.0 ]--
DisposeComponent
--[ 2020.10.27.18.45.52.605.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2020.10.27.18.45.52.799.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2020.10.27.18.45.52.799.1 ]--
InitFile: /.cos265


--[ 2020.10.27.18.45.52.815.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2020.10.27.18.45.52.815.1 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2020.10.27.18.45.52.815.2 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> path;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        private Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) this.cost = 0.0f;
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.cost + nextCost;
                }
            }
        }

        public float getCost(float heuristic) {
            return cost + heuristic*terrain.computeDistance(loc, end);
        }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
        path = null;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        boolean found = false;
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (c.getLoc().equals(getPathEnd())) {
                        currentNode = c;
                        found = true;
                        break;
                    }
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            if (found) {
                pathFound = true;
                endNode = currentNode;
                PFNode c = endNode;
                path = new Stack<>();
                while (c != null) {
                    path.push(c.getLoc());
                    c = c.fromNode;
                }
                break;
            }
            atStart = false;
        }
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(0);
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2020.10.27.18.45.52.815.3 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float progress;
    int calls;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.progress = 0.0f;
        this.calls = 0;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        calls++;
        float end = totalCost + byTime;
        while (totalCost < end) {
            float cost = terrain.computeTravelCost(loc, nextLoc);
            if (totalCost + (cost - progress) > end) {
                float prev = end - totalCost;
                totalCost += prev;
                progress += prev;
                break;
            } else {
                totalCost += (cost - progress);
                progress = 0.0f;
                loc = path.dequeue();
                if (!path.isEmpty()) nextLoc = path.peek();
                else {
                    nextLoc = null;
                    break;
                }
            }
        }
    }

}

--[ 2020.10.27.18.45.52.830.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2020.10.27.18.45.52.830.1 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2020.10.27.18.45.52.830.2 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[9];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2020.10.27.18.45.52.846.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2020.10.27.18.47.46.563.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2020.10.27.18.47.47.188.0 ]--
r 48     private final static String emapFilename = emaps[2];        // change index to load a different elevation map
--[ 2020.10.27.18.47.55.619.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.10.27.18.57.35.973.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.10.27.19.20.24.574.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.10.27.19.36.30.176.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.10.27.19.49.15.521.0 ]--
:/src/Pathfinder.java
- 64
r 64         public float getCost(float heuristic) { return cost + heuristic*terrain.computeDistance(loc, end);
--[ 2020.10.27.19.49.17.773.0 ]--
- 64
r 64         public float getCost(float heuristic) { return cost + heuristic*terrain.computeDistance(loc, end); }
--[ 2020.10.27.19.58.12.130.0 ]--
r 64         //public float getCost(float heuristic) { return cost + heuristic*terrain.computeDistance(loc, end); }
--[ 2020.10.27.19.58.14.561.0 ]--
+ 65         
--[ 2020.10.27.19.58.15.320.0 ]--
r 65         p
--[ 2020.10.27.19.58.15.367.0 ]--
r 65         pu
--[ 2020.10.27.19.58.15.492.0 ]--
r 65         pub
--[ 2020.10.27.19.58.15.555.0 ]--
r 65         publ
--[ 2020.10.27.19.58.15.664.0 ]--
r 65         publi
--[ 2020.10.27.19.58.15.758.0 ]--
r 65         public
--[ 2020.10.27.19.58.15.961.0 ]--
r 65         public 
--[ 2020.10.27.19.58.16.023.0 ]--
r 65         public f
--[ 2020.10.27.19.58.16.086.0 ]--
r 65         public fl
--[ 2020.10.27.19.58.16.304.0 ]--
r 65         public flo
--[ 2020.10.27.19.58.16.414.0 ]--
r 65         public floa
--[ 2020.10.27.19.58.16.507.0 ]--
r 65         public float
--[ 2020.10.27.19.58.16.617.0 ]--
r 65         public float 
--[ 2020.10.27.19.58.16.773.0 ]--
r 65         public float g
--[ 2020.10.27.19.58.16.836.0 ]--
r 65         public float ge
--[ 2020.10.27.19.58.17.007.0 ]--
r 65         public float get
--[ 2020.10.27.19.58.17.252.0 ]--
r 65         public float getC
--[ 2020.10.27.19.58.17.393.0 ]--
r 65         public float getCo
--[ 2020.10.27.19.58.17.478.0 ]--
r 65         public float getCos
--[ 2020.10.27.19.58.17.579.0 ]--
r 65         public float getCost
--[ 2020.10.27.19.58.17.939.0 ]--
r 65         public float getCost()
--[ 2020.10.27.19.58.18.371.0 ]--
r 65         public float getCost(f)
--[ 2020.10.27.19.58.18.433.0 ]--
r 65         public float getCost(fl)
--[ 2020.10.27.19.58.18.589.0 ]--
r 65         public float getCost(flo)
--[ 2020.10.27.19.58.18.700.0 ]--
r 65         public float getCost(floa)
--[ 2020.10.27.19.58.18.772.0 ]--
r 65         public float getCost(float)
--[ 2020.10.27.19.58.18.850.0 ]--
r 65         public float getCost(float )
--[ 2020.10.27.19.58.19.006.0 ]--
r 65         public float getCost(float h)
--[ 2020.10.27.19.58.19.367.0 ]--
r 65         public float getCost(float he)
--[ 2020.10.27.19.58.19.442.0 ]--
r 65         public float getCost(float heu)
--[ 2020.10.27.19.58.19.536.0 ]--
r 65         public float getCost(float heur)
--[ 2020.10.27.19.58.19.677.0 ]--
r 65         public float getCost(float heuri)
--[ 2020.10.27.19.58.19.723.0 ]--
r 65         public float getCost(float heuris)
--[ 2020.10.27.19.58.19.801.0 ]--
r 65         public float getCost(float heurist)
--[ 2020.10.27.19.58.19.895.0 ]--
r 65         public float getCost(float heuristi)
--[ 2020.10.27.19.58.20.020.0 ]--
r 65         public float getCost(float heuristic)
--[ 2020.10.27.19.58.20.693.0 ]--
r 65         public float getCost(float heuristic) 
--[ 2020.10.27.19.58.20.866.0 ]--
r 65         public float getCost(float heuristic) {}
--[ 2020.10.27.19.58.21.581.0 ]--
r 65         public float getCost(float heuristic) { }
--[ 2020.10.27.19.58.21.743.0 ]--
r 65         public float getCost(float heuristic) {  }
--[ 2020.10.27.19.58.28.042.0 ]--
r 65         public float getCost(float heuristic) { r }
--[ 2020.10.27.19.58.28.225.0 ]--
r 65         public float getCost(float heuristic) { re }
--[ 2020.10.27.19.58.28.287.0 ]--
r 65         public float getCost(float heuristic) { ret }
--[ 2020.10.27.19.58.28.366.0 ]--
r 65         public float getCost(float heuristic) { retu }
--[ 2020.10.27.19.58.28.491.0 ]--
r 65         public float getCost(float heuristic) { retur }
--[ 2020.10.27.19.58.28.553.0 ]--
r 65         public float getCost(float heuristic) { return }
--[ 2020.10.27.19.58.28.615.0 ]--
r 65         public float getCost(float heuristic) { return  }
--[ 2020.10.27.19.58.28.772.0 ]--
r 65         public float getCost(float heuristic) { return c }
--[ 2020.10.27.19.58.28.819.0 ]--
r 65         public float getCost(float heuristic) { return co }
--[ 2020.10.27.19.58.29.193.0 ]--
r 65         public float getCost(float heuristic) { return c }
--[ 2020.10.27.19.58.29.335.0 ]--
r 65         public float getCost(float heuristic) { return  }
--[ 2020.10.27.19.58.30.010.0 ]--
r 65         public float getCost(float heuristic) { return t }
--[ 2020.10.27.19.58.30.074.0 ]--
r 65         public float getCost(float heuristic) { return th }
--[ 2020.10.27.19.58.30.136.0 ]--
r 65         public float getCost(float heuristic) { return thi }
--[ 2020.10.27.19.58.30.230.0 ]--
r 65         public float getCost(float heuristic) { return this }
--[ 2020.10.27.19.58.30.339.0 ]--
r 65         public float getCost(float heuristic) { return this. }
--[ 2020.10.27.19.58.30.495.0 ]--
r 65         public float getCost(float heuristic) { return this.c }
--[ 2020.10.27.19.58.30.607.0 ]--
r 65         public float getCost(float heuristic) { return this.co }
--[ 2020.10.27.19.58.30.742.0 ]--
r 65         public float getCost(float heuristic) { return this.cos }
--[ 2020.10.27.19.58.30.788.0 ]--
r 65         public float getCost(float heuristic) { return this.cost }
--[ 2020.10.27.19.58.30.835.0 ]--
r 65         public float getCost(float heuristic) { return this.cost; }
--[ 2020.10.27.19.58.35.751.0 ]--
r 59                     this.cost = b.cost + nextCost ;
--[ 2020.10.27.19.58.35.907.0 ]--
r 59                     this.cost = b.cost + nextCost +;
--[ 2020.10.27.19.58.35.963.0 ]--
r 59                     this.cost = b.cost + nextCost + ;
--[ 2020.10.27.19.58.36.119.0 ]--
r 59                     this.cost = b.cost + nextCost + h;
--[ 2020.10.27.19.58.36.260.0 ]--
r 59                     this.cost = b.cost + nextCost + he;
--[ 2020.10.27.19.58.36.589.0 ]--
r 59                     this.cost = b.cost + nextCost + h;
--[ 2020.10.27.19.58.36.717.0 ]--
r 59                     this.cost = b.cost + nextCost + ;
--[ 2020.10.27.19.58.37.569.0 ]--
r 59                     this.cost = b.cost + nextCost + h;
--[ 2020.10.27.19.58.37.631.0 ]--
r 59                     this.cost = b.cost + nextCost + he;
--[ 2020.10.27.19.58.37.753.0 ]--
r 59                     this.cost = b.cost + nextCost + heu;
--[ 2020.10.27.19.58.37.871.0 ]--
r 59                     this.cost = b.cost + nextCost + heur;
--[ 2020.10.27.19.58.38.008.0 ]--
r 59                     this.cost = b.cost + nextCost + heurs;
--[ 2020.10.27.19.58.38.103.0 ]--
r 59                     this.cost = b.cost + nextCost + heurst;
--[ 2020.10.27.19.58.38.320.0 ]--
r 59                     this.cost = b.cost + nextCost + heursti;
--[ 2020.10.27.19.58.38.335.0 ]--
r 59                     this.cost = b.cost + nextCost + heurstic;
--[ 2020.10.27.19.58.39.007.0 ]--
r 59                     this.cost = b.cost + nextCost + heursti;
--[ 2020.10.27.19.58.39.195.0 ]--
r 59                     this.cost = b.cost + nextCost + heurst;
--[ 2020.10.27.19.58.39.364.0 ]--
r 59                     this.cost = b.cost + nextCost + heurs;
--[ 2020.10.27.19.58.39.919.0 ]--
r 59                     this.cost = b.cost + nextCost + heur;
--[ 2020.10.27.19.58.40.156.0 ]--
r 59                     this.cost = b.cost + nextCost + heuri;
--[ 2020.10.27.19.58.40.304.0 ]--
r 59                     this.cost = b.cost + nextCost + heuris;
--[ 2020.10.27.19.58.40.335.0 ]--
r 59                     this.cost = b.cost + nextCost + heurist;
--[ 2020.10.27.19.58.40.444.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristi;
--[ 2020.10.27.19.58.40.572.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic;
--[ 2020.10.27.19.58.41.056.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*;
--[ 2020.10.27.19.58.42.232.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*t;
--[ 2020.10.27.19.58.42.389.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*te;
--[ 2020.10.27.19.58.42.469.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*ter;
--[ 2020.10.27.19.58.42.660.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*terr;
--[ 2020.10.27.19.58.42.754.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*terra;
--[ 2020.10.27.19.58.42.832.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*terrai;
--[ 2020.10.27.19.58.42.879.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*terrain;
--[ 2020.10.27.19.58.43.118.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*terrain.;
--[ 2020.10.27.19.58.43.337.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*terrain.c;
--[ 2020.10.27.19.58.43.386.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*terrain.co;
--[ 2020.10.27.19.58.43.499.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*terrain.com;
--[ 2020.10.27.19.58.43.624.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*terrain.comp;
--[ 2020.10.27.19.58.43.749.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*terrain.compu;
--[ 2020.10.27.19.58.43.829.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*terrain.comput;
--[ 2020.10.27.19.58.43.923.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*terrain.compute;
--[ 2020.10.27.19.58.44.174.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*terrain.computeD;
--[ 2020.10.27.19.58.44.353.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*terrain.computeDi;
--[ 2020.10.27.19.58.44.464.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*terrain.computeDis;
--[ 2020.10.27.19.58.44.523.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*terrain.computeDist;
--[ 2020.10.27.19.58.44.663.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*terrain.computeDista;
--[ 2020.10.27.19.58.44.726.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*terrain.computeDistan;
--[ 2020.10.27.19.58.44.820.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*terrain.computeDistanc;
--[ 2020.10.27.19.58.45.071.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*terrain.computeDistance;
--[ 2020.10.27.19.58.45.243.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*terrain.computeDistance();
--[ 2020.10.27.19.58.45.446.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*terrain.computeDistance(l);
--[ 2020.10.27.19.58.45.630.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*terrain.computeDistance(lo);
--[ 2020.10.27.19.58.45.692.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*terrain.computeDistance(loc);
--[ 2020.10.27.19.58.45.802.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*terrain.computeDistance(loc,);
--[ 2020.10.27.19.58.45.895.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*terrain.computeDistance(loc, );
--[ 2020.10.27.19.58.46.020.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*terrain.computeDistance(loc, e);
--[ 2020.10.27.19.58.46.114.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*terrain.computeDistance(loc, en);
--[ 2020.10.27.19.58.46.867.0 ]--
r 59                     this.cost = b.cost + nextCost + heuristic*terrain.computeDistance(loc, end);
--[ 2020.10.27.19.58.53.754.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.10.27.20.04.24.011.0 ]--
r 64         /public float getCost(float heuristic) { return cost + heuristic*terrain.computeDistance(loc, end); }
--[ 2020.10.27.20.04.24.145.0 ]--
r 64         public float getCost(float heuristic) { return cost + heuristic*terrain.computeDistance(loc, end); }
--[ 2020.10.27.20.04.29.579.0 ]--
r 65         
--[ 2020.10.27.20.04.29.824.0 ]--
- 65
--[ 2020.10.27.20.04.33.766.0 ]--
r 59                     this.cost = b.cost + nextCost;
--[ 2020.10.27.20.04.38.186.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.10.27.20.13.30.321.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.10.27.20.13.49.078.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2020.10.27.20.13.49.993.0 ]--
r 48     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2020.10.27.20.13.50.145.0 ]--
r 48     private final static String emapFilename = emaps[11];        // change index to load a different elevation map
--[ 2020.10.27.20.13.54.676.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.10.27.21.46.59.787.0 ]--
DisposeComponent
--[ 2020.10.29.14.20.10.262.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2020.10.29.14.20.10.417.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2020.10.29.14.20.10.421.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2020.10.29.14.20.10.426.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2020.10.29.14.20.10.432.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> path;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        private Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) this.cost = 0.0f;
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.cost + nextCost;
                }
            }
        }

        public float getCost(float heuristic) { return cost + heuristic*terrain.computeDistance(loc, end); }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
        path = null;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        boolean found = false;
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (c.getLoc().equals(getPathEnd())) {
                        currentNode = c;
                        found = true;
                        break;
                    }
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            if (found) {
                pathFound = true;
                endNode = currentNode;
                PFNode c = endNode;
                path = new Stack<>();
                while (c != null) {
                    path.push(c.getLoc());
                    c = c.fromNode;
                }
                break;
            }
            atStart = false;
        }
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(0);
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2020.10.29.14.20.10.436.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2020.10.29.14.20.10.441.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[11];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2020.10.29.14.20.10.450.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2020.10.29.14.20.10.453.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2020.10.29.14.20.10.458.0 ]--
InitFile: /.cos265


--[ 2020.10.29.14.20.10.462.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float progress;
    int calls;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.progress = 0.0f;
        this.calls = 0;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        calls++;
        float end = totalCost + byTime;
        while (totalCost < end) {
            float cost = terrain.computeTravelCost(loc, nextLoc);
            if (totalCost + (cost - progress) > end) {
                float prev = end - totalCost;
                totalCost += prev;
                progress += prev;
                break;
            } else {
                totalCost += (cost - progress);
                progress = 0.0f;
                loc = path.dequeue();
                if (!path.isEmpty()) nextLoc = path.peek();
                else {
                    nextLoc = null;
                    break;
                }
            }
        }
    }

}

--[ 2020.10.29.14.59.46.526.0 ]--
DisposeComponent
--[ 2020.10.29.15.52.06.251.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2020.10.29.15.52.06.494.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2020.10.29.15.52.06.497.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2020.10.29.15.52.06.501.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2020.10.29.15.52.06.504.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> path;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        private Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) this.cost = 0.0f;
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.cost + nextCost;
                }
            }
        }

        public float getCost(float heuristic) { return cost + heuristic*terrain.computeDistance(loc, end); }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
        path = null;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        boolean found = false;
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (c.getLoc().equals(getPathEnd())) {
                        currentNode = c;
                        found = true;
                        break;
                    }
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            if (found) {
                pathFound = true;
                endNode = currentNode;
                PFNode c = endNode;
                path = new Stack<>();
                while (c != null) {
                    path.push(c.getLoc());
                    c = c.fromNode;
                }
                break;
            }
            atStart = false;
        }
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(0);
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2020.10.29.15.52.06.507.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2020.10.29.15.52.06.511.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[11];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2020.10.29.15.52.06.514.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2020.10.29.15.52.06.517.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2020.10.29.15.52.06.520.0 ]--
InitFile: /.cos265


--[ 2020.10.29.15.52.06.522.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float progress;
    int calls;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.progress = 0.0f;
        this.calls = 0;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        calls++;
        float end = totalCost + byTime;
        while (totalCost < end) {
            float cost = terrain.computeTravelCost(loc, nextLoc);
            if (totalCost + (cost - progress) > end) {
                float prev = end - totalCost;
                totalCost += prev;
                progress += prev;
                break;
            } else {
                totalCost += (cost - progress);
                progress = 0.0f;
                loc = path.dequeue();
                if (!path.isEmpty()) nextLoc = path.peek();
                else {
                    nextLoc = null;
                    break;
                }
            }
        }
    }

}

--[ 2020.10.29.15.54.41.457.0 ]--
DisposeComponent
--[ 2020.10.29.16.32.44.712.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2020.10.29.16.32.44.897.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2020.10.29.16.32.44.911.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2020.10.29.16.32.44.925.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2020.10.29.16.32.44.941.0 ]--
InitFile: /.cos265


--[ 2020.10.29.16.32.44.955.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2020.10.29.16.32.44.973.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2020.10.29.16.32.44.990.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[11];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2020.10.29.16.32.45.010.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2020.10.29.16.32.45.027.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float progress;
    int calls;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.progress = 0.0f;
        this.calls = 0;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        calls++;
        float end = totalCost + byTime;
        while (totalCost < end) {
            float cost = terrain.computeTravelCost(loc, nextLoc);
            if (totalCost + (cost - progress) > end) {
                float prev = end - totalCost;
                totalCost += prev;
                progress += prev;
                break;
            } else {
                totalCost += (cost - progress);
                progress = 0.0f;
                loc = path.dequeue();
                if (!path.isEmpty()) nextLoc = path.peek();
                else {
                    nextLoc = null;
                    break;
                }
            }
        }
    }

}

--[ 2020.10.29.16.32.45.047.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> path;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        private Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) this.cost = 0.0f;
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.cost + nextCost;
                }
            }
        }

        public float getCost(float heuristic) { return cost + heuristic*terrain.computeDistance(loc, end); }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
        path = null;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        boolean found = false;
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (c.getLoc().equals(getPathEnd())) {
                        currentNode = c;
                        found = true;
                        break;
                    }
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            if (found) {
                pathFound = true;
                endNode = currentNode;
                PFNode c = endNode;
                path = new Stack<>();
                while (c != null) {
                    path.push(c.getLoc());
                    c = c.fromNode;
                }
                break;
            }
            atStart = false;
        }
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(0);
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2020.10.29.16.57.55.066.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2020.10.29.16.57.55.918.0 ]--
r 48     private final static String emapFilename = emaps[0];        // change index to load a different elevation map
--[ 2020.10.29.16.58.04.599.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.10.29.17.05.28.954.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.10.29.17.05.35.157.0 ]--
r 48     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2020.10.29.17.05.35.240.0 ]--
r 48     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2020.10.29.17.05.35.345.0 ]--
r 48     private final static String emapFilename = emaps[10];        // change index to load a different elevation map
--[ 2020.10.29.17.05.39.312.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.10.29.17.45.36.072.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.10.29.17.50.22.125.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.10.29.18.00.35.976.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.10.29.18.05.42.870.0 ]--
DisposeComponent
--[ 2020.10.29.21.59.39.716.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2020.10.29.21.59.39.884.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2020.10.29.21.59.39.892.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2020.10.29.21.59.39.896.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2020.10.29.21.59.39.902.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> path;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        private Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) this.cost = 0.0f;
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.cost + nextCost;
                }
            }
        }

        public float getCost(float heuristic) { return cost + heuristic*terrain.computeDistance(loc, end); }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
        path = null;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        boolean found = false;
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (c.getLoc().equals(getPathEnd())) {
                        currentNode = c;
                        found = true;
                        break;
                    }
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            if (found) {
                pathFound = true;
                endNode = currentNode;
                PFNode c = endNode;
                path = new Stack<>();
                while (c != null) {
                    path.push(c.getLoc());
                    c = c.fromNode;
                }
                break;
            }
            atStart = false;
        }
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(0);
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2020.10.29.21.59.39.907.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2020.10.29.21.59.39.911.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[10];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2020.10.29.21.59.39.916.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2020.10.29.21.59.39.922.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2020.10.29.21.59.39.926.0 ]--
InitFile: /.cos265


--[ 2020.10.29.21.59.39.930.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float progress;
    int calls;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.progress = 0.0f;
        this.calls = 0;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        calls++;
        float end = totalCost + byTime;
        while (totalCost < end) {
            float cost = terrain.computeTravelCost(loc, nextLoc);
            if (totalCost + (cost - progress) > end) {
                float prev = end - totalCost;
                totalCost += prev;
                progress += prev;
                break;
            } else {
                totalCost += (cost - progress);
                progress = 0.0f;
                loc = path.dequeue();
                if (!path.isEmpty()) nextLoc = path.peek();
                else {
                    nextLoc = null;
                    break;
                }
            }
        }
    }

}

--[ 2020.10.29.23.03.05.188.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2020.10.29.23.03.05.274.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2020.10.29.23.03.05.285.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2020.10.29.23.03.05.288.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2020.10.29.23.03.05.294.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> path;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        private Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) this.cost = 0.0f;
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.cost + nextCost;
                }
            }
        }

        public float getCost(float heuristic) { return cost + heuristic*terrain.computeDistance(loc, end); }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
        path = null;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        boolean found = false;
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (c.getLoc().equals(getPathEnd())) {
                        currentNode = c;
                        found = true;
                        break;
                    }
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            if (found) {
                pathFound = true;
                endNode = currentNode;
                PFNode c = endNode;
                path = new Stack<>();
                while (c != null) {
                    path.push(c.getLoc());
                    c = c.fromNode;
                }
                break;
            }
            atStart = false;
        }
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(0);
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2020.10.29.23.03.05.299.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2020.10.29.23.03.05.306.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[10];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2020.10.29.23.03.05.309.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2020.10.29.23.03.05.313.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2020.10.29.23.03.05.320.0 ]--
InitFile: /.cos265


--[ 2020.10.29.23.03.05.324.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float progress;
    int calls;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.progress = 0.0f;
        this.calls = 0;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        calls++;
        float end = totalCost + byTime;
        while (totalCost < end) {
            float cost = terrain.computeTravelCost(loc, nextLoc);
            if (totalCost + (cost - progress) > end) {
                float prev = end - totalCost;
                totalCost += prev;
                progress += prev;
                break;
            } else {
                totalCost += (cost - progress);
                progress = 0.0f;
                loc = path.dequeue();
                if (!path.isEmpty()) nextLoc = path.peek();
                else {
                    nextLoc = null;
                    break;
                }
            }
        }
    }

}

--[ 2020.10.29.23.04.05.635.0 ]--
DisposeComponent
--[ 2020.10.29.23.04.10.042.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2020.10.29.23.04.10.092.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2020.10.29.23.04.10.095.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2020.10.29.23.04.10.102.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2020.10.29.23.04.10.106.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> path;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        private Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) this.cost = 0.0f;
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.cost + nextCost;
                }
            }
        }

        public float getCost(float heuristic) { return cost + heuristic*terrain.computeDistance(loc, end); }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
        path = null;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        boolean found = false;
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (c.getLoc().equals(getPathEnd())) {
                        currentNode = c;
                        found = true;
                        break;
                    }
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            if (found) {
                pathFound = true;
                endNode = currentNode;
                PFNode c = endNode;
                path = new Stack<>();
                while (c != null) {
                    path.push(c.getLoc());
                    c = c.fromNode;
                }
                break;
            }
            atStart = false;
        }
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(0);
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2020.10.29.23.04.10.109.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2020.10.29.23.04.10.114.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[10];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2020.10.29.23.04.10.122.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2020.10.29.23.04.10.126.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2020.10.29.23.04.10.129.0 ]--
InitFile: /.cos265


--[ 2020.10.29.23.04.10.132.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float progress;
    int calls;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.progress = 0.0f;
        this.calls = 0;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        calls++;
        float end = totalCost + byTime;
        while (totalCost < end) {
            float cost = terrain.computeTravelCost(loc, nextLoc);
            if (totalCost + (cost - progress) > end) {
                float prev = end - totalCost;
                totalCost += prev;
                progress += prev;
                break;
            } else {
                totalCost += (cost - progress);
                progress = 0.0f;
                loc = path.dequeue();
                if (!path.isEmpty()) nextLoc = path.peek();
                else {
                    nextLoc = null;
                    break;
                }
            }
        }
    }

}

--[ 2020.10.29.23.05.52.133.0 ]--
DisposeComponent
--[ 2020.10.29.23.09.19.277.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2020.10.29.23.09.19.448.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2020.10.29.23.09.19.448.1 ]--
InitFile: /.cos265


--[ 2020.10.29.23.09.19.464.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2020.10.29.23.09.19.464.1 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2020.10.29.23.09.19.464.2 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> path;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        private Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) this.cost = 0.0f;
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.cost + nextCost;
                }
            }
        }

        public float getCost(float heuristic) { return cost + heuristic*terrain.computeDistance(loc, end); }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
        path = null;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        boolean found = false;
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (c.getLoc().equals(getPathEnd())) {
                        currentNode = c;
                        found = true;
                        break;
                    }
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            if (found) {
                pathFound = true;
                endNode = currentNode;
                PFNode c = endNode;
                path = new Stack<>();
                while (c != null) {
                    path.push(c.getLoc());
                    c = c.fromNode;
                }
                break;
            }
            atStart = false;
        }
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(0);
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2020.10.29.23.09.19.464.3 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float progress;
    int calls;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.progress = 0.0f;
        this.calls = 0;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        calls++;
        float end = totalCost + byTime;
        while (totalCost < end) {
            float cost = terrain.computeTravelCost(loc, nextLoc);
            if (totalCost + (cost - progress) > end) {
                float prev = end - totalCost;
                totalCost += prev;
                progress += prev;
                break;
            } else {
                totalCost += (cost - progress);
                progress = 0.0f;
                loc = path.dequeue();
                if (!path.isEmpty()) nextLoc = path.peek();
                else {
                    nextLoc = null;
                    break;
                }
            }
        }
    }

}

--[ 2020.10.29.23.09.19.480.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2020.10.29.23.09.19.480.1 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2020.10.29.23.09.19.480.2 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[10];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2020.10.29.23.09.19.495.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2020.10.30.14.55.33.326.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2020.10.30.14.55.33.594.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2020.10.30.14.55.33.614.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2020.10.30.14.55.33.628.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2020.10.30.14.55.33.645.0 ]--
InitFile: /.cos265


--[ 2020.10.30.14.55.33.666.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2020.10.30.14.55.33.683.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2020.10.30.14.55.33.700.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[10];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2020.10.30.14.55.33.717.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2020.10.30.14.55.33.732.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float progress;
    int calls;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.progress = 0.0f;
        this.calls = 0;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        calls++;
        float end = totalCost + byTime;
        while (totalCost < end) {
            float cost = terrain.computeTravelCost(loc, nextLoc);
            if (totalCost + (cost - progress) > end) {
                float prev = end - totalCost;
                totalCost += prev;
                progress += prev;
                break;
            } else {
                totalCost += (cost - progress);
                progress = 0.0f;
                loc = path.dequeue();
                if (!path.isEmpty()) nextLoc = path.peek();
                else {
                    nextLoc = null;
                    break;
                }
            }
        }
    }

}

--[ 2020.10.30.14.55.33.752.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> path;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        private Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) this.cost = 0.0f;
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.cost + nextCost;
                }
            }
        }

        public float getCost(float heuristic) { return cost + heuristic*terrain.computeDistance(loc, end); }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
        path = null;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        boolean found = false;
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (c.getLoc().equals(getPathEnd())) {
                        currentNode = c;
                        found = true;
                        break;
                    }
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            if (found) {
                pathFound = true;
                endNode = currentNode;
                PFNode c = endNode;
                path = new Stack<>();
                while (c != null) {
                    path.push(c.getLoc());
                    c = c.fromNode;
                }
                break;
            }
            atStart = false;
        }
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(0);
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2020.10.30.17.07.08.767.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2020.10.30.17.07.08.962.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2020.10.30.17.07.08.978.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2020.10.30.17.07.08.996.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2020.10.30.17.07.09.012.0 ]--
InitFile: /.cos265


--[ 2020.10.30.17.07.09.029.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2020.10.30.17.07.09.046.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2020.10.30.17.07.09.063.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[10];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2020.10.30.17.07.09.081.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2020.10.30.17.07.09.098.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float progress;
    int calls;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.progress = 0.0f;
        this.calls = 0;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        calls++;
        float end = totalCost + byTime;
        while (totalCost < end) {
            float cost = terrain.computeTravelCost(loc, nextLoc);
            if (totalCost + (cost - progress) > end) {
                float prev = end - totalCost;
                totalCost += prev;
                progress += prev;
                break;
            } else {
                totalCost += (cost - progress);
                progress = 0.0f;
                loc = path.dequeue();
                if (!path.isEmpty()) nextLoc = path.peek();
                else {
                    nextLoc = null;
                    break;
                }
            }
        }
    }

}

--[ 2020.10.30.17.07.09.116.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> path;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        private Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) this.cost = 0.0f;
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.cost + nextCost;
                }
            }
        }

        public float getCost(float heuristic) { return cost + heuristic*terrain.computeDistance(loc, end); }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
        path = null;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        boolean found = false;
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (c.getLoc().equals(getPathEnd())) {
                        currentNode = c;
                        found = true;
                        break;
                    }
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            if (found) {
                pathFound = true;
                endNode = currentNode;
                PFNode c = endNode;
                path = new Stack<>();
                while (c != null) {
                    path.push(c.getLoc());
                    c = c.fromNode;
                }
                break;
            }
            atStart = false;
        }
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(0);
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2020.10.30.17.10.17.939.0 ]--
DisposeComponent
--[ 2020.10.30.17.26.09.136.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2020.10.30.17.26.09.215.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2020.10.30.17.26.09.217.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2020.10.30.17.26.09.221.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2020.10.30.17.26.09.224.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> path;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        private Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) this.cost = 0.0f;
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.cost + nextCost;
                }
            }
        }

        public float getCost(float heuristic) { return cost + heuristic*terrain.computeDistance(loc, end); }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
        path = null;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        boolean found = false;
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (c.getLoc().equals(getPathEnd())) {
                        currentNode = c;
                        found = true;
                        break;
                    }
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            if (found) {
                pathFound = true;
                endNode = currentNode;
                PFNode c = endNode;
                path = new Stack<>();
                while (c != null) {
                    path.push(c.getLoc());
                    c = c.fromNode;
                }
                break;
            }
            atStart = false;
        }
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(0);
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2020.10.30.17.26.09.227.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2020.10.30.17.26.09.231.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[10];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2020.10.30.17.26.09.235.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2020.10.30.17.26.09.237.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2020.10.30.17.26.09.239.0 ]--
InitFile: /.cos265


--[ 2020.10.30.17.26.09.241.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float progress;
    int calls;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.progress = 0.0f;
        this.calls = 0;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        calls++;
        float end = totalCost + byTime;
        while (totalCost < end) {
            float cost = terrain.computeTravelCost(loc, nextLoc);
            if (totalCost + (cost - progress) > end) {
                float prev = end - totalCost;
                totalCost += prev;
                progress += prev;
                break;
            } else {
                totalCost += (cost - progress);
                progress = 0.0f;
                loc = path.dequeue();
                if (!path.isEmpty()) nextLoc = path.peek();
                else {
                    nextLoc = null;
                    break;
                }
            }
        }
    }

}

--[ 2020.10.30.17.26.20.153.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.10.30.17.27.29.090.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.10.30.17.27.49.546.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.10.30.17.28.24.984.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.10.30.17.28.48.479.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.10.30.17.30.55.996.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.10.30.17.35.24.948.0 ]--
DisposeComponent
--[ 2020.11.03.14.03.48.790.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2020.11.03.14.03.49.091.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/writeupTest.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/elevationTests.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/writeupTest.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/heightmaps/elevationTests.emap
/.cos265
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2020.11.03.14.03.49.115.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2020.11.03.14.03.49.135.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2020.11.03.14.03.49.164.0 ]--
InitFile: /.cos265


--[ 2020.11.03.14.03.49.181.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2020.11.03.14.03.49.197.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2020.11.03.14.03.49.211.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
            "writeupTest.emap",     // 12  (map from writeup)
            "elevationTests.emap",  // 13  (for me to comprehend elevation stuff)
    };

    private final static String emapFilename = emaps[10];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2020.11.03.14.03.49.234.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);

        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2020.11.03.14.03.49.251.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    Queue<Coord> path;
    Coord loc;
    Coord nextLoc;
    Terrain terrain;
    float totalCost;
    float progress;
    int calls;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.path = new Queue<>();
        for (Coord c : path) {
            this.path.enqueue(c);
        }
        this.loc = this.path.dequeue();
        this.nextLoc = this.path.peek();
        this.terrain = terrain;
        this.totalCost = 0.0f;
        this.progress = 0.0f;
        this.calls = 0;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return this.loc;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return this.path.isEmpty();
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        calls++;
        float end = totalCost + byTime;
        while (totalCost < end) {
            float cost = terrain.computeTravelCost(loc, nextLoc);
            if (totalCost + (cost - progress) > end) {
                float prev = end - totalCost;
                totalCost += prev;
                progress += prev;
                break;
            } else {
                totalCost += (cost - progress);
                progress = 0.0f;
                loc = path.dequeue();
                if (!path.isEmpty()) nextLoc = path.peek();
                else {
                    nextLoc = null;
                    break;
                }
            }
        }
    }

}

--[ 2020.11.03.14.03.49.274.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    private float h;
    private int N;
    private int searchSize;
    private boolean pathFound;
    private Terrain terrain;
    private Coord start;
    private Coord end;
    private MinPQ<PFNode> pq;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> path;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */

    private class PFNode implements Comparable<PFNode> {
        private Coord loc;
        private PFNode fromNode;
        private float cost;

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            computeCost(h);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if      (this.getCost(h) < that.getCost(h)) return -1;
            else if (this.getCost(h) > that.getCost(h)) return 1;
            else return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain

        // Returns the location of the PFNode
        private Coord getLoc() {
            return loc;
        }

        private void computeCost(float heuristic) {
            if (validateCoord(this.loc)) {
                PFNode b = fromNode;
                if (b == null) this.cost = 0.0f;
                else {
                    float nextCost = terrain.computeTravelCost(b.getLoc(), loc);
                    this.cost = b.cost + nextCost;
                }
            }
        }

        public float getCost(float heuristic) { return cost + heuristic*terrain.computeDistance(loc, end); }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Coord[] coords = findNeighbors(loc);
            Stack<PFNode> s = new Stack<>();
            for (Coord c : coords) {
                s.push(new PFNode(c, this));
            }
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        start = null;
        end = null;
        pq = new MinPQ<>();
        this.terrain = terrain;
        N = this.terrain.getN();
        h = 0.0f;
        searchSize = 0;
        pathFound = false;
        board = new PFNode[N][N];
    }

    public void setPathStart(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: start input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: start coord is out of bounds");
        start = new Coord(loc.getI(), loc.getJ());
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if (loc == null) throw new IllegalArgumentException("Error: end input coord is null");
        if (!validateCoord(loc)) throw new IndexOutOfBoundsException("Error: end coord is out of bounds");
        end = new Coord(loc.getI(), loc.getJ());
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) {
        this.h = v;
    }

    public float getHeuristic() {
        return this.h;
    }

    public void resetPath() {
        pq = new MinPQ<>();
        N = this.terrain.getN();
        board = new PFNode[N][N];
        searchSize = 0;
        path = null;
    }

    // Helper function to find neighbors given a coord
    private Coord[] findNeighbors(Coord s) {
        Coord a = new Coord(s.getI(), s.getJ()-1);
        Coord b = new Coord(s.getI()+1, s.getJ());
        Coord c = new Coord(s.getI(), s.getJ()+1);
        Coord d = new Coord(s.getI()-1, s.getJ());
        // a is 1 up, b is 1 right, c is 1 down, d is 1 left
        Coord[] e = new Coord[4];
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d;
        return e;
    }

    public void computePath() {
        if (start == null) throw new IllegalArgumentException("Error: start has not been set");
        if (end == null) throw new IllegalArgumentException("Error: end has not been set");
        Coord currentLoc = getPathStart();
        boolean atStart = true;
        boolean found = false;
        while (true) {
            PFNode currentNode;
            if (atStart) currentNode = new PFNode(currentLoc, null);
            else {
                if (pq.isEmpty()) break;
                else {
                    currentNode = pq.delMin();
                    currentLoc = currentNode.getLoc();
                }
            }
            for (PFNode c : currentNode.neighbors()) {
                if (validateCoord(c.getLoc())) {
                    if (c.getLoc().equals(getPathEnd())) {
                        currentNode = c;
                        found = true;
                        break;
                    }
                    if (board[c.getLoc().getI()][c.getLoc().getJ()] == null) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                        searchSize++;
                    } else if (c.getCost(h) < board[c.getLoc().getI()][c.getLoc().getJ()].getCost(h)) {
                        pq.insert(c);
                        board[c.getLoc().getI()][c.getLoc().getJ()] = c;
                    }
                }
            }
            if (found) {
                pathFound = true;
                endNode = currentNode;
                PFNode c = endNode;
                path = new Stack<>();
                while (c != null) {
                    path.push(c.getLoc());
                    c = c.fromNode;
                }
                break;
            }
            atStart = false;
        }
    }

    public boolean validateCoord(Coord c) {
        int ci = c.getI();
        int cj = c.getJ();
        return ci >= 0 && ci < N && cj >= 0 && cj < N;
    }

    public boolean foundPath() {
        return pathFound;
    }

    public float getPathCost() {
        PFNode c = endNode;
        if (c != null) return c.getCost(0);
        else return 0;
    }

    public int getSearchSize() {
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return path;
    }

    public boolean wasSearched(Coord loc) {
        return board[loc.getI()][loc.getJ()] != null;
    }
}

--[ 2020.11.03.14.04.12.885.0 ]--
DisposeComponent
